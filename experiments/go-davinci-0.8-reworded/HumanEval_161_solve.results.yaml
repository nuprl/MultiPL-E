language: go_test.go
name: HumanEval_161_solve
results:
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var result []byte\n    for i := len(s) - 1; i >= 0; i-- {\n        if\
    \ isLetter(s[i]) {\n            if isLower(s[i]) {\n                result = append(result,\
    \ s[i] - 32)\n            } else {\n                result = append(result, s[i]\
    \ + 32)\n            }\n        } else {\n            result = append(result,\
    \ s[i])\n        }\n    }\n    return string(result)\n}\n\nfunc TestSolve(t *testing.T)\
    \ {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"\
    ), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprdkd9pn0_test.go:23:12: undefined: isLetter

    /tmp/tmprdkd9pn0_test.go:24:16: undefined: isLower

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073394
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    // pre-allocate a string slice\n    result := make([]byte, len(s))\n\
    \    for i, c := range s {\n        if c >= 'a' && c <= 'z' {\n            result[i]\
    \ = byte(c - 'a' + 'A')\n        } else if c >= 'A' && c <= 'Z' {\n          \
    \  result[i] = byte(c - 'A' + 'a')\n        } else {\n            result[i] =\
    \ byte(c)\n        }\n    }\n    return string(result)\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmpct5_kd3t_test.go:55: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmpct5_kd3t_test.go:55: expected '2@6#', got '#6@2'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073394
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    r := []rune(s)\n    for i, v := range r {\n        if v >= 'a' && v <=\
    \ 'z' {\n            r[i] = v - 32\n        } else if v >= 'A' && v <= 'Z' {\n\
    \            r[i] = v + 32\n        }\n    }\n    return string(r)\n}\n\nfunc\
    \ TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmp8i8kkytu_test.go:52: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmp8i8kkytu_test.go:52: expected '2@6#', got '#6@2'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073394
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    if s == \"\" {\n        return s\n    }\n    letters := make([]byte,\
    \ 0)\n    for i := 0; i < len(s); i++ {\n        if s[i] >= 'a' && s[i] <= 'z'\
    \ || s[i] >= 'A' && s[i] <= 'Z' {\n            letters = append(letters, s[i])\n\
    \        }\n    }\n    if len(letters) == 0 {\n        return reverse(s)\n   \
    \ }\n    for i := 0; i < len(s); i++ {\n        if s[i] >= 'a' && s[i] <= 'z'\
    \ || s[i] >= 'A' && s[i] <= 'Z' {\n            s = s[:i] + changeCase(s[i]) +\
    \ s[i+1:]\n        }\n    }\n    return s\n}\n\nfunc TestSolve(t *testing.T) {\n\
    \  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected:\
    \ \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n   \
    \  { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppaf9m4qu_test.go:31:16: undefined: reverse

    /tmp/tmppaf9m4qu_test.go:35:25: undefined: changeCase

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073394
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    // your code here\n    return \"\"\n}\n\nfunc TestSolve(t *testing.T)\
    \ {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"\
    ), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmp7iqcwyhb_test.go:45: expected 'aSdF', got ''\n    --- FAIL: TestSolve/test_num__1\
    \ (0.00s)\n        tmp7iqcwyhb_test.go:45: expected '4321', got ''\n    --- FAIL:\
    \ TestSolve/test_num__2 (0.00s)\n        tmp7iqcwyhb_test.go:45: expected 'AB',\
    \ got ''\n    --- FAIL: TestSolve/test_num__3 (0.00s)\n        tmp7iqcwyhb_test.go:45:\
    \ expected '#A@c', got ''\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n     \
    \   tmp7iqcwyhb_test.go:45: expected '#aSDFw^45', got ''\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmp7iqcwyhb_test.go:45: expected '2@6#', got ''\n    --- FAIL:\
    \ TestSolve/test_num__6 (0.00s)\n        tmp7iqcwyhb_test.go:45: expected '#$A^d',\
    \ got ''\n    --- FAIL: TestSolve/test_num__7 (0.00s)\n        tmp7iqcwyhb_test.go:45:\
    \ expected '#CCC', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073213
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    if s == \"\" {\n        return s\n    }\n    var newString string\n \
    \   for _, char := range s {\n        if ('a' <= char && char <= 'z') || ('A'\
    \ <= char && char <= 'Z') {\n            if char > 'Z' {\n                newString\
    \ += string(char - 32)\n            } else {\n                newString += string(char\
    \ + 32)\n            }\n        } else {\n            newString += string(char)\n\
    \        }\n    }\n    return newString\n}\n\nfunc TestSolve(t *testing.T) {\n\
    \  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected:\
    \ \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n   \
    \  { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmpnd3a8g30_test.go:59: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmpnd3a8g30_test.go:59: expected '2@6#', got '#6@2'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073395
- exit_code: 0
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    if len(s) == 0 {\n        return s\n    }\n    var isLetter bool\n  \
    \  for _, v := range s {\n        if (v >= 'a' && v <= 'z') || (v >= 'A' && v\
    \ <= 'Z') {\n            isLetter = true\n            break\n        }\n    }\n\
    \    if !isLetter {\n        var res string\n        for i := len(s) - 1; i >=\
    \ 0; i-- {\n            res += string(s[i])\n        }\n        return res\n \
    \   }\n    var res string\n    for _, v := range s {\n        if v >= 'a' && v\
    \ <= 'z' {\n            res += string(v - 32)\n        } else if v >= 'A' && v\
    \ <= 'Z' {\n            res += string(v + 32)\n        } else {\n            res\
    \ += string(v)\n        }\n    }\n    return res\n}\n\nfunc TestSolve(t *testing.T)\
    \ {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"\
    ), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073395
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    res := make([]byte, len(s))\n    for i := range s {\n        if s[i]\
    \ >= 'a' && s[i] <= 'z' {\n            res[i] = s[i] - 32\n        } else if s[i]\
    \ >= 'A' && s[i] <= 'Z' {\n            res[i] = s[i] + 32\n        } else {\n\
    \            res[i] = s[i]\n        }\n    }\n    return string(res)\n}\n\nfunc\
    \ TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmp53i4c9g0_test.go:54: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmp53i4c9g0_test.go:54: expected '2@6#', got '#6@2'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073394
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    if isLetter(s) {\n        r := make([]rune, len(s))\n        for i, v\
    \ := range s {\n            if isLower(v) {\n                r[i] = upper(v)\n\
    \            } else if isUpper(v) {\n                r[i] = lower(v)\n       \
    \     } else {\n                r[i] = v\n            }\n        }\n        return\
    \ string(r)\n    } else {\n        return reverse(s)\n    }\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplhgh6ze3_test.go:21:8: undefined: isLetter

    /tmp/tmplhgh6ze3_test.go:24:16: undefined: isLower

    /tmp/tmplhgh6ze3_test.go:25:24: undefined: upper

    /tmp/tmplhgh6ze3_test.go:26:23: undefined: isUpper

    /tmp/tmplhgh6ze3_test.go:27:24: undefined: lower

    /tmp/tmplhgh6ze3_test.go:34:16: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073394
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    reversed := \"\"\n    letters := 0\n    for _, c := range s {\n     \
    \   if c >= 'a' && c <= 'z' {\n            reversed += string(c - 32)\n      \
    \      letters++\n        } else if c >= 'A' && c <= 'Z' {\n            reversed\
    \ += string(c + 32)\n            letters++\n        } else {\n            reversed\
    \ += string(c)\n        }\n    }\n    if letters > 0 {\n        return reversed\n\
    \    }\n    return reverse(s)\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmwbkbm0l_test.go:37:12: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073394
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    // your code\n    isLetter := func(r rune) bool {\n        return (r\
    \ >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z')\n    }\n    newString := \"\"\n\
    \    for _, v := range s {\n        if isLetter(v) {\n            if v >= 'a'\
    \ && v <= 'z' {\n                newString += string(v - 32)\n            } else\
    \ {\n                newString += string(v + 32)\n            }\n        } else\
    \ {\n            newString += string(v)\n        }\n    }\n    if newString ==\
    \ s {\n        return reverse(s)\n    }\n    return newString\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpny_50d_x_test.go:38:16: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073394
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    res := \"\"\n    for _, ch := range s {\n        if !unicode.IsLetter(ch)\
    \ {\n            res += string(ch)\n            continue\n        }\n        if\
    \ unicode.IsUpper(ch) {\n            res += strings.ToLower(string(ch))\n    \
    \    } else {\n            res += strings.ToUpper(string(ch))\n        }\n   \
    \ }\n    if res == \"\" {\n        return strings.Reverse(s)\n    }\n    return\
    \ res\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n    \
    \ { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpv3k_2s35_test.go:23:13: undefined: unicode

    /tmp/tmpv3k_2s35_test.go:27:12: undefined: unicode

    /tmp/tmpv3k_2s35_test.go:28:20: undefined: strings

    /tmp/tmpv3k_2s35_test.go:30:20: undefined: strings

    /tmp/tmpv3k_2s35_test.go:34:16: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073394
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    if len(s) == 0 {\n        return s\n    }\n    for i, _ := range s {\n\
    \        if (isAlphabet(s[i])) {\n            if isUpper(s[i]) {\n           \
    \     s = s[:i] + string(s[i] + 32) + s[i+1:]\n            } else {\n        \
    \        s = s[:i] + string(s[i] - 32) + s[i+1:]\n            }\n        }\n \
    \   }\n    return s\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n\
    \     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp265cbgc8_test.go:25:13: undefined: isAlphabet

    /tmp/tmp265cbgc8_test.go:26:16: undefined: isUpper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073394
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    if !has_letters(s) {\n        return reverse(s)\n    }\n    str := \"\
    \"\n    for _, c := range s {\n        var nc string\n        if is_letter(c)\
    \ {\n            nc = string(flip_case(c))\n        } else {\n            nc =\
    \ string(c)\n        }\n        str += nc\n    }\n    return str\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprglv9k8e_test.go:21:9: undefined: has_letters

    /tmp/tmprglv9k8e_test.go:22:16: undefined: reverse

    /tmp/tmprglv9k8e_test.go:27:12: undefined: is_letter

    /tmp/tmprglv9k8e_test.go:28:25: undefined: flip_case

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073394
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    r := []rune(s)\n    for i, c := range r {\n        if c >= 'a' && c <=\
    \ 'z' {\n            r[i] = 'A' + (c - 'a')\n        } else if c >= 'A' && c <=\
    \ 'Z' {\n            r[i] = 'a' + (c - 'A')\n        }\n    }\n    return string(r)\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmpu30ifaam_test.go:52: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmpu30ifaam_test.go:52: expected '2@6#', got '#6@2'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073395
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var d rune\n    for i, c := range s {\n        // fmt.Println(i, c)\n\
    \        if isLetter(c) {\n            if (c >= 'a' && c <= 'z') {\n         \
    \       d = c - 32\n            } else {\n                d = c + 32\n       \
    \     }\n            s = s[:i] + string(d) + s[i+1:]\n        }\n    }\n    return\
    \ s\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpq1rwmj6q_test.go:24:12: undefined: isLetter

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073394
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var reverse func(r rune) rune\n    if len(s) == 0 {\n        reverse\
    \ = func(r rune) rune { return r }\n    } else {\n        reverse = func(r rune)\
    \ rune {\n            if r >= 'a' && r <= 'z' {\n                return r - 32\n\
    \            } else if r >= 'A' && r <= 'Z' {\n                return r + 32\n\
    \            } else {\n                return r\n            }\n        }\n  \
    \  }\n    return string(map(reverse, s))\n}\n\nfunc TestSolve(t *testing.T) {\n\
    \  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected:\
    \ \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n   \
    \  { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzx0fvob6_test.go:35:22: expected ''['', found ''(''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073393
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    // Write your code here\n    if !isContainLetter(s) {\n        return\
    \ reverse(s)\n    }\n\n    sSlice := []rune(s)\n    for i, v := range sSlice {\n\
    \        if isLetter(v) {\n            sSlice[i] = reverseCase(v)\n        }\n\
    \    }\n    return string(sSlice)\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj_9d5u6o_test.go:22:9: undefined: isContainLetter

    /tmp/tmpj_9d5u6o_test.go:23:16: undefined: reverse

    /tmp/tmpj_9d5u6o_test.go:28:12: undefined: isLetter

    /tmp/tmpj_9d5u6o_test.go:29:25: undefined: reverseCase

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073394
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    asBytes := []byte(s)\n    fmt.Println(asBytes)\n    if s == \"\" {\n\
    \        return s\n    }\n    for i := 0; i < len(asBytes); i++ {\n        if\
    \ asBytes[i] >= 'a' && asBytes[i] <= 'z' {\n            asBytes[i] = asBytes[i]\
    \ - 'a' + 'A'\n        } else if asBytes[i] >= 'A' && asBytes[i] <= 'Z' {\n  \
    \          asBytes[i] = asBytes[i] - 'A' + 'a'\n        }\n    }\n    return string(asBytes)\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "[65 115 68 102]\n[49 50 51 52]\n[97 98]\n[35 97 64 67]\n[35 65 115 100\
    \ 102 87 94 52 53]\n[35 54 64 50]\n[35 36 97 94 68]\n[35 99 99 99]\n--- FAIL:\
    \ TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n        tmpmtbzke2h_test.go:56:\
    \ expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__5 (0.00s)\n \
    \       tmpmtbzke2h_test.go:56: expected '2@6#', got '#6@2'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073394
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    if len(s) < 1 {\n        return s\n    }\n    for i, c := range s {\n\
    \        if c >= 'a' && c <= 'z' {\n            return solve(s[i+1:]) + string(c\
    \ - 32)\n        } else if c >= 'A' && c <= 'Z' {\n            return solve(s[i+1:])\
    \ + string(c + 32)\n        }\n    }\n    return s\n}\n\nfunc TestSolve(t *testing.T)\
    \ {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"\
    ), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmpews09bhr_test.go:54: expected 'aSdF', got 'FdSa'\n    --- FAIL: TestSolve/test_num__1\
    \ (0.00s)\n        tmpews09bhr_test.go:54: expected '4321', got '1234'\n    ---\
    \ FAIL: TestSolve/test_num__2 (0.00s)\n        tmpews09bhr_test.go:54: expected\
    \ 'AB', got 'BA'\n    --- FAIL: TestSolve/test_num__3 (0.00s)\n        tmpews09bhr_test.go:54:\
    \ expected '#A@c', got 'cA'\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n   \
    \     tmpews09bhr_test.go:54: expected '#aSDFw^45', got '^45wFDSa'\n    --- FAIL:\
    \ TestSolve/test_num__5 (0.00s)\n        tmpews09bhr_test.go:54: expected '2@6#',\
    \ got '#6@2'\n    --- FAIL: TestSolve/test_num__6 (0.00s)\n        tmpews09bhr_test.go:54:\
    \ expected '#$A^d', got 'dA'\n    --- FAIL: TestSolve/test_num__7 (0.00s)\n  \
    \      tmpews09bhr_test.go:54: expected '#CCC', got 'CCC'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073394
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    if !isContainLetters(s) {\n        return reverse(s)\n    }\n    str\
    \ := \"\"\n    for _, c := range s {\n        if isLetter(c) {\n            if\
    \ isUpper(c) {\n                str += string(c + 32)\n            } else {\n\
    \                str += string(c - 32)\n            }\n        } else {\n    \
    \        str += string(c)\n        }\n    }\n    return str\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpx674vy64_test.go:21:9: undefined: isContainLetters

    /tmp/tmpx674vy64_test.go:22:16: undefined: reverse

    /tmp/tmpx674vy64_test.go:26:12: undefined: isLetter

    /tmp/tmpx674vy64_test.go:27:16: undefined: isUpper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073394
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    if s == \"\" {\n        return s\n    }\n    runes := []rune(s)\n   \
    \ for i, ch := range runes {\n        if ch >= 'a' && ch <= 'z' {\n          \
    \  runes[i] = ch - 32\n        } else if ch >= 'A' && ch <= 'Z' {\n          \
    \  runes[i] = ch + 32\n        }\n    }\n    return string(runes)\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmpf15zw81d_test.go:55: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmpf15zw81d_test.go:55: expected '2@6#', got '#6@2'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073394
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var m int = len(s)\n    if m == 0 {\n        return s\n    }\n    var\
    \ r, strs []rune\n    for _, c := range s {\n        if c >= 65 && c <= 90 {\n\
    \            r = append(r, c+32)\n        } else if c >= 97 && c <= 122 {\n  \
    \          r = append(r, c-32)\n        } else {\n            strs = append(strs,\
    \ c)\n        }\n    }\n    r = append(r, strs...)\n    return string(r)\n}\n\n\
    func TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmpllwz1qey_test.go:59: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__3\
    \ (0.00s)\n        tmpllwz1qey_test.go:59: expected '#A@c', got 'Ac#@'\n    ---\
    \ FAIL: TestSolve/test_num__4 (0.00s)\n        tmpllwz1qey_test.go:59: expected\
    \ '#aSDFw^45', got 'aSDFw#^45'\n    --- FAIL: TestSolve/test_num__5 (0.00s)\n\
    \        tmpllwz1qey_test.go:59: expected '2@6#', got '#6@2'\n    --- FAIL: TestSolve/test_num__6\
    \ (0.00s)\n        tmpllwz1qey_test.go:59: expected '#$A^d', got 'Ad#$^'\n   \
    \ --- FAIL: TestSolve/test_num__7 (0.00s)\n        tmpllwz1qey_test.go:59: expected\
    \ '#CCC', got 'CCC#'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073395
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    chars := []rune(s)\n    for _, c := range chars {\n        if (c >= 'a'\
    \ && c <= 'z') || (c >= 'A' && c <= 'Z') {\n            if c >= 'a' && c <= 'z'\
    \ {\n                c -= 32\n            } else {\n                c += 32\n\
    \            }\n        }\n    }\n    return string(chars)\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmp5fif3n35_test.go:54: expected 'aSdF', got 'AsDf'\n    --- FAIL: TestSolve/test_num__1\
    \ (0.00s)\n        tmp5fif3n35_test.go:54: expected '4321', got '1234'\n    ---\
    \ FAIL: TestSolve/test_num__2 (0.00s)\n        tmp5fif3n35_test.go:54: expected\
    \ 'AB', got 'ab'\n    --- FAIL: TestSolve/test_num__3 (0.00s)\n        tmp5fif3n35_test.go:54:\
    \ expected '#A@c', got '#a@C'\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n \
    \       tmp5fif3n35_test.go:54: expected '#aSDFw^45', got '#AsdfW^45'\n    ---\
    \ FAIL: TestSolve/test_num__5 (0.00s)\n        tmp5fif3n35_test.go:54: expected\
    \ '2@6#', got '#6@2'\n    --- FAIL: TestSolve/test_num__6 (0.00s)\n        tmp5fif3n35_test.go:54:\
    \ expected '#$A^d', got '#$a^D'\n    --- FAIL: TestSolve/test_num__7 (0.00s)\n\
    \        tmp5fif3n35_test.go:54: expected '#CCC', got '#ccc'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073394
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var result string\n    for _, char := range s {\n        // if char is\
    \ a letter, reverse its case.\n        if char >= 'a' && char <= 'z' {\n     \
    \       result += string(char - 'a' + 'A')\n        } else if char >= 'A' && char\
    \ <= 'Z' {\n            result += string(char - 'A' + 'a')\n        } else {\n\
    \            result += string(char)\n        }\n    }\n    return reverse(result)\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcxk0fgcs_test.go:32:12: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073395
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    if len(s) == 0 {\n        return s\n    }\n    var b []byte\n    for\
    \ i := len(s) - 1; i >= 0; i-- {\n        b = append(b, s[i])\n    }\n    for\
    \ i := 0; i < len(b); i++ {\n        if b[i] >= 'a' && b[i] <= 'z' {\n       \
    \     b[i] -= 'a' - 'A'\n        } else if b[i] >= 'A' && b[i] <= 'Z' {\n    \
    \        b[i] += 'a' - 'A'\n        }\n    }\n    return string(b)\n}\n\nfunc\
    \ TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmpjmjwjvme_test.go:58: expected 'aSdF', got 'FdSa'\n    --- FAIL: TestSolve/test_num__2\
    \ (0.00s)\n        tmpjmjwjvme_test.go:58: expected 'AB', got 'BA'\n    --- FAIL:\
    \ TestSolve/test_num__3 (0.00s)\n        tmpjmjwjvme_test.go:58: expected '#A@c',\
    \ got 'c@A#'\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n        tmpjmjwjvme_test.go:58:\
    \ expected '#aSDFw^45', got '54^wFDSa#'\n    --- FAIL: TestSolve/test_num__6 (0.00s)\n\
    \        tmpjmjwjvme_test.go:58: expected '#$A^d', got 'd^A$#'\n    --- FAIL:\
    \ TestSolve/test_num__7 (0.00s)\n        tmpjmjwjvme_test.go:58: expected '#CCC',\
    \ got 'CCC#'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073397
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    for i, c := range s {\n        if (c >= 'a' && c <= 'z') || (c >= 'A'\
    \ && c <= 'Z') {\n            s = s[:i] + string(c ^ 32) + s[i+1:]\n        }\n\
    \    }\n    return s\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n\
    \     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmp1urbu1_w_test.go:49: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmp1urbu1_w_test.go:49: expected '2@6#', got '#6@2'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073397
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    if len(s) == 0 {\n        return s\n    }\n    var res = \"\"\n    for\
    \ _, r := range s {\n        if r >= 'a' && r <= 'z' {\n            res += string(r\
    \ - 32)\n        } else if r >= 'A' && r <= 'Z' {\n            res += string(r\
    \ + 32)\n        } else {\n            res += string(r)\n        }\n    }\n  \
    \  return res\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n    \
    \ { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmp0qrc1p73_test.go:57: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmp0qrc1p73_test.go:57: expected '2@6#', got '#6@2'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073397
- exit_code: 0
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    sl := []rune(s)\n    l := len(sl)\n    letters := false\n    for i :=\
    \ 0; i < l; i++ {\n        if sl[i] > 64 && sl[i] < 91 || sl[i] > 96 && sl[i]\
    \ < 123 {\n            if sl[i] > 64 && sl[i] < 91 {\n                sl[i] +=\
    \ 32\n            } else {\n                sl[i] -= 32\n            }\n     \
    \       letters = true\n        }\n    }\n    if !letters {\n        for i :=\
    \ 0; i < l / 2; i++ {\n            sl[i], sl[l - i - 1] = sl[l - i - 1], sl[i]\n\
    \        }\n    }\n    return string(sl)\n}\n\nfunc TestSolve(t *testing.T) {\n\
    \  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected:\
    \ \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n   \
    \  { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073397
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var res string\n    for _, c := range s {\n        if 'a' <= c && c <=\
    \ 'z' {\n            res += string(c-32)\n        } else if 'A' <= c && c <= 'Z'\
    \ {\n            res += string(c+32)\n        } else {\n            res += string(c)\n\
    \        }\n    }\n    return res\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmpfeeoy15n_test.go:54: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmpfeeoy15n_test.go:54: expected '2@6#', got '#6@2'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073397
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    if len(s) == 0 {\n        return s\n    }\n    for i := 0; i < len(s);\
    \ i++ {\n        if ('a' <= s[i] && s[i] <= 'z') || ('A' <= s[i] && s[i] <= 'Z')\
    \ {\n            return s[:i] + string(s[i] ^ 32) + solve(s[i+1:])\n        }\n\
    \    }\n    return s[1:] + string(s[0])\n}\n\nfunc TestSolve(t *testing.T) {\n\
    \  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected:\
    \ \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n   \
    \  { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmpeg6dljxk_test.go:52: expected '4321', got '2341'\n    --- FAIL: TestSolve/test_num__4\
    \ (0.00s)\n        tmpeg6dljxk_test.go:52: expected '#aSDFw^45', got '#aSDFw45^'\n\
    \    --- FAIL: TestSolve/test_num__5 (0.00s)\n        tmpeg6dljxk_test.go:52:\
    \ expected '2@6#', got '6@2#'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073397
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    if s == \"\" {\n        return s\n    }\n    runes := []rune(s)\n   \
    \ if runeIsLetter(runes[0]) {\n        runes[0] = changeCase(runes[0])\n    }\n\
    \    for i := 1; i < len(runes); i++ {\n        if runeIsLetter(runes[i]) {\n\
    \            runes[i] = changeCase(runes[i])\n            runes[i], runes[i-1]\
    \ = runes[i-1], runes[i]\n        }\n    }\n    return string(runes)\n}\n\nfunc\
    \ TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpx0osp5rc_test.go:25:8: undefined: runeIsLetter

    /tmp/tmpx0osp5rc_test.go:26:20: undefined: changeCase

    /tmp/tmpx0osp5rc_test.go:29:12: undefined: runeIsLetter

    /tmp/tmpx0osp5rc_test.go:30:24: undefined: changeCase

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073396
- exit_code: 0
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    res := make([]byte, len(s))\n    count := 0\n    for i, v := range s\
    \ {\n        if v >= 'a' && v <= 'z' {\n            res[i] = byte(v) - 32\n  \
    \      } else if v >= 'A' && v <= 'Z' {\n            res[i] = byte(v) + 32\n \
    \       } else {\n            res[i] = byte(v)\n        }\n        if v >= 'a'\
    \ && v <= 'z' || v >= 'A' && v <= 'Z' {\n            count++\n        }\n    }\n\
    \    if count == 0 {\n        for i, j := 0, len(res) - 1; i < j; i, j = i + 1,\
    \ j - 1 {\n            res[i], res[j] = res[j], res[i]\n        }\n    }\n   \
    \ return string(res)\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n\
    \     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073397
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    if len(s) == 0 {\n        return s\n    }\n    for i := 0; i < len(s);\
    \ i++ {\n        if s[i] >= 'a' && s[i] <= 'z' {\n            s = s[:i] + string(s[i]\
    \ - 'a' + 'A') + s[i+1:]\n        } else if s[i] >= 'A' && s[i] <= 'Z' {\n   \
    \         s = s[:i] + string(s[i] - 'A' + 'a') + s[i+1:]\n        }\n    }\n \
    \   return s\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n    \
    \ { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmpfrvq6ow3_test.go:54: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmpfrvq6ow3_test.go:54: expected '2@6#', got '#6@2'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073397
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var res string\n    for _, r := range s {\n        if r >= 'a' && r <=\
    \ 'z' {\n            res += string(r - 32)\n        } else if r >= 'A' && r <=\
    \ 'Z' {\n            res += string(r + 32)\n        } else {\n            res\
    \ += string(r)\n        }\n    }\n    return res\n}\n\nfunc TestSolve(t *testing.T)\
    \ {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"\
    ), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmp7qzeex_j_test.go:54: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmp7qzeex_j_test.go:54: expected '2@6#', got '#6@2'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073397
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    isLetter := false\n    letters := make([]rune, 0)\n    others := make([]rune,\
    \ 0)\n    for _, c := range s {\n        if c >= 'a' && c <= 'z' || c >= 'A' &&\
    \ c <= 'Z' {\n            isLetter = true\n            letters = append(letters,\
    \ c)\n        } else {\n            others = append(others, c)\n        }\n  \
    \  }\n    if !isLetter {\n        for i, j := 0, len(s) - 1; i < j; i, j = i +\
    \ 1, j - 1 {\n            s[i], s[j] = s[j], s[i]\n        }\n        return s\n\
    \    }\n    for i, j := 0, len(letters) - 1; i < j; i, j = i + 1, j - 1 {\n  \
    \      letters[i], letters[j] = letters[j], letters[i]\n    }\n    return string(others)\
    \ + string(letters)\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n\
    \     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpn0_6qcrg_test.go:34:13: cannot assign to s[i] (value of type byte)

    /tmp/tmpn0_6qcrg_test.go:34:19: cannot assign to s[j] (value of type byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073396
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    if s == \"\" {\n        return s\n    }\n    r := []rune(s)\n    for\
    \ i, c := range r {\n        if c >= 'a' && c <= 'z' {\n            r[i] = c -\
    \ 'a' + 'A'\n        } else if c >= 'A' && c <= 'Z' {\n            r[i] = c -\
    \ 'A' + 'a'\n        }\n    }\n    return string(r)\n}\n\nfunc TestSolve(t *testing.T)\
    \ {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"\
    ), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmpl14eiy7i_test.go:55: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmpl14eiy7i_test.go:55: expected '2@6#', got '#6@2'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073397
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    if len(s) == 0 {\n        return s\n    }\n    result := make([]byte,\
    \ len(s))\n    for i := range s {\n        if (s[i] >= 'a' && s[i] <= 'z') ||\
    \ (s[i] >= 'A' && s[i] <= 'Z') {\n            if s[i] >= 'a' && s[i] <= 'z' {\n\
    \                result[i] = s[i] - 32\n            } else {\n               \
    \ result[i] = s[i] + 32\n            }\n        } else {\n            result[i]\
    \ = s[i]\n        }\n    }\n    return string(result)\n}\n\nfunc TestSolve(t *testing.T)\
    \ {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"\
    ), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmp_s6yer0d_test.go:59: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmp_s6yer0d_test.go:59: expected '2@6#', got '#6@2'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073397
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    l := len(s)\n    if l == 0 {\n        return s\n    }\n    buf := make([]byte,\
    \ l)\n    bufIdx := 0\n    for i := 0; i < l; i++ {\n        b := s[i]\n     \
    \   if (b >= 'a' && b <= 'z') || (b >= 'A' && b <= 'Z') {\n            if (b >=\
    \ 'a' && b <= 'z') {\n                b -= 32\n            } else {\n        \
    \        b += 32\n            }\n        }\n        buf[bufIdx] = b\n        bufIdx++\n\
    \    }\n    return string(buf)\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmpk_t4dcjp_test.go:62: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmpk_t4dcjp_test.go:62: expected '2@6#', got '#6@2'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073397
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    l := []rune(s)\n    for i, v := range l {\n        if ('a' <= v && v\
    \ <= 'z') || ('A' <= v && v <= 'Z') {\n            l[i] = rune(v ^ (1 << 5))\n\
    \        }\n    }\n    return string(l)\n}\n\nvar testCases = []\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpno55dqg8_test.go:30:19: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073396
- exit_code: 0
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var res = make([]byte, len(s))\n    for i := range s {\n        if s[i]\
    \ >= 'a' && s[i] <= 'z' {\n            res[i] = s[i] - 32\n        } else if s[i]\
    \ >= 'A' && s[i] <= 'Z' {\n            res[i] = s[i] + 32\n        } else {\n\
    \            res[i] = s[i]\n        }\n    }\n    // If the string contains no\
    \ letters, reverse the string.\n    isNoLetters := true\n    for i := range res\
    \ {\n        if (res[i] >= 'a' && res[i] <= 'z') || (res[i] >= 'A' && res[i] <=\
    \ 'Z') {\n            isNoLetters = false\n            break\n        }\n    }\n\
    \    if isNoLetters {\n        for i := 0; i < len(res) / 2; i++ {\n         \
    \   res[i], res[len(res) - 1 - i] = res[len(res) - 1 - i], res[i]\n        }\n\
    \    }\n    return string(res)\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073397
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var (\n        i int = 0\n        l int = len(s)\n        r string =\
    \ \"\"\n    )\n    for ; i < l; i++ {\n        if isLetter(s[i]) {\n         \
    \   r += string(revCase(s[i]))\n        } else {\n            r += string(s[i])\n\
    \        }\n    }\n    return r\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpts7a3jc6_test.go:27:12: undefined: isLetter

    /tmp/tmpts7a3jc6_test.go:28:25: undefined: revCase

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073397
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    if len(s) == 0 {\n        return s\n    }\n    runes := []rune(s)\n \
    \   for i, c := range runes {\n        if c >= 'a' && c <= 'z' {\n           \
    \ runes[i] = c - 'a' + 'A'\n        } else if c >= 'A' && c <= 'Z' {\n       \
    \     runes[i] = c - 'A' + 'a'\n        }\n    }\n    return string(runes)\n}\n\
    \nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmpa6u9ykxl_test.go:55: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmpa6u9ykxl_test.go:55: expected '2@6#', got '#6@2'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073397
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    // your code here\n    return \"\"\n}\n\nfunc TestSolve(t *testing.T)\
    \ {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"\
    ), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmp7iqcwyhb_test.go:45: expected 'aSdF', got ''\n    --- FAIL: TestSolve/test_num__1\
    \ (0.00s)\n        tmp7iqcwyhb_test.go:45: expected '4321', got ''\n    --- FAIL:\
    \ TestSolve/test_num__2 (0.00s)\n        tmp7iqcwyhb_test.go:45: expected 'AB',\
    \ got ''\n    --- FAIL: TestSolve/test_num__3 (0.00s)\n        tmp7iqcwyhb_test.go:45:\
    \ expected '#A@c', got ''\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n     \
    \   tmp7iqcwyhb_test.go:45: expected '#aSDFw^45', got ''\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmp7iqcwyhb_test.go:45: expected '2@6#', got ''\n    --- FAIL:\
    \ TestSolve/test_num__6 (0.00s)\n        tmp7iqcwyhb_test.go:45: expected '#$A^d',\
    \ got ''\n    --- FAIL: TestSolve/test_num__7 (0.00s)\n        tmp7iqcwyhb_test.go:45:\
    \ expected '#CCC', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073213
- exit_code: 0
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    // the function body\n    var (\n        is_letter bool\n        res\
    \ string\n    )\n    for _, char := range s {\n        fmt.Println(char)\n   \
    \     fmt.Println(is_letter)\n        if char > 96 && char < 123 {\n         \
    \   is_letter = true\n            res += string(char - 32)\n        } else if\
    \ char > 64 && char < 91 {\n            is_letter = true\n            res += string(char\
    \ + 32)\n        } else {\n            res += string(char)\n        }\n    }\n\
    \    if is_letter {\n        return res\n    } else {\n        // fmt.Println(res)\n\
    \        var reversed string\n        for i := len(res) - 1; i >= 0; i-- {\n \
    \           reversed += string(res[i])\n        }\n        return reversed\n \
    \   }\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n    \
    \ { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073397
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    if len(s) == 0 {\n        return s\n    }\n    var s_ []byte\n    if\
    \ 'A' <= s[0] && s[0] <= 'Z' {\n        s_ = []byte(s)\n        s_[0] = s_[0]\
    \ + ('a' - 'A')\n    } else if 'a' <= s[0] && s[0] <= 'z' {\n        s_ = []byte(s)\n\
    \        s_[0] = s_[0] - ('a' - 'A')\n    } else {\n        s_ = []byte(s)\n \
    \   }\n    for i := 1; i < len(s); i++ {\n        if 'A' <= s[i] && s[i] <= 'Z'\
    \ {\n            s_[i] = s_[i] + ('a' - 'A')\n        } else if 'a' <= s[i] &&\
    \ s[i] <= 'z' {\n            s_[i] = s_[i] - ('a' - 'A')\n        }\n    }\n \
    \   return string(s_)\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n\
    \     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmp4s7wm5nd_test.go:64: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmp4s7wm5nd_test.go:64: expected '2@6#', got '#6@2'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073397
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    if len(s) == 0 {\n        return s\n    }\n    for i,c := range s {\n\
    \        if c >= 'a' && c <= 'z' {\n            s = s[:i] + string(c-32) + s[i+1:]\n\
    \        } else if c >= 'A' && c <= 'Z' {\n            s = s[:i] + string(c+32)\
    \ + s[i+1:]\n        }\n    }\n    return s\n}\n\nfunc TestSolve(t *testing.T)\
    \ {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"\
    ), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmpgwfixpcn_test.go:54: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmpgwfixpcn_test.go:54: expected '2@6#', got '#6@2'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073397
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    l := len(s)\n    if l == 0 {\n        return s\n    }\n    for i := 0;\
    \ i < l; i++ {\n        if s[i] >= 'a' && s[i] <= 'z' {\n            s = s[:i]\
    \ + string(s[i] + 'A' - 'a') + s[i+1:]\n        } else if s[i] >= 'A' && s[i]\
    \ <= 'Z' {\n            s = s[:i] + string(s[i] + 'a' - 'A') + s[i+1:]\n     \
    \   }\n    }\n    for i := 0; i < l/2; i++ {\n        s = s[:i] + string(s[l-i-1])\
    \ + s[i+1:l-i-1] + string(s[i]) + s[l-i:]\n    }\n    return s\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmp6nf9uipv_test.go:58: expected 'aSdF', got 'FdSa'\n    --- FAIL: TestSolve/test_num__2\
    \ (0.00s)\n        tmp6nf9uipv_test.go:58: expected 'AB', got 'BA'\n    --- FAIL:\
    \ TestSolve/test_num__3 (0.00s)\n        tmp6nf9uipv_test.go:58: expected '#A@c',\
    \ got 'c@A#'\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n        tmp6nf9uipv_test.go:58:\
    \ expected '#aSDFw^45', got '54^wFDSa#'\n    --- FAIL: TestSolve/test_num__6 (0.00s)\n\
    \        tmp6nf9uipv_test.go:58: expected '#$A^d', got 'd^A$#'\n    --- FAIL:\
    \ TestSolve/test_num__7 (0.00s)\n        tmp6nf9uipv_test.go:58: expected '#CCC',\
    \ got 'CCC#'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073397
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var buffer string\n    for _, v := range s {\n        if v >= 'a' &&\
    \ v <= 'z' {\n            buffer += string(v - 32)\n        } else if v >= 'A'\
    \ && v <= 'Z' {\n            buffer += string(v + 32)\n        } else {\n    \
    \        buffer += string(v)\n        }\n    }\n    return buffer\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmpiw2kvjie_test.go:54: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmpiw2kvjie_test.go:54: expected '2@6#', got '#6@2'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073398
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    runes := []rune(s)\n    for i, r := range runes {\n        if r >= 'a'\
    \ && r <= 'z' {\n            runes[i] = 'A' + (r - 'a')\n        } else if r >=\
    \ 'A' && r <= 'Z' {\n            runes[i] = 'a' + (r - 'A')\n        }\n    }\n\
    \    return string(runes)\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmpo_652m1n_test.go:52: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmpo_652m1n_test.go:52: expected '2@6#', got '#6@2'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073398
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    // your code here\n    runes := []rune(s)\n    for i, r := range runes\
    \ {\n        if !(r >= 'a' && r <= 'z' || r >= 'A' && r <= 'Z') {\n          \
    \  if i == 0 {\n                continue\n            } else {\n             \
    \   return string(runes[i:])\n            }\n        }\n        if r >= 'a' &&\
    \ r <= 'z' {\n            runes[i] = r - 32\n        } else {\n            runes[i]\
    \ = r + 32\n        }\n    }\n    return string(runes)\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmpw6d_hdjx_test.go:60: expected '4321', got '234'\n    --- FAIL: TestSolve/test_num__3\
    \ (0.00s)\n        tmpw6d_hdjx_test.go:60: expected '#A@c', got '@C'\n    ---\
    \ FAIL: TestSolve/test_num__4 (0.00s)\n        tmpw6d_hdjx_test.go:60: expected\
    \ '#aSDFw^45', got '^45'\n    --- FAIL: TestSolve/test_num__5 (0.00s)\n      \
    \  tmpw6d_hdjx_test.go:60: expected '2@6#', got '6@2'\n    --- FAIL: TestSolve/test_num__6\
    \ (0.00s)\n        tmpw6d_hdjx_test.go:60: expected '#$A^d', got '$a^D'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073399
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    runes := []rune(s)\n    start := 0\n    end := len(runes) - 1\n    if\
    \ start == end {\n        if unicode.IsLetter(runes[start]) {\n            runes[start]\
    \ = unicode.ToLower(runes[start])\n        }\n        return string(runes)\n \
    \   }\n    for start < end {\n        for start < end && !unicode.IsLetter(runes[start])\
    \ {\n            start++\n        }\n        for start < end && !unicode.IsLetter(runes[end])\
    \ {\n            end--\n        }\n        if start < end {\n            if unicode.IsLower(runes[start])\
    \ {\n                runes[start] = unicode.ToUpper(runes[start])\n          \
    \  } else {\n                runes[start] = unicode.ToLower(runes[start])\n  \
    \          }\n            if unicode.IsLower(runes[end]) {\n                runes[end]\
    \ = unicode.ToUpper(runes[end])\n            } else {\n                runes[end]\
    \ = unicode.ToLower(runes[end])\n            }\n            start++\n        \
    \    end--\n        }\n    }\n    return string(runes)\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfi3fg3vg_test.go:25:12: undefined: unicode

    /tmp/tmpfi3fg3vg_test.go:26:28: undefined: unicode

    /tmp/tmpfi3fg3vg_test.go:31:29: undefined: unicode

    /tmp/tmpfi3fg3vg_test.go:34:29: undefined: unicode

    /tmp/tmpfi3fg3vg_test.go:38:16: undefined: unicode

    /tmp/tmpfi3fg3vg_test.go:39:32: undefined: unicode

    /tmp/tmpfi3fg3vg_test.go:41:32: undefined: unicode

    /tmp/tmpfi3fg3vg_test.go:43:16: undefined: unicode

    /tmp/tmpfi3fg3vg_test.go:44:30: undefined: unicode

    /tmp/tmpfi3fg3vg_test.go:46:30: undefined: unicode

    /tmp/tmpfi3fg3vg_test.go:46:30: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073398
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    new_str := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            new_str += string(char - 32)\n        } else if\
    \ char >= 'A' && char <= 'Z' {\n            new_str += string(char + 32)\n   \
    \     } else {\n            new_str += string(char)\n        }\n    }\n    return\
    \ new_str\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n    \
    \ { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmpvcx6lppt_test.go:54: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmpvcx6lppt_test.go:54: expected '2@6#', got '#6@2'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073399
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var r []rune\n    l := len(s)\n    for i := l - 1; i >= 0; i-- {\n  \
    \      if !isLetter(s[i]) {\n            r = append(r, rune(s[i]))\n        }\
    \ else {\n            r = append(r, toUpperOrLower(s[i]))\n        }\n    }\n\
    \    return string(r)\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n\
    \     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf14i4dvr_test.go:24:13: undefined: isLetter

    /tmp/tmpf14i4dvr_test.go:27:27: undefined: toUpperOrLower

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073399
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    if len(s) == 0 {\n        return s\n    }\n    runes := []rune(s)\n \
    \   letterFound := false\n    for _, r := range runes {\n        if ('a' <= r\
    \ && r <= 'z') || ('A' <= r && r <= 'Z') {\n            letterFound = true\n \
    \           break\n        }\n    }\n    if !letterFound {\n        return reverse(s)\n\
    \    }\n    for i, r := range runes {\n        if 'a' <= r && r <= 'z' {\n   \
    \         runes[i] = r - 32\n        } else if 'A' <= r && r <= 'Z' {\n      \
    \      runes[i] = r + 32\n        }\n    }\n    return string(runes)\n}\n\nfunc\
    \ TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp12otv0bz_test.go:33:16: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073399
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var (\n        num int\n        reverse, str string\n    )\n    for _,\
    \ v := range s {\n        if (v >= 65 && v <= 90) || (v >= 97 && v <= 122) {\n\
    \            if v >= 65 && v <= 90 {\n                num = 32\n            }\
    \ else {\n                num = -32\n            }\n            v += rune(num)\n\
    \        }\n        reverse = string(v) + reverse\n    }\n    return reverse\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyo9vqpyk_test.go:23:18: str declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073399
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    if len(s) == 0 {\n        return s\n    }\n    // Letters between 'a'\
    \ and 'z' are 32 apart.\n    // Letters between 'A' and 'Z' are 32 apart.\n  \
    \  // 'a' - 'A' = 32\n    // 'z' - 'Z' = 32\n    // 'a' - 'z' = -32\n    // 'A'\
    \ - 'Z' = -32\n    letters := make([]byte, 0, len(s))\n    for i := 0; i < len(s);\
    \ i++ {\n        char := s[i]\n        if char >= 'a' && char <= 'z' || char >=\
    \ 'A' && char <= 'Z' {\n            letters = append(letters, char)\n        }\n\
    \    }\n    if len(letters) == 0 {\n        for i := 0; i < len(s) / 2; i++ {\n\
    \            s[i], s[len(s) - 1 - i] = s[len(s) - 1 - i], s[i]\n        }\n  \
    \      return s\n    }\n    j := 0\n    for i := 0; i < len(s); i++ {\n      \
    \  char := s[i]\n        if char >= 'a' && char <= 'z' || char >= 'A' && char\
    \ <= 'Z' {\n            s[i] = letters[j]\n            j++\n        }\n    }\n\
    \    return s\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n    \
    \ { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbppwcahn_test.go:39:13: cannot assign to s[i] (value of type byte)

    /tmp/tmpbppwcahn_test.go:39:19: cannot assign to s[len(s) - 1 - i] (value of type
    byte)

    /tmp/tmpbppwcahn_test.go:47:13: cannot assign to s[i] (value of type byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073399
- exit_code: 0
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var result string\n    var upper bool\n    if s == \"\" {\n        return\
    \ s\n    }\n    // if there are no letters\n    for _, c := range s {\n      \
    \  if c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' {\n            upper = true\n\
    \            break\n        }\n    }\n    if !upper {\n        l := len(s)\n \
    \       for i := l - 1; i >= 0; i-- {\n            result += string(s[i])\n  \
    \      }\n        return result\n    }\n    for _, c := range s {\n        if\
    \ c >= 'a' && c <= 'z' {\n            result += string(c - 32)\n        } else\
    \ if c >= 'A' && c <= 'Z' {\n            result += string(c + 32)\n        } else\
    \ {\n            result += string(c)\n        }\n    }\n    return result\n}\n\
    \nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073399
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var newS string\n    for _, r := range s {\n        if r >= 'a' && r\
    \ <= 'z' {\n            newS += string(r - 32)\n        } else if r >= 'A' &&\
    \ r <= 'Z' {\n            newS += string(r + 32)\n        } else {\n         \
    \   newS += string(r)\n        }\n    }\n    if newS == s {\n        for i, j\
    \ := 0, len(newS) - 1; i < j; i, j = i + 1, j - 1 {\n            newS[i], newS[j]\
    \ = newS[j], newS[i]\n        }\n    }\n    return newS\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp__rj3b7h_test.go:33:13: cannot assign to newS[i] (value of type byte)

    /tmp/tmp__rj3b7h_test.go:33:22: cannot assign to newS[j] (value of type byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073399
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    if len(s) == 0 {\n        return s\n    }\n    r := make([]rune, len(s))\n\
    \    for i, c := range s {\n        if c >= 'a' && c <= 'z' {\n            r[i]\
    \ = c - 32\n        } else if c >= 'A' && c <= 'Z' {\n            r[i] = c + 32\n\
    \        } else {\n            r[i] = c\n        }\n    }\n    if len(r) == 1\
    \ && (r[0] < 'a' || r[0] > 'z') && (r[0] < 'A' || r[0] > 'Z') {\n        return\
    \ string(r)\n    }\n    return string(r)\n}\n\nfunc TestSolve(t *testing.T) {\n\
    \  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected:\
    \ \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n   \
    \  { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmpn420duat_test.go:60: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmpn420duat_test.go:60: expected '2@6#', got '#6@2'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073399
- exit_code: 0
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    if len(s) == 0 {\n        return s\n    }\n    var result = make([]byte,\
    \ len(s))\n    for i := 0; i < len(s); i++ {\n        var this = s[i]\n      \
    \  var upper = this >= 'A' && this <= 'Z'\n        var lower = this >= 'a' &&\
    \ this <= 'z'\n        if upper {\n            result[i] = this + 32\n       \
    \ } else if lower {\n            result[i] = this - 32\n        } else {\n   \
    \         result[i] = this\n        }\n    }\n    // reverse if no letters\n \
    \   var hasLetters = false\n    for i := 0; i < len(result); i++ {\n        if\
    \ result[i] >= 'A' && result[i] <= 'Z' {\n            hasLetters = true\n    \
    \        break\n        }\n        if result[i] >= 'a' && result[i] <= 'z' {\n\
    \            hasLetters = true\n            break\n        }\n    }\n    if !hasLetters\
    \ {\n        for i := 0; i < len(result) / 2; i++ {\n            result[i], result[len(result)\
    \ - 1 - i] = result[len(result) - 1 - i], result[i]\n        }\n    }\n    return\
    \ string(result)\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n\
    \     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073399
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    charMap := map[string]string{\n        \"a\": \"A\",\n        \"b\":\
    \ \"B\",\n        \"c\": \"C\",\n        \"d\": \"D\",\n        \"e\": \"E\",\n\
    \        \"f\": \"F\",\n        \"g\": \"G\",\n        \"h\": \"H\",\n       \
    \ \"i\": \"I\",\n        \"j\": \"J\",\n        \"k\": \"K\",\n        \"l\":\
    \ \"L\",\n        \"m\": \"M\",\n        \"n\": \"N\",\n        \"o\": \"O\",\n\
    \        \"p\": \"P\",\n        \"q\": \"Q\",\n        \"r\": \"R\",\n       \
    \ \"s\": \"S\",\n        \"t\": \"T\",\n        \"u\": \"U\",\n        \"v\":\
    \ \"V\",\n        \"w\": \"W\",\n        \"x\": \"X\",\n        \"y\": \"Y\",\n\
    \        \"z\": \"Z\",\n        \"A\": \"a\",\n        \"B\": \"b\",\n       \
    \ \"C\": \"c\",\n        \"D\": \"d\",\n        \"E\": \"e\",\n        \"F\":\
    \ \"f\",\n        \"G\": \"g\",\n        \"H\": \"h\",\n        \"I\": \"i\",\n\
    \        \"J\": \"j\",\n        \"K\": \"k\",\n        \"L\": \"l\",\n       \
    \ \"M\": \"m\",\n        \"N\": \"n\",\n        \"O\": \"o\",\n        \"P\":\
    \ \"p\",\n        \"Q\": \"q\",\n        \"R\": \"r\",\n        \"S\": \"s\",\n\
    \        \"T\": \"t\",\n        \"U\": \"u\",\n        \"V\": \"v\",\n       \
    \ \"W\": \"w\",\n        \"X\": \"x\",\n        \"Y\": \"y\",\n        \"Z\":\
    \ \"z\",\n    }\n    newStr := \"\"\n    for _, c := range s {\n        if _,\
    \ ok := charMap[string(c)]; ok {\n            newStr += charMap[string(c)]\n \
    \       } else {\n            newStr += string(c)\n        }\n    }\n    return\
    \ newStr\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n    \
    \ { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmpfqexcahc_test.go:106: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmpfqexcahc_test.go:106: expected '2@6#', got '#6@2'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073399
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    //new_s := make([]rune, len(s))\n    res := \"\"\n    for _, char :=\
    \ range s {\n        if (char >= 'a' && char <= 'z') || (char >= 'A' && char <=\
    \ 'Z') {\n            res += string(reverse(char))\n        } else {\n       \
    \     res += string(char)\n        }\n    }\n    return res\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpawtxp242_test.go:25:27: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073399
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    if len(s) == 0 {\n        return s\n    }\n    runes := []rune(s)\n \
    \   length := len(runes)\n    for i := 0; i < length / 2; i++ {\n        runes[i],\
    \ runes[length - i - 1] = runes[length - i - 1], runes[i]\n    }\n    return string(runes)\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmp93adqkz3_test.go:52: expected 'aSdF', got 'fDsA'\n    --- FAIL: TestSolve/test_num__2\
    \ (0.00s)\n        tmp93adqkz3_test.go:52: expected 'AB', got 'ba'\n    --- FAIL:\
    \ TestSolve/test_num__3 (0.00s)\n        tmp93adqkz3_test.go:52: expected '#A@c',\
    \ got 'C@a#'\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n        tmp93adqkz3_test.go:52:\
    \ expected '#aSDFw^45', got '54^WfdsA#'\n    --- FAIL: TestSolve/test_num__6 (0.00s)\n\
    \        tmp93adqkz3_test.go:52: expected '#$A^d', got 'D^a$#'\n    --- FAIL:\
    \ TestSolve/test_num__7 (0.00s)\n        tmp93adqkz3_test.go:52: expected '#CCC',\
    \ got 'ccc#'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073400
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    // your code here\n    return \"\"\n}\n\nfunc TestSolve(t *testing.T)\
    \ {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"\
    ), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmp7iqcwyhb_test.go:45: expected 'aSdF', got ''\n    --- FAIL: TestSolve/test_num__1\
    \ (0.00s)\n        tmp7iqcwyhb_test.go:45: expected '4321', got ''\n    --- FAIL:\
    \ TestSolve/test_num__2 (0.00s)\n        tmp7iqcwyhb_test.go:45: expected 'AB',\
    \ got ''\n    --- FAIL: TestSolve/test_num__3 (0.00s)\n        tmp7iqcwyhb_test.go:45:\
    \ expected '#A@c', got ''\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n     \
    \   tmp7iqcwyhb_test.go:45: expected '#aSDFw^45', got ''\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmp7iqcwyhb_test.go:45: expected '2@6#', got ''\n    --- FAIL:\
    \ TestSolve/test_num__6 (0.00s)\n        tmp7iqcwyhb_test.go:45: expected '#$A^d',\
    \ got ''\n    --- FAIL: TestSolve/test_num__7 (0.00s)\n        tmp7iqcwyhb_test.go:45:\
    \ expected '#CCC', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073213
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var result string\n    for _, c := range s {\n        if c >= 'a' &&\
    \ c <= 'z' {\n            result += string(c - 32)\n        } else if c >= 'A'\
    \ && c <= 'Z' {\n            result += string(c + 32)\n        } else {\n    \
    \        result += string(c)\n        }\n    }\n    if len(result) == len(s) {\n\
    \        var reverse []byte\n        for i := len(result) - 1; i >= 0; i-- {\n\
    \            reverse = append(reverse, result[i])\n        }\n        return string(reverse)\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmp4pa1xx6z_test.go:61: expected 'aSdF', got 'FdSa'\n    --- FAIL: TestSolve/test_num__2\
    \ (0.00s)\n        tmp4pa1xx6z_test.go:61: expected 'AB', got 'BA'\n    --- FAIL:\
    \ TestSolve/test_num__3 (0.00s)\n        tmp4pa1xx6z_test.go:61: expected '#A@c',\
    \ got 'c@A#'\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n        tmp4pa1xx6z_test.go:61:\
    \ expected '#aSDFw^45', got '54^wFDSa#'\n    --- FAIL: TestSolve/test_num__6 (0.00s)\n\
    \        tmp4pa1xx6z_test.go:61: expected '#$A^d', got 'd^A$#'\n    --- FAIL:\
    \ TestSolve/test_num__7 (0.00s)\n        tmp4pa1xx6z_test.go:61: expected '#CCC',\
    \ got 'CCC#'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073400
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    l := len(s)\n    r := make([]byte, l)\n    for i, c := range s {\n  \
    \      if 'a' <= c && c <= 'z' {\n            r[l-i-1] = byte(c - 'a' + 'A')\n\
    \        } else if 'A' <= c && c <= 'Z' {\n            r[l-i-1] = byte(c - 'A'\
    \ + 'a')\n        } else {\n            r[l-i-1] = byte(c)\n        }\n    }\n\
    \    return string(r)\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n\
    \     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmpvqsa_8r0_test.go:55: expected 'aSdF', got 'FdSa'\n    --- FAIL: TestSolve/test_num__2\
    \ (0.00s)\n        tmpvqsa_8r0_test.go:55: expected 'AB', got 'BA'\n    --- FAIL:\
    \ TestSolve/test_num__3 (0.00s)\n        tmpvqsa_8r0_test.go:55: expected '#A@c',\
    \ got 'c@A#'\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n        tmpvqsa_8r0_test.go:55:\
    \ expected '#aSDFw^45', got '54^wFDSa#'\n    --- FAIL: TestSolve/test_num__6 (0.00s)\n\
    \        tmpvqsa_8r0_test.go:55: expected '#$A^d', got 'd^A$#'\n    --- FAIL:\
    \ TestSolve/test_num__7 (0.00s)\n        tmpvqsa_8r0_test.go:55: expected '#CCC',\
    \ got 'CCC#'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073400
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var sb strings.Builder\n    for _, c := range s {\n        if unicode.IsLetter(c)\
    \ {\n            if unicode.IsUpper(c) {\n                sb.WriteRune(unicode.ToLower(c))\n\
    \            } else {\n                sb.WriteRune(unicode.ToUpper(c))\n    \
    \        }\n        } else {\n            sb.WriteRune(c)\n        }\n    }\n\
    \    if len(sb.String()) == 0 {\n        sb.WriteString(s)\n    }\n    return\
    \ sb.String()\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n    \
    \ { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_zdr9jtm_test.go:21:12: undefined: strings

    /tmp/tmp_zdr9jtm_test.go:23:12: undefined: unicode

    /tmp/tmp_zdr9jtm_test.go:24:16: undefined: unicode

    /tmp/tmp_zdr9jtm_test.go:25:30: undefined: unicode

    /tmp/tmp_zdr9jtm_test.go:27:30: undefined: unicode

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073399
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    // your code here\n    return \"\"\n}\n\nfunc TestSolve(t *testing.T)\
    \ {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"\
    ), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmp7iqcwyhb_test.go:45: expected 'aSdF', got ''\n    --- FAIL: TestSolve/test_num__1\
    \ (0.00s)\n        tmp7iqcwyhb_test.go:45: expected '4321', got ''\n    --- FAIL:\
    \ TestSolve/test_num__2 (0.00s)\n        tmp7iqcwyhb_test.go:45: expected 'AB',\
    \ got ''\n    --- FAIL: TestSolve/test_num__3 (0.00s)\n        tmp7iqcwyhb_test.go:45:\
    \ expected '#A@c', got ''\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n     \
    \   tmp7iqcwyhb_test.go:45: expected '#aSDFw^45', got ''\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmp7iqcwyhb_test.go:45: expected '2@6#', got ''\n    --- FAIL:\
    \ TestSolve/test_num__6 (0.00s)\n        tmp7iqcwyhb_test.go:45: expected '#$A^d',\
    \ got ''\n    --- FAIL: TestSolve/test_num__7 (0.00s)\n        tmp7iqcwyhb_test.go:45:\
    \ expected '#CCC', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073213
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    if len(s) == 0 {\n        return s\n    }\n    if s[0] >= 97 && s[0]\
    \ <= 122 {\n        return string(s[0] - 32) + solve(s[1:])\n    } else if s[0]\
    \ >= 65 && s[0] <= 90 {\n        return string(s[0] + 32) + solve(s[1:])\n   \
    \ } else {\n        return string(s[0]) + solve(s[1:])\n    }\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmp8q4dlwcl_test.go:53: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmp8q4dlwcl_test.go:53: expected '2@6#', got '#6@2'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073400
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    runes := []rune(s)\n    c := 0\n    for i, r := range runes {\n     \
    \   if unicode.IsLetter(r) {\n            runes[i] = unicode.ToLower(r)\n    \
    \        c += 1\n        }\n    }\n    if c == 0 {\n        for i, j := 0, len(runes)-1;\
    \ i < j; i, j = i+1, j-1 {\n            runes[i], runes[j] = runes[j], runes[i]\n\
    \        }\n    }\n    return string(runes)\n}\n\nfunc TestSolve(t *testing.T)\
    \ {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"\
    ), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_mlnb8_4_test.go:24:12: undefined: unicode

    /tmp/tmp_mlnb8_4_test.go:25:24: undefined: unicode

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073399
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    r := make([]rune, len(s))\n    for i, c := range s {\n        if (c >=\
    \ 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') {\n            r[i] = c ^ 0x20\n\
    \        } else {\n            r[i] = c\n        }\n    }\n    // no letters in\
    \ the string\n    if len(r) > 0 && r[0] == 0 {\n        return reverse(s)\n  \
    \  }\n    return string(r)\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqocrwt_r_test.go:31:16: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073399
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    return \"\"\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n\
    \     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmpfxerxnn2_test.go:44: expected 'aSdF', got ''\n    --- FAIL: TestSolve/test_num__1\
    \ (0.00s)\n        tmpfxerxnn2_test.go:44: expected '4321', got ''\n    --- FAIL:\
    \ TestSolve/test_num__2 (0.00s)\n        tmpfxerxnn2_test.go:44: expected 'AB',\
    \ got ''\n    --- FAIL: TestSolve/test_num__3 (0.00s)\n        tmpfxerxnn2_test.go:44:\
    \ expected '#A@c', got ''\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n     \
    \   tmpfxerxnn2_test.go:44: expected '#aSDFw^45', got ''\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmpfxerxnn2_test.go:44: expected '2@6#', got ''\n    --- FAIL:\
    \ TestSolve/test_num__6 (0.00s)\n        tmpfxerxnn2_test.go:44: expected '#$A^d',\
    \ got ''\n    --- FAIL: TestSolve/test_num__7 (0.00s)\n        tmpfxerxnn2_test.go:44:\
    \ expected '#CCC', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073400
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var l, r rune\n    var rs []rune\n    for _, r = range s {\n        if\
    \ is_letter(r) {\n            rs = append(rs, change_case(r))\n        } else\
    \ {\n            rs = append(rs, r)\n        }\n    }\n    l = 0\n    r = len(rs)\
    \ - 1\n    for l < r {\n        rs[l], rs[r] = rs[r], rs[l]\n        l++\n   \
    \     r--\n    }\n    return string(rs)\n}\n\nfunc TestSolve(t *testing.T) {\n\
    \  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected:\
    \ \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n   \
    \  { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp4wspdmy_test.go:24:12: undefined: is_letter

    /tmp/tmpp4wspdmy_test.go:25:29: undefined: change_case

    /tmp/tmpp4wspdmy_test.go:31:9: cannot use len(rs) - 1 (value of type int) as type
    rune in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073400
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var r []rune\n    for _, v := range s {\n        if (v >= 'a' && v <=\
    \ 'z') || (v >= 'A' && v <= 'Z') {\n            r = append(r, unicode.ToLower(v))\n\
    \        } else {\n            r = append(r, v)\n        }\n    }\n    if len(r)\
    \ == 0 {\n        // If the string contains no letters, reverse the string.\n\
    \        return Reverse(s)\n    } else {\n        return string(r)\n    }\n}\n\
    \nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_p9xyrx__test.go:24:27: undefined: unicode

    /tmp/tmp_p9xyrx__test.go:31:16: undefined: Reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073401
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    slen := len(s)\n    res := \"\"\n    for i:=0; i<slen; i++ {\n      \
    \  if s[i] >= 'a' && s[i] <= 'z' {\n            res += string(s[i] - 32)\n   \
    \     } else if s[i] >= 'A' && s[i] <= 'Z' {\n            res += string(s[i] +\
    \ 32)\n        } else {\n            res += string(s[i])\n        }\n    }\n \
    \   return res\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n\
    \     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmpkppygrrf_test.go:55: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmpkppygrrf_test.go:55: expected '2@6#', got '#6@2'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073401
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    if len(s) == 0 {\n        return s\n    }\n    var b []byte\n    for\
    \ i := len(s) - 1; i >= 0; i-- {\n        b = append(b, byte(s[i]))\n    }\n \
    \   for i := 0; i < len(b); i++ {\n        if b[i] >= 'a' && b[i] <= 'z' {\n \
    \           b[i] -= 32\n        } else if b[i] >= 'A' && b[i] <= 'Z' {\n     \
    \       b[i] += 32\n        }\n    }\n    return string(b)\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmpgld84_25_test.go:58: expected 'aSdF', got 'FdSa'\n    --- FAIL: TestSolve/test_num__2\
    \ (0.00s)\n        tmpgld84_25_test.go:58: expected 'AB', got 'BA'\n    --- FAIL:\
    \ TestSolve/test_num__3 (0.00s)\n        tmpgld84_25_test.go:58: expected '#A@c',\
    \ got 'c@A#'\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n        tmpgld84_25_test.go:58:\
    \ expected '#aSDFw^45', got '54^wFDSa#'\n    --- FAIL: TestSolve/test_num__6 (0.00s)\n\
    \        tmpgld84_25_test.go:58: expected '#$A^d', got 'd^A$#'\n    --- FAIL:\
    \ TestSolve/test_num__7 (0.00s)\n        tmpgld84_25_test.go:58: expected '#CCC',\
    \ got 'CCC#'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073401
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var allLetters = false\n    for _, char := range s {\n        if char\
    \ >= 'a' && char <= 'z' || char >= 'A' && char <= 'Z' {\n            allLetters\
    \ = true\n            break\n        }\n    }\n    if !allLetters {\n        return\
    \ reverseString(s)\n    }\n    var result = \"\"\n    for _, char := range s {\n\
    \        if char >= 'a' && char <= 'z' {\n            result += string(char -\
    \ 'a' + 'A')\n        } else if char >= 'A' && char <= 'Z' {\n            result\
    \ += string(char - 'A' + 'a')\n        } else {\n            result += string(char)\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp9a3ns_a_test.go:29:16: undefined: reverseString

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073401
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var result string\n    for _, r := range s {\n        if r >= 'a' &&\
    \ r <= 'z' {\n            result += string(r - 'a' + 'A')\n        } else if r\
    \ >= 'A' && r <= 'Z' {\n            result += string(r - 'A' + 'a')\n        }\
    \ else {\n            result += string(r)\n        }\n    }\n    if result ==\
    \ s {\n        for i, j := 0, len(result) - 1; i < j; i, j = i + 1, j - 1 {\n\
    \            result[i], result[j] = result[j], result[i]\n        }\n    }\n \
    \   return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n\
    \     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpq4ts64uo_test.go:33:13: cannot assign to result[i] (value of type byte)

    /tmp/tmpq4ts64uo_test.go:33:24: cannot assign to result[j] (value of type byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073401
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    t := \"\"\n    l := len(s)\n    if l < 1 {\n        return t\n    }\n\
    \    if l < 2 {\n        if s[0] >='a' && s[0] <= 'z' {\n            t = string(s[0]\
    \ - 32)\n        } else if s[0] >='A' && s[0] <= 'Z' {\n            t = string(s[0]\
    \ + 32)\n        } else {\n            t = s\n        }\n        return t\n  \
    \  }\n    for i := 0; i < l; i++ {\n        if s[i] >='a' && s[i] <= 'z' {\n \
    \           t += string(s[i] - 32)\n        } else if s[i] >='A' && s[i] <= 'Z'\
    \ {\n            t += string(s[i] + 32)\n        } else {\n            t += string(s[i])\n\
    \        }\n    }\n    return t\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmppongluz1_test.go:68: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmppongluz1_test.go:68: expected '2@6#', got '#6@2'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073402
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    ln := len(s)\n    if ln == 0 {\n        return s\n    }\n    for i :=\
    \ 0; i < ln; i++ {\n        if s[i] >= 'a' && s[i] <= 'z' {\n            s = s[:i]\
    \ + string(s[i] - 32) + s[i+1:]\n        } else if s[i] >= 'A' && s[i] <= 'Z'\
    \ {\n            s = s[:i] + string(s[i] + 32) + s[i+1:]\n        }\n    }\n \
    \   return s\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n    \
    \ { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmpl_3i03cd_test.go:55: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmpl_3i03cd_test.go:55: expected '2@6#', got '#6@2'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073402
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    if len(s) == 0 {\n        return s\n    }\n    var revert bool\n    for\
    \ _, c := range s {\n        if c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' {\n\
    \            revert = true\n            break\n        }\n    }\n    res := make([]byte,\
    \ len(s))\n    for i, c := range s {\n        if c >= 'a' && c <= 'z' {\n    \
    \        res[i] = byte(c - 32)\n        } else if c >= 'A' && c <= 'Z' {\n   \
    \         res[i] = byte(c + 32)\n        } else {\n            res[i] = byte(c)\n\
    \        }\n    }\n    if revert {\n        return string(res)\n    }\n    return\
    \ string(reverse(res))\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n\
    \     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp33tfobt8_test.go:44:19: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073401
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var sRunes []rune\n    for _, v := range s {\n        if v >= 'a' &&\
    \ v <= 'z' {\n            sRunes = append(sRunes, v - 32)\n        } else if v\
    \ >= 'A' && v <= 'Z' {\n            sRunes = append(sRunes, v + 32)\n        }\
    \ else {\n            sRunes = append(sRunes, v)\n        }\n    }\n    return\
    \ string(sRunes)\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n\
    \     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmpgtbs7qqk_test.go:54: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmpgtbs7qqk_test.go:54: expected '2@6#', got '#6@2'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073402
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    // your code here\n    return \"\"\n}\n\nfunc TestSolve(t *testing.T)\
    \ {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"\
    ), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmp7iqcwyhb_test.go:45: expected 'aSdF', got ''\n    --- FAIL: TestSolve/test_num__1\
    \ (0.00s)\n        tmp7iqcwyhb_test.go:45: expected '4321', got ''\n    --- FAIL:\
    \ TestSolve/test_num__2 (0.00s)\n        tmp7iqcwyhb_test.go:45: expected 'AB',\
    \ got ''\n    --- FAIL: TestSolve/test_num__3 (0.00s)\n        tmp7iqcwyhb_test.go:45:\
    \ expected '#A@c', got ''\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n     \
    \   tmp7iqcwyhb_test.go:45: expected '#aSDFw^45', got ''\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmp7iqcwyhb_test.go:45: expected '2@6#', got ''\n    --- FAIL:\
    \ TestSolve/test_num__6 (0.00s)\n        tmp7iqcwyhb_test.go:45: expected '#$A^d',\
    \ got ''\n    --- FAIL: TestSolve/test_num__7 (0.00s)\n        tmp7iqcwyhb_test.go:45:\
    \ expected '#CCC', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073213
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    r := []rune(s)\n    for i, c := range r {\n        if c >= 'a' && c <=\
    \ 'z' {\n            r[i] = c - 'a' + 'A'\n        } else if c >= 'A' && c <=\
    \ 'Z' {\n            r[i] = c - 'A' + 'a'\n        }\n    }\n    return string(r)\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmpc8t5d73r_test.go:52: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmpc8t5d73r_test.go:52: expected '2@6#', got '#6@2'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073402
- exit_code: 0
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    if len(s) == 0 {\n        return s\n    }\n    if len(s) == 1 {\n   \
    \     return s\n    }\n    b := []byte(s)\n    ch := false\n    for i := 0; i\
    \ < len(b); i++ {\n        if b[i] >= 'a' && b[i] <= 'z' {\n            ch = true\n\
    \            break\n        }\n        if b[i] >= 'A' && b[i] <= 'Z' {\n     \
    \       ch = true\n            break\n        }\n    }\n    if !ch {\n       \
    \ for i := 0; i < len(b)/2; i++ {\n            b[i], b[len(b)-i-1] = b[len(b)-i-1],\
    \ b[i]\n        }\n        return string(b)\n    }\n    for i := 0; i < len(b);\
    \ i++ {\n        if b[i] >= 'a' && b[i] <= 'z' {\n            b[i] -= 'a' - 'A'\n\
    \        } else if b[i] >= 'A' && b[i] <= 'Z' {\n            b[i] += 'a' - 'A'\n\
    \        }\n    }\n    return string(b)\n}\n\nfunc TestSolve(t *testing.T) {\n\
    \  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected:\
    \ \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n   \
    \  { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073402
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    sRune := []rune(s)\n    for i, c := range sRune {\n        if (c >= 'a'\
    \ && c <= 'z') || (c >= 'A' && c <= 'Z') {\n            if c >= 'a' && c <= 'z'\
    \ {\n                sRune[i] = c - 'a' + 'A'\n            } else {\n        \
    \        sRune[i] = c - 'A' + 'a'\n            }\n        }\n    }\n    if len(sRune)\
    \ > 0 {\n        return string(sRune)\n    }\n    return s\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmphu6ppbk2_test.go:57: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmphu6ppbk2_test.go:57: expected '2@6#', got '#6@2'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073402
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    if len(s) == 0 {\n        return s\n    }\n    if len(s) == 1 {\n   \
    \     return s\n    }\n    for i := 0; i < len(s); i++ {\n        if (s[i] >=\
    \ 'a' && s[i] <= 'z') || (s[i] >= 'A' && s[i] <= 'Z') {\n            if s[i] ==\
    \ 'a' || s[i] == 'A' {\n                s = s[:i] + string(s[i] - 'a' + 'A') +\
    \ s[i+1:]\n            } else if s[i] == 'z' || s[i] == 'Z' {\n              \
    \  s = s[:i] + string(s[i] - 'Z' + 'z') + s[i+1:]\n            } else {\n    \
    \            if s[i] > 'Z' {\n                    s = s[:i] + string(s[i] - 'a'\
    \ + 'A') + s[i+1:]\n                } else {\n                    s = s[:i] +\
    \ string(s[i] - 'A' + 'a') + s[i+1:]\n                }\n            }\n     \
    \   }\n    }\n    return s\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmpuhqzi72o_test.go:65: expected 'aSdF', got '!SdF'\n    --- FAIL: TestSolve/test_num__1\
    \ (0.00s)\n        tmpuhqzi72o_test.go:65: expected '4321', got '1234'\n    ---\
    \ FAIL: TestSolve/test_num__4 (0.00s)\n        tmpuhqzi72o_test.go:65: expected\
    \ '#aSDFw^45', got '#!SDFw^45'\n    --- FAIL: TestSolve/test_num__5 (0.00s)\n\
    \        tmpuhqzi72o_test.go:65: expected '2@6#', got '#6@2'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073402
- exit_code: 0
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    if s == \"\" {\n        return s\n    }\n    res := make([]byte, len(s))\n\
    \    isLetter := false\n    for i := 0; i < len(s); i++ {\n        c := s[i]\n\
    \        isLower := c >= 'a' && c <= 'z'\n        isUpper := c >= 'A' && c <=\
    \ 'Z'\n        if isLower || isUpper {\n            isLetter = true\n        \
    \    if isLower {\n                res[i] = c - 'a' + 'A'\n            } else\
    \ {\n                res[i] = c - 'A' + 'a'\n            }\n        } else {\n\
    \            res[i] = c\n        }\n    }\n    if !isLetter {\n        for i :=\
    \ 0; i < len(s) / 2; i++ {\n            res[i], res[len(s) - i - 1] = res[len(s)\
    \ - i - 1], res[i]\n        }\n    }\n    return string(res)\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073402
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    return \"\";\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n\
    \     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmpbhc4j7yz_test.go:44: expected 'aSdF', got ''\n    --- FAIL: TestSolve/test_num__1\
    \ (0.00s)\n        tmpbhc4j7yz_test.go:44: expected '4321', got ''\n    --- FAIL:\
    \ TestSolve/test_num__2 (0.00s)\n        tmpbhc4j7yz_test.go:44: expected 'AB',\
    \ got ''\n    --- FAIL: TestSolve/test_num__3 (0.00s)\n        tmpbhc4j7yz_test.go:44:\
    \ expected '#A@c', got ''\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n     \
    \   tmpbhc4j7yz_test.go:44: expected '#aSDFw^45', got ''\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmpbhc4j7yz_test.go:44: expected '2@6#', got ''\n    --- FAIL:\
    \ TestSolve/test_num__6 (0.00s)\n        tmpbhc4j7yz_test.go:44: expected '#$A^d',\
    \ got ''\n    --- FAIL: TestSolve/test_num__7 (0.00s)\n        tmpbhc4j7yz_test.go:44:\
    \ expected '#CCC', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073402
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    r := []rune(s)\n    for i, v := range r {\n        if unicode.IsLetter(v)\
    \ {\n            if unicode.IsUpper(v) {\n                r[i] = unicode.ToLower(v)\n\
    \            } else {\n                r[i] = unicode.ToUpper(v)\n           \
    \ }\n        }\n    }\n    return string(r)\n}\n\nfunc TestSolve(t *testing.T)\
    \ {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"\
    ), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph4gy_x19_test.go:23:12: undefined: unicode

    /tmp/tmph4gy_x19_test.go:24:16: undefined: unicode

    /tmp/tmph4gy_x19_test.go:25:24: undefined: unicode

    /tmp/tmph4gy_x19_test.go:27:24: undefined: unicode

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073402
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var s2 []byte\n    for i, c := range s {\n        if (c >= 'a' && c <=\
    \ 'z') || (c >= 'A' && c <= 'Z') {\n            if c >= 'a' && c <= 'z' {\n  \
    \              s2 = append(s2, byte(c - 'a' + 'A'))\n            } else {\n  \
    \              s2 = append(s2, byte(c - 'A' + 'a'))\n            }\n        }\
    \ else {\n            s2 = append(s2, s[i])\n        }\n    }\n    if len(s2)\
    \ == 0 {\n        s2 = []byte(s)\n    }\n    return string(s2)\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmp0vcamrm6_test.go:59: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmp0vcamrm6_test.go:59: expected '2@6#', got '#6@2'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073402
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    l := []rune(s)\n    for i, c := range l {\n        if c >= 'a' && c <=\
    \ 'z' {\n            l[i] = c - 32\n        } else if c >= 'A' && c <= 'Z' {\n\
    \            l[i] = c + 32\n        }\n    }\n    return string(l)\n}\n\nfunc\
    \ TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmpzihv0qmu_test.go:52: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmpzihv0qmu_test.go:52: expected '2@6#', got '#6@2'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073402
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    str := []rune(s)\n    var char rune\n    for i, char := range str {\n\
    \        if char >= 'a' && char <= 'z' {\n            str[i] = char - 32\n   \
    \     } else if char >= 'A' && char <= 'Z' {\n            str[i] = char + 32\n\
    \        }\n    }\n    return string(str)\n}\n\nfunc TestSolve(t *testing.T) {\n\
    \  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected:\
    \ \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n   \
    \  { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5b_ytkt8_test.go:22:9: char declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073402
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    return \"\"\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n\
    \     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmpfxerxnn2_test.go:44: expected 'aSdF', got ''\n    --- FAIL: TestSolve/test_num__1\
    \ (0.00s)\n        tmpfxerxnn2_test.go:44: expected '4321', got ''\n    --- FAIL:\
    \ TestSolve/test_num__2 (0.00s)\n        tmpfxerxnn2_test.go:44: expected 'AB',\
    \ got ''\n    --- FAIL: TestSolve/test_num__3 (0.00s)\n        tmpfxerxnn2_test.go:44:\
    \ expected '#A@c', got ''\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n     \
    \   tmpfxerxnn2_test.go:44: expected '#aSDFw^45', got ''\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmpfxerxnn2_test.go:44: expected '2@6#', got ''\n    --- FAIL:\
    \ TestSolve/test_num__6 (0.00s)\n        tmpfxerxnn2_test.go:44: expected '#$A^d',\
    \ got ''\n    --- FAIL: TestSolve/test_num__7 (0.00s)\n        tmpfxerxnn2_test.go:44:\
    \ expected '#CCC', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073400
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var (\n        bs = []byte(s)\n        foundLetter bool\n    )\n    for\
    \ i, b := range bs {\n        if isLetter(b) {\n            foundLetter = true\n\
    \            bs[i] = toggle(b)\n        }\n    }\n    if !foundLetter {\n    \
    \    // if no letters found, reverse\n        for i, j := 0, len(bs) - 1; i <\
    \ j; i, j = i + 1, j - 1 {\n            bs[i], bs[j] = bs[j], bs[i]\n        }\n\
    \    }\n    return string(bs)\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjnt54l1x_test.go:26:12: undefined: isLetter

    /tmp/tmpjnt54l1x_test.go:28:21: undefined: toggle

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073402
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    i := 0\n    for i < len(s) && !isAlpha(s[i]) {\n        i++\n    }\n\
    \    if i == len(s) {\n        return Reverse(s)\n    }\n    for j := i; j < len(s);\
    \ j++ {\n        if isAlpha(s[j]) {\n            if isLower(s[j]) {\n        \
    \        s = s[:j] + string(s[j] - 32) + s[j+1:]\n            } else {\n     \
    \           s = s[:j] + string(s[j] + 32) + s[j+1:]\n            }\n        }\n\
    \    }\n    return s\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n\
    \     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpuviwz28m_test.go:22:24: undefined: isAlpha

    /tmp/tmpuviwz28m_test.go:26:16: undefined: Reverse

    /tmp/tmpuviwz28m_test.go:29:12: undefined: isAlpha

    /tmp/tmpuviwz28m_test.go:30:16: undefined: isLower

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073402
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    // Your code here\n    return \"\"\n}\n\nfunc TestSolve(t *testing.T)\
    \ {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"\
    ), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmpoa4_fjf9_test.go:45: expected 'aSdF', got ''\n    --- FAIL: TestSolve/test_num__1\
    \ (0.00s)\n        tmpoa4_fjf9_test.go:45: expected '4321', got ''\n    --- FAIL:\
    \ TestSolve/test_num__2 (0.00s)\n        tmpoa4_fjf9_test.go:45: expected 'AB',\
    \ got ''\n    --- FAIL: TestSolve/test_num__3 (0.00s)\n        tmpoa4_fjf9_test.go:45:\
    \ expected '#A@c', got ''\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n     \
    \   tmpoa4_fjf9_test.go:45: expected '#aSDFw^45', got ''\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmpoa4_fjf9_test.go:45: expected '2@6#', got ''\n    --- FAIL:\
    \ TestSolve/test_num__6 (0.00s)\n        tmpoa4_fjf9_test.go:45: expected '#$A^d',\
    \ got ''\n    --- FAIL: TestSolve/test_num__7 (0.00s)\n        tmpoa4_fjf9_test.go:45:\
    \ expected '#CCC', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073402
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    if len(s) == 0 {\n        return s\n    }\n    for i := 0; i < len(s);\
    \ i++ {\n        if s[i] >= 65 && s[i] <= 90 {\n            s = s[:i] + string(s[i]\
    \ + 32) + s[i+1:]\n        } else if s[i] >= 97 && s[i] <= 122 {\n           \
    \ s = s[:i] + string(s[i] - 32) + s[i+1:]\n        }\n    }\n    return s\n}\n\
    \nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmp85b2vfcz_test.go:54: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmp85b2vfcz_test.go:54: expected '2@6#', got '#6@2'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073403
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    if s == \"\" {\n        return s\n    }\n    r := []rune(s)\n    for\
    \ i, c := range r {\n        if c > 64 && c < 91 {\n            r[i] = c + 32\n\
    \        } else if c > 96 && c < 123 {\n            r[i] = c - 32\n        }\n\
    \    }\n    return string(r)\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmp90dgu09r_test.go:55: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmp90dgu09r_test.go:55: expected '2@6#', got '#6@2'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073404
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    if len(s) == 0 {\n        return s\n    }\n    var ret []byte\n    for\
    \ i := 0; i < len(s); i++ {\n        if s[i] >= 'a' && s[i] <= 'z' {\n       \
    \     ret = append(ret, s[i] - 32)\n        } else if s[i] >= 'A' && s[i] <= 'Z'\
    \ {\n            ret = append(ret, s[i] + 32)\n        } else {\n            ret\
    \ = append(ret, s[i])\n        }\n    }\n    if len(ret) == 0 {\n        return\
    \ reverseString(s)\n    }\n    return string(ret)\n}\n\nfunc TestSolve(t *testing.T)\
    \ {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"\
    ), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp26q2r03a_test.go:35:16: undefined: reverseString

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073404
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    // reverse case of letters, if any.\n    // if there are no letters,\
    \ reverse string\n    if isLetter(s) {\n        // reverse case\n        var out\
    \ string\n        for _, c := range s {\n            if isLower(c) {\n       \
    \         out += string(c - 'a' + 'A')\n            } else if isUpper(c) {\n \
    \               out += string(c - 'A' + 'a')\n            } else {\n         \
    \       out += string(c)\n            }\n        }\n        return out\n    }\n\
    \    return reverse(s)\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n\
    \     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9dqp11t0_test.go:23:8: undefined: isLetter

    /tmp/tmp9dqp11t0_test.go:27:16: undefined: isLower

    /tmp/tmp9dqp11t0_test.go:29:23: undefined: isUpper

    /tmp/tmp9dqp11t0_test.go:37:12: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073404
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    l := len(s)\n    if l == 0 {\n        return s\n    }\n    runes := []rune(s)\n\
    \    for i := 0; i < l; i++ {\n        if (runes[i] >= 'a' && runes[i] <= 'z')\
    \ || (runes[i] >= 'A' && runes[i] <= 'Z') {\n            runes[i] = reverseCase(runes[i])\n\
    \        }\n    }\n    return string(runes)\n}\n\nfunc TestSolve(t *testing.T)\
    \ {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"\
    ), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjr4lr1ic_test.go:28:24: undefined: reverseCase

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073404
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    if s == \"\" {\n        return s\n    }\n    var c byte\n    var i int\n\
    \    for i = 0; i < len(s); i++ {\n        c = s[i]\n        if c >= 'a' && c\
    \ <= 'z' || c >= 'A' && c <= 'Z' {\n            break\n        }\n    }\n    if\
    \ i == len(s) {\n        return reverse(s)\n    }\n    for j := i; j < len(s);\
    \ j++ {\n        if s[j] >= 'a' && s[j] <= 'z' {\n            s = s[:j] + string(s[j]\
    \ - 'a' + 'A') + s[j+1:]\n        } else if s[j] >= 'A' && s[j] <= 'Z' {\n   \
    \         s = s[:j] + string(s[j] - 'A' + 'a') + s[j+1:]\n        }\n    }\n \
    \   return s\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n    \
    \ { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsxld743u_test.go:33:16: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073404
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    // Write your code here\n    return \"\"\n}\n\nfunc TestSolve(t *testing.T)\
    \ {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"\
    ), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmpqwwri4t0_test.go:45: expected 'aSdF', got ''\n    --- FAIL: TestSolve/test_num__1\
    \ (0.00s)\n        tmpqwwri4t0_test.go:45: expected '4321', got ''\n    --- FAIL:\
    \ TestSolve/test_num__2 (0.00s)\n        tmpqwwri4t0_test.go:45: expected 'AB',\
    \ got ''\n    --- FAIL: TestSolve/test_num__3 (0.00s)\n        tmpqwwri4t0_test.go:45:\
    \ expected '#A@c', got ''\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n     \
    \   tmpqwwri4t0_test.go:45: expected '#aSDFw^45', got ''\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmpqwwri4t0_test.go:45: expected '2@6#', got ''\n    --- FAIL:\
    \ TestSolve/test_num__6 (0.00s)\n        tmpqwwri4t0_test.go:45: expected '#$A^d',\
    \ got ''\n    --- FAIL: TestSolve/test_num__7 (0.00s)\n        tmpqwwri4t0_test.go:45:\
    \ expected '#CCC', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073215
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var c byte\n    var n string\n    for i:=len(s)-1; i>=0; i-- {\n    \
    \    c = s[i]\n        if c >= 'a' && c <= 'z' {\n            c -= ('a' - 'A')\n\
    \        } else if c >= 'A' && c <= 'Z' {\n            c += ('a' - 'A')\n    \
    \    }\n        n += string(c)\n    }\n    return n\n}\n\nfunc TestSolve(t *testing.T)\
    \ {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"\
    ), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmpsf9xum7n_test.go:55: expected 'aSdF', got 'FdSa'\n    --- FAIL: TestSolve/test_num__2\
    \ (0.00s)\n        tmpsf9xum7n_test.go:55: expected 'AB', got 'BA'\n    --- FAIL:\
    \ TestSolve/test_num__3 (0.00s)\n        tmpsf9xum7n_test.go:55: expected '#A@c',\
    \ got 'c@A#'\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n        tmpsf9xum7n_test.go:55:\
    \ expected '#aSDFw^45', got '54^wFDSa#'\n    --- FAIL: TestSolve/test_num__6 (0.00s)\n\
    \        tmpsf9xum7n_test.go:55: expected '#$A^d', got 'd^A$#'\n    --- FAIL:\
    \ TestSolve/test_num__7 (0.00s)\n        tmpsf9xum7n_test.go:55: expected '#CCC',\
    \ got 'CCC#'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073404
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    for _, c := range s {\n        fmt.Println(c)\n    }\n    return \"\"\
    \n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "65\n115\n68\n102\n49\n50\n51\n52\n97\n98\n35\n97\n64\n67\n35\n65\n115\n\
    100\n102\n87\n94\n52\n53\n35\n54\n64\n50\n35\n36\n97\n94\n68\n35\n99\n99\n99\n\
    --- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n   \
    \     tmp5tknhep2_test.go:47: expected 'aSdF', got ''\n    --- FAIL: TestSolve/test_num__1\
    \ (0.00s)\n        tmp5tknhep2_test.go:47: expected '4321', got ''\n    --- FAIL:\
    \ TestSolve/test_num__2 (0.00s)\n        tmp5tknhep2_test.go:47: expected 'AB',\
    \ got ''\n    --- FAIL: TestSolve/test_num__3 (0.00s)\n        tmp5tknhep2_test.go:47:\
    \ expected '#A@c', got ''\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n     \
    \   tmp5tknhep2_test.go:47: expected '#aSDFw^45', got ''\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmp5tknhep2_test.go:47: expected '2@6#', got ''\n    --- FAIL:\
    \ TestSolve/test_num__6 (0.00s)\n        tmp5tknhep2_test.go:47: expected '#$A^d',\
    \ got ''\n    --- FAIL: TestSolve/test_num__7 (0.00s)\n        tmp5tknhep2_test.go:47:\
    \ expected '#CCC', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073405
- exit_code: 0
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    num := 0\n    // count number of letters in s\n    for _, c := range\
    \ s {\n        if c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' {\n           \
    \ num++\n        }\n    }\n    // if no letters, reverse the string\n    if num\
    \ == 0 {\n        b := []byte(s)\n        for i := 0; i < len(b)/2; i++ {\n  \
    \          b[i], b[len(b)-i-1] = b[len(b)-i-1], b[i]\n        }\n        return\
    \ string(b)\n    }\n    // else, reverse the case of letters\n    b := []byte(s)\n\
    \    for i := 0; i < len(b); i++ {\n        if b[i] >= 'a' && b[i] <= 'z' {\n\
    \            b[i] -= 'a' - 'A'\n        } else if b[i] >= 'A' && b[i] <= 'Z' {\n\
    \            b[i] += 'a' - 'A'\n        }\n    }\n    return string(b)\n}\n\n\
    func TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073405
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    if len(s) == 0 {\n        return s\n    }\n    var output string\n  \
    \  // var revs = []rune(s)\n    // var revSize = len(revs)\n    for _, c := range\
    \ s {\n        if c >= 'a' && c <= 'z' {\n            output += string(c + 'A'\
    \ - 'a')\n        } else if c >= 'A' && c <= 'Z' {\n            output += string(c\
    \ + 'a' - 'A')\n        } else {\n            output += string(c)\n        }\n\
    \    }\n    return output\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmpaexjwa54_test.go:59: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmpaexjwa54_test.go:59: expected '2@6#', got '#6@2'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073405
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    if len(s) == 0 {\n        return s\n    }\n    for i := 0; i < len(s);\
    \ i++ {\n        if s[i] >= 'a' && s[i] <= 'z' {\n            s = s[:i] + string(s[i]\
    \ - 32) + s[i+1:]\n        } else if s[i] >= 'A' && s[i] <= 'Z' {\n          \
    \  s = s[:i] + string(s[i] + 32) + s[i+1:]\n        }\n    }\n    return s\n}\n\
    \nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmpzc3tqasr_test.go:54: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmpzc3tqasr_test.go:54: expected '2@6#', got '#6@2'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073215
- exit_code: 0
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var (\n        runes = []rune(s)\n        result = make([]rune, len(runes))\n\
    \    )\n    has_letter := false\n    for i, r := range runes {\n        if (r\
    \ >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z') {\n            has_letter = true\n\
    \            if r >= 'a' && r <= 'z' {\n                result[i] = r - 32\n \
    \           } else {\n                result[i] = r + 32\n            }\n    \
    \    } else {\n            result[i] = r\n        }\n    }\n    if !has_letter\
    \ {\n        var i int\n        for i = 0; i < len(result) / 2; i++ {\n      \
    \      result[i], result[len(result) - i - 1] = result[len(result) - i - 1], result[i]\n\
    \        }\n    }\n    return string(result)\n}\n\nfunc TestSolve(t *testing.T)\
    \ {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"\
    ), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073405
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    // TODO: Implement the solution\n    return s\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmp_psxyg6q_test.go:45: expected 'aSdF', got 'AsDf'\n    --- FAIL: TestSolve/test_num__1\
    \ (0.00s)\n        tmp_psxyg6q_test.go:45: expected '4321', got '1234'\n    ---\
    \ FAIL: TestSolve/test_num__2 (0.00s)\n        tmp_psxyg6q_test.go:45: expected\
    \ 'AB', got 'ab'\n    --- FAIL: TestSolve/test_num__3 (0.00s)\n        tmp_psxyg6q_test.go:45:\
    \ expected '#A@c', got '#a@C'\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n \
    \       tmp_psxyg6q_test.go:45: expected '#aSDFw^45', got '#AsdfW^45'\n    ---\
    \ FAIL: TestSolve/test_num__5 (0.00s)\n        tmp_psxyg6q_test.go:45: expected\
    \ '2@6#', got '#6@2'\n    --- FAIL: TestSolve/test_num__6 (0.00s)\n        tmp_psxyg6q_test.go:45:\
    \ expected '#$A^d', got '#$a^D'\n    --- FAIL: TestSolve/test_num__7 (0.00s)\n\
    \        tmp_psxyg6q_test.go:45: expected '#CCC', got '#ccc'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073405
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    // best solution\n    // return (strings.Map(func(r rune) rune {\n  \
    \  //     if r < 'a' {\n    //         return r\n    //     }\n    //     return\
    \ r ^ 32\n    // }, s))\n\n    // my solution\n    if len(s) == 0 {\n        return\
    \ s\n    }\n    for i := 0; i < len(s); i++ {\n        if ('a' <= s[i] && s[i]\
    \ <= 'z') || ('A' <= s[i] && s[i] <= 'Z') {\n            if s[i] <= 'Z' {\n  \
    \              s = s[:i] + string(s[i] + 32) + s[i+1:]\n            } else {\n\
    \                s = s[:i] + string(s[i] - 32) + s[i+1:]\n            }\n    \
    \    }\n    }\n    return s\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmpz2tz3a5q_test.go:65: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmpz2tz3a5q_test.go:65: expected '2@6#', got '#6@2'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073405
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    runes := []rune(s)\n    if len(runes) == 0 {\n        return s\n    }\n\
    \    // we need to keep track if there is any letter in the string\n    var hasLetter\
    \ bool\n    for i, r := range runes {\n        // if we find a letter\n      \
    \  if isLetter(r) {\n            // reverse the case\n            if isUpper(r)\
    \ {\n                runes[i] = toLower(r)\n            } else {\n           \
    \     runes[i] = toUpper(r)\n            }\n            hasLetter = true\n   \
    \     }\n    }\n    // if we find no letter in the string, reverse the string\n\
    \    if !hasLetter {\n        reverse(runes)\n    }\n    return string(runes)\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfulgywt2_test.go:29:12: undefined: isLetter

    /tmp/tmpfulgywt2_test.go:31:16: undefined: isUpper

    /tmp/tmpfulgywt2_test.go:32:28: undefined: toLower

    /tmp/tmpfulgywt2_test.go:34:28: undefined: toUpper

    /tmp/tmpfulgywt2_test.go:41:9: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073404
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    n := len(s)\n    nn := make([]byte, n)\n    c := 0\n    lc := 0\n   \
    \ for i := 0; i < n; i++ {\n        if s[i] >= 'a' && s[i] <= 'z' || s[i] >= 'A'\
    \ && s[i] <= 'Z' {\n            lc = 1\n            if s[i] >= 'a' && s[i] <=\
    \ 'z' {\n                nn[c] = s[i] - 32\n            } else {\n           \
    \     nn[c] = s[i] + 32\n            }\n            c++\n        } else {\n  \
    \          nn[c] = s[i]\n            c++\n        }\n    }\n    if lc == 0 {\n\
    \        lc = 1\n    }\n    r := n - c\n    return string(nn[r:n])\n}\n\nfunc\
    \ TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmp8wdia1_e_test.go:66: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmp8wdia1_e_test.go:66: expected '2@6#', got '#6@2'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073405
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    output := \"\"\n    noletters := true\n    for _, c := range s {\n  \
    \      if c >= 'a' && c <= 'z' {\n            noletters = false\n            c\
    \ = c - 'a' + 'A'\n        } else if c >= 'A' && c <= 'Z' {\n            noletters\
    \ = false\n            c = c - 'A' + 'a'\n        }\n        output += string(c)\n\
    \    }\n    if noletters {\n        s = reverse(s)\n    }\n    return output\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9qb99fx0_test.go:34:13: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073404
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    chars := []rune(s)\n    for i, char := range chars {\n        if char\
    \ >= 'a' && char <= 'z' {\n            chars[i] = char - 'a' + 'A'\n        }\
    \ else if char >= 'A' && char <= 'Z' {\n            chars[i] = char - 'A' + 'a'\n\
    \        }\n    }\n    return string(chars)\n}\n\nfunc TestSolve(t *testing.T)\
    \ {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"\
    ), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmp3zpmjp7w_test.go:52: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmp3zpmjp7w_test.go:52: expected '2@6#', got '#6@2'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073405
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    res := \"\"\n    for _, v := range s {\n        c := string(v)\n    \
    \    switch {\n        case (v >= 'a' && v <= 'z'):\n            res += strings.ToUpper(c)\n\
    \        case (v >= 'A' && v <= 'Z'):\n            res += strings.ToLower(c)\n\
    \        default:\n            res += c\n        }\n    }\n    // if there is\
    \ no letter in the string, it is already reversed\n    if res == s {\n       \
    \ return s\n    }\n    // reverse it\n    return reverse(res)\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpr_012k5d_test.go:26:20: undefined: strings

    /tmp/tmpr_012k5d_test.go:28:20: undefined: strings

    /tmp/tmpr_012k5d_test.go:38:12: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073404
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    if len(s) == 0 {\n        return s\n    }\n    if s[0] > 96 && s[0] <\
    \ 123 {\n        return string(s[0] - 32) + solve(s[1:])\n    } else if s[0] >\
    \ 64 && s[0] < 91 {\n        return string(s[0] + 32) + solve(s[1:])\n    } else\
    \ {\n        return string(s[0]) + solve(s[1:])\n    }\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmpe680_6g7_test.go:53: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmpe680_6g7_test.go:53: expected '2@6#', got '#6@2'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073405
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    str := \"\"\n    letters := 0\n    for _, v := range s {\n        if\
    \ 'a' <= v && v <= 'z' {\n            letters++\n            str += string(v -\
    \ 32)\n        } else if 'A' <= v && v <= 'Z' {\n            letters++\n     \
    \       str += string(v + 32)\n        } else {\n            str += string(v)\n\
    \        }\n    }\n    if letters == 0 {\n        for i, j := 0, len(str) - 1;\
    \ i < j; i, j = i + 1, j - 1 {\n            str[i], str[j] = str[j], str[i]\n\
    \        }\n    }\n    return str\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8e5cjsaf_test.go:36:13: cannot assign to str[i] (value of type byte)

    /tmp/tmp8e5cjsaf_test.go:36:21: cannot assign to str[j] (value of type byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073404
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    if len(s) == 0 {\n        return s\n    }\n    if s[0] < 'a' {\n    \
    \    return s\n    }\n    t := make([]byte, len(s))\n    for i := 0; i < len(s);\
    \ i++ {\n        if s[i] >= 'a' {\n            t[i] = s[i] - ('a' - 'A')\n   \
    \     } else {\n            t[i] = s[i] + ('a' - 'A')\n        }\n    }\n    return\
    \ string(t)\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n    \
    \ { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmpmkeogjri_test.go:58: expected 'aSdF', got 'AsDf'\n    --- FAIL: TestSolve/test_num__1\
    \ (0.00s)\n        tmpmkeogjri_test.go:58: expected '4321', got '1234'\n    ---\
    \ FAIL: TestSolve/test_num__3 (0.00s)\n        tmpmkeogjri_test.go:58: expected\
    \ '#A@c', got '#a@C'\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n        tmpmkeogjri_test.go:58:\
    \ expected '#aSDFw^45', got '#AsdfW^45'\n    --- FAIL: TestSolve/test_num__5 (0.00s)\n\
    \        tmpmkeogjri_test.go:58: expected '2@6#', got '#6@2'\n    --- FAIL: TestSolve/test_num__6\
    \ (0.00s)\n        tmpmkeogjri_test.go:58: expected '#$A^d', got '#$a^D'\n   \
    \ --- FAIL: TestSolve/test_num__7 (0.00s)\n        tmpmkeogjri_test.go:58: expected\
    \ '#CCC', got '#ccc'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073405
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    str := []rune(s)\n    for i, v := range str {\n        if v > 64 && v\
    \ < 91 {\n            str[i] = v + 32\n        } else if v > 96 && v < 123 {\n\
    \            str[i] = v - 32\n        }\n    }\n    return string(str)\n}\n\n\
    func TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmp8c0f25sg_test.go:52: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmp8c0f25sg_test.go:52: expected '2@6#', got '#6@2'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073405
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    str := []rune(s)\n    for i, _ := range str {\n        if str[i] >= 'a'\
    \ && str[i] <= 'z' {\n            str[i] -= 32\n        } else if str[i] >= 'A'\
    \ && str[i] <= 'Z' {\n            str[i] += 32\n        }\n    }\n    if len(str)\
    \ != 0 {\n        for i, j := 0, len(str) - 1; i < j; i, j = i + 1, j - 1 {\n\
    \            str[i], str[j] = str[j], str[i]\n        }\n    }\n    return string(str)\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmpx6_9vi6v_test.go:57: expected 'aSdF', got 'FdSa'\n    --- FAIL: TestSolve/test_num__2\
    \ (0.00s)\n        tmpx6_9vi6v_test.go:57: expected 'AB', got 'BA'\n    --- FAIL:\
    \ TestSolve/test_num__3 (0.00s)\n        tmpx6_9vi6v_test.go:57: expected '#A@c',\
    \ got 'c@A#'\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n        tmpx6_9vi6v_test.go:57:\
    \ expected '#aSDFw^45', got '54^wFDSa#'\n    --- FAIL: TestSolve/test_num__6 (0.00s)\n\
    \        tmpx6_9vi6v_test.go:57: expected '#$A^d', got 'd^A$#'\n    --- FAIL:\
    \ TestSolve/test_num__7 (0.00s)\n        tmpx6_9vi6v_test.go:57: expected '#CCC',\
    \ got 'CCC#'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073405
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var r []rune\n    for _, c := range s {\n        if c >= 'a' && c <=\
    \ 'z' {\n            r = append(r, c - 32)\n        } else if c >= 'A' && c <=\
    \ 'Z' {\n            r = append(r, c + 32)\n        } else {\n            r =\
    \ append(r, c)\n        }\n    }\n    if len(r) == 0 {\n        return Reverse(s)\n\
    \    }\n    return string(r)\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmps6mg9_mz_test.go:32:16: undefined: Reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073405
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    tmp := []rune(s)\n    if len(tmp) == 0 {\n        return s\n    }\n \
    \   if _, ok := tmp[0].(string); ok {\n        fmt.Println(\"ok\")\n    }\n  \
    \  return s\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n    \
    \ { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpztgir3kc_test.go:25:17: invalid operation: tmp[0] (variable of type rune)
    is not an interface

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073406
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    if len(s) == 0 {\n        return s\n    }\n    b := []byte(s)\n    for\
    \ i, c := range b {\n        if c >= 'a' && c <= 'z' {\n            b[i] = c -\
    \ 'a' + 'A'\n        } else if c >= 'A' && c <= 'Z' {\n            b[i] = c -\
    \ 'A' + 'a'\n        }\n    }\n    return string(b)\n}\n\nfunc TestSolve(t *testing.T)\
    \ {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"\
    ), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmp0towkz4r_test.go:55: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmp0towkz4r_test.go:55: expected '2@6#', got '#6@2'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073406
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    if s == \"\" {\n        return s\n    }\n    var sl []byte\n    for i\
    \ := 0; i < len(s); i++ {\n        if isLetter(s[i]) {\n            sl = append(sl,\
    \ toggleCase(s[i]))\n        } else {\n            sl = append(sl, s[i])\n   \
    \     }\n    }\n    return string(sl)\n}\n\nfunc TestSolve(t *testing.T) {\n \
    \ candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected:\
    \ \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n   \
    \  { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmrk_55xu_test.go:26:12: undefined: isLetter

    /tmp/tmpmrk_55xu_test.go:27:29: undefined: toggleCase

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073406
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var x string\n    for _, v := range s {\n        if v >= 'a' && v <=\
    \ 'z' {\n            x += string(v - 32)\n        } else if v >= 'A' && v <= 'Z'\
    \ {\n            x += string(v + 32)\n        } else {\n            x += string(v)\n\
    \        }\n    }\n    return x\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmp55sfuxac_test.go:54: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmp55sfuxac_test.go:54: expected '2@6#', got '#6@2'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073406
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var rs []rune\n    isEmpty := true\n    for _, c := range s {\n     \
    \   if c >= 'a' && c <= 'z' {\n            c -= 32\n        } else if c >= 'A'\
    \ && c <= 'Z' {\n            c += 32\n        }\n        rs = append(rs, c)\n\
    \        if c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' {\n            isEmpty\
    \ = false\n        }\n    }\n    if isEmpty {\n        return reverse(string(rs))\n\
    \    }\n    return string(rs)\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpssuwlpel_test.go:35:16: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073406
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    r := []rune(s)\n    for i, c := range r {\n        // check if c is letter\n\
    \        if c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' {\n            // if\
    \ c is lower, convert to upper and vice versa\n            if c >= 'a' && c <=\
    \ 'z' {\n                r[i] = c - 32\n            } else {\n               \
    \ r[i] = c + 32\n            }\n        }\n    }\n    return string(r)\n}\n\n\
    func TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmpv_xbuhga_test.go:56: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmpv_xbuhga_test.go:56: expected '2@6#', got '#6@2'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073407
- exit_code: 0
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := make([]byte, len(s))\n    isLetter := false\n    for i := 0;\
    \ i < len(s); i++ {\n        if s[i] >= 'a' && s[i] <= 'z' {\n            result[i]\
    \ = s[i] - 32\n            isLetter = true\n        } else if s[i] >= 'A' && s[i]\
    \ <= 'Z' {\n            result[i] = s[i] + 32\n            isLetter = true\n \
    \       } else {\n            result[i] = s[i]\n        }\n    }\n    if !isLetter\
    \ {\n        for i := 0; i < len(s) / 2; i++ {\n            result[i], result[len(s)\
    \ - i - 1] = result[len(s) - i - 1], result[i]\n        }\n    }\n    return string(result)\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073407
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    if len(s) == 0 {\n        return s\n    }\n    res := make([]byte, len(s))\n\
    \    var contain_letter bool\n    for i, v := range s {\n        if v >= 'a' &&\
    \ v <= 'z' {\n            res[i] = v - 'a' + 'A'\n            contain_letter =\
    \ true\n        } else if v >= 'A' && v <= 'Z' {\n            res[i] = v - 'A'\
    \ + 'a'\n            contain_letter = true\n        } else {\n            res[i]\
    \ = byte(v)\n        }\n    }\n    if !contain_letter {\n        for i, j := 0,\
    \ len(s) - 1; i < j; i, j = i + 1, j - 1 {\n            res[i], res[j] = res[j],\
    \ res[i]\n        }\n    }\n    return string(res)\n}\n\nfunc TestSolve(t *testing.T)\
    \ {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"\
    ), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpr9r1hli1_test.go:28:22: cannot use v - ''a'' + ''A'' (value of type rune)
    as type byte in assignment

    /tmp/tmpr9r1hli1_test.go:31:22: cannot use v - ''A'' + ''a'' (value of type rune)
    as type byte in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073406
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    if len(s) == 0 {\n        return s\n    }\n    s_runes := []rune(s)\n\
    \    for i, v := range s_runes {\n        if v >= 'a' && v <= 'z' {\n        \
    \    s_runes[i] = v - 32\n        } else if v >= 'A' && v <= 'Z' {\n         \
    \   s_runes[i] = v + 32\n        }\n    }\n    return string(s_runes)\n}\n\nfunc\
    \ TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmppmnhw67u_test.go:55: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmppmnhw67u_test.go:55: expected '2@6#', got '#6@2'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073407
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    return \"\"\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n\
    \     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmpfxerxnn2_test.go:44: expected 'aSdF', got ''\n    --- FAIL: TestSolve/test_num__1\
    \ (0.00s)\n        tmpfxerxnn2_test.go:44: expected '4321', got ''\n    --- FAIL:\
    \ TestSolve/test_num__2 (0.00s)\n        tmpfxerxnn2_test.go:44: expected 'AB',\
    \ got ''\n    --- FAIL: TestSolve/test_num__3 (0.00s)\n        tmpfxerxnn2_test.go:44:\
    \ expected '#A@c', got ''\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n     \
    \   tmpfxerxnn2_test.go:44: expected '#aSDFw^45', got ''\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmpfxerxnn2_test.go:44: expected '2@6#', got ''\n    --- FAIL:\
    \ TestSolve/test_num__6 (0.00s)\n        tmpfxerxnn2_test.go:44: expected '#$A^d',\
    \ got ''\n    --- FAIL: TestSolve/test_num__7 (0.00s)\n        tmpfxerxnn2_test.go:44:\
    \ expected '#CCC', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073400
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    if s == \"\" {\n        return s\n    }\n    result := \"\"\n    for\
    \ _, v := range s {\n        c := string(v)\n        if c >= \"a\" && c <= \"\
    z\" {\n            result += strings.ToUpper(c)\n        } else if c >= \"A\"\
    \ && c <= \"Z\" {\n            result += strings.ToLower(c)\n        } else {\n\
    \            result += c\n        }\n    }\n    if result == s {\n        return\
    \ s\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdu7bc15l_test.go:28:23: undefined: strings

    /tmp/tmpdu7bc15l_test.go:30:23: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073406
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var (\n        i, l int\n        res string\n    )\n    l = len(s)\n\
    \    for i = 0; i < l; i++ {\n        if isLetter(s[i]) {\n            if isLower(s[i])\
    \ {\n                res += string(s[i] - 32)\n            } else {\n        \
    \        res += string(s[i] + 32)\n            }\n        } else {\n         \
    \   res += string(s[i])\n        }\n    }\n    if len(res) == 0 {\n        return\
    \ reverse(s)\n    }\n    return res\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp88mqxiyf_test.go:27:12: undefined: isLetter

    /tmp/tmp88mqxiyf_test.go:28:16: undefined: isLower

    /tmp/tmp88mqxiyf_test.go:38:16: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073407
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    if len(s) == 0 {\n        return s\n    }\n    nums := []rune{}\n   \
    \ var letter rune\n    for _, v := range s {\n        if v >= 'a' && v <= 'z'\
    \ || v >= 'A' && v <= 'Z' {\n            letter = v\n            break\n     \
    \   }\n        nums = append(nums, v)\n    }\n    if letter == 0 {\n        return\
    \ reverse(nums)\n    }\n    return reverse(nums) + reverseWord(s)\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp50_fwrtc_test.go:34:16: undefined: reverse

    /tmp/tmp50_fwrtc_test.go:36:12: undefined: reverse

    /tmp/tmp50_fwrtc_test.go:36:28: undefined: reverseWord

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073407
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    if len(s) == 0 {\n        return s\n    }\n    var result string\n  \
    \  for _, c := range s {\n        if c >= 'a' && c <= 'z' {\n            result\
    \ += string(c - 32)\n        } else if c >= 'A' && c <= 'Z' {\n            result\
    \ += string(c + 32)\n        } else {\n            result += string(c)\n     \
    \   }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmp6k0gpyd9_test.go:57: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmp6k0gpyd9_test.go:57: expected '2@6#', got '#6@2'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073213
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    t := []rune(s)\n    for i, r := range s {\n        if r >= 'a' && r <=\
    \ 'z' {\n            t[i] = r - 'a' + 'A'\n        } else if r >= 'A' && r <=\
    \ 'Z' {\n            t[i] = r - 'A' + 'a'\n        }\n    }\n    return string(t)\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmpnxy5tzrn_test.go:52: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmpnxy5tzrn_test.go:52: expected '2@6#', got '#6@2'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073407
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    l := len(s)\n    if l == 0 {\n        return s\n    }\n    b := []byte(s)\n\
    \    for i := 0; i < l; i++ {\n        if isLetter(b[i]) {\n            b[i] =\
    \ b[i] ^ ' '\n        }\n    }\n    return string(b)\n}\n\nfunc TestSolve(t *testing.T)\
    \ {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"\
    ), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1onp3s_1_test.go:27:12: undefined: isLetter

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073407
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    // write code here\n    return \"\"\n}\n\nfunc TestSolve(t *testing.T)\
    \ {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"\
    ), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmpspgpwj8k_test.go:45: expected 'aSdF', got ''\n    --- FAIL: TestSolve/test_num__1\
    \ (0.00s)\n        tmpspgpwj8k_test.go:45: expected '4321', got ''\n    --- FAIL:\
    \ TestSolve/test_num__2 (0.00s)\n        tmpspgpwj8k_test.go:45: expected 'AB',\
    \ got ''\n    --- FAIL: TestSolve/test_num__3 (0.00s)\n        tmpspgpwj8k_test.go:45:\
    \ expected '#A@c', got ''\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n     \
    \   tmpspgpwj8k_test.go:45: expected '#aSDFw^45', got ''\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmpspgpwj8k_test.go:45: expected '2@6#', got ''\n    --- FAIL:\
    \ TestSolve/test_num__6 (0.00s)\n        tmpspgpwj8k_test.go:45: expected '#$A^d',\
    \ got ''\n    --- FAIL: TestSolve/test_num__7 (0.00s)\n        tmpspgpwj8k_test.go:45:\
    \ expected '#CCC', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073407
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    runes := []rune(s)\n    runes = reverse(runes)\n    return string(runes)\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpu_nw2exw_test.go:22:13: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073407
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var buf []byte\n    buf = make([]byte, len(s))\n    t := []byte(s)\n\
    \    flag := false\n    for i := 0; i < len(s); i++ {\n        if t[i] >= 'a'\
    \ && t[i] <= 'z' {\n            buf[i] = t[i] - 32\n            flag = true\n\
    \        } else if t[i] >= 'A' && t[i] <= 'Z' {\n            buf[i] = t[i] + 32\n\
    \            flag = true\n        } else {\n            buf[i] = t[i]\n      \
    \  }\n    }\n    if flag {\n        return string(buf)\n    } else {\n       \
    \ return string(buf[len(buf)-1:0:-1])\n    }\n}\n\nfunc TestSolve(t *testing.T)\
    \ {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"\
    ), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprud062ap_test.go:39:40: invalid argument: index -1 (constant of type int)
    must not be negative

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073407
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    // Write your code here\n    return \"\"\n}\n\nfunc TestSolve(t *testing.T)\
    \ {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"\
    ), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmpqwwri4t0_test.go:45: expected 'aSdF', got ''\n    --- FAIL: TestSolve/test_num__1\
    \ (0.00s)\n        tmpqwwri4t0_test.go:45: expected '4321', got ''\n    --- FAIL:\
    \ TestSolve/test_num__2 (0.00s)\n        tmpqwwri4t0_test.go:45: expected 'AB',\
    \ got ''\n    --- FAIL: TestSolve/test_num__3 (0.00s)\n        tmpqwwri4t0_test.go:45:\
    \ expected '#A@c', got ''\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n     \
    \   tmpqwwri4t0_test.go:45: expected '#aSDFw^45', got ''\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmpqwwri4t0_test.go:45: expected '2@6#', got ''\n    --- FAIL:\
    \ TestSolve/test_num__6 (0.00s)\n        tmpqwwri4t0_test.go:45: expected '#$A^d',\
    \ got ''\n    --- FAIL: TestSolve/test_num__7 (0.00s)\n        tmpqwwri4t0_test.go:45:\
    \ expected '#CCC', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073215
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    if len(s) == 0 {\n        return s\n    }\n    str := []rune(s)\n   \
    \ letExists := false\n    for i := 0; i < len(str); i++ {\n        if !isLetter(str[i])\
    \ {\n            continue\n        }\n        letExists = true\n        if isUpper(str[i])\
    \ {\n            str[i] = toLower(str[i])\n        } else {\n            str[i]\
    \ = toUpper(str[i])\n        }\n    }\n    if !letExists {\n        return reverse(s)\n\
    \    }\n    return string(str)\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_sv4op5q_test.go:27:13: undefined: isLetter

    /tmp/tmp_sv4op5q_test.go:31:12: undefined: isUpper

    /tmp/tmp_sv4op5q_test.go:32:22: undefined: toLower

    /tmp/tmp_sv4op5q_test.go:34:22: undefined: toUpper

    /tmp/tmp_sv4op5q_test.go:38:16: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073407
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    return \"your_answer\"\n}\n\ntype S \nfunc TestSolve(t *testing.T) {\n\
    \  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected:\
    \ \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n   \
    \  { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpcycwn7xn_test.go:24:8: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073406
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    chars := []rune(s)\n    for i, c := range chars {\n        if ('a' <=\
    \ c && c <= 'z') || ('A' <= c && c <= 'Z') {\n            chars[i] = ^c\n    \
    \    }\n    }\n    return string(chars)\n}\n\nfunc TestSolve(t *testing.T) {\n\
    \  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected:\
    \ \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n   \
    \  { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmpz8xexfqd_test.go:50: expected 'aSdF', got '\uFFFD\uFFFD\uFFFD\uFFFD\
    '\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n        tmpz8xexfqd_test.go:50:\
    \ expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__2 (0.00s)\n \
    \       tmpz8xexfqd_test.go:50: expected 'AB', got '\uFFFD\uFFFD'\n    --- FAIL:\
    \ TestSolve/test_num__3 (0.00s)\n        tmpz8xexfqd_test.go:50: expected '#A@c',\
    \ got '#\uFFFD@\uFFFD'\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n        tmpz8xexfqd_test.go:50:\
    \ expected '#aSDFw^45', got '#\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD^45'\n    --- FAIL:\
    \ TestSolve/test_num__5 (0.00s)\n        tmpz8xexfqd_test.go:50: expected '2@6#',\
    \ got '#6@2'\n    --- FAIL: TestSolve/test_num__6 (0.00s)\n        tmpz8xexfqd_test.go:50:\
    \ expected '#$A^d', got '#$\uFFFD^\uFFFD'\n    --- FAIL: TestSolve/test_num__7\
    \ (0.00s)\n        tmpz8xexfqd_test.go:50: expected '#CCC', got '#\uFFFD\uFFFD\
    \uFFFD'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073408
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    res := \"\"\n    if isLetter(s) {\n        res = reverseCase(s)\n   \
    \ } else {\n        res = reverse(s)\n    }\n    return res\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp22_8ih4w_test.go:22:8: undefined: isLetter

    /tmp/tmp22_8ih4w_test.go:23:15: undefined: reverseCase

    /tmp/tmp22_8ih4w_test.go:25:15: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073407
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    s_bytes := []byte(s)\n    if len(s_bytes) == 0 {\n        return s\n\
    \    }\n    for i, b := range s_bytes {\n        if (b >= 'a' && b <= 'z') ||\
    \ (b >= 'A' && b <= 'Z') {\n            s_bytes[i] = s_bytes[len(s_bytes) - 1\
    \ - i]\n        }\n    }\n    return string(s_bytes)\n}\n\nfunc TestSolve(t *testing.T)\
    \ {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"\
    ), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmpo_hyr2yr_test.go:53: expected 'aSdF', got 'fDDf'\n    --- FAIL: TestSolve/test_num__1\
    \ (0.00s)\n        tmpo_hyr2yr_test.go:53: expected '4321', got '1234'\n    ---\
    \ FAIL: TestSolve/test_num__2 (0.00s)\n        tmpo_hyr2yr_test.go:53: expected\
    \ 'AB', got 'bb'\n    --- FAIL: TestSolve/test_num__3 (0.00s)\n        tmpo_hyr2yr_test.go:53:\
    \ expected '#A@c', got '#@@#'\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n \
    \       tmpo_hyr2yr_test.go:53: expected '#aSDFw^45', got '#4^WfW^45'\n    ---\
    \ FAIL: TestSolve/test_num__5 (0.00s)\n        tmpo_hyr2yr_test.go:53: expected\
    \ '2@6#', got '#6@2'\n    --- FAIL: TestSolve/test_num__6 (0.00s)\n        tmpo_hyr2yr_test.go:53:\
    \ expected '#$A^d', got '#$a^#'\n    --- FAIL: TestSolve/test_num__7 (0.00s)\n\
    \        tmpo_hyr2yr_test.go:53: expected '#CCC', got '#cc#'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073408
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    r := make([]rune, len(s))\n    for i, rr := range s {\n        if rr\
    \ >= 'a' && rr <= 'z' {\n            r[i] = rr - 'a' + 'A'\n        } else if\
    \ rr >= 'A' && rr <= 'Z' {\n            r[i] = rr - 'A' + 'a'\n        } else\
    \ {\n            r[i] = rr\n        }\n    }\n    return string(r)\n}\n\nfunc\
    \ TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmpc1o25bl1_test.go:54: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmpc1o25bl1_test.go:54: expected '2@6#', got '#6@2'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073408
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    if len(s) == 0 {\n        return s\n    }\n    result := \"\"\n    letters\
    \ := \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    for _, v :=\
    \ range s {\n        if strings.Contains(letters, string(v)) {\n            if\
    \ v >= 65 && v <= 90 {\n                result += string(v + 32)\n           \
    \ } else if v >= 97 && v <= 122 {\n                result += string(v - 32)\n\
    \            }\n        } else {\n            result += string(v)\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpg8day_ix_test.go:27:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073408
- exit_code: 0
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    letters := make([]byte, 0)\n    for i := 0; i < len(s); i++ {\n     \
    \   if s[i] >='a' && s[i] <= 'z' || s[i] >= 'A' && s[i] <= 'Z' {\n           \
    \ letters = append(letters, s[i])\n        }\n    }\n    // fmt.Println(letters)\n\
    \    if len(letters) == 0 {\n        var result []byte\n        for i := len(s)\
    \ - 1; i >= 0; i-- {\n            result = append(result, s[i])\n        }\n \
    \       return string(result)\n    }\n    for i := 0; i < len(letters); i++ {\n\
    \        if letters[i] >= 'a' && letters[i] <= 'z' {\n            letters[i] -=\
    \ 'a' - 'A'\n        } else {\n            letters[i] += 'a' - 'A'\n        }\n\
    \    }\n    fmt.Println(letters)\n    j := 0\n    result := make([]byte, len(s))\n\
    \    for i := 0; i < len(s); i++ {\n        if s[i] >='a' && s[i] <= 'z' || s[i]\
    \ >= 'A' && s[i] <= 'Z' {\n            result[i] = letters[j]\n            j++\n\
    \        } else {\n            result[i] = s[i]\n        }\n    }\n    return\
    \ string(result)\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n\
    \     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073408
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    if len(s) == 0 {\n        return s\n    }\n    if len(s) == 1 {\n   \
    \     if (s[0] >= 'a' && s[0] <= 'z') || (s[0] >= 'A' && s[0] <= 'Z') {\n    \
    \        return string(s[0] ^ 32)\n        }\n        return s\n    }\n    for\
    \ i := 0; i < len(s); i++ {\n        if (s[i] >= 'a' && s[i] <= 'z') || (s[i]\
    \ >= 'A' && s[i] <= 'Z') {\n            s = string(s[:i]) + string(s[i] ^ 32)\
    \ + string(s[i+1:])\n            break\n        }\n    }\n    return s\n}\n\n\
    type TestCase \nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n    \
    \ { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp2vmv09vd_test.go:39:15: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073407
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    if len(s) == 0 {\n        return s\n    }\n    s_runes := []rune(s)\n\
    \    for i, c := range s_runes {\n        if isLetter(c) {\n            s_runes[i]\
    \ = switchCase(c)\n        }\n    }\n    return string(s_runes)\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp56azcdki_test.go:26:12: undefined: isLetter

    /tmp/tmp56azcdki_test.go:27:26: undefined: switchCase

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073408
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    if len(s) == 0 {\n        return s\n    }\n    var r rune\n    for _,\
    \ v := range s {\n        if isLetter(v) {\n            r = v ^ 0x20\n       \
    \ } else {\n            r = v\n        }\n        fmt.Printf(\"%c\", r)\n    }\n\
    \    fmt.Println()\n    return \"\"\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmzw6k_km_test.go:26:12: undefined: isLetter

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073408
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var re_s string\n    var char int32\n    for _, char = range s {\n  \
    \      switch {\n        case char >= 'a' && char <= 'z':\n            re_s +=\
    \ string(char - 'a' + 'A')\n        case char >= 'A' && char <= 'Z':\n       \
    \     re_s += string(char - 'A' + 'a')\n        default:\n            re_s +=\
    \ string(char)\n        }\n    }\n    return re_s\n}\n\nfunc TestSolve(t *testing.T)\
    \ {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"\
    ), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmpgxybkt74_test.go:56: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmpgxybkt74_test.go:56: expected '2@6#', got '#6@2'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073409
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    n := len(s)\n    if n == 0 {\n        return s\n    }\n    if n == 1\
    \ {\n        if isLetter(s[0]) {\n            return string(tolower(s[0]))\n \
    \       }\n        return s\n    }\n    // len(s) >= 2\n    i := 0\n    j := n\
    \ - 1\n    for i < j {\n        for i < j && !isLetter(s[i]) {\n            i++\n\
    \        }\n        for i < j && !isLetter(s[j]) {\n            j--\n        }\n\
    \        if i < j {\n            s = swap(s, i, j)\n            i++\n        \
    \    j--\n        }\n    }\n    if !isLetter(s[i]) {\n        return reverse(s[:i])\n\
    \    }\n    return reverse(s[:i+1])\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpy4a6efe8_test.go:26:12: undefined: isLetter

    /tmp/tmpy4a6efe8_test.go:27:27: undefined: tolower

    /tmp/tmpy4a6efe8_test.go:35:23: undefined: isLetter

    /tmp/tmpy4a6efe8_test.go:38:23: undefined: isLetter

    /tmp/tmpy4a6efe8_test.go:42:17: undefined: swap

    /tmp/tmpy4a6efe8_test.go:47:9: undefined: isLetter

    /tmp/tmpy4a6efe8_test.go:48:16: undefined: reverse

    /tmp/tmpy4a6efe8_test.go:50:12: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073408
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    r := []rune(s)\n    for i, v := range r {\n        if v >= 'a' && v <=\
    \ 'z' {\n            r[i] = v - 'a' + 'A'\n        } else if v >= 'A' && v <=\
    \ 'Z' {\n            r[i] = v - 'A' + 'a'\n        }\n    }\n    return string(r)\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmperdmzmrk_test.go:52: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmperdmzmrk_test.go:52: expected '2@6#', got '#6@2'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073409
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    if s == \"\" {\n        return s\n    }\n    result := make([]byte, len(s))\n\
    \    for i := range s {\n        if s[i] >= 'a' && s[i] <= 'z' {\n           \
    \ result[i] = s[i] - 'a' + 'A'\n        } else if s[i] >= 'A' && s[i] <= 'Z' {\n\
    \            result[i] = s[i] - 'A' + 'a'\n        } else {\n            result[i]\
    \ = s[i]\n        }\n    }\n    return string(result)\n}\n\nfunc TestSolve(t *testing.T)\
    \ {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"\
    ), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmpyzemt379_test.go:57: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmpyzemt379_test.go:57: expected '2@6#', got '#6@2'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073409
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    if s == \"\" {\n        return s\n    }\n    runes := []rune(s)\n   \
    \ for i, r := range runes {\n        if r >= 'a' && r <= 'z' {\n            runes[i]\
    \ = r - 32\n        } else if r >= 'A' && r <= 'Z' {\n            runes[i] = r\
    \ + 32\n        }\n    }\n    return string(runes)\n}\n\nvar tests = []\nfunc\
    \ TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp43wgeknp_test.go:35:15: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073408
- exit_code: 0
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    if len(s) == 0 {\n        return s\n    }\n    var isLetter bool\n  \
    \  result := make([]byte, len(s))\n    for i := range s {\n        if s[i] >=\
    \ 'a' && s[i] <= 'z' || s[i] >= 'A' && s[i] <= 'Z' {\n            isLetter = true\n\
    \            result[i] = s[i] ^ 32\n        } else {\n            result[i] =\
    \ s[i]\n        }\n    }\n    if !isLetter {\n        for i := 0; i < len(s)/2;\
    \ i++ {\n            result[i], result[len(s)-i-1] = result[len(s)-i-1], result[i]\n\
    \        }\n    }\n    return string(result)\n}\n\nfunc TestSolve(t *testing.T)\
    \ {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"\
    ), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073409
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    // your code here\n    return s\n}\n\nfunc TestSolve(t *testing.T) {\n\
    \  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected:\
    \ \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n   \
    \  { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmp03sdl587_test.go:45: expected 'aSdF', got 'AsDf'\n    --- FAIL: TestSolve/test_num__1\
    \ (0.00s)\n        tmp03sdl587_test.go:45: expected '4321', got '1234'\n    ---\
    \ FAIL: TestSolve/test_num__2 (0.00s)\n        tmp03sdl587_test.go:45: expected\
    \ 'AB', got 'ab'\n    --- FAIL: TestSolve/test_num__3 (0.00s)\n        tmp03sdl587_test.go:45:\
    \ expected '#A@c', got '#a@C'\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n \
    \       tmp03sdl587_test.go:45: expected '#aSDFw^45', got '#AsdfW^45'\n    ---\
    \ FAIL: TestSolve/test_num__5 (0.00s)\n        tmp03sdl587_test.go:45: expected\
    \ '2@6#', got '#6@2'\n    --- FAIL: TestSolve/test_num__6 (0.00s)\n        tmp03sdl587_test.go:45:\
    \ expected '#$A^d', got '#$a^D'\n    --- FAIL: TestSolve/test_num__7 (0.00s)\n\
    \        tmp03sdl587_test.go:45: expected '#CCC', got '#ccc'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073409
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    res := \"\"\n    if len(s) == 0 {\n        return res\n    }\n    hasLetters\
    \ := false\n    for _, r := range s {\n        if (r >= 'a' && r <= 'z') || (r\
    \ >= 'A' && r <= 'Z') {\n            hasLetters = true\n            if r >= 'a'\
    \ && r <= 'z' {\n                res += string(r - 32)\n            } else {\n\
    \                res += string(r + 32)\n            }\n        } else {\n    \
    \        res += string(r)\n        }\n    }\n    if !hasLetters {\n        for\
    \ i, j := 0, len(res) - 1; i < j; i, j = i + 1, j - 1 {\n            res[i], res[j]\
    \ = res[j], res[i]\n        }\n    }\n    return res\n}\n\nfunc TestSolve(t *testing.T)\
    \ {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"\
    ), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpswop1we4_test.go:40:13: cannot assign to res[i] (value of type byte)

    /tmp/tmpswop1we4_test.go:40:21: cannot assign to res[j] (value of type byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073409
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    if len(s) == 0 {\n        return s\n    }\n    var res string\n    for\
    \ _, r := range s {\n        if r >= 'a' && r <= 'z' {\n            res += string(r\
    \ - 32)\n        } else if r >= 'A' && r <= 'Z' {\n            res += string(r\
    \ + 32)\n        } else {\n            res += string(r)\n        }\n    }\n  \
    \  return res\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n    \
    \ { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmp0jgd41i1_test.go:57: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmp0jgd41i1_test.go:57: expected '2@6#', got '#6@2'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073306
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    return solveWithRune(s)\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf0xropej_test.go:21:12: undefined: solveWithRune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073409
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    c := []rune(s)\n    for i, n := range c {\n        if n >= 'a' && n <=\
    \ 'z' {\n            c[i] = n - 32\n        } else if n >= 'A' && n <= 'Z' {\n\
    \            c[i] = n + 32\n        }\n    }\n    return string(c)\n}\n\nfunc\
    \ TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmp183uy996_test.go:52: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmp183uy996_test.go:52: expected '2@6#', got '#6@2'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073410
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var result string\n    isEmpty := true\n    for _, c := range s {\n \
    \       if c >= 'a' && c <= 'z' {\n            isEmpty = false\n            result\
    \ = fmt.Sprintf(\"%s%c\", result, c-32)\n        } else if c >= 'A' && c <= 'Z'\
    \ {\n            isEmpty = false\n            result = fmt.Sprintf(\"%s%c\", result,\
    \ c+32)\n        } else {\n            result = fmt.Sprintf(\"%s%c\", result,\
    \ c)\n        }\n    }\n    if isEmpty {\n        sLen := len(s)\n        for\
    \ i := 0; i < sLen/2; i++ {\n            s[i], s[sLen-i-1] = s[sLen-i-1], s[i]\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkr6vhpj1_test.go:37:13: cannot assign to s[i] (value of type byte)

    /tmp/tmpkr6vhpj1_test.go:37:19: cannot assign to s[sLen - i - 1] (value of type
    byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073409
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    if len(s) == 0 {\n        return s\n    }\n    var ret string\n    for\
    \ _, ch := range s {\n        if 'a' <= ch && ch <= 'z' {\n            ret +=\
    \ string(ch - 32)\n        } else if 'A' <= ch && ch <= 'Z' {\n            ret\
    \ += string(ch + 32)\n        } else {\n            ret += string(ch)\n      \
    \  }\n    }\n    return ret\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmpa1hfnfgz_test.go:57: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmpa1hfnfgz_test.go:57: expected '2@6#', got '#6@2'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073410
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    if len(s) == 0 {\n        return s\n    }\n    if _, err := strconv.Atoi(s);\
    \ err == nil {\n        return reverse(s)\n    }\n    var ns []byte\n    for i\
    \ := 0; i < len(s); i++ {\n        if s[i] >= 'a' && s[i] <= 'z' {\n         \
    \   ns = append(ns, s[i] - 32)\n        } else if s[i] >= 'A' && s[i] <= 'Z' {\n\
    \            ns = append(ns, s[i] + 32)\n        } else {\n            ns = append(ns,\
    \ s[i])\n        }\n    }\n    return string(ns)\n}\n\nfunc TestSolve(t *testing.T)\
    \ {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"\
    ), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1a2lz93z_test.go:24:18: undefined: strconv

    /tmp/tmp1a2lz93z_test.go:25:16: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073409
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    for i := 0; i < len(s); i++ {\n        if (s[i] > 96 && s[i] < 123) ||\
    \ (s[i] > 64 && s[i] < 91) {\n            if s[i] > 96 {\n                s =\
    \ s[:i] + string(s[i] - 32) + s[i+1:]\n            } else {\n                s\
    \ = s[:i] + string(s[i] + 32) + s[i+1:]\n            }\n        }\n    }\n   \
    \ return s\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n    \
    \ { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmpehh0507m_test.go:53: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmpehh0507m_test.go:53: expected '2@6#', got '#6@2'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073410
- exit_code: 0
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var l = len(s)\n    if l == 0 {\n        return s\n    }\n    rs := make([]rune,\
    \ l)\n    isLetter := false\n    var i, j int\n    for i = 0; i < l; i++ {\n \
    \       if (s[i] >= 'a' && s[i] <= 'z') || (s[i] >= 'A' && s[i] <= 'Z') {\n  \
    \          isLetter = true\n            break\n        }\n    }\n    if !isLetter\
    \ {\n        for i, j = 0, l - 1; i < j; i, j = i + 1, j - 1 {\n            rs[i],\
    \ rs[j] = rune(s[j]), rune(s[i])\n        }\n        return string(rs)\n    }\n\
    \    for i = 0; i < l; i++ {\n        if s[i] >= 'a' && s[i] <= 'z' {\n      \
    \      rs[i] = rune(s[i] - 'a' + 'A')\n        } else if s[i] >= 'A' && s[i] <=\
    \ 'Z' {\n            rs[i] = rune(s[i] - 'A' + 'a')\n        } else {\n      \
    \      rs[i] = rune(s[i])\n        }\n    }\n    return string(rs)\n}\n\nfunc\
    \ TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073410
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    reversed := \"\"\n    for _, ch := range s {\n        if (ch >= 'a' &&\
    \ ch <= 'z') || (ch >= 'A' && ch <= 'Z') {\n            if ch >= 'a' && ch <=\
    \ 'z' {\n                reversed += string(ch - 32)\n            } else {\n \
    \               reversed += string(ch + 32)\n            }\n        } else {\n\
    \            reversed += string(ch)\n        }\n    }\n    return reversed\n}\n\
    \nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmpkpyrmdsn_test.go:56: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmpkpyrmdsn_test.go:56: expected '2@6#', got '#6@2'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073410
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    newStr := \"\"\n    for _, v := range s {\n        if (v >= 65 && v <=\
    \ 90) || (v >= 97 && v <= 122) {\n            newStr += string(v ^ 32)\n     \
    \   } else {\n            newStr += string(v)\n        }\n    }\n    if newStr\
    \ == s {\n        return reverse(s)\n    }\n    return newStr\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpq5_soma7_test.go:30:16: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073410
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    if len(s) == 0 {\n        return s\n    }\n    bs := []byte(s)\n    for\
    \ i := 0; i < len(bs); i++ {\n        if bs[i] >= 'a' && bs[i] <= 'z' {\n    \
    \        bs[i] = bs[i] - 'a' + 'A'\n        } else if bs[i] >= 'A' && bs[i] <=\
    \ 'Z' {\n            bs[i] = bs[i] - 'A' + 'a'\n        }\n    }\n    return string(bs)\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmpi19tomyf_test.go:55: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmpi19tomyf_test.go:55: expected '2@6#', got '#6@2'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073410
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := make([]byte, len(s))\n    if len(s) == 0 {\n        return\
    \ s\n    }\n\n    for i := range result {\n        if s[i] >= 'a' && s[i] <= 'z'\
    \ {\n            result[i] = s[i] - 32\n        } else if s[i] >= 'A' && s[i]\
    \ <= 'Z' {\n            result[i] = s[i] + 32\n        } else {\n            result[i]\
    \ = s[i]\n        }\n    }\n\n    return string(result)\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmpqigoat_8_test.go:59: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmpqigoat_8_test.go:59: expected '2@6#', got '#6@2'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073410
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    rn := []rune(s)\n    if len(rn) == 0 {\n        return s\n    }\n   \
    \ for i := 0; i < len(rn); i++ {\n        if rn[i] >= 'a' && rn[i] <= 'z' {\n\
    \            rn[i] = rn[i] - 32\n        } else if rn[i] >= 'A' && rn[i] <= 'Z'\
    \ {\n            rn[i] = rn[i] + 32\n        }\n    }\n    return string(rn)\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmpcxmovv2a_test.go:55: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmpcxmovv2a_test.go:55: expected '2@6#', got '#6@2'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073410
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    if len(s) == 0 {\n        return s\n    }\n    for i := 0; i < len(s);\
    \ i++ {\n        if s[i] >= 'a' && s[i] <= 'z' {\n            s = fmt.Sprintf(\"\
    %s%c%s\", s[:i], s[i]-32, s[i+1:])\n        } else if s[i] >= 'A' && s[i] <= 'Z'\
    \ {\n            s = fmt.Sprintf(\"%s%c%s\", s[:i], s[i]+32, s[i+1:])\n      \
    \  }\n    }\n    return s\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmp30a1vfx6_test.go:54: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmp30a1vfx6_test.go:54: expected '2@6#', got '#6@2'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073410
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    runes := []rune(s)\n    for i, r := range runes {\n        if r >= 'a'\
    \ && r <= 'z' {\n            runes[i] = r - 32\n        } else if r >= 'A' &&\
    \ r <= 'Z' {\n            runes[i] = r + 32\n        }\n    }\n    return string(runes)\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmptzsu1z06_test.go:52: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmptzsu1z06_test.go:52: expected '2@6#', got '#6@2'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073410
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    output := \"\"\n    for _, char := range s {\n        charValue := int(char)\n\
    \        if ((charValue >= 65) && (charValue <= 90)) ||\n           ((charValue\
    \ >= 97) && (charValue <= 122)) {\n            charValue ^= 32\n        }\n  \
    \      output = fmt.Sprintf(\"%s%c\", output, charValue)\n    }\n    return output\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmpp_bnzvy9_test.go:53: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmpp_bnzvy9_test.go:53: expected '2@6#', got '#6@2'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073411
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    if len(s) == 0 {\n        return s\n    }\n    var sb []byte\n    for\
    \ i := 0; i < len(s); i++ {\n        if s[i] >= 'a' && s[i] <= 'z' {\n       \
    \     sb = append(sb, s[i] - 'a' + 'A')\n        } else if s[i] >= 'A' && s[i]\
    \ <= 'Z' {\n            sb = append(sb, s[i] - 'A' + 'a')\n        } else {\n\
    \            sb = append(sb, s[i])\n        }\n    }\n    if len(sb) == 0 {\n\
    \        return s\n    }\n    for i := 0; i < len(sb) / 2; i++ {\n        sb[i],\
    \ sb[len(sb) - 1 - i] = sb[len(sb) - 1 - i], sb[i]\n    }\n    return string(sb)\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmp7d_1g_y7_test.go:63: expected 'aSdF', got 'FdSa'\n    --- FAIL: TestSolve/test_num__2\
    \ (0.00s)\n        tmp7d_1g_y7_test.go:63: expected 'AB', got 'BA'\n    --- FAIL:\
    \ TestSolve/test_num__3 (0.00s)\n        tmp7d_1g_y7_test.go:63: expected '#A@c',\
    \ got 'c@A#'\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n        tmp7d_1g_y7_test.go:63:\
    \ expected '#aSDFw^45', got '54^wFDSa#'\n    --- FAIL: TestSolve/test_num__6 (0.00s)\n\
    \        tmp7d_1g_y7_test.go:63: expected '#$A^d', got 'd^A$#'\n    --- FAIL:\
    \ TestSolve/test_num__7 (0.00s)\n        tmp7d_1g_y7_test.go:63: expected '#CCC',\
    \ got 'CCC#'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073411
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    // your code here\n    return s\n}\n\nfunc TestSolve(t *testing.T) {\n\
    \  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected:\
    \ \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n   \
    \  { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmp03sdl587_test.go:45: expected 'aSdF', got 'AsDf'\n    --- FAIL: TestSolve/test_num__1\
    \ (0.00s)\n        tmp03sdl587_test.go:45: expected '4321', got '1234'\n    ---\
    \ FAIL: TestSolve/test_num__2 (0.00s)\n        tmp03sdl587_test.go:45: expected\
    \ 'AB', got 'ab'\n    --- FAIL: TestSolve/test_num__3 (0.00s)\n        tmp03sdl587_test.go:45:\
    \ expected '#A@c', got '#a@C'\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n \
    \       tmp03sdl587_test.go:45: expected '#aSDFw^45', got '#AsdfW^45'\n    ---\
    \ FAIL: TestSolve/test_num__5 (0.00s)\n        tmp03sdl587_test.go:45: expected\
    \ '2@6#', got '#6@2'\n    --- FAIL: TestSolve/test_num__6 (0.00s)\n        tmp03sdl587_test.go:45:\
    \ expected '#$A^d', got '#$a^D'\n    --- FAIL: TestSolve/test_num__7 (0.00s)\n\
    \        tmp03sdl587_test.go:45: expected '#CCC', got '#ccc'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073409
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    if len(s) == 0 {\n        return s\n    }\n    var r []rune\n    var\
    \ i int\n    for i = 0; i < len(s); i++ {\n        r = append(r, rune(s[i]))\n\
    \    }\n    i = 0\n    var letter bool\n    for ; i < len(r); i++ {\n        if\
    \ (r[i] >= 'a' && r[i] <= 'z') || (r[i] >= 'A' && r[i] <= 'Z') {\n           \
    \ letter = true\n            break\n        }\n    }\n    if !letter {\n     \
    \   return reverse(r)\n    }\n    r = reverse_letter(r)\n    return string(r)\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp219193xk_test.go:38:16: undefined: reverse

    /tmp/tmp219193xk_test.go:40:9: undefined: reverse_letter

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073410
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var res string\n    if len(s) == 0 {\n        return s\n    }\n\n   \
    \ for _, c := range s {\n        if c >= 'a' && c <= 'z' {\n            res +=\
    \ string(c - 'a' + 'A')\n        } else if c >= 'A' && c <= 'Z' {\n          \
    \  res += string(c - 'A' + 'a')\n        } else {\n            res += string(c)\n\
    \        }\n    }\n\n    // how to check if the string contains no letters???\n\
    \    if s == res {\n        return reverse(s)\n    }\n    return res\n}\n\nfunc\
    \ TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpm_9z0o3y_test.go:38:16: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073411
- exit_code: 0
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    r := []rune(s)\n    var has_letter bool\n    for i, c := range r {\n\
    \        if (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') {\n            has_letter\
    \ = true\n            if c >= 'a' && c <= 'z' {\n                r[i] = c - 32\n\
    \            } else {\n                r[i] = c + 32\n            }\n        }\n\
    \    }\n    if !has_letter {\n        for i, j := 0, len(r) - 1; i < j; i, j =\
    \ i + 1, j - 1 {\n            r[i], r[j] = r[j], r[i]\n        }\n    }\n    return\
    \ string(r)\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n    \
    \ { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073411
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    // Write your code here\n    return \"\"\n}\n\nfunc TestSolve(t *testing.T)\
    \ {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"\
    ), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmpqwwri4t0_test.go:45: expected 'aSdF', got ''\n    --- FAIL: TestSolve/test_num__1\
    \ (0.00s)\n        tmpqwwri4t0_test.go:45: expected '4321', got ''\n    --- FAIL:\
    \ TestSolve/test_num__2 (0.00s)\n        tmpqwwri4t0_test.go:45: expected 'AB',\
    \ got ''\n    --- FAIL: TestSolve/test_num__3 (0.00s)\n        tmpqwwri4t0_test.go:45:\
    \ expected '#A@c', got ''\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n     \
    \   tmpqwwri4t0_test.go:45: expected '#aSDFw^45', got ''\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmpqwwri4t0_test.go:45: expected '2@6#', got ''\n    --- FAIL:\
    \ TestSolve/test_num__6 (0.00s)\n        tmpqwwri4t0_test.go:45: expected '#$A^d',\
    \ got ''\n    --- FAIL: TestSolve/test_num__7 (0.00s)\n        tmpqwwri4t0_test.go:45:\
    \ expected '#CCC', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073215
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    return \"\"\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n\
    \     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmpfxerxnn2_test.go:44: expected 'aSdF', got ''\n    --- FAIL: TestSolve/test_num__1\
    \ (0.00s)\n        tmpfxerxnn2_test.go:44: expected '4321', got ''\n    --- FAIL:\
    \ TestSolve/test_num__2 (0.00s)\n        tmpfxerxnn2_test.go:44: expected 'AB',\
    \ got ''\n    --- FAIL: TestSolve/test_num__3 (0.00s)\n        tmpfxerxnn2_test.go:44:\
    \ expected '#A@c', got ''\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n     \
    \   tmpfxerxnn2_test.go:44: expected '#aSDFw^45', got ''\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmpfxerxnn2_test.go:44: expected '2@6#', got ''\n    --- FAIL:\
    \ TestSolve/test_num__6 (0.00s)\n        tmpfxerxnn2_test.go:44: expected '#$A^d',\
    \ got ''\n    --- FAIL: TestSolve/test_num__7 (0.00s)\n        tmpfxerxnn2_test.go:44:\
    \ expected '#CCC', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073400
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    size := len(s)\n    if size < 1 {\n        return s\n    }\n    letters\
    \ := make([]byte, 0, size)\n    for i:=0; i<size; i++ {\n        c := s[i]\n \
    \       if 'a' <= c && c <= 'z' || 'A' <= c && c <= 'Z' {\n            letters\
    \ = append(letters, c)\n        }\n    }\n    if len(letters) < 1 {\n        for\
    \ i,j := 0, size-1; i<j; i,j = i+1, j-1 {\n            s[i], s[j] = s[j], s[i]\n\
    \        }\n        return s\n    }\n    for i, l := range letters {\n       \
    \ if 'a' <= l && l <= 'z' {\n            s[i] = l - 32\n        } else {\n   \
    \         s[i] = l + 32\n        }\n    }\n    return s\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyiex7l4n_test.go:34:13: cannot assign to s[i] (value of type byte)

    /tmp/tmpyiex7l4n_test.go:34:19: cannot assign to s[j] (value of type byte)

    /tmp/tmpyiex7l4n_test.go:40:13: cannot assign to s[i] (value of type byte)

    /tmp/tmpyiex7l4n_test.go:42:13: cannot assign to s[i] (value of type byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073411
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var buff []byte\n    for i := 0; i < len(s); i++ {\n        if s[i] >=\
    \ 65 && s[i] <= 90 {\n            buff = append(buff, s[i] + 32)\n        } else\
    \ if s[i] >= 97 && s[i] <= 122 {\n            buff = append(buff, s[i] - 32)\n\
    \        } else {\n            buff = append(buff, s[i])\n        }\n    }\n \
    \   return string(buff)\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n\
    \     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmphw_19v8m_test.go:54: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmphw_19v8m_test.go:54: expected '2@6#', got '#6@2'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073411
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    n := len(s)\n    chars := []rune(s)\n    for i, j := 0, n-1; i < j; i,\
    \ j = i+1, j-1 {\n        if unicode.IsLetter(chars[i]) {\n            if unicode.IsLetter(chars[j])\
    \ {\n                chars[i], chars[j] = chars[j], chars[i]\n            } else\
    \ {\n                j += 1\n            }\n        } else {\n            if unicode.IsLetter(chars[j])\
    \ {\n                i -= 1\n            }\n        }\n    }\n    if unicode.IsLetter(chars[n/2])\
    \ {\n        chars[n/2] = unicode.ToLower(chars[n/2])\n    }\n    return string(chars)\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwirolw17_test.go:24:12: undefined: unicode

    /tmp/tmpwirolw17_test.go:25:16: undefined: unicode

    /tmp/tmpwirolw17_test.go:31:16: undefined: unicode

    /tmp/tmpwirolw17_test.go:36:8: undefined: unicode

    /tmp/tmpwirolw17_test.go:37:22: undefined: unicode

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073411
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    runes := []rune(s)\n    for i, v := range runes {\n        if (v > 64\
    \ && v < 91) || (v > 96 && v < 123) {\n            if v > 64 && v < 91 {\n   \
    \             runes[i] = v + 32\n            } else {\n                runes[i]\
    \ = v - 32\n            }\n        }\n    }\n    return string(runes)\n}\n\nfunc\
    \ TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmpnmmqzs2y_test.go:54: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmpnmmqzs2y_test.go:54: expected '2@6#', got '#6@2'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073411
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var result string\n    for _, c := range s {\n        if c >= 'a' &&\
    \ c <= 'z' {\n            result += string(c - 32)\n        } else if c >= 'A'\
    \ && c <= 'Z' {\n            result += string(c + 32)\n        } else {\n    \
    \        result += string(c)\n        }\n    }\n    if len(result) == len(s) {\n\
    \        return Reverse(result)\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpa6929_bd_test.go:32:16: undefined: Reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073215
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    if !hasLetters(s) {\n        return Reverse(s)\n    }\n\n    var sb strings.Builder\n\
    \    for _, c := range s {\n        if isLetter(c) {\n            c = reverseCase(c)\n\
    \        }\n        sb.WriteRune(c)\n    }\n    return sb.String()\n}\n\nfunc\
    \ TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdf702os__test.go:21:9: undefined: hasLetters

    /tmp/tmpdf702os__test.go:22:16: undefined: Reverse

    /tmp/tmpdf702os__test.go:25:12: undefined: strings

    /tmp/tmpdf702os__test.go:27:12: undefined: isLetter

    /tmp/tmpdf702os__test.go:28:17: undefined: reverseCase

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073411
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    fmt.Println(s)\n    return \"\"\n}\n\nfunc TestSolve(t *testing.T) {\n\
    \  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected:\
    \ \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n   \
    \  { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "AsDf\n1234\nab\n#a@C\n#AsdfW^45\n#6@2\n#$a^D\n#ccc\n--- FAIL: TestSolve\
    \ (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n        tmpk1_vq5_0_test.go:45:\
    \ expected 'aSdF', got ''\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n     \
    \   tmpk1_vq5_0_test.go:45: expected '4321', got ''\n    --- FAIL: TestSolve/test_num__2\
    \ (0.00s)\n        tmpk1_vq5_0_test.go:45: expected 'AB', got ''\n    --- FAIL:\
    \ TestSolve/test_num__3 (0.00s)\n        tmpk1_vq5_0_test.go:45: expected '#A@c',\
    \ got ''\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n        tmpk1_vq5_0_test.go:45:\
    \ expected '#aSDFw^45', got ''\n    --- FAIL: TestSolve/test_num__5 (0.00s)\n\
    \        tmpk1_vq5_0_test.go:45: expected '2@6#', got ''\n    --- FAIL: TestSolve/test_num__6\
    \ (0.00s)\n        tmpk1_vq5_0_test.go:45: expected '#$A^d', got ''\n    --- FAIL:\
    \ TestSolve/test_num__7 (0.00s)\n        tmpk1_vq5_0_test.go:45: expected '#CCC',\
    \ got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073411
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    if len(s) == 0 {\n        return s\n    }\n    runes := []rune(s)\n \
    \   switch runes[0] {\n    case 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',\
    \ 'k', 'l', 'm',\n        'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x',\
    \ 'y', 'z':\n        runes[0] = unicode.ToUpper(runes[0])\n    case 'A', 'B',\
    \ 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n        'N', 'O', 'P',\
    \ 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z':\n        runes[0] = unicode.ToLower(runes[0])\n\
    \    }\n    return string(runes)\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3nmxi33e_test.go:28:20: undefined: unicode

    /tmp/tmp3nmxi33e_test.go:31:20: undefined: unicode

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073411
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    runes := []rune(s)\n    for i, r := range runes {\n        if (r >= 'a'\
    \ && r <= 'z') || (r >= 'A' && r <= 'Z') {\n            runes[i] = r ^ 32\n  \
    \      }\n    }\n    return string(runes)\n}\n\nfunc TestSolve(t *testing.T) {\n\
    \  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected:\
    \ \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n   \
    \  { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmpw2e04t9d_test.go:50: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmpw2e04t9d_test.go:50: expected '2@6#', got '#6@2'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073411
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    r := []rune(s)\n    for i, v := range s {\n        // isalpha\n     \
    \   if v >= 'a' && v <= 'z' || v >= 'A' && v <= 'Z' {\n            fmt.Println(i,\
    \ v)\n            // islower\n            if v >= 'a' && v <= 'z' {\n        \
    \        r[i] = unicode.ToUpper(v)\n            } else {\n                r[i]\
    \ = unicode.ToLower(v)\n            }\n        }\n    }\n    return string(r)\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpha74yek0_test.go:28:24: undefined: unicode

    /tmp/tmpha74yek0_test.go:30:24: undefined: unicode

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073411
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    ans := \"\"\n    for _, c := range s {\n        if 'a' <= c && c <= 'z'\
    \ {\n            ans += string(c - 32)\n        } else if 'A' <= c && c <= 'Z'\
    \ {\n            ans += string(c + 32)\n        } else {\n            ans += string(c)\n\
    \        }\n    }\n    if ans == s {\n        ans = Reverse(ans)\n    }\n    return\
    \ ans\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n    \
    \ { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp63srea3a_test.go:32:15: undefined: Reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073411
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    if len(s) < 1 {\n        return s\n    }\n    for i, r := range s {\n\
    \        c := r\n        if (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') {\n\
    \            c = c ^ 32\n        }\n        s = s[:i] + string(c) + s[i+1:]\n\
    \    }\n    return s\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n\
    \     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n\
    \        tmpjctm6t42_test.go:54: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__5\
    \ (0.00s)\n        tmpjctm6t42_test.go:54: expected '2@6#', got '#6@2'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073411
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    // Slices\n    arr := []rune(s)\n    for i, c := range arr {\n      \
    \  if c >= 'a' && c <= 'z' {\n            arr[i] = unicode.ToUpper(c)\n      \
    \  } else if c >= 'A' && c <= 'Z' {\n            arr[i] = unicode.ToLower(c)\n\
    \        }\n    }\n    return string(arr)\n}\n\nfunc TestSolve(t *testing.T) {\n\
    \  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected:\
    \ \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n   \
    \  { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpo73ju2n4_test.go:25:22: undefined: unicode

    /tmp/tmpo73ju2n4_test.go:27:22: undefined: unicode

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073411
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    if len(s) == 0 {\n        return s\n    }\n    out := make([]byte, len(s))\n\
    \    for i := 0; i < len(s); i++ {\n        out[i] = solveRune(s[i])\n    }\n\
    \    return string(out)\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n\
    \     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdi0iu55__test.go:26:18: undefined: solveRune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073411
