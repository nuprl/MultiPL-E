name: HumanEval_140_fix_spaces
language: go_test.go
prompt: "package fix_spaces_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
  // Given a string text, replace all spaces in it with underscores, \n// and if a\
  \ string has more than 2 consecutive spaces, \n// then replace all consecutive spaces\
  \ with - \n// >>> fix_spaces(\" Example\")\n// \"Example\"\n// >>> fix_spaces(\"\
  \ Example 1\")\n// \"Example_1\"\n// >>> fix_spaces(\" Example 2\")\n// \"_Example_2\"\
  \n// >>> fix_spaces(\" Example 3\")\n// \"_Example-3\"\nfunc fix_spaces(text string)\
  \ string {\n"
tests: "func TestFix_Spaces(t *testing.T) {\n  candidate := fix_spaces\n\ttype test\
  \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests :=\
  \ []test{\n     { actual: candidate(\"Example\"), expected: \"Example\" },\n   \
  \  { actual: candidate(\"Mudasir Hanif \"), expected: \"Mudasir_Hanif_\" },\n  \
  \   { actual: candidate(\"Yellow Yellow  Dirty  Fellow\"), expected: \"Yellow_Yellow__Dirty__Fellow\"\
  \ },\n     { actual: candidate(\"Exa   mple\"), expected: \"Exa-mple\" },\n    \
  \ { actual: candidate(\"   Exa 1 2 2 mple\"), expected: \"-Exa_1_2_2_mple\" },\n\
  \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
  \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
  %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
  \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    text_array := []rune(text)\n    result := []rune{}\n    is_previous_space\
    \ := false\n    count_consecutive_spaces := 0\n    for _, s := range text_array\
    \ {\n        if s == ' ' {\n            if is_previous_space {\n             \
    \   count_consecutive_spaces += 1\n            } else {\n                is_previous_space\
    \ = true\n                count_consecutive_spaces = 1\n            }\n      \
    \  } else {\n            if is_previous_space {\n                if count_consecutive_spaces\
    \ > 2 {\n                    result = append(result, '-')\n                } else\
    \ {\n                    result = append(result, '_')\n                }\n   \
    \             is_previous_space = false\n                count_consecutive_spaces\
    \ = 0\n            }\n            result = append(result, s)\n        }\n    }\n\
    \    if is_previous_space {\n        if count_consecutive_spaces > 2 {\n     \
    \       result = append(result, '-')\n        } else {\n            result = append(result,\
    \ '_')\n        }\n    }\n    return string(result)\n}\n", "    s := \"\"\n  \
    \  spaceCount := 0\n    for _, c := range text {\n        switch {\n        case\
    \ c == ' ':\n            spaceCount++\n            if spaceCount == 2 {\n    \
    \            s += \"-\"\n            }\n        default:\n            spaceCount\
    \ = 0\n            s += string(c)\n        }\n    }\n    return s\n}\n", "   \
    \ prev := ' '\n    result := \"\"\n    spaces := 0\n    for _, ch := range text\
    \ {\n        if ch == ' ' {\n            spaces++\n        } else {\n        \
    \    if spaces > 2 {\n                result += \"-\"\n            } else if spaces\
    \ > 0 {\n                result += \"_\"\n            }\n            spaces =\
    \ 0\n            result += string(ch)\n        }\n    }\n    return result\n}\n",
  "    return \"\"\n}\n", "    var result string\n    var spaces int\n    for _, c\
    \ := range text {\n        if c == ' ' {\n            spaces += 1\n          \
    \  if spaces == 1 {\n                result += \"_\"\n            } else if spaces\
    \ == 2 {\n                result += \"_\"\n            } else {\n            \
    \    result += \"-\"\n            }\n        } else {\n            result += string(c)\n\
    \            spaces = 0\n        }\n    }\n    return result\n}\n", "    // your\
    \ code here\n    // ...\n    return \"your implementation here\"\n}\n", "    var\
    \ last_space int = -1\n    var ret []rune = make([]rune, len(text))\n    for i,\
    \ ch := range text {\n        if ch == ' ' {\n            if last_space == -1\
    \ {\n                ret[i] = '_'\n            } else if i - last_space == 1 {\n\
    \                ret[i] = '-'\n            } else {\n                ret[i] =\
    \ '_'\n            }\n            last_space = i\n        } else {\n         \
    \   ret[i] = ch\n        }\n    }\n    return string(ret)\n}\n", "    var result\
    \ string\n    var consecutiveSpaces int = 0\n    for _, char := range text {\n\
    \        if char == ' ' {\n            consecutiveSpaces++\n            if consecutiveSpaces\
    \ > 2 {\n                result += \"-\"\n            } else {\n             \
    \   result += \"_\"\n            }\n        } else {\n            consecutiveSpaces\
    \ = 0\n            result += string(char)\n        }\n    }\n    return result\n\
    }\n", "    res := \"\"\n    for _, v := range text {\n        if res == \"\" {\n\
    \            if v == ' ' {\n                continue\n            } else {\n \
    \               res += string(v)\n            }\n        } else {\n          \
    \  if v == ' ' {\n                if res[len(res)-1] == '_' {\n              \
    \      res += \"-\"\n                } else {\n                    res += \"_\"\
    \n                }\n            } else {\n                res += string(v)\n\
    \            }\n        }\n    }\n    return res\n}\n", "    res := \"\"\n   \
    \ for i, char := range text {\n        if char == ' ' {\n            res += \"\
    _\"\n        } else {\n            res += string(char)\n        }\n        if\
    \ (i > 0 && i < len(text) - 1) && text[i+1] == ' ' && res[i] == '_' && res[i-1]\
    \ == '_' {\n            fmt.Println(i, text[i+1], res[i], res[i-1])\n        \
    \    res = res[:i] + \"-\" + res[i+1:]\n        }\n    }\n    return res\n}\n",
  "    // TODO\n    return \"\"\n}\n", "    if len(text) == 0 {\n        return text\n\
    \    }\n    res := []byte(text)\n    for i, c := range res {\n        if c ==\
    \ ' ' {\n            if i == 0 {\n                res[i] = '_'\n            }\
    \ else if res[i-1] == ' ' {\n                res[i] = '-'\n            } else\
    \ {\n                res[i] = '_'\n            }\n        }\n    }\n    return\
    \ string(res)\n}\n", "    text = \" \" + text // insert a space at the beginning\n\
    \    l := len(text)\n    s := \"\"\n    i := 0\n    j := 0\n    n := 0\n    state\
    \ := 'A'\n    for ; i < l; i++ {\n        switch text[i] {\n        case ' ':\n\
    \            if state == 'A' {\n                state = 'B'\n            } else\
    \ if state == 'B' {\n                state = 'C'\n            } else if state\
    \ == 'C' {\n                state = 'D'\n            }\n        default:\n   \
    \         switch state {\n            case 'A':\n                s += string(text[i])\n\
    \            case 'B':\n                s += \"_\" + string(text[i])\n       \
    \     case 'C':\n                if j == 0 {\n                    s += string(text[i])\n\
    \                } else {\n                    s += \"_\" + string(text[i])\n\
    \                }\n            case 'D':\n                n++\n             \
    \   if n == 2 {\n                    if j == 0 {\n                        s +=\
    \ string(text[i])\n                    } else {\n                        s +=\
    \ \"-_\" + string(text[i])\n                    }\n                }\n       \
    \     }\n            j++\n            state = 'A'\n        }\n    }\n    return\
    \ s\n}\n", "    // write code here\n    return \"\"\n}\n", "    chars := []rune(text)\n\
    \    for i, char := range chars {\n        if char == ' ' {\n            // \u0441\
    \u0447\u0438\u0442\u0430\u0435\u043C \u043A\u043E\u043B\u0438\u0447\u0435\u0441\
    \u0442\u0432\u043E \u043F\u0440\u043E\u0431\u0435\u043B\u043E\u0432 \u043F\u043E\
    \u0434\u0440\u044F\u0434\n            count := 0\n            for j := i; j <\
    \ len(chars); j++ {\n                if chars[j] == ' ' {\n                  \
    \  count++\n                } else {\n                    break\n            \
    \    }\n            }\n            if count > 2 {\n                chars[i] =\
    \ '-'\n                for j := i + 1; j < len(chars); j++ {\n               \
    \     if chars[j] == ' ' {\n                        chars[j] = '-'\n         \
    \           } else {\n                        break\n                    }\n \
    \               }\n            } else {\n                chars[i] = '_'\n    \
    \        }\n        }\n    }\n    return string(chars)\n}\n", "    var result\
    \ string\n    var spaces int\n    for _, char := range text {\n        if char\
    \ == ' ' {\n            spaces++\n            if spaces == 1 {\n             \
    \   result += \"_\"\n            } else if spaces > 2 {\n                result\
    \ += \"-\"\n            }\n        } else {\n            result += string(char)\n\
    \            spaces = 0\n        }\n    }\n    return result\n}\n", "    var result\
    \ []rune\n    var word []rune\n    var prev rune\n    for _, curr := range text\
    \ {\n        if curr == ' ' {\n            if prev == ' ' {\n                if\
    \ len(word) > 0 {\n                    result = append(result, word...)\n    \
    \                word = []rune{}\n                }\n                result =\
    \ append(result, '-')\n            } else {\n                if len(word) > 0\
    \ {\n                    result = append(result, word...)\n                  \
    \  word = []rune{}\n                }\n                result = append(result,\
    \ '_')\n            }\n        } else {\n            word = append(word, curr)\n\
    \        }\n        prev = curr\n    }\n    if len(word) > 0 {\n        result\
    \ = append(result, word...)\n    }\n    return string(result)\n}\n", "    length\
    \ := len(text)\n    var data []byte\n    data = make([]byte, length)\n    p :=\
    \ 0\n    space_count := 0\n    for i:=0; i<length; i++ {\n        if text[i] !=\
    \ ' ' {\n            if space_count > 2 {\n                data[p] = '-'\n   \
    \             p++\n            } else if space_count == 1 {\n                data[p]\
    \ = '_'\n                p++\n            }\n            data[p] = text[i]\n \
    \           p++\n            space_count = 0\n        } else {\n            space_count++\n\
    \        }\n    }\n    if space_count > 2 {\n        data[p] = '-'\n        p++\n\
    \    } else if space_count == 1 {\n        data[p] = '_'\n        p++\n    }\n\
    \    return string(data[:p])\n}\n", "    return \"\"\n}\n", "    s := []rune(text)\n\
    \    for i, _ := range s {\n        if s[i] == ' ' {\n            n := 1\n   \
    \         for j := i + 1; j < len(s); j++ {\n                if s[j] == ' ' {\n\
    \                    n++\n                } else {\n                    break\n\
    \                }\n            }\n            if n > 2 {\n                for\
    \ k := i; k < i + n; k++ {\n                    s[k] = '-'\n                }\n\
    \            } else {\n                s[i] = '_'\n            }\n        }\n\
    \    }\n    return string(s)\n}\n\ntype Case "]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
