name: HumanEval_158_find_max
language: go_test.go
prompt: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
  \ Write a function that accepts a list of strings.\n// The list contains different\
  \ words. Return the word with maximum number\n// of unique characters. If multiple\
  \ strings have maximum number of unique\n// characters, return the one which comes\
  \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\", \"\
  string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"game\"\
  })\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n// \"aaaaaaa\"\
  \nfunc find_max(words []string) string {\n"
tests: "func TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
  \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
  \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
  string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}), expected:\
  \ \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\", \"cc\"}),\
  \ expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\", \"cba\"}),\
  \ expected: \"abc\" },\n     { actual: candidate([]string{\"play\", \"this\", \"\
  game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n     { actual: candidate([]string{\"\
  we\", \"are\", \"gonna\", \"rock\"}), expected: \"gonna\" },\n     { actual: candidate([]string{\"\
  we\", \"are\", \"a\", \"mad\", \"nation\"}), expected: \"nation\" },\n     { actual:\
  \ candidate([]string{\"this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n\
  \     { actual: candidate([]string{\"b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"\
  play\", \"play\", \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range\
  \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\
  \tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
  \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\
  \t}\n}\n"
completions: ["    var max string\n    max_unique := 0\n    for _, word := range words\
    \ {\n        unique := make(map[rune]bool)\n        for _, ch := range word {\n\
    \            unique[ch] = true\n        }\n        if len(unique) > max_unique\
    \ {\n            max = word\n            max_unique = len(unique)\n        }\n\
    \    }\n    return max\n}\n", "    // Write your code here\n    return \"\"\n\
    }\n", "    var max_words []string\n    max_chars := 0\n    for _, word := range\
    \ words {\n        if num_unique_chars(word) > max_chars {\n            max_chars\
    \ = num_unique_chars(word)\n            max_words = []string{word}\n        }\
    \ else if num_unique_chars(word) == max_chars {\n            max_words = append(max_words,\
    \ word)\n        }\n    }\n    min_word := min_word(max_words)\n    return min_word\n\
    }\n", "    // TODO - Add your code here\n    return \"\"\n}\n", "    word := \"\
    \"\n    max := 0\n    for _, v := range words {\n        if len(v) > max {\n \
    \           word = v\n            max = len(v)\n        }\n    }\n    return word\n\
    }\n", "    var max_num int\n    var result string\n    for _, word := range words\
    \ {\n        if max_num < len(get_unique_chars(word)) {\n            max_num =\
    \ len(get_unique_chars(word))\n            result = word\n        }\n    }\n \
    \   return result\n}\n", "    maxWord := \"\"\n    maxLength := 0\n    for _,\
    \ word := range words {\n        if len(word) > maxLength {\n            maxWord\
    \ = word\n            maxLength = len(word)\n        }\n    }\n    return maxWord\n\
    }\n", "    max_word := \"\"\n    max_uniq_len := 0\n    uniq_map := make(map[rune]bool)\n\
    \    for _, word := range words {\n        // uniq_map := make(map[rune]bool)\n\
    \        for _, c := range word {\n            uniq_map[c] = true\n        }\n\
    \        uniq_len := len(uniq_map)\n        if uniq_len > max_uniq_len {\n   \
    \         max_uniq_len = uniq_len\n            max_word = word\n        }\n  \
    \      if uniq_len == max_uniq_len && word < max_word {\n            max_word\
    \ = word\n        }\n        // fmt.Println(uniq_map)\n        // clear map\n\
    \        for k := range uniq_map {\n            delete(uniq_map, k)\n        }\n\
    \    }\n    return max_word\n}\n", "    max := 0\n    result := \"\"\n    for\
    \ _, word := range words {\n        if len(remove_duplicates(word)) > max {\n\
    \            max = len(remove_duplicates(word))\n            result = word\n \
    \       }\n    }\n    return result\n}\n", "    // TODO: implement\n\n    return\
    \ \"\"\n}\n", "    var max int\n    var ans string\n    for _, word := range words\
    \ {\n        count := make(map[rune]int)\n        for _, char := range word {\n\
    \            count[char]++\n        }\n        len := len(count)\n        if len\
    \ > max {\n            max = len\n            ans = word\n        } else if len\
    \ == max {\n            if word < ans {\n                ans = word\n        \
    \    }\n        }\n    }\n    return ans\n}\n", "    max := \"\"\n    maxCount\
    \ := 0\n    for _, v := range words {\n        m := make(map[rune]int)\n     \
    \   for _, vv := range v {\n            m[vv]++\n        }\n        if len(m)\
    \ > maxCount {\n            max = v\n            maxCount = len(m)\n        }\n\
    \    }\n    return max\n}\n", "    max_word := \"\"\n    max_uniq := 0\n    for\
    \ _, word := range words {\n        uniq := len(get_uniq_chars(word))\n      \
    \  if uniq > max_uniq {\n            max_uniq = uniq\n            max_word = word\n\
    \        }\n    }\n    return max_word\n}\n", "    if len(words) == 0 {\n    \
    \    return \"\"\n    }\n\n    max_word := words[0]\n    max_count := map_count(max_word)\n\
    \n    for _, word := range words[1:] {\n        word_count := map_count(word)\n\
    \        if word_count > max_count {\n            max_word = word\n          \
    \  max_count = word_count\n        } else if word_count == max_count {\n     \
    \       if word < max_word {\n                max_word = word\n            }\n\
    \        }\n    }\n\n    return max_word\n}\n", "    if len(words) == 0 {\n  \
    \      return \"\"\n    }\n\n    var max_word string\n    var max_length int\n\
    \n    for _, word := range words {\n        if len(word) > max_length {\n    \
    \        max_word = word\n            max_length = len(word)\n        }\n    }\n\
    \n    return max_word\n}\n", "    uniq_counts := map[string]int{}\n    for _,\
    \ word := range words {\n        uniq_counts[word] = count_uniq_chars(word)\n\
    \    }\n    return find_max_len(uniq_counts)\n}\n", "    if len(words) == 0 {\n\
    \        return \"\"\n    }\n    max_str := words[0]\n    max_count := unique_chars(max_str)\n\
    \    for _, word := range words[1:] {\n        count := unique_chars(word)\n \
    \       if count > max_count {\n            max_str = word\n            max_count\
    \ = count\n        } else if count == max_count && word < max_str {\n        \
    \    max_str = word\n        }\n    }\n    return max_str\n}\n", "    var max_word\
    \ string\n    var max_chars = 0\n    for _, w := range words {\n        chars\
    \ := map[rune]bool{}\n        for _, c := range w {\n            chars[c] = true\n\
    \        }\n        n := len(chars)\n        if n > max_chars {\n            max_chars\
    \ = n\n            max_word = w\n        } else if n == max_chars && w < max_word\
    \ {\n            max_word = w\n        }\n    }\n    return max_word\n}\n", " \
    \   max := 0\n    var maxStr string\n    for _, w := range words {\n        m\
    \ := len(unique(w))\n        if m > max {\n            max = m\n            maxStr\
    \ = w\n        }\n    }\n    return maxStr\n}\n", "    max_word := \"\"\n    max_length\
    \ := 0\n    for _, word := range words {\n        unique_chars := make(map[rune]int)\n\
    \        for _, char := range word {\n            unique_chars[char] = 1\n   \
    \     }\n        if len(unique_chars) > max_length {\n            max_length =\
    \ len(unique_chars)\n            max_word = word\n        }\n    }\n    return\
    \ max_word\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
