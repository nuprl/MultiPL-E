name: HumanEval_39_prime_fib
language: go_test.go
prompt: "package prime_fib_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
  \ prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n\
  // >>> prime_fib(1)\n// 2\n// >>> prime_fib(2)\n// 3\n// >>> prime_fib(3)\n// 5\n\
  // >>> prime_fib(4)\n// 13\n// >>> prime_fib(5)\n// 89\nfunc prime_fib(n int) int\
  \ {\n"
tests: "func TestPrime_Fib(t *testing.T) {\n  candidate := prime_fib\n\ttype test\
  \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests :=\
  \ []test{\n     { actual: candidate(1), expected: 2 },\n     { actual: candidate(2),\
  \ expected: 3 },\n     { actual: candidate(3), expected: 5 },\n     { actual: candidate(4),\
  \ expected: 13 },\n     { actual: candidate(5), expected: 89 },\n     { actual:\
  \ candidate(6), expected: 233 },\n     { actual: candidate(7), expected: 1597 },\n\
  \     { actual: candidate(8), expected: 28657 },\n     { actual: candidate(9), expected:\
  \ 514229 },\n     { actual: candidate(10), expected: 433494437 },\n   }\n\n\tfor\
  \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
  \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
  \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\
  \t}\n\t\t})\n\t}\n}\n"
completions: ["    i := 1\n    f := 1\n    f1 := 1\n    f2 := 1\n    count := 0\n\
    \    for {\n        if is_prime(f) {\n            count++\n            if count\
    \ == n {\n                return f\n            }\n        }\n        i++\n  \
    \      f = f1 + f2\n        f1 = f2\n        f2 = f\n    }\n}\n", "    if n ==\
    \ 1 {\n        return 2\n    }\n    nth := 1\n    counter := 0\n    for i := 1;\
    \ ; i++ {\n        fib := fibonacci(i)\n        if is_prime(fib) {\n         \
    \   counter++\n            if counter == n {\n                nth = fib\n    \
    \            break\n            }\n        }\n    }\n    return nth\n}\n", " \
    \   if n < 1 {\n        return 0\n    }\n\n    var a, b, c int = 0, 1, 1\n   \
    \ for i := 1; i < n; i++ {\n        a, b, c = b, c, a + b\n        for c % 2 ==\
    \ 0 {\n            a, b, c = b, c, a + b\n        }\n    }\n    return c\n}\n",
  "    //raise ValueError('n should be a positive integer')\n    if n < 1 {\n    \
    \    return 0\n    }\n\n    // As first two Fibonacci numbers are prime, we start\
    \ by setting the first two\n    // primes.\n    i := 2 // first prime\n    primes\
    \ := []int{2, 3}\n    // Fibonacci numbers\n    fibonacci := []int{1, 1}\n\n \
    \   for len(primes) < n {\n        i += 1\n        fibonacci = append(fibonacci,\
    \ fibonacci[len(fibonacci)-1] + fibonacci[len(fibonacci)-2])\n        // to check\
    \ if the number is prime\n        j := 0\n        flag := true\n        for j\
    \ < len(primes) && primes[j]*primes[j] <= i {\n            if i % primes[j] ==\
    \ 0 {\n                flag = false\n                break\n            }\n  \
    \          j += 1\n        }\n        if flag {\n            primes = append(primes,\
    \ i)\n        }\n    }\n    return fibonacci[len(fibonacci)-1]\n}\n", "    return\
    \ 0\n}\n", "    f1, f2 := 2, 3\n    for i := 2; i < n; i++ {\n        f1, f2 =\
    \ f2, f1 + f2\n    }\n    return f1\n}\n", "    fibs := make([]int, n)\n    fibs[0]\
    \ = 2\n    fibs[1] = 3\n    prime_count := 2\n    for i := 2; i < n; i++ {\n \
    \       for {\n            n := fibs[i-1] + fibs[i-2]\n            fibs[i] = n\n\
    \            is_prime := true\n            for j := 1; j < i; j++ {\n        \
    \        if n % fibs[j] == 0 {\n                    is_prime = false\n       \
    \             break\n                }\n            }\n            if is_prime\
    \ {\n                prime_count++\n                break\n            }\n   \
    \     }\n    }\n    return fibs[n-1]\n}\n", "    return 42\n}\n", "    // TODO\n\
    \    return 0\n}\n", "    var prime_count int = 0\n    var fib_count int = 0\n\
    \    for fib_count < n {\n        if is_prime(fib_count) {\n            prime_count++\n\
    \        }\n        if prime_count == n {\n            return fib_count\n    \
    \    }\n        fib_count++\n    }\n    return fib_count\n}\n", "    return 0\n\
    }\n", "    counter := 0\n    for idx, fib_num := range Fibonacci() {\n       \
    \ if IsPrime(fib_num) {\n            counter += 1\n            if counter == n\
    \ {\n                return fib_num\n            }\n        }\n        fmt.Println(idx,\
    \ fib_num)\n    }\n    return 0\n}\n", "    fib := 2\n    result := 0\n    for\
    \ n > 0 {\n        if is_prime(fib) {\n            result = fib\n            n--\n\
    \        }\n        fib += result\n    }\n    return result\n}\n", "    i, j,\
    \ k := 0, 0, 1\n    x := 1\n    for x <= n {\n        if is_prime(k) {\n     \
    \       i, j, k = j, k, j + k\n            x += 1\n        } else {\n        \
    \    j, k = k, j + k\n        }\n    }\n    return k\n}\n", "    i := 0\n    for\
    \ {\n        f := fib(i)\n        if is_prime(f) {\n            n--\n        \
    \    if n == 0 {\n                return f\n            }\n        }\n       \
    \ i++\n    }\n}\n", "    prev, curr := 0, 1\n    i := 1\n    for {\n        prev,\
    \ curr = curr, prev + curr\n        if is_prime(curr) {\n            i++\n   \
    \         if i == n {\n                return curr\n            }\n        }\n\
    \    }\n}\n", "    var current, next int = 2, 3\n    var count int = 1\n    for\
    \ count < n {\n        current, next = next, current + next\n        if (is_prime(current))\
    \ {\n            count += 1\n        }\n    }\n    return current\n}\n", "   \
    \ var x, y int = 2, 3\n    var i int = 2\n    for true {\n        if is_prime(y)\
    \ {\n            i += 1\n            if i == n {\n                return y\n \
    \           }\n        }\n        z := x + y\n        x = y\n        y = z\n \
    \   }\n    return 0\n}\n", "    if n == 1 {\n        return 2\n    }\n\n    var\
    \ result = 3\n    var prime_fib_count = 1\n    var fib1 = 2\n    var fib2 = 3\n\
    \n    for prime_fib_count < n {\n        fib1, fib2 = fib2, fib1 + fib2\n    \
    \    if is_prime(fib2) {\n            prime_fib_count++\n            result =\
    \ fib2\n        }\n    }\n\n    return result\n}\n", "    count := 0\n    last,\
    \ fib := 1, 2\n    for count < n {\n        if is_prime(fib) {\n            count++\n\
    \        }\n        last, fib = fib, last + fib\n    }\n    return fib\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
