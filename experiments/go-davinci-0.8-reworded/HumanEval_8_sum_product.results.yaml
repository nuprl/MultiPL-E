language: go_test.go
name: HumanEval_8_sum_product
results:
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, i := range\
    \ numbers {\n        sum += i\n        product *= i\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075088
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, v := range\
    \ numbers {\n        sum += v\n        product *= v\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, n := range\
    \ numbers {\n        sum += n\n        product *= n\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum int\n    var product int\n    for _, n :=\
    \ range numbers {\n        sum += n\n        if product == 0 {\n            product\
    \ = n\n        } else {\n            product *= n\n        }\n    }\n    return\
    \ []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate\
    \ := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}), expected:\
    \ []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmpfb101hkc_test.go:45: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660075088
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum, product int\n    if len(numbers) == 0 {\n\
    \        return []interface{}{0, 1}\n    }\n    for _, n := range numbers {\n\
    \        sum += n\n        product *= n\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__1\
    \ (0.00s)\n        tmp0ddv5r6m_test.go:43: expected '[%!s(int=3) %!s(int=1)]',\
    \ got '[%!s(int=3) %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__3 (0.00s)\n\
    \        tmp0ddv5r6m_test.go:43: expected '[%!s(int=15) %!s(int=105)]', got '[%!s(int=15)\
    \ %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__4 (0.00s)\n        tmp0ddv5r6m_test.go:43:\
    \ expected '[%!s(int=10) %!s(int=10)]', got '[%!s(int=10) %!s(int=0)]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075088
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, number :=\
    \ range numbers {\n        sum += number\n        product *= number\n    }\n \
    \   return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, v := range\
    \ numbers {\n        sum += v\n        product *= v\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return []interface{}{0,\
    \ 1}\n    }\n    sum := 0\n    product := 1\n    for _, num := range numbers {\n\
    \        sum += num\n        product *= num\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075088
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    return []interface{}{sum(numbers), product(numbers)}\n\
    }\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0, 1}\
    \ },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3, 1}\
    \ },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100, 0}\
    \ },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15, 105}\
    \ },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpamgvf51a_test.go:15:26: undefined: sum

    /tmp/tmpamgvf51a_test.go:15:40: undefined: product

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075088
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, n := range\
    \ numbers {\n        sum += n\n        product *= n\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, number :=\
    \ range numbers {\n        sum += number\n        product *= number\n    }\n \
    \   return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return []interface{}{0,\
    \ 1}\n    }\n    sum := 0\n    product := 1\n    for _, n := range numbers {\n\
    \        sum += n\n        product *= n\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    fmt.Println(numbers)\n    if len(numbers) == 0 {\n\
    \        return []interface{}{0, 1}\n    }\n    sum := 0\n    product := 1\n \
    \   for _, n := range numbers {\n        sum += n\n        product *= n\n    }\n\
    \    return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.005s\n"
  timestamp: 1660075088
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum int\n    var product int = 1\n    for _,\
    \ num := range numbers {\n        sum += num\n        product *= num\n    }\n\
    \    return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, number :=\
    \ range numbers {\n        sum += number\n        product *= number\n    }\n \
    \   return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum, product int\n    sum = 0\n    product =\
    \ 1\n    for _, number := range numbers {\n        sum += number\n        product\
    \ *= number\n    }\n    return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t\
    \ *testing.T) {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1,\
    \ 1, 1}), expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100,\
    \ 0}), expected: []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5,\
    \ 7}), expected: []interface{}{15, 105} },\n     { actual: candidate([]int{10}),\
    \ expected: []interface{}{10, 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075088
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return []interface{}{0,\
    \ 1}\n    }\n    var sum int\n    var product int\n    for _, v := range numbers\
    \ {\n        sum += v\n        product *= v\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__1\
    \ (0.00s)\n        tmpnnbym2y__test.go:44: expected '[%!s(int=3) %!s(int=1)]',\
    \ got '[%!s(int=3) %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__3 (0.00s)\n\
    \        tmpnnbym2y__test.go:44: expected '[%!s(int=15) %!s(int=105)]', got '[%!s(int=15)\
    \ %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__4 (0.00s)\n        tmpnnbym2y__test.go:44:\
    \ expected '[%!s(int=10) %!s(int=10)]', got '[%!s(int=10) %!s(int=0)]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075088
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    if len(numbers)\
    \ == 0 {\n        return []interface{}{sum, product}\n    }\n\n    for _, v :=\
    \ range numbers {\n        sum += v\n        product *= v\n    }\n\n    return\
    \ []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate\
    \ := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}), expected:\
    \ []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075088
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum, product int\n    for _, v := range numbers\
    \ {\n        sum += v\n        product *= v\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmp1kummb1f_test.go:40: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__1 (0.00s)\n\
    \        tmp1kummb1f_test.go:40: expected '[%!s(int=3) %!s(int=1)]', got '[%!s(int=3)\
    \ %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__3 (0.00s)\n        tmp1kummb1f_test.go:40:\
    \ expected '[%!s(int=15) %!s(int=105)]', got '[%!s(int=15) %!s(int=0)]'\n    ---\
    \ FAIL: TestSum_Product/test_num__4 (0.00s)\n        tmp1kummb1f_test.go:40: expected\
    \ '[%!s(int=10) %!s(int=10)]', got '[%!s(int=10) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075088
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return []interface{}{0,\
    \ 1}\n    }\n    sum := 0\n    product := 1\n    for _, n := range numbers {\n\
    \        sum += n\n        product *= n\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum int\n    var product int\n    switch len(numbers)\
    \ {\n    case 0:\n        sum = 0\n        product = 1\n    default:\n       \
    \ sum = numbers[0]\n        product = numbers[0]\n        for _, i := range numbers[1:]\
    \ {\n            sum += i\n            product *= i\n        }\n    }\n    return\
    \ []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate\
    \ := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}), expected:\
    \ []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075088
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, n := range\
    \ numbers {\n        sum += n\n        product *= n\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum, product int\n    for _, value := range\
    \ numbers {\n        sum += value\n        product *= value\n    }\n    return\
    \ []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate\
    \ := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}), expected:\
    \ []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmprzm7a978_test.go:40: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__1 (0.00s)\n\
    \        tmprzm7a978_test.go:40: expected '[%!s(int=3) %!s(int=1)]', got '[%!s(int=3)\
    \ %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__3 (0.00s)\n        tmprzm7a978_test.go:40:\
    \ expected '[%!s(int=15) %!s(int=105)]', got '[%!s(int=15) %!s(int=0)]'\n    ---\
    \ FAIL: TestSum_Product/test_num__4 (0.00s)\n        tmprzm7a978_test.go:40: expected\
    \ '[%!s(int=10) %!s(int=10)]', got '[%!s(int=10) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075088
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    // your code here\n    sum := 0\n    product :=\
    \ 1\n    for _, num := range numbers {\n        sum += num\n        product *=\
    \ num\n    }\n    return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t\
    \ *testing.T) {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1,\
    \ 1, 1}), expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100,\
    \ 0}), expected: []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5,\
    \ 7}), expected: []interface{}{15, 105} },\n     { actual: candidate([]int{10}),\
    \ expected: []interface{}{10, 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075088
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, value :=\
    \ range numbers {\n        sum += value\n        product *= value\n    }\n   \
    \ return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, number :=\
    \ range numbers {\n        sum += number\n        product *= number\n    }\n \
    \   return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return []interface{}{0,\
    \ 1}\n    }\n    sum := 0\n    product := 1\n    for _, v := range numbers {\n\
    \        sum += v\n        product *= v\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075088
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum int\n    var product int\n    for _, number\
    \ := range numbers {\n        sum += number\n        if product == 0 {\n     \
    \       product = number\n        } else {\n            product *= number\n  \
    \      }\n    }\n    return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t\
    \ *testing.T) {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1,\
    \ 1, 1}), expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100,\
    \ 0}), expected: []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5,\
    \ 7}), expected: []interface{}{15, 105} },\n     { actual: candidate([]int{10}),\
    \ expected: []interface{}{10, 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmpnjy475pn_test.go:45: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074981
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    return nil\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmpngv3rr9j_test.go:35: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestSum_Product/test_num__1 (0.00s)\n        tmpngv3rr9j_test.go:35:\
    \ expected '[%!s(int=3) %!s(int=1)]', got '[]'\n    --- FAIL: TestSum_Product/test_num__2\
    \ (0.00s)\n        tmpngv3rr9j_test.go:35: expected '[%!s(int=100) %!s(int=0)]',\
    \ got '[]'\n    --- FAIL: TestSum_Product/test_num__3 (0.00s)\n        tmpngv3rr9j_test.go:35:\
    \ expected '[%!s(int=15) %!s(int=105)]', got '[]'\n    --- FAIL: TestSum_Product/test_num__4\
    \ (0.00s)\n        tmpngv3rr9j_test.go:35: expected '[%!s(int=10) %!s(int=10)]',\
    \ got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075088
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum int = 0\n    var product int = 1\n    for\
    \ _, x := range numbers {\n        sum += x\n        product *= x\n    }\n   \
    \ return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075088
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum, product int\n    for _, n := range numbers\
    \ {\n        sum += n\n        product *= n\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmp1am5sq3p_test.go:40: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__1 (0.00s)\n\
    \        tmp1am5sq3p_test.go:40: expected '[%!s(int=3) %!s(int=1)]', got '[%!s(int=3)\
    \ %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__3 (0.00s)\n        tmp1am5sq3p_test.go:40:\
    \ expected '[%!s(int=15) %!s(int=105)]', got '[%!s(int=15) %!s(int=0)]'\n    ---\
    \ FAIL: TestSum_Product/test_num__4 (0.00s)\n        tmp1am5sq3p_test.go:40: expected\
    \ '[%!s(int=10) %!s(int=10)]', got '[%!s(int=10) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, num := range\
    \ numbers {\n        sum += num\n        product *= num\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    s := 0\n    p := 1\n    for _, val := range numbers\
    \ {\n        s += val\n        p *= val\n    }\n    return []interface{}{s, p}\n\
    }\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0, 1}\
    \ },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3, 1}\
    \ },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100, 0}\
    \ },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15, 105}\
    \ },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075088
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum int = 0\n    var product int = 1\n    if\
    \ len(numbers) == 0 {\n        return []interface{}{sum, product}\n    }\n   \
    \ for _, number := range numbers {\n        sum += number\n        product *=\
    \ number\n    }\n    return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t\
    \ *testing.T) {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1,\
    \ 1, 1}), expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100,\
    \ 0}), expected: []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5,\
    \ 7}), expected: []interface{}{15, 105} },\n     { actual: candidate([]int{10}),\
    \ expected: []interface{}{10, 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075088
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum int\n    var product int = 1\n    for _,\
    \ number := range numbers {\n        sum += number\n        product *= number\n\
    \    }\n    return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, number :=\
    \ range numbers {\n        sum += number\n        product *= number\n    }\n \
    \   return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, number :=\
    \ range numbers {\n        sum += number\n        product *= number\n    }\n \
    \   return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, value :=\
    \ range numbers {\n        sum += value\n        product *= value\n    }\n   \
    \ return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return []interface{}{0,\
    \ 1}\n    }\n    var sum int\n    var product int\n    for _, num := range numbers\
    \ {\n        sum += num\n        product *= num\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__1\
    \ (0.00s)\n        tmptafv2nxb_test.go:44: expected '[%!s(int=3) %!s(int=1)]',\
    \ got '[%!s(int=3) %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__3 (0.00s)\n\
    \        tmptafv2nxb_test.go:44: expected '[%!s(int=15) %!s(int=105)]', got '[%!s(int=15)\
    \ %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__4 (0.00s)\n        tmptafv2nxb_test.go:44:\
    \ expected '[%!s(int=10) %!s(int=10)]', got '[%!s(int=10) %!s(int=0)]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075088
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    res := make([]interface{}, 2)\n    for _, num :=\
    \ range numbers {\n        res[0] = res[0].(int) + num\n        res[1] = res[1].(int)\
    \ * num\n    }\n    return res\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate\
    \ := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}), expected:\
    \ []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\npanic: interface conversion: interface\
    \ {} is nil, not int [recovered]\n\tpanic: interface conversion: interface {}\
    \ is nil, not int\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503f20,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503f20, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.sum_product(...)\n\t/tmp/tmplqtp58yi_test.go:17\n\
    command-line-arguments_test.TestSum_Product(0x0?)\n\t/tmp/tmplqtp58yi_test.go:31\
    \ +0x905\ntesting.tRunner(0xc0001a0340, 0x528fc0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075088
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return []interface{}{0,\
    \ 1}\n    }\n\n    sum := 0\n    product := 1\n    for _, number := range numbers\
    \ {\n        sum += number\n        product *= number\n    }\n\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075088
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum, product int\n    for _, v := range numbers\
    \ {\n        sum += v\n        product *= v\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmp1kummb1f_test.go:40: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__1 (0.00s)\n\
    \        tmp1kummb1f_test.go:40: expected '[%!s(int=3) %!s(int=1)]', got '[%!s(int=3)\
    \ %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__3 (0.00s)\n        tmp1kummb1f_test.go:40:\
    \ expected '[%!s(int=15) %!s(int=105)]', got '[%!s(int=15) %!s(int=0)]'\n    ---\
    \ FAIL: TestSum_Product/test_num__4 (0.00s)\n        tmp1kummb1f_test.go:40: expected\
    \ '[%!s(int=10) %!s(int=10)]', got '[%!s(int=10) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075088
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, number :=\
    \ range numbers {\n        sum += number\n        product *= number\n    }\n \
    \   return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var result []interface{}\n    sum := 0\n    product\
    \ := 1\n    for _, num := range numbers {\n        sum += num\n        product\
    \ *= num\n    }\n    result = append(result, sum, product)\n    return result\n\
    }\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0, 1}\
    \ },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3, 1}\
    \ },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100, 0}\
    \ },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15, 105}\
    \ },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075088
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    result := make([]interface{}, 2)\n    sum := 0\n\
    \    product := 1\n    for _, number := range numbers {\n        sum += number\n\
    \        product *= number\n    }\n    result[0] = sum\n    result[1] = product\n\
    \    return result\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate :=\
    \ sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075088
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    return nil\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmpngv3rr9j_test.go:35: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestSum_Product/test_num__1 (0.00s)\n        tmpngv3rr9j_test.go:35:\
    \ expected '[%!s(int=3) %!s(int=1)]', got '[]'\n    --- FAIL: TestSum_Product/test_num__2\
    \ (0.00s)\n        tmpngv3rr9j_test.go:35: expected '[%!s(int=100) %!s(int=0)]',\
    \ got '[]'\n    --- FAIL: TestSum_Product/test_num__3 (0.00s)\n        tmpngv3rr9j_test.go:35:\
    \ expected '[%!s(int=15) %!s(int=105)]', got '[]'\n    --- FAIL: TestSum_Product/test_num__4\
    \ (0.00s)\n        tmpngv3rr9j_test.go:35: expected '[%!s(int=10) %!s(int=10)]',\
    \ got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075088
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, number :=\
    \ range numbers {\n        sum += number\n        product *= number\n    }\n \
    \   return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, number :=\
    \ range numbers {\n        sum += number\n        product *= number\n    }\n \
    \   return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return []interface{}{0,\
    \ 1}\n    }\n    sum := 0\n    product := 1\n    for _, i := range numbers {\n\
    \        sum += i\n        product *= i\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075089
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum int\n    var product int = 1\n    for _,\
    \ n := range numbers {\n        sum += n\n        product *= n\n    }\n    return\
    \ []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate\
    \ := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}), expected:\
    \ []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, num := range\
    \ numbers {\n        sum += num\n        product *= num\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074981
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    return []interface{}{0, 1}\n}\n\nfunc TestSum_Product(t\
    \ *testing.T) {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1,\
    \ 1, 1}), expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100,\
    \ 0}), expected: []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5,\
    \ 7}), expected: []interface{}{15, 105} },\n     { actual: candidate([]int{10}),\
    \ expected: []interface{}{10, 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__1\
    \ (0.00s)\n        tmpnztfvhk6_test.go:35: expected '[%!s(int=3) %!s(int=1)]',\
    \ got '[%!s(int=0) %!s(int=1)]'\n    --- FAIL: TestSum_Product/test_num__2 (0.00s)\n\
    \        tmpnztfvhk6_test.go:35: expected '[%!s(int=100) %!s(int=0)]', got '[%!s(int=0)\
    \ %!s(int=1)]'\n    --- FAIL: TestSum_Product/test_num__3 (0.00s)\n        tmpnztfvhk6_test.go:35:\
    \ expected '[%!s(int=15) %!s(int=105)]', got '[%!s(int=0) %!s(int=1)]'\n    ---\
    \ FAIL: TestSum_Product/test_num__4 (0.00s)\n        tmpnztfvhk6_test.go:35: expected\
    \ '[%!s(int=10) %!s(int=10)]', got '[%!s(int=0) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _,v := range\
    \ numbers {\n        sum += v\n        product *= v\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075090
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return []interface{}{0,\
    \ 1}\n    }\n\n    sum := 0\n    product := 1\n    for _, number := range numbers\
    \ {\n        sum += number\n        product *= number\n    }\n\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075088
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, v := range\
    \ numbers {\n        sum += v\n        product *= v\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return []interface{}{0,\
    \ 1}\n    }\n\n    sum := 0\n    product := 1\n    for _, i := range numbers {\n\
    \        sum += i\n        product *= i\n    }\n\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075090
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, v := range\
    \ numbers {\n        sum += v\n        product *= v\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum int\n    var product int = 1\n    for _,\
    \ v := range numbers {\n        sum += v\n        product *= v\n    }\n    return\
    \ []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate\
    \ := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}), expected:\
    \ []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum = 0\n    var product = 1\n    for _, value\
    \ := range numbers {\n        sum += value\n        product *= value\n    }\n\
    \    return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075090
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, number :=\
    \ range numbers {\n        sum += number\n        product *= number\n    }\n \
    \   return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    // YOUR CODE HERE\n    return []interface{}{0, 0}\n\
    }\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0, 1}\
    \ },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3, 1}\
    \ },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100, 0}\
    \ },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15, 105}\
    \ },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmp3ayu7_g9_test.go:36: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__1 (0.00s)\n\
    \        tmp3ayu7_g9_test.go:36: expected '[%!s(int=3) %!s(int=1)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__2 (0.00s)\n        tmp3ayu7_g9_test.go:36:\
    \ expected '[%!s(int=100) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\n    ---\
    \ FAIL: TestSum_Product/test_num__3 (0.00s)\n        tmp3ayu7_g9_test.go:36: expected\
    \ '[%!s(int=15) %!s(int=105)]', got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__4\
    \ (0.00s)\n        tmp3ayu7_g9_test.go:36: expected '[%!s(int=10) %!s(int=10)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660075090
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum, product int\n    for _, v := range numbers\
    \ {\n        sum += v\n        product *= v\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmp1kummb1f_test.go:40: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__1 (0.00s)\n\
    \        tmp1kummb1f_test.go:40: expected '[%!s(int=3) %!s(int=1)]', got '[%!s(int=3)\
    \ %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__3 (0.00s)\n        tmp1kummb1f_test.go:40:\
    \ expected '[%!s(int=15) %!s(int=105)]', got '[%!s(int=15) %!s(int=0)]'\n    ---\
    \ FAIL: TestSum_Product/test_num__4 (0.00s)\n        tmp1kummb1f_test.go:40: expected\
    \ '[%!s(int=10) %!s(int=10)]', got '[%!s(int=10) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075088
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    s := 0\n    p := 1\n    for _, v := range numbers\
    \ {\n        s += v\n        p *= v\n    }\n    return []interface{}{s, p}\n}\n\
    \nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0, 1}\
    \ },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3, 1}\
    \ },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100, 0}\
    \ },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15, 105}\
    \ },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075090
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    for _, v := range numbers {\n        sum := sum\
    \ + v\n        product = product * v\n    }\n    return []interface{}{sum, product}\n\
    }\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0, 1}\
    \ },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3, 1}\
    \ },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100, 0}\
    \ },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15, 105}\
    \ },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsrj4muoo_test.go:16:16: undefined: sum

    /tmp/tmpsrj4muoo_test.go:17:19: undefined: product

    /tmp/tmpsrj4muoo_test.go:19:26: undefined: sum

    /tmp/tmpsrj4muoo_test.go:19:31: undefined: product

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075090
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, v := range\
    \ numbers {\n        sum += v\n        product *= v\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    return nil\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmpngv3rr9j_test.go:35: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestSum_Product/test_num__1 (0.00s)\n        tmpngv3rr9j_test.go:35:\
    \ expected '[%!s(int=3) %!s(int=1)]', got '[]'\n    --- FAIL: TestSum_Product/test_num__2\
    \ (0.00s)\n        tmpngv3rr9j_test.go:35: expected '[%!s(int=100) %!s(int=0)]',\
    \ got '[]'\n    --- FAIL: TestSum_Product/test_num__3 (0.00s)\n        tmpngv3rr9j_test.go:35:\
    \ expected '[%!s(int=15) %!s(int=105)]', got '[]'\n    --- FAIL: TestSum_Product/test_num__4\
    \ (0.00s)\n        tmpngv3rr9j_test.go:35: expected '[%!s(int=10) %!s(int=10)]',\
    \ got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075088
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return []interface{}{0,\
    \ 1}\n    }\n\n    sum := 0\n    product := 1\n    for _, v := range numbers {\n\
    \        sum += v\n        product *= v\n    }\n\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075090
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    if len(numbers)\
    \ == 0 {\n        return []interface{}{sum, product}\n    }\n    for _, num :=\
    \ range numbers {\n        sum += num\n        product *= num\n    }\n    return\
    \ []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate\
    \ := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}), expected:\
    \ []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075090
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, number :=\
    \ range numbers {\n        sum += number\n        product *= number\n    }\n \
    \   return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, n := range\
    \ numbers {\n        sum += n\n        product *= n\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum int\n    var product int = 1\n    for _,\
    \ value := range numbers {\n        sum += value\n        product *= value\n \
    \   }\n    return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.005s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    length := len(numbers)\n    if length == 0 {\n \
    \       return []interface{}{0, 1}\n    }\n    sum := 0\n    product := 1\n  \
    \  for _, num := range numbers {\n        sum += num\n        product *= num\n\
    \    }\n    return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075090
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum, product int\n    for _, value := range\
    \ numbers {\n        sum += value\n        product *= value\n    }\n    return\
    \ []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate\
    \ := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}), expected:\
    \ []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmprzm7a978_test.go:40: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__1 (0.00s)\n\
    \        tmprzm7a978_test.go:40: expected '[%!s(int=3) %!s(int=1)]', got '[%!s(int=3)\
    \ %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__3 (0.00s)\n        tmprzm7a978_test.go:40:\
    \ expected '[%!s(int=15) %!s(int=105)]', got '[%!s(int=15) %!s(int=0)]'\n    ---\
    \ FAIL: TestSum_Product/test_num__4 (0.00s)\n        tmprzm7a978_test.go:40: expected\
    \ '[%!s(int=10) %!s(int=10)]', got '[%!s(int=10) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075088
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    // return []interface{}{}\n    sum := 0\n    prod\
    \ := 1\n    for _, num := range numbers {\n        sum += num\n        prod *=\
    \ num\n    }\n    return []interface{}{sum, prod}\n}\n\nfunc TestSum_Product(t\
    \ *testing.T) {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1,\
    \ 1, 1}), expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100,\
    \ 0}), expected: []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5,\
    \ 7}), expected: []interface{}{15, 105} },\n     { actual: candidate([]int{10}),\
    \ expected: []interface{}{10, 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075090
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, number :=\
    \ range numbers {\n        sum += number\n        product *= number\n    }\n \
    \   return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum, product int = 0, 1\n    for _, n := range\
    \ numbers {\n        sum += n\n        product *= n\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075090
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, x := range\
    \ numbers {\n        sum += x\n        product *= x\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075090
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, n := range\
    \ numbers {\n        sum += n\n        product *= n\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    res := make([]interface{}, 2)\n    res[0] = 0\n\
    \    res[1] = 1\n    for _, number := range numbers {\n        res[0] = res[0].(int)\
    \ + number\n        res[1] = res[1].(int) * number\n    }\n    return res\n}\n\
    \nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0, 1}\
    \ },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3, 1}\
    \ },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100, 0}\
    \ },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15, 105}\
    \ },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075090
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, v := range\
    \ numbers {\n        sum += v\n        product *= v\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum, product int\n    for _, num := range numbers\
    \ {\n        sum += num\n        product *= num\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmp1bmgk4gb_test.go:40: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__1 (0.00s)\n\
    \        tmp1bmgk4gb_test.go:40: expected '[%!s(int=3) %!s(int=1)]', got '[%!s(int=3)\
    \ %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__3 (0.00s)\n        tmp1bmgk4gb_test.go:40:\
    \ expected '[%!s(int=15) %!s(int=105)]', got '[%!s(int=15) %!s(int=0)]'\n    ---\
    \ FAIL: TestSum_Product/test_num__4 (0.00s)\n        tmp1bmgk4gb_test.go:40: expected\
    \ '[%!s(int=10) %!s(int=10)]', got '[%!s(int=10) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075090
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum, product int\n    for _, number := range\
    \ numbers {\n        sum += number\n        product *= number\n    }\n    return\
    \ []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate\
    \ := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}), expected:\
    \ []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmpfk_kcq20_test.go:40: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__1 (0.00s)\n\
    \        tmpfk_kcq20_test.go:40: expected '[%!s(int=3) %!s(int=1)]', got '[%!s(int=3)\
    \ %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__3 (0.00s)\n        tmpfk_kcq20_test.go:40:\
    \ expected '[%!s(int=15) %!s(int=105)]', got '[%!s(int=15) %!s(int=0)]'\n    ---\
    \ FAIL: TestSum_Product/test_num__4 (0.00s)\n        tmpfk_kcq20_test.go:40: expected\
    \ '[%!s(int=10) %!s(int=10)]', got '[%!s(int=10) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075090
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    total := 0\n    product := 1\n    for _, num :=\
    \ range numbers {\n        total += num\n        product *= num\n    }\n    return\
    \ []interface{}{total, product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n \
    \ candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075090
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum, product int\n    for _, v := range numbers\
    \ {\n        sum += v\n        product *= v\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmp1kummb1f_test.go:40: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__1 (0.00s)\n\
    \        tmp1kummb1f_test.go:40: expected '[%!s(int=3) %!s(int=1)]', got '[%!s(int=3)\
    \ %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__3 (0.00s)\n        tmp1kummb1f_test.go:40:\
    \ expected '[%!s(int=15) %!s(int=105)]', got '[%!s(int=15) %!s(int=0)]'\n    ---\
    \ FAIL: TestSum_Product/test_num__4 (0.00s)\n        tmp1kummb1f_test.go:40: expected\
    \ '[%!s(int=10) %!s(int=10)]', got '[%!s(int=10) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075088
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum int\n    var product int\n    for _, n :=\
    \ range numbers {\n        sum += n\n        if product == 0 {\n            product\
    \ = n\n        } else {\n            product *= n\n        }\n    }\n    return\
    \ []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate\
    \ := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}), expected:\
    \ []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmpfb101hkc_test.go:45: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660075088
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return []interface{}{0,\
    \ 1}\n    }\n    sum := 0\n    product := 1\n    for _, v := range numbers {\n\
    \        sum += v\n        product *= v\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075088
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum int\n    var product int = 1\n    for _,\
    \ value := range numbers {\n        sum += value\n        product *= value\n \
    \   }\n    return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.005s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, number :=\
    \ range numbers {\n        sum += number\n        product *= number\n    }\n \
    \   return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, num := range\
    \ numbers {\n        sum += num\n        product *= num\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    prod := 1\n    for _, v := range numbers\
    \ {\n        sum += v\n        prod *= v\n    }\n    return []interface{}{sum,\
    \ prod}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075090
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    // Fill this in\n    sum := 0\n    product := 1\n\
    \    for _, n := range numbers {\n        sum += n\n        product *= n\n   \
    \ }\n    return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075090
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, v := range\
    \ numbers {\n        sum += v\n        product *= v\n    }\n    var empty = []interface{}{}\n\
    \    if len(numbers) == 0 {\n        return append(empty, 0, 1)\n    }\n    return\
    \ append(empty, sum, product)\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate\
    \ := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}), expected:\
    \ []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075090
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    s := 0\n    p := 1\n    for _, n := range numbers\
    \ {\n        s += n\n        p *= n\n    }\n    return []interface{}{s, p}\n}\n\
    \nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0, 1}\
    \ },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3, 1}\
    \ },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100, 0}\
    \ },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15, 105}\
    \ },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075090
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var result []interface{}\n    var sum, product int\n\
    \    for _, n := range numbers {\n        sum += n\n        product *= n\n   \
    \ }\n    result = append(result, sum, product)\n    return result\n}\n\nfunc TestSum_Product(t\
    \ *testing.T) {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1,\
    \ 1, 1}), expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100,\
    \ 0}), expected: []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5,\
    \ 7}), expected: []interface{}{15, 105} },\n     { actual: candidate([]int{10}),\
    \ expected: []interface{}{10, 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmpe2rtug20_test.go:42: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__1 (0.00s)\n\
    \        tmpe2rtug20_test.go:42: expected '[%!s(int=3) %!s(int=1)]', got '[%!s(int=3)\
    \ %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__3 (0.00s)\n        tmpe2rtug20_test.go:42:\
    \ expected '[%!s(int=15) %!s(int=105)]', got '[%!s(int=15) %!s(int=0)]'\n    ---\
    \ FAIL: TestSum_Product/test_num__4 (0.00s)\n        tmpe2rtug20_test.go:42: expected\
    \ '[%!s(int=10) %!s(int=10)]', got '[%!s(int=10) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075090
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var result []interface{}\n    result = append(result,\
    \ 0)\n    result = append(result, 1)\n    for _, number := range numbers {\n \
    \       result[0] = result[0].(int) + number\n        result[1] = result[1].(int)\
    \ * number\n    }\n    return result\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075090
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, v := range\
    \ numbers {\n        sum += v\n        product *= v\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, number :=\
    \ range numbers {\n        sum += number\n        product *= number\n    }\n \
    \   return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, n := range\
    \ numbers {\n        sum += n\n        product *= n\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, v := range\
    \ numbers {\n        sum += v\n        product *= v\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum = 0\n    var product = 1\n    for _, number\
    \ := range numbers {\n        sum += number\n        product *= number\n    }\n\
    \    return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075090
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, number :=\
    \ range numbers {\n        sum += number\n        product *= number\n    }\n \
    \   return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return []interface{}{0,\
    \ 1}\n    }\n    sum := 0\n    product := 1\n    for _, n := range numbers {\n\
    \        sum += n\n        product *= n\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    r := []interface{}{0, 1}\n    for _, n := range\
    \ numbers {\n        r[0] = r[0].(int) + n\n        r[1] = r[1].(int) * n\n  \
    \  }\n    return r\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate :=\
    \ sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075091
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, num := range\
    \ numbers {\n        sum += num\n        product *= num\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, number :=\
    \ range numbers {\n        sum += number\n        product *= number\n    }\n \
    \   return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return []interface{}{0,\
    \ 1}\n    }\n    sum := 0\n    product := 1\n    for _, val := range numbers {\n\
    \        sum += val\n        product *= val\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075093
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    return []interface{}{0, 1}\n}\n\nfunc TestSum_Product(t\
    \ *testing.T) {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1,\
    \ 1, 1}), expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100,\
    \ 0}), expected: []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5,\
    \ 7}), expected: []interface{}{15, 105} },\n     { actual: candidate([]int{10}),\
    \ expected: []interface{}{10, 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__1\
    \ (0.00s)\n        tmpnztfvhk6_test.go:35: expected '[%!s(int=3) %!s(int=1)]',\
    \ got '[%!s(int=0) %!s(int=1)]'\n    --- FAIL: TestSum_Product/test_num__2 (0.00s)\n\
    \        tmpnztfvhk6_test.go:35: expected '[%!s(int=100) %!s(int=0)]', got '[%!s(int=0)\
    \ %!s(int=1)]'\n    --- FAIL: TestSum_Product/test_num__3 (0.00s)\n        tmpnztfvhk6_test.go:35:\
    \ expected '[%!s(int=15) %!s(int=105)]', got '[%!s(int=0) %!s(int=1)]'\n    ---\
    \ FAIL: TestSum_Product/test_num__4 (0.00s)\n        tmpnztfvhk6_test.go:35: expected\
    \ '[%!s(int=10) %!s(int=10)]', got '[%!s(int=0) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    if len(numbers)\
    \ == 0 {\n        return []interface{}{0, 1}\n    }\n    for _, number := range\
    \ numbers {\n        sum += number\n        product *= number\n    }\n    return\
    \ []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate\
    \ := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}), expected:\
    \ []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075093
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return []interface{}{0,\
    \ 1}\n    }\n    sum := 0\n    product := 1\n    for _, number := range numbers\
    \ {\n        sum += number\n        product *= number\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum, product int\n    for _, n := range numbers\
    \ {\n        sum += n\n        product *= n\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmp1am5sq3p_test.go:40: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__1 (0.00s)\n\
    \        tmp1am5sq3p_test.go:40: expected '[%!s(int=3) %!s(int=1)]', got '[%!s(int=3)\
    \ %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__3 (0.00s)\n        tmp1am5sq3p_test.go:40:\
    \ expected '[%!s(int=15) %!s(int=105)]', got '[%!s(int=15) %!s(int=0)]'\n    ---\
    \ FAIL: TestSum_Product/test_num__4 (0.00s)\n        tmp1am5sq3p_test.go:40: expected\
    \ '[%!s(int=10) %!s(int=10)]', got '[%!s(int=10) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum int\n    product := 1\n    for _, v := range\
    \ numbers {\n        sum += v\n        product *= v\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075093
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum = 0\n    var product = 1\n    for _, n :=\
    \ range numbers {\n        sum += n\n        product *= n\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075093
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum int = 0\n    var product int = 1\n    for\
    \ _,n := range numbers {\n        sum += n\n        product *= n\n    }\n    return\
    \ []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate\
    \ := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}), expected:\
    \ []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075093
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, number :=\
    \ range numbers {\n        sum += number\n        product *= number\n    }\n \
    \   return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, number :=\
    \ range numbers {\n        sum += number\n        product *= number\n    }\n \
    \   return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, number :=\
    \ range numbers {\n        sum += number\n        product *= number\n    }\n \
    \   return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return []interface{}{0,\
    \ 1}\n    }\n    sum := 0\n    product := 1\n    for _, number := range numbers\
    \ {\n        sum += number\n        product *= number\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    return []interface{}{}\n}\n\nfunc TestSum_Product(t\
    \ *testing.T) {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1,\
    \ 1, 1}), expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100,\
    \ 0}), expected: []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5,\
    \ 7}), expected: []interface{}{15, 105} },\n     { actual: candidate([]int{10}),\
    \ expected: []interface{}{10, 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmpp20b2ioq_test.go:35: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestSum_Product/test_num__1 (0.00s)\n        tmpp20b2ioq_test.go:35:\
    \ expected '[%!s(int=3) %!s(int=1)]', got '[]'\n    --- FAIL: TestSum_Product/test_num__2\
    \ (0.00s)\n        tmpp20b2ioq_test.go:35: expected '[%!s(int=100) %!s(int=0)]',\
    \ got '[]'\n    --- FAIL: TestSum_Product/test_num__3 (0.00s)\n        tmpp20b2ioq_test.go:35:\
    \ expected '[%!s(int=15) %!s(int=105)]', got '[]'\n    --- FAIL: TestSum_Product/test_num__4\
    \ (0.00s)\n        tmpp20b2ioq_test.go:35: expected '[%!s(int=10) %!s(int=10)]',\
    \ got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075092
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    return []interface{}{sum(numbers), product(numbers)}\n\
    }\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0, 1}\
    \ },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3, 1}\
    \ },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100, 0}\
    \ },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15, 105}\
    \ },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpamgvf51a_test.go:15:26: undefined: sum

    /tmp/tmpamgvf51a_test.go:15:40: undefined: product

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075088
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    return nil\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmpngv3rr9j_test.go:35: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestSum_Product/test_num__1 (0.00s)\n        tmpngv3rr9j_test.go:35:\
    \ expected '[%!s(int=3) %!s(int=1)]', got '[]'\n    --- FAIL: TestSum_Product/test_num__2\
    \ (0.00s)\n        tmpngv3rr9j_test.go:35: expected '[%!s(int=100) %!s(int=0)]',\
    \ got '[]'\n    --- FAIL: TestSum_Product/test_num__3 (0.00s)\n        tmpngv3rr9j_test.go:35:\
    \ expected '[%!s(int=15) %!s(int=105)]', got '[]'\n    --- FAIL: TestSum_Product/test_num__4\
    \ (0.00s)\n        tmpngv3rr9j_test.go:35: expected '[%!s(int=10) %!s(int=10)]',\
    \ got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075088
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum int = 0\n    var product int = 1\n    for\
    \ _, number := range numbers {\n        sum += number\n        product *= number\n\
    \    }\n    return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, number :=\
    \ range numbers {\n        sum += number\n        product *= number\n    }\n \
    \   return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    s := 0\n    p := 1\n    for _, i := range numbers\
    \ {\n        s += i\n        p *= i\n    }\n    return []interface{}{s, p}\n}\n\
    \nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0, 1}\
    \ },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3, 1}\
    \ },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100, 0}\
    \ },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15, 105}\
    \ },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075093
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, num := range\
    \ numbers {\n        sum += num\n        product *= num\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, num := range\
    \ numbers {\n        sum += num\n        product *= num\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, number :=\
    \ range numbers {\n        sum += number\n        product *= number\n    }\n \
    \   return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    result := make([]interface{},\
    \ 2)\n    for _, number := range numbers {\n        sum += number\n        product\
    \ *= number\n    }\n    result[0] = sum\n    result[1] = product\n    return result\n\
    }\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0, 1}\
    \ },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3, 1}\
    \ },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100, 0}\
    \ },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15, 105}\
    \ },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075093
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, v := range\
    \ numbers {\n        sum += v\n        product *= v\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return []interface{}{0,\
    \ 1}\n    }\n    sum := 0\n    product := 1\n    for _, number := range numbers\
    \ {\n        sum += number\n        product *= number\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum int\n    var product int\n    if len(numbers)\
    \ == 0 {\n        return []interface{}{0, 1}\n    }\n    for _, v := range numbers\
    \ {\n        sum += v\n        product *= v\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__1\
    \ (0.00s)\n        tmpd8vl5wgb_test.go:44: expected '[%!s(int=3) %!s(int=1)]',\
    \ got '[%!s(int=3) %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__3 (0.00s)\n\
    \        tmpd8vl5wgb_test.go:44: expected '[%!s(int=15) %!s(int=105)]', got '[%!s(int=15)\
    \ %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__4 (0.00s)\n        tmpd8vl5wgb_test.go:44:\
    \ expected '[%!s(int=10) %!s(int=10)]', got '[%!s(int=10) %!s(int=0)]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074981
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return []interface{}{0,\
    \ 1}\n    }\n    var sum, product int\n    for _, number := range numbers {\n\
    \        sum += number\n        product *= number\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__1\
    \ (0.00s)\n        tmpq4w08ljn_test.go:43: expected '[%!s(int=3) %!s(int=1)]',\
    \ got '[%!s(int=3) %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__3 (0.00s)\n\
    \        tmpq4w08ljn_test.go:43: expected '[%!s(int=15) %!s(int=105)]', got '[%!s(int=15)\
    \ %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__4 (0.00s)\n        tmpq4w08ljn_test.go:43:\
    \ expected '[%!s(int=10) %!s(int=10)]', got '[%!s(int=10) %!s(int=0)]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075093
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, n := range\
    \ numbers {\n        sum += n\n        product *= n\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum int\n    var product int\n    sum = 0\n\
    \    product = 1\n    for _, n := range numbers {\n        sum += n\n        product\
    \ *= n\n    }\n    return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t\
    \ *testing.T) {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1,\
    \ 1, 1}), expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100,\
    \ 0}), expected: []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5,\
    \ 7}), expected: []interface{}{15, 105} },\n     { actual: candidate([]int{10}),\
    \ expected: []interface{}{10, 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075093
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, n := range\
    \ numbers {\n        sum += n\n        product *= n\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\ntype TestCase \nfunc TestSum_Product(t *testing.T) {\n  candidate\
    \ := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}), expected:\
    \ []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqvwvjpvr_test.go:24:15: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075092
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, num := range\
    \ numbers {\n        sum += num\n        product *= num\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074981
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    return []interface{}{\n        sum(numbers),\n \
    \       product(numbers),\n    }\n}\n\nfunc TestSum_Product(t *testing.T) {\n\
    \  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpuvcwzy6a_test.go:16:9: undefined: sum

    /tmp/tmpuvcwzy6a_test.go:17:9: undefined: product

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075092
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, n := range\
    \ numbers {\n        sum += n\n        product *= n\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    result := make([]interface{},\
    \ 2)\n    for _, value := range numbers {\n        sum += value\n        product\
    \ *= value\n    }\n    result[0] = sum\n    result[1] = product\n    return result\n\
    }\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0, 1}\
    \ },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3, 1}\
    \ },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100, 0}\
    \ },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15, 105}\
    \ },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075093
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var result []interface{}\n    result = append(result,\
    \ 0)\n    result = append(result, 1)\n    for _, n := range numbers {\n      \
    \  result[0] = result[0].(int) + n\n        result[1] = result[1].(int) * n\n\
    \    }\n    return result\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate\
    \ := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}), expected:\
    \ []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075093
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, v := range\
    \ numbers {\n        sum += v\n        product *= v\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, v := range\
    \ numbers {\n        sum += v\n        product *= v\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum, product int\n    for _, x := range numbers\
    \ {\n        sum += x\n        product *= x\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmpqsqcg7pz_test.go:40: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__1 (0.00s)\n\
    \        tmpqsqcg7pz_test.go:40: expected '[%!s(int=3) %!s(int=1)]', got '[%!s(int=3)\
    \ %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__3 (0.00s)\n        tmpqsqcg7pz_test.go:40:\
    \ expected '[%!s(int=15) %!s(int=105)]', got '[%!s(int=15) %!s(int=0)]'\n    ---\
    \ FAIL: TestSum_Product/test_num__4 (0.00s)\n        tmpqsqcg7pz_test.go:40: expected\
    \ '[%!s(int=10) %!s(int=10)]', got '[%!s(int=10) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075093
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var result []interface{}\n    sum := 0\n    product\
    \ := 1\n    for _, v := range numbers {\n        sum += v\n        product *=\
    \ v\n    }\n    result = append(result, sum, product)\n    return result\n}\n\n\
    func TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0, 1}\
    \ },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3, 1}\
    \ },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100, 0}\
    \ },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15, 105}\
    \ },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075093
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    result := make([]interface{}, 2)\n    result[0]\
    \ = 0\n    result[1] = 1\n    for _, number := range numbers {\n        result[0]\
    \ = result[0].(int) + number\n        result[1] = result[1].(int) * number\n \
    \   }\n    return result\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate\
    \ := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}), expected:\
    \ []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075093
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, v := range\
    \ numbers {\n        sum += v\n        product *= v\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\ntype testCase \nfunc TestSum_Product(t *testing.T) {\n  candidate\
    \ := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}), expected:\
    \ []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8lzu04t9_test.go:24:15: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075092
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, v := range\
    \ numbers {\n        sum += v\n        product *= v\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    result := make([]interface{},\
    \ 2)\n    for _, n := range numbers {\n        sum += n\n        product *= n\n\
    \    }\n    result[0] = sum\n    result[1] = product\n    return result\n}\n\n\
    func TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0, 1}\
    \ },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3, 1}\
    \ },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100, 0}\
    \ },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15, 105}\
    \ },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075093
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, number :=\
    \ range numbers {\n        sum += number\n        product *= number\n    }\n \
    \   return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    s := 0\n    p := 1\n    for _, n := range numbers\
    \ {\n        s += n\n        p *= n\n    }\n    return []interface{}{s, p}\n}\n\
    \nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0, 1}\
    \ },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3, 1}\
    \ },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100, 0}\
    \ },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15, 105}\
    \ },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075090
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    product := 1\n    sum := 0\n    for _, number :=\
    \ range numbers {\n        product *= number\n        sum += number\n    }\n \
    \   return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075093
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum int = 0\n    var product int = 1\n    for\
    \ _, v := range numbers {\n        sum += v\n        product *= v\n    }\n   \
    \ return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    res := make([]interface{}, 2)\n    res[0] = 0\n\
    \    res[1] = 1\n    for _, num := range numbers {\n        res[0] = res[0].(int)\
    \ + num\n        res[1] = res[1].(int) * num\n    }\n    return res\n}\n\nfunc\
    \ TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{}), expected: []interface{}{0, 1} },\n     { actual:\
    \ candidate([]int{1, 1, 1}), expected: []interface{}{3, 1} },\n     { actual:\
    \ candidate([]int{100, 0}), expected: []interface{}{100, 0} },\n     { actual:\
    \ candidate([]int{3, 5, 7}), expected: []interface{}{15, 105} },\n     { actual:\
    \ candidate([]int{10}), expected: []interface{}{10, 10} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075093
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    return []interface{}{sum(numbers), product(numbers)}\n\
    }\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0, 1}\
    \ },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3, 1}\
    \ },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100, 0}\
    \ },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15, 105}\
    \ },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpamgvf51a_test.go:15:26: undefined: sum

    /tmp/tmpamgvf51a_test.go:15:40: undefined: product

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075088
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var result []interface{}\n    var sum int\n    var\
    \ product int\n    if len(numbers) == 0 {\n        sum = 0\n        product =\
    \ 1\n    } else {\n        for _, v := range numbers {\n            sum += v\n\
    \            if product == 0 {\n                product = v\n            } else\
    \ {\n                product *= v\n            }\n        }\n    }\n    result\
    \ = append(result, sum)\n    result = append(result, product)\n    return result\n\
    }\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0, 1}\
    \ },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3, 1}\
    \ },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100, 0}\
    \ },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15, 105}\
    \ },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075093
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return []interface{}{0,\
    \ 1}\n    }\n\n    sum := 0\n    product := 1\n    for _, number := range numbers\
    \ {\n        sum += number\n        product *= number\n    }\n\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075088
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    result := make([]interface{},\
    \ 2)\n    for _, n := range numbers {\n        sum += n\n        product *= n\n\
    \    }\n    result[0] = sum\n    result[1] = product\n    return result\n}\n\n\
    func TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0, 1}\
    \ },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3, 1}\
    \ },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100, 0}\
    \ },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15, 105}\
    \ },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075093
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum, product int = 0, 1\n    for _, i := range\
    \ numbers {\n        sum += i\n        product *= i\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075093
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, number :=\
    \ range numbers {\n        sum += number\n        product *= number\n    }\n \
    \   return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, i := range\
    \ numbers {\n        sum += i\n        product *= i\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075088
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum int = 0\n    var product int = 1\n    for\
    \ _,n := range numbers {\n        sum += n\n        product *= n\n    }\n    return\
    \ []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate\
    \ := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}), expected:\
    \ []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075093
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    return nil\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmpngv3rr9j_test.go:35: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestSum_Product/test_num__1 (0.00s)\n        tmpngv3rr9j_test.go:35:\
    \ expected '[%!s(int=3) %!s(int=1)]', got '[]'\n    --- FAIL: TestSum_Product/test_num__2\
    \ (0.00s)\n        tmpngv3rr9j_test.go:35: expected '[%!s(int=100) %!s(int=0)]',\
    \ got '[]'\n    --- FAIL: TestSum_Product/test_num__3 (0.00s)\n        tmpngv3rr9j_test.go:35:\
    \ expected '[%!s(int=15) %!s(int=105)]', got '[]'\n    --- FAIL: TestSum_Product/test_num__4\
    \ (0.00s)\n        tmpngv3rr9j_test.go:35: expected '[%!s(int=10) %!s(int=10)]',\
    \ got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075088
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, v := range\
    \ numbers {\n        sum += v\n        product *= v\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return []interface{}{0,\
    \ 1}\n    }\n\n    sum := 0\n    product := 1\n    for _, number := range numbers\
    \ {\n        sum += number\n        product *= number\n    }\n\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075088
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return []interface{}{0,\
    \ 1}\n    }\n    sum := 0\n    product := 1\n    for _, v := range numbers {\n\
    \        sum += v\n        product *= v\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075088
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, number :=\
    \ range numbers {\n        sum += number\n        product *= number\n    }\n \
    \   return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, v := range\
    \ numbers {\n        sum += v\n        product *= v\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\ntype TestData \nfunc TestSum_Product(t *testing.T) {\n  candidate\
    \ := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}), expected:\
    \ []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpru7yr0bo_test.go:24:15: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075092
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, num := range\
    \ numbers {\n        sum += num\n        product *= num\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, number :=\
    \ range numbers {\n        sum += number\n        product *= number\n    }\n \
    \   return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 2
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var empty_float64 []float64\n    var empty_int []int\n\
    \    float_slice := make([]float64, len(numbers))\n    for idx, value := range\
    \ numbers {\n        float_slice[idx] = float64(value)\n    }\n    var result\
    \ []interface{}\n    result = append(result, sum(float_slice))\n    result = append(result,\
    \ product(float_slice))\n    return result\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqmrg24tp_test.go:15:9: empty_float64 declared but not used

    /tmp/tmpqmrg24tp_test.go:16:9: empty_int declared but not used

    /tmp/tmpqmrg24tp_test.go:22:29: undefined: sum

    /tmp/tmpqmrg24tp_test.go:23:29: undefined: product

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075093
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, v := range\
    \ numbers {\n        sum += v\n        product *= v\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, n := range\
    \ numbers {\n        sum += n\n        product *= n\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    // your code here\n    var res []interface{}\n \
    \   var sum int = 0\n    var product int = 1\n    for _, number := range numbers\
    \ {\n        sum += number\n        product *= number\n    }\n    res = append(res,\
    \ sum)\n    res = append(res, product)\n    return res\n}\n\nfunc TestSum_Product(t\
    \ *testing.T) {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1,\
    \ 1, 1}), expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100,\
    \ 0}), expected: []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5,\
    \ 7}), expected: []interface{}{15, 105} },\n     { actual: candidate([]int{10}),\
    \ expected: []interface{}{10, 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075093
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    res := make([]interface{}, 2)\n    res[0] = 0\n\
    \    res[1] = 1\n    for _, v := range numbers {\n        res[0] = res[0].(int)\
    \ + v\n        res[1] = res[1].(int) * v\n    }\n    return res\n}\n\nfunc TestSum_Product(t\
    \ *testing.T) {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1,\
    \ 1, 1}), expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100,\
    \ 0}), expected: []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5,\
    \ 7}), expected: []interface{}{15, 105} },\n     { actual: candidate([]int{10}),\
    \ expected: []interface{}{10, 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075094
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    result := make([]interface{}, 2)\n    result[0]\
    \ = 0\n    result[1] = 1\n    for _, number := range numbers {\n        result[0]\
    \ = result[0].(int) + number\n        result[1] = result[1].(int) * number\n \
    \   }\n    return result\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate\
    \ := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}), expected:\
    \ []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075093
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum int = 0\n    var product int = 1\n    for\
    \ _, i := range numbers {\n        sum += i\n        product *= i\n    }\n   \
    \ return []interface{}{sum, product}\n}\n\ntype testpair \nfunc TestSum_Product(t\
    \ *testing.T) {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1,\
    \ 1, 1}), expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100,\
    \ 0}), expected: []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5,\
    \ 7}), expected: []interface{}{15, 105} },\n     { actual: candidate([]int{10}),\
    \ expected: []interface{}{10, 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmf62wk02_test.go:24:15: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075093
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, v := range\
    \ numbers {\n        sum += v\n        product *= v\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return []interface{}{0,\
    \ 1}\n    }\n\n    sum := 0\n    product := 1\n    for _, num := range numbers\
    \ {\n        sum += num\n        product *= num\n    }\n\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075094
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    // your code goes here\n    return nil\n}\n\nfunc\
    \ TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{}), expected: []interface{}{0, 1} },\n     { actual:\
    \ candidate([]int{1, 1, 1}), expected: []interface{}{3, 1} },\n     { actual:\
    \ candidate([]int{100, 0}), expected: []interface{}{100, 0} },\n     { actual:\
    \ candidate([]int{3, 5, 7}), expected: []interface{}{15, 105} },\n     { actual:\
    \ candidate([]int{10}), expected: []interface{}{10, 10} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmpqek6v8s9_test.go:36: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestSum_Product/test_num__1 (0.00s)\n        tmpqek6v8s9_test.go:36:\
    \ expected '[%!s(int=3) %!s(int=1)]', got '[]'\n    --- FAIL: TestSum_Product/test_num__2\
    \ (0.00s)\n        tmpqek6v8s9_test.go:36: expected '[%!s(int=100) %!s(int=0)]',\
    \ got '[]'\n    --- FAIL: TestSum_Product/test_num__3 (0.00s)\n        tmpqek6v8s9_test.go:36:\
    \ expected '[%!s(int=15) %!s(int=105)]', got '[]'\n    --- FAIL: TestSum_Product/test_num__4\
    \ (0.00s)\n        tmpqek6v8s9_test.go:36: expected '[%!s(int=10) %!s(int=10)]',\
    \ got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075094
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return []interface{}{0,\
    \ 1}\n    }\n\n    sum := 0\n    product := 1\n    for _, number := range numbers\
    \ {\n        sum += number\n        product *= number\n    }\n\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075088
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, v := range\
    \ numbers {\n        sum += v\n        product *= v\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, v := range\
    \ numbers {\n        sum += v\n        product *= v\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum int\n    var product int = 1\n    for _,\
    \ n := range numbers {\n        sum += n\n        product *= n\n    }\n    return\
    \ []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate\
    \ := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}), expected:\
    \ []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    prod := 1\n    for _, val := range\
    \ numbers {\n        sum += val\n        prod *= val\n    }\n    return []interface{}{sum,\
    \ prod}\n}\n\ntype TestCase \nfunc TestSum_Product(t *testing.T) {\n  candidate\
    \ := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}), expected:\
    \ []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5plmoy16_test.go:24:15: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075093
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, n := range\
    \ numbers {\n        sum += n\n        product *= n\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, n := range\
    \ numbers {\n        sum += n\n        product *= n\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, value :=\
    \ range numbers {\n        sum += value\n        product *= value\n    }\n   \
    \ return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, number :=\
    \ range numbers {\n        sum += number\n        product *= number\n    }\n \
    \   return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, number :=\
    \ range numbers {\n        sum += number\n        product *= number\n    }\n \
    \   return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var result []interface{}\n    result = append(result,\
    \ 0)\n    result = append(result, 1)\n    for _, n := range numbers {\n      \
    \  result[0] = result[0].(int) + n\n        result[1] = result[1].(int) * n\n\
    \    }\n    return result\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate\
    \ := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}), expected:\
    \ []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075093
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var s, p int\n    var res []interface{}\n    for\
    \ _, n := range numbers {\n        s += n\n        p *= n\n    }\n    res = append(res,\
    \ s, p)\n    return res\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate\
    \ := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}), expected:\
    \ []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmpihhy7thp_test.go:42: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__1 (0.00s)\n\
    \        tmpihhy7thp_test.go:42: expected '[%!s(int=3) %!s(int=1)]', got '[%!s(int=3)\
    \ %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__3 (0.00s)\n        tmpihhy7thp_test.go:42:\
    \ expected '[%!s(int=15) %!s(int=105)]', got '[%!s(int=15) %!s(int=0)]'\n    ---\
    \ FAIL: TestSum_Product/test_num__4 (0.00s)\n        tmpihhy7thp_test.go:42: expected\
    \ '[%!s(int=10) %!s(int=10)]', got '[%!s(int=10) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075094
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, number :=\
    \ range numbers {\n        sum += number\n        product *= number\n    }\n \
    \   return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, value :=\
    \ range numbers {\n        sum += value\n        product *= value\n    }\n   \
    \ return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum = 0\n    var product = 1\n    for _, value\
    \ := range numbers {\n        sum += value\n        product *= value\n    }\n\
    \    return []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T)\
    \ {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}),\
    \ expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected:\
    \ []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5, 7}), expected:\
    \ []interface{}{15, 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10,\
    \ 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075090
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum int\n    var product int = 1\n    for _,\
    \ v := range numbers {\n        sum += v\n        product *= v\n    }\n    return\
    \ []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate\
    \ := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}), expected:\
    \ []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    res := make([]interface{}, 2)\n    sum := 0\n  \
    \  prod := 1\n    for _, num := range numbers {\n        sum += num\n        prod\
    \ *= num\n    }\n    res[0] = sum\n    res[1] = prod\n    return res\n}\n\nfunc\
    \ TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{}), expected: []interface{}{0, 1} },\n     { actual:\
    \ candidate([]int{1, 1, 1}), expected: []interface{}{3, 1} },\n     { actual:\
    \ candidate([]int{100, 0}), expected: []interface{}{100, 0} },\n     { actual:\
    \ candidate([]int{3, 5, 7}), expected: []interface{}{15, 105} },\n     { actual:\
    \ candidate([]int{10}), expected: []interface{}{10, 10} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075094
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, item := range\
    \ numbers {\n        sum += item\n        product *= item\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075094
- exit_code: 0
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    sum := 0\n    product := 1\n    for _, n := range\
    \ numbers {\n        sum += n\n        product *= n\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074981
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    if len(numbers) == 0 {\n        return []interface{}{0,\
    \ 1}\n    }\n    var sum int\n    var product int\n    for _, number := range\
    \ numbers {\n        sum += number\n        product *= number\n    }\n    return\
    \ []interface{}{sum, product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate\
    \ := sum_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []interface{}{0, 1} },\n     { actual: candidate([]int{1, 1, 1}), expected:\
    \ []interface{}{3, 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__1\
    \ (0.00s)\n        tmpv9ghm98b_test.go:44: expected '[%!s(int=3) %!s(int=1)]',\
    \ got '[%!s(int=3) %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__3 (0.00s)\n\
    \        tmpv9ghm98b_test.go:44: expected '[%!s(int=15) %!s(int=105)]', got '[%!s(int=15)\
    \ %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__4 (0.00s)\n        tmpv9ghm98b_test.go:44:\
    \ expected '[%!s(int=10) %!s(int=10)]', got '[%!s(int=10) %!s(int=0)]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075094
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    return []interface{}{1, 2}\n}\n\nfunc TestSum_Product(t\
    \ *testing.T) {\n  candidate := sum_product\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []interface{}{0, 1} },\n     { actual: candidate([]int{1,\
    \ 1, 1}), expected: []interface{}{3, 1} },\n     { actual: candidate([]int{100,\
    \ 0}), expected: []interface{}{100, 0} },\n     { actual: candidate([]int{3, 5,\
    \ 7}), expected: []interface{}{15, 105} },\n     { actual: candidate([]int{10}),\
    \ expected: []interface{}{10, 10} },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmp11yv5sv3_test.go:35: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[%!s(int=1) %!s(int=2)]'\n    --- FAIL: TestSum_Product/test_num__1 (0.00s)\n\
    \        tmp11yv5sv3_test.go:35: expected '[%!s(int=3) %!s(int=1)]', got '[%!s(int=1)\
    \ %!s(int=2)]'\n    --- FAIL: TestSum_Product/test_num__2 (0.00s)\n        tmp11yv5sv3_test.go:35:\
    \ expected '[%!s(int=100) %!s(int=0)]', got '[%!s(int=1) %!s(int=2)]'\n    ---\
    \ FAIL: TestSum_Product/test_num__3 (0.00s)\n        tmp11yv5sv3_test.go:35: expected\
    \ '[%!s(int=15) %!s(int=105)]', got '[%!s(int=1) %!s(int=2)]'\n    --- FAIL: TestSum_Product/test_num__4\
    \ (0.00s)\n        tmp11yv5sv3_test.go:35: expected '[%!s(int=10) %!s(int=10)]',\
    \ got '[%!s(int=1) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\n\
    FAIL\n"
  timestamp: 1660075094
- exit_code: 1
  program: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// For a given list of integers, return a list consisting of a sum and a product\
    \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty\
    \ product should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0,\
    \ 1}\n// >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
    \ []int) []interface{} {\n    var sum, product int\n    for _, n := range numbers\
    \ {\n        sum += n\n        product *= n\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\nfunc TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []interface{}{0,\
    \ 1} },\n     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3,\
    \ 1} },\n     { actual: candidate([]int{100, 0}), expected: []interface{}{100,\
    \ 0} },\n     { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15,\
    \ 105} },\n     { actual: candidate([]int{10}), expected: []interface{}{10, 10}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSum_Product (0.00s)\n    --- FAIL: TestSum_Product/test_num__0\
    \ (0.00s)\n        tmp1am5sq3p_test.go:40: expected '[%!s(int=0) %!s(int=1)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__1 (0.00s)\n\
    \        tmp1am5sq3p_test.go:40: expected '[%!s(int=3) %!s(int=1)]', got '[%!s(int=3)\
    \ %!s(int=0)]'\n    --- FAIL: TestSum_Product/test_num__3 (0.00s)\n        tmp1am5sq3p_test.go:40:\
    \ expected '[%!s(int=15) %!s(int=105)]', got '[%!s(int=15) %!s(int=0)]'\n    ---\
    \ FAIL: TestSum_Product/test_num__4 (0.00s)\n        tmp1am5sq3p_test.go:40: expected\
    \ '[%!s(int=10) %!s(int=10)]', got '[%!s(int=10) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074981
