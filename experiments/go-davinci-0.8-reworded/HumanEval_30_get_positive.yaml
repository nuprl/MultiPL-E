name: HumanEval_30_get_positive
language: go_test.go
prompt: "package get_positive_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
  // Return only positive numbers in the list.\n// >>> get_positive([]int{-1, 2, -4,\
  \ 5, 6})\n// []int{2, 5, 6}\n// >>> get_positive([]int{5, 3, -5, 2, -3, 3, 9, 0,\
  \ 123, 1, -10})\n// []int{5, 3, 2, 3, 9, 123, 1}\nfunc get_positive(l []int) []int\
  \ {\n"
tests: "func TestGet_Positive(t *testing.T) {\n  candidate := get_positive\n\ttype\
  \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
  \ := []test{\n     { actual: candidate([]int{-1, -2, 4, 5, 6}), expected: []int{4,\
  \ 5, 6} },\n     { actual: candidate([]int{5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10}),\
  \ expected: []int{5, 3, 2, 3, 3, 9, 123, 1} },\n     { actual: candidate([]int{-1,\
  \ -2}), expected: []int{} },\n     { actual: candidate([]int{}), expected: []int{}\
  \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
  , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
  %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
  \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    var r []int\n    for _, v := range l {\n        if v > 0 {\n  \
    \          r = append(r, v)\n        }\n    }\n    return r\n}\n", "    // Implement\
    \ me!\n    return []int{}\n}\n", "    res := make([]int, 0)\n    for _, e := range\
    \ l {\n        if e > 0 {\n            res = append(res, e)\n        }\n    }\n\
    \    return res\n}\n", "    var res []int\n    for _, n := range l {\n       \
    \ if n > 0 {\n            res = append(res, n)\n        }\n    }\n    return res\n\
    }\n", "    res := make([]int, 0)\n    for _, v := range l {\n        if v > 0\
    \ {\n            res = append(res, v)\n        }\n    }\n    return res\n}\n",
  "    var r []int\n    for _, v := range l {\n        if v > 0 {\n            r =\
    \ append(r, v)\n        }\n    }\n    return r\n}\n", "    result := []int{}\n\
    \    for _, v := range l {\n        if v > 0 {\n            result = append(result,\
    \ v)\n        }\n    }\n    return result\n}\n", "    var result []int\n    for\
    \ _, number := range l {\n        if number > 0 {\n            result = append(result,\
    \ number)\n        }\n    }\n    return result\n}\n", "    var positive []int\n\
    \    for _, v := range l {\n        if v > 0 {\n            positive = append(positive,\
    \ v)\n        }\n    }\n    return positive\n}\n", "    var result []int\n   \
    \ for _, n := range l {\n        if n > 0 {\n            result = append(result,\
    \ n)\n        }\n    }\n    return result\n}\n", "    positives := []int{}\n \
    \   for _, n := range l {\n        if n > 0 {\n            positives = append(positives,\
    \ n)\n        }\n    }\n    return positives\n}\n", "    return l\n}\n", "   \
    \ r := []int{}\n    for _, n := range l {\n        if n > 0 {\n            r =\
    \ append(r, n)\n        }\n    }\n    return r\n}\n", "    r := []int{}\n    for\
    \ _, i := range l {\n        if i > 0 {\n            r = append(r, i)\n      \
    \  }\n    }\n    return r\n}\n", "    // Implementation here.\n    return nil\n\
    }\n", "    // First, find the number of positive numbers.\n    // This way, we\
    \ will know the size of the list for the result.\n    n := 0\n    for _, v :=\
    \ range l {\n        if v > 0 {\n            n += 1\n        }\n    }\n\n    res\
    \ := make([]int, n)\n    n = 0\n    for _, v := range l {\n        if v > 0 {\n\
    \            res[n] = v\n            n += 1\n        }\n    }\n\n    return res\n\
    }\n", "    var res []int\n    for _, x := range l {\n        if x > 0 {\n    \
    \        res = append(res, x)\n        }\n    }\n    return res\n}\n", "    var\
    \ res []int\n    for _, i := range l {\n        if i > 0 {\n            res =\
    \ append(res, i)\n        }\n    }\n    return res\n}\n", "    var ret []int\n\
    \    for _, v := range l {\n        if v > 0 {\n            ret = append(ret,\
    \ v)\n        }\n    }\n    return ret\n}\n", "    return l\n}\n", "    ret :=\
    \ []int{}\n    for _, v := range l {\n        if v > 0 {\n            ret = append(ret,\
    \ v)\n        }\n    }\n    return ret\n}\n", "    return l\n}\n", "    var result\
    \ []int\n    for _, e := range l {\n        if e > 0 {\n            result = append(result,\
    \ e)\n        }\n    }\n    return result\n}\n", "    var positive_list []int\n\
    \    for _, v := range l {\n        if v > 0 {\n            positive_list = append(positive_list,\
    \ v)\n        }\n    }\n    return positive_list\n}\n", "    var r []int\n   \
    \ for _, i := range l {\n        if i > 0 {\n            r = append(r, i)\n  \
    \      }\n    }\n    return r\n}\n", "    var res []int\n    for _, v := range\
    \ l {\n        if v > 0 {\n            res = append(res, v)\n        }\n    }\n\
    \    return res\n}\n", "    var res []int\n    for _, el := range l {\n      \
    \  if el > 0 {\n            res = append(res, el)\n        }\n    }\n    return\
    \ res\n}\n", "    l = l[0:0]\n    for _, item := range l {\n        if item >\
    \ 0 {\n            l = append(l, item)\n        }\n    }\n    return l\n}\n",
  "    var res []int\n    for _, v := range l {\n        if v > 0 {\n            res\
    \ = append(res, v)\n        }\n    }\n    return res\n}\n", "    var r []int\n\
    \    for _, v := range l {\n        if v > 0 {\n            r = append(r, v)\n\
    \        }\n    }\n    return r\n}\n", "    var ret []int\n    for _, i := range\
    \ l {\n        if i > 0 {\n            ret = append(ret, i)\n        }\n    }\n\
    \    return ret\n}\n", "    res := make([]int, 0)\n    for _, val := range l {\n\
    \        if val > 0 {\n            res = append(res, val)\n        }\n    }\n\
    \    return res\n}\n", "    var result []int\n    for _, n := range l {\n    \
    \    if n > 0 {\n            result = append(result, n)\n        }\n    }\n  \
    \  return result\n}\n", "    for i, n := range l {\n        if n <= 0 {\n    \
    \        l = append(l[:i], l[i+1:]...)\n        }\n    }\n    return l\n}\n",
  "    ret := []int{}\n    for _, i := range l {\n        if i > 0 {\n           \
    \ ret = append(ret, i)\n        }\n    }\n    return ret\n}\n", "    var out []int\n\
    \    for _, i := range l {\n        if i > 0 {\n            out = append(out,\
    \ i)\n        }\n    }\n    return out\n}\n", "    var r []int\n    for _, v :=\
    \ range l {\n        if v > 0 {\n            r = append(r, v)\n        }\n   \
    \ }\n    return r\n}\n", "    var positives []int\n    for _, n := range l {\n\
    \        if n > 0 {\n            positives = append(positives, n)\n        }\n\
    \    }\n    return positives\n}\n", "    var res []int\n\n    for _, v := range\
    \ l {\n        if v > 0 {\n            res = append(res, v)\n        }\n    }\n\
    \n    return res\n}\n", "    return l\n}\n", "    var positives []int\n    for\
    \ _, i := range l {\n        if i > 0 {\n            positives = append(positives,\
    \ i)\n        }\n    }\n    return positives\n}\n", "    res := make([]int, 0)\n\
    \    for _, v := range l {\n        if v > 0 {\n            res = append(res,\
    \ v)\n        }\n    }\n    return res\n}\n", "    // fmt.Println(l)\n    var\
    \ pos []int\n    for _, v := range l {\n        if v > 0 {\n            pos =\
    \ append(pos, v)\n        }\n    }\n    return pos\n}\n", "    res := make([]int,\
    \ 0)\n    for _, i := range l {\n        if i > 0 {\n            res = append(res,\
    \ i)\n        }\n    }\n    return res\n}\n", "    res := make([]int, 0)\n   \
    \ for _, e := range l {\n        if e > 0 {\n            res = append(res, e)\n\
    \        }\n    }\n    return res\n}\n", "    var result []int\n    for _, i :=\
    \ range l {\n        if i > 0 {\n            result = append(result, i)\n    \
    \    }\n    }\n    return result\n}\n", "    var res []int\n    for _, v := range\
    \ l {\n        if v > 0 {\n            res = append(res, v)\n        }\n    }\n\
    \    return res\n}\n", "    var ret []int\n    for _, v := range l {\n       \
    \ if v > 0 {\n            ret = append(ret, v)\n        }\n    }\n    return ret\n\
    }\n", "    var pos []int\n    for _, v := range l {\n        if v > 0 {\n    \
    \        pos = append(pos, v)\n        }\n    }\n    return pos\n}\n", "    var\
    \ pos_l []int\n    for _, num := range l {\n        if num > 0 {\n           \
    \ pos_l = append(pos_l, num)\n        }\n    }\n    return pos_l\n}\n", "    var\
    \ res []int\n    for _, v := range l {\n        if v > 0 {\n            res =\
    \ append(res, v)\n        }\n    }\n    return res\n}\n", "    var result []int\n\
    \    for _, v := range l {\n        if v > 0 {\n            result = append(result,\
    \ v)\n        }\n    }\n    return result\n}\n", "    ret := []int{}\n    for\
    \ _, v := range l {\n        if v > 0 {\n            ret = append(ret, v)\n  \
    \      }\n    }\n    return ret\n}\n", "    var res []int\n    for _, i := range\
    \ l {\n        if i > 0 {\n            res = append(res, i)\n        }\n    }\n\
    \    return res\n}\n", "    result := []int{}\n    for _, v := range l {\n   \
    \     if v > 0 {\n            result = append(result, v)\n        }\n    }\n \
    \   return result\n}\n", "    ans := []int{}\n    for _, v := range l {\n    \
    \    if v > 0 {\n            ans = append(ans, v)\n        }\n    }\n    return\
    \ ans\n}\n", "    var sl []int\n    for _, i := range l {\n        if i > 0 {\n\
    \            sl = append(sl, i)\n        }\n    }\n    return sl\n}\n", "    var\
    \ r []int\n    for _, v := range l {\n        if v > 0 {\n            r = append(r,\
    \ v)\n        }\n    }\n    return r\n}\n", "    res := []int{}\n    for _, x\
    \ := range l {\n        if x > 0 {\n            res = append(res, x)\n       \
    \ }\n    }\n    return res\n}\n", "    res := []int{}\n    for _, v := range l\
    \ {\n        if v > 0 {\n            res = append(res, v)\n        }\n    }\n\
    \    return res\n}\n", "    var positive_l []int\n    for _, i := range l {\n\
    \        if i > 0 {\n            positive_l = append(positive_l, i)\n        }\n\
    \    }\n    return positive_l\n}\n", "    r := []int{}\n    for _, v := range\
    \ l {\n        if v > 0 {\n            r = append(r, v)\n        }\n    }\n  \
    \  return r\n}\n", "    var ll []int\n    for _, v := range l {\n        if v\
    \ > 0 {\n            ll = append(ll, v)\n        }\n    }\n    return ll\n}\n",
  "    var res []int\n    for _, v := range l {\n        if v > 0 {\n            res\
    \ = append(res, v)\n        }\n    }\n    return res\n}\n", "    new_l := []int{}\n\
    \    for _, item := range l {\n        if item > 0 {\n            new_l = append(new_l,\
    \ item)\n        }\n    }\n    return new_l\n}\n", "    // TODO\n\n    return\
    \ []int{}\n}\n", "    res := make([]int, 0)\n    for _, elem := range l {\n  \
    \      if elem > 0 {\n            res = append(res, elem)\n        }\n    }\n\
    \    return res\n}\n", "    pos := make([]int, 0)\n    for _, i := range l {\n\
    \        if i > 0 {\n            pos = append(pos, i)\n        }\n    }\n    return\
    \ pos\n}\n", "    res := make([]int, 0)\n    for _, n := range l {\n        if\
    \ n > 0 {\n            res = append(res, n)\n        }\n    }\n    return res\n\
    }\n", "    var res []int\n    for _, x := range l {\n        if x > 0 {\n    \
    \        res = append(res, x)\n        }\n    }\n    return res\n}\n", "    var\
    \ l2 []int\n    for _, value := range l {\n        if value > 0 {\n          \
    \  l2 = append(l2, value)\n        }\n    }\n    return l2\n}\n", "    res :=\
    \ make([]int, 0)\n    for _,v := range l {\n        if v > 0 {\n            res\
    \ = append(res, v)\n        }\n    }\n    return res\n}\n", "    var result []int\n\
    \    for _, el := range l {\n        if el > 0 {\n            result = append(result,\
    \ el)\n        }\n    }\n    return result\n}\n", "    var r []int\n    for _,\
    \ v := range l {\n        if v > 0 {\n            r = append(r, v)\n        }\n\
    \    }\n    return r\n}\n", "    var result []int\n    for _, item := range l\
    \ {\n        if item > 0 {\n            result = append(result, item)\n      \
    \  }\n    }\n    return result\n}\n", "    var positive []int\n    for _, i :=\
    \ range l {\n        if i > 0 {\n            positive = append(positive, i)\n\
    \        }\n    }\n    return positive\n}\n", "    var r []int\n    for _, i :=\
    \ range l {\n        if i > 0 {\n            r = append(r, i)\n        }\n   \
    \ }\n    return r\n}\n", "    return nil\n}\n", "    var pos_l []int\n    for\
    \ _, val := range l {\n        if val > 0 {\n            pos_l = append(pos_l,\
    \ val)\n        }\n    }\n    return pos_l\n}\n", "    return l\n}\n", "    var\
    \ ret []int\n    for _, v := range l {\n        if v > 0 {\n            ret =\
    \ append(ret, v)\n        }\n    }\n    return ret\n}\n", "    result := []int{}\n\
    \    for _, item := range l {\n        if item > 0 {\n            result = append(result,\
    \ item)\n        }\n    }\n    return result\n}\n", "    res := []int{}\n    for\
    \ _, v := range l {\n        if v > 0 {\n            res = append(res, v)\n  \
    \      }\n    }\n    return res\n}\n", "    var positives []int\n    for _, val\
    \ := range l {\n        if val > 0 {\n            positives = append(positives,\
    \ val)\n        }\n    }\n    return positives\n}\n", "    var r []int\n    for\
    \ _, e := range l {\n        if e > 0 {\n            r = append(r, e)\n      \
    \  }\n    }\n    return r\n}\n", "    var positive_list []int\n    for _, value\
    \ := range l {\n        if value > 0 {\n            positive_list = append(positive_list,\
    \ value)\n        }\n    }\n    return positive_list\n}\n", "    p := []int{}\n\
    \    for _, v := range l {\n        if v > 0 {\n            p = append(p, v)\n\
    \        }\n    }\n    return p\n}\n", "    ret := []int{}\n    for _, e := range\
    \ l {\n        if e > 0 {\n            ret = append(ret, e)\n        }\n    }\n\
    \    return ret\n}\n", "    if len(l) <= 0 {\n        return []int{}\n    }\n\n\
    \    res := []int{}\n    for _, elem := range l {\n        if elem > 0 {\n   \
    \         res = append(res, elem)\n        }\n    }\n\n    return res\n}\n", " \
    \   // Write your code here!\n    var r []int\n    for _, n := range l {\n   \
    \     if n > 0 {\n            r = append(r, n)\n        }\n    }\n    return r\n\
    }\n", "    var out []int\n    for _, val := range l {\n        if val > 0 {\n\
    \            out = append(out, val)\n        }\n    }\n    return out\n}\n", " \
    \   var result []int\n    for _, item := range l {\n        if item > 0 {\n  \
    \          result = append(result, item)\n        }\n    }\n    return result\n\
    }\n", "    return []int{}\n}\n", "    var result []int\n    for _, i := range\
    \ l {\n        if i > 0 {\n            result = append(result, i)\n        }\n\
    \    }\n    return result\n}\n", "    res := []int{}\n    for _, v := range l\
    \ {\n        if v > 0 {\n            res = append(res, v)\n        }\n    }\n\
    \    return res\n}\n", "    return_list := []int{}\n    for _, i := range l {\n\
    \        if i > 0 {\n            return_list = append(return_list, i)\n      \
    \  }\n    }\n    return return_list\n}\n", "    var result []int\n    for _, value\
    \ := range l {\n        if value > 0 {\n            result = append(result, value)\n\
    \        }\n    }\n    return result\n}\n", "    // Init a slice\n    positiveSlice\
    \ := make([]int, 0)\n    for _, num := range l {\n        if num > 0 {\n     \
    \       positiveSlice = append(positiveSlice, num)\n        }\n    }\n    return\
    \ positiveSlice\n}\n", "    var res []int\n    for _, v := range l {\n       \
    \ if v > 0 {\n            res = append(res, v)\n        }\n    }\n    return res\n\
    }\n", "    var result []int\n    for _, x := range l {\n        if x > 0 {\n \
    \           result = append(result, x)\n        }\n    }\n    return result\n\
    }\n", "    var res []int\n    for _, v := range l {\n        if v > 0 {\n    \
    \        res = append(res, v)\n        }\n    }\n    return res\n}\n", "    list\
    \ := []int{}\n    for _, num := range l {\n        if num > 0 {\n            list\
    \ = append(list, num)\n        }\n    }\n    return list\n}\n", "    var ret []int\n\
    \    for _, v := range l {\n        if v > 0 {\n            ret = append(ret,\
    \ v)\n        }\n    }\n    return ret\n}\n", "    p := []int{}\n    for _, n\
    \ := range l {\n        if n > 0 {\n            p = append(p, n)\n        }\n\
    \    }\n    return p\n}\n", "    r := []int{}\n    for _, v := range l {\n   \
    \     if v > 0 {\n            r = append(r, v)\n        }\n    }\n    return r\n\
    }\n", "    var res []int\n\n    for _, e := range l {\n        if e > 0 {\n  \
    \          res = append(res, e)\n        }\n    }\n\n    return res\n}\n", " \
    \   res := make([]int, 0)\n    for _, n := range l {\n        if n > 0 {\n   \
    \         res = append(res, n)\n        }\n    }\n    return res\n}\n", "    res\
    \ := make([]int, 0)\n    for _, v := range l {\n        if v > 0 {\n         \
    \   res = append(res, v)\n        }\n    }\n    return res\n}\n", "    return\
    \ []int{}\n}\n", "    res := make([]int, 0)\n    for _, value := range l {\n \
    \       if value > 0 {\n            res = append(res, value)\n        }\n    }\n\
    \    return res\n}\n", "    res := make([]int, 0)\n    for _, e := range l {\n\
    \        if e > 0 {\n            res = append(res, e)\n        }\n    }\n    return\
    \ res\n}\n", "    var new_list []int\n    for _, e := range l {\n        if e\
    \ > 0 {\n            new_list = append(new_list, e)\n        }\n    }\n    return\
    \ new_list\n}\n", "    var res []int\n    for _, v := range l {\n        if v\
    \ > 0 {\n            res = append(res, v)\n        }\n    }\n    return res\n\
    }\n", "    return l\n}\n", "    var positives []int\n    for _,v := range l {\n\
    \        if v > 0 {\n            positives = append(positives, v)\n        }\n\
    \    }\n    return positives\n}\n", "    var result []int\n    for _, v := range\
    \ l {\n        if v > 0 {\n            result = append(result, v)\n        }\n\
    \    }\n    return result\n}\n", "    // panic(\"Not implemented\") // TODO: Implement\n\
    \    positive := []int{}\n    for _, v := range l {\n        if v > 0 {\n    \
    \        positive = append(positive, v)\n        }\n    }\n    return positive\n\
    }\n", "    return l\n}\n", "    var result []int\n    for _, el := range l {\n\
    \        if el > 0 {\n            result = append(result, el)\n        }\n   \
    \ }\n    return result\n}\n", "    var result []int\n    for _, v := range l {\n\
    \        if v > 0 {\n            result = append(result, v)\n        }\n    }\n\
    \    return result\n}\n", "    r := []int{}\n    for _, el := range l {\n    \
    \    if el > 0 {\n            r = append(r, el)\n        }\n    }\n    return\
    \ r\n}\n", "    r := []int{}\n    for _, v := range l {\n        if v > 0 {\n\
    \            r = append(r, v)\n        }\n    }\n    return r\n}\n", "    var\
    \ new_l []int\n    for _, number := range l {\n        if number > 0 {\n     \
    \       new_l = append(new_l, number)\n        }\n    }\n    return new_l\n}\n",
  "    if len(l) == 0 {\n        return l\n    }\n    result := make([]int, 0)\n \
    \   for _, v := range l {\n        if v > 0 {\n            result = append(result,\
    \ v)\n        }\n    }\n    return result\n}\n", "    return l\n}\n", "    var\
    \ pos_l []int\n    for _, num := range l {\n        if num > 0 {\n           \
    \ pos_l = append(pos_l, num)\n        }\n    }\n    return pos_l\n}\n", "    var\
    \ res []int\n    for _, v := range l {\n        if v > 0 {\n            res =\
    \ append(res, v)\n        }\n    }\n    return res\n}\n", "    var positives []int\n\
    \    for _, v := range l {\n        if v > 0 {\n            positives = append(positives,\
    \ v)\n        }\n    }\n    return positives\n}\n", "    var res []int\n    for\
    \ _, i := range l {\n        if i > 0 {\n            res = append(res, i)\n  \
    \      }\n    }\n    return res\n}\n", "    r := []int{}\n    for _, v := range\
    \ l {\n        if v > 0 {\n            r = append(r, v)\n        }\n    }\n  \
    \  return r\n}\n", "    var r []int\n    for _, n := range l {\n        if n >\
    \ 0 {\n            r = append(r, n)\n        }\n    }\n    return r\n}\n", " \
    \   var pos []int\n    for _, v := range l {\n        if v > 0 {\n           \
    \ pos = append(pos, v)\n        }\n    }\n    return pos\n}\n", "    return_list\
    \ := []int{}\n    for _, elem := range l {\n        if elem > 0 {\n          \
    \  return_list = append(return_list, elem)\n        }\n    }\n    return return_list\n\
    }\n", "    var res []int\n    for _, i := range l {\n        if i > 0 {\n    \
    \        res = append(res, i)\n        }\n    }\n    return res\n}\n", "    var\
    \ result []int\n    for _, v := range l {\n        if v > 0 {\n            result\
    \ = append(result, v)\n        }\n    }\n    return result\n}\n", "    // Create\
    \ a slice of int with the same size as the input parameter\n    r := make([]int,\
    \ len(l))\n    // Filter a list of positive numbers\n    for _, v := range l {\n\
    \        if v > 0 {\n            r = append(r, v)\n        }\n    }\n    return\
    \ r\n}\n", "    var res []int\n    for _, v := range l {\n        if v > 0 {\n\
    \            res = append(res, v)\n        }\n    }\n    return res\n}\n", " \
    \   var result []int\n\n    for _, item := range l {\n        if item > 0 {\n\
    \            result = append(result, item)\n        }\n    }\n\n    return result\n\
    }\n", "    var r []int\n    for _, i := range l {\n        if i > 0 {\n      \
    \      r = append(r, i)\n        }\n    }\n    return r\n}\n", "    var result\
    \ []int\n    for _, x := range l {\n        if x > 0 {\n            result = append(result,\
    \ x)\n        }\n    }\n    return result\n}\n", "    return nil\n}\n", "    //\
    \ write your solution here\n    res := make([]int, 0)\n    for _, v := range l\
    \ {\n        if v > 0 {\n            res = append(res, v)\n        }\n    }\n\
    \    return res\n}\n", "    var result []int\n    for _, i := range l {\n    \
    \    if i > 0 {\n            result = append(result, i)\n        }\n    }\n  \
    \  return result\n}\n", "    var pos_l []int\n    for _, n := range l {\n    \
    \    if n > 0 {\n            pos_l = append(pos_l, n)\n        }\n    }\n    return\
    \ pos_l\n}\n", "    var ret []int\n    for _, v := range l {\n        if v > 0\
    \ {\n            ret = append(ret, v)\n        }\n    }\n    return ret\n}\n",
  "    var pl []int\n    for _, n := range l {\n        if n > 0 {\n            pl\
    \ = append(pl, n)\n        }\n    }\n    return pl\n}\n", "    var new_list []int\n\
    \    for _, v := range l {\n        if v > 0 {\n            new_list = append(new_list,\
    \ v)\n        }\n    }\n    return new_list\n}\n", "    var r []int\n    for _,\
    \ v := range l {\n        if v > 0 {\n            r = append(r, v)\n        }\n\
    \    }\n    return r\n}\n", "    answer := []int{}\n    for _, elem := range l\
    \ {\n        if elem > 0 {\n            answer = append(answer, elem)\n      \
    \  }\n    }\n    return answer\n}\n", "    var res []int\n    for _, v := range\
    \ l {\n        if v > 0 {\n            res = append(res, v)\n        }\n    }\n\
    \    return res\n}\n", "    var res []int\n    for _, n := range l {\n       \
    \ if n > 0 {\n            res = append(res, n)\n        }\n    }\n    return res\n\
    }\n", "    var res []int\n    for _, v := range l {\n        if v > 0 {\n    \
    \        res = append(res, v)\n        }\n    }\n    return res\n}\n", "    var\
    \ res []int\n    for _, v := range l {\n        if v > 0 {\n            res =\
    \ append(res, v)\n        }\n    }\n    return res\n}\n", "    var (\n       \
    \ i int\n        res []int\n    )\n    for i = 0; i < len(l); i++ {\n        if\
    \ l[i] > 0 {\n            res = append(res, l[i])\n        }\n    }\n    return\
    \ res\n}\n", "    var res []int\n\n    for _, i := range l {\n        if i > 0\
    \ {\n            res = append(res, i)\n        }\n    }\n\n    return res\n}\n",
  "    var positive_list []int\n    for _, i := range l {\n        if i > 0 {\n  \
    \          positive_list = append(positive_list, i)\n        }\n    }\n    return\
    \ positive_list\n}\n", "    var result []int\n    for _, x := range l {\n    \
    \    if x > 0 {\n            result = append(result, x)\n        }\n    }\n  \
    \  return result\n}\n", "    result := []int{}\n    for _, val := range l {\n\
    \        if val > 0 {\n            result = append(result, val)\n        }\n \
    \   }\n    return result\n}\n", "    var res []int\n    for _, n := range l {\n\
    \        if n > 0 {\n            res = append(res, n)\n        }\n    }\n    return\
    \ res\n}\n", "    return []int{}\n}\n", "    newList := []int{}\n    for _, value\
    \ := range l {\n        if value > 0 {\n            newList = append(newList,\
    \ value)\n        }\n    }\n    return newList\n}\n", "    if len(l) == 0 {\n\
    \        return l\n    }\n    var result []int\n    for _, v := range l {\n  \
    \      if v > 0 {\n            result = append(result, v)\n        }\n    }\n\
    \    return result\n}\n", "    positive := []int{}\n    for _, i := range l {\n\
    \        if i > 0 {\n            positive = append(positive, i)\n        }\n \
    \   }\n    return positive\n}\n", "    var positive []int\n    for _, i := range\
    \ l {\n        if i > 0 {\n            positive = append(positive, i)\n      \
    \  }\n    }\n    return positive\n}\n", "    var positives []int\n    for _, v\
    \ := range l {\n        if v > 0 {\n            positives = append(positives,\
    \ v)\n        }\n    }\n    return positives\n}\n", "    var res []int\n    for\
    \ _, v := range l {\n        if v > 0 {\n            res = append(res, v)\n  \
    \      }\n    }\n    return res\n}\n", "    ret := []int{}\n    for _, x := range\
    \ l {\n        if x > 0 {\n            ret = append(ret, x)\n        }\n    }\n\
    \    return ret\n}\n", "    // Get only positive numbers from list l.\n    if\
    \ l == nil {\n        return nil\n    }\n    res := make([]int, 0)\n    for _,\
    \ v := range l {\n        if v > 0 {\n            res = append(res, v)\n     \
    \   }\n    }\n    return res\n}\n", "    var slice []int\n    for _, value :=\
    \ range l {\n        if value > 0 {\n            slice = append(slice, value)\n\
    \        }\n    }\n    return slice\n}\n", "    if len(l) == 0 {\n        return\
    \ l\n    }\n    s := make([]int, 0)\n    for _, v := range l {\n        if v >\
    \ 0 {\n            s = append(s, v)\n        }\n    }\n    return s\n}\n", " \
    \   var t []int\n    for _, v := range l {\n        if v > 0 {\n            t\
    \ = append(t, v)\n        }\n    }\n    return t\n}\n", "    var res []int\n \
    \   for _, i := range l {\n        if i > 0 {\n            res = append(res, i)\n\
    \        }\n    }\n    return res\n}\n", "    return []int{}\n}\n", "    return\
    \ l\n}\n", "    var ans []int\n    for _, item := range l {\n        if item >\
    \ 0 {\n            ans = append(ans, item)\n        }\n    }\n    return ans\n\
    }\n", "    var ret []int\n    for _,v := range l {\n        if v > 0 {\n     \
    \       ret = append(ret, v)\n        }\n    }\n    return ret\n}\n", "    out\
    \ := []int{}\n    for _, el := range l {\n        if el > 0 {\n            out\
    \ = append(out, el)\n        }\n    }\n    return out\n}\n", "    var newSlice\
    \ []int\n    for _, i := range l {\n        if i > 0 {\n            newSlice =\
    \ append(newSlice, i)\n        }\n    }\n    return newSlice\n}\n", "    var out\
    \ []int\n    for _, i := range l {\n        if i > 0 {\n            out = append(out,\
    \ i)\n        }\n    }\n    return out\n}\n", "    res := []int{}\n    for _,\
    \ x := range l {\n        if x > 0 {\n            res = append(res, x)\n     \
    \   }\n    }\n    return res\n}\n", "    var positives []int\n    for _, v :=\
    \ range l {\n        if v > 0 {\n            positives = append(positives, v)\n\
    \        }\n    }\n    return positives\n}\n", "    var r []int\n    for _, i\
    \ := range l {\n        if i > 0 {\n            r = append(r, i)\n        }\n\
    \    }\n    return r\n}\n", "    var p []int\n    for _, x := range l {\n    \
    \    if x > 0 {\n            p = append(p, x)\n        }\n    }\n    return p\n\
    }\n", "    l2 := []int{}\n    for _, val := range l {\n        if val > 0 {\n\
    \            l2 = append(l2, val)\n        }\n    }\n    return l2\n}\n", "  \
    \  // TODO: implement\n    return nil\n}\n", "    // Write your code here...\n\
    \    return nil\n}\n", "    if len(l) == 0 {\n        return l\n    }\n\n    //\
    \ Filter the list and return only positive numbers.\n    var ret []int\n    for\
    \ _, v := range l {\n        if v > 0 {\n            ret = append(ret, v)\n  \
    \      }\n    }\n\n    return ret\n}\n", "    p := []int{}\n    for _, v := range\
    \ l {\n        if v > 0 {\n            p = append(p, v)\n        }\n    }\n  \
    \  return p\n}\n", "    var ret []int\n\n    for _, v := range l {\n        if\
    \ v > 0 {\n            ret = append(ret, v)\n        }\n    }\n\n    return ret\n\
    }\n", "    var ret []int\n    for _, v := range l {\n        if v > 0 {\n    \
    \        ret = append(ret, v)\n        }\n    }\n    return ret\n}\n", "    var\
    \ result []int\n    for _, n := range l {\n        if n > 0 {\n            result\
    \ = append(result, n)\n        }\n    }\n    return result\n}\n", "    r := []int{}\n\
    \    for _, v := range l {\n        if v > 0 {\n            r = append(r, v)\n\
    \        }\n    }\n    return r\n}\n", "    for idx, item := range l {\n     \
    \   if item < 0 {\n            l = append(l[:idx], l[idx+1:]...)\n        }\n\
    \    }\n    return l\n}\n", "    out := []int{}\n    for _, x := range l {\n \
    \       if x > 0 {\n            out = append(out, x)\n        }\n    }\n    return\
    \ out\n}\n", "    var result []int\n    for _, x := range l {\n        if x >\
    \ 0 {\n            result = append(result, x)\n        }\n    }\n    return result\n\
    }\n", "    r := []int{}\n    for _, v := range l {\n        if v > 0 {\n     \
    \       r = append(r, v)\n        }\n    }\n    return r\n}\n", "    r := []int{}\n\
    \    for _, v := range l {\n        if v > 0 {\n            r = append(r, v)\n\
    \        }\n    }\n    return r\n}\n", "    // fill it in\n    return []int{}\n\
    }\n", "    return []int{}\n}\n", "    var result []int\n    for _, v := range\
    \ l {\n        if v > 0 {\n            result = append(result, v)\n        }\n\
    \    }\n    return result\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
