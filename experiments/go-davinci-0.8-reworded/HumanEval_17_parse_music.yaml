name: HumanEval_17_parse_music
language: go_test.go
prompt: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
  // Input to this function is a string representing musical notes in a special ASCII\
  \ format.\n// Your task is to parse this string and return list of integers corresponding\
  \ to how many beats does each\n// not last.\n// Here is a legend:\n// 'o' - whole\
  \ note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater\
  \ note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n\
  // []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string string)\
  \ []int {\n"
tests: "func TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test\
  \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests :=\
  \ []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual:\
  \ candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\"\
  .| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o|\
  \ .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"\
  o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\t\
  for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
  \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
  \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\
  \t}\n\t\t})\n\t}\n}\n"
completions: ["    var duration []int\n    if len(music_string) == 0 {\n        return\
    \ duration\n    }\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i]\
    \ == 'o' {\n            duration = append(duration, 4)\n        } else if music_string[i]\
    \ == '.' {\n            duration = append(duration, 1)\n        }\n        if\
    \ i + 1 < len(music_string) && music_string[i+1] == '|' {\n            duration[len(duration)-1]\
    \ /= 2\n            i++\n        }\n    }\n    return duration\n}\n", "    beats\
    \ := make([]int, 0)\n    state := 0\n    current_beat := 1\n    for _, char :=\
    \ range music_string {\n        if char == 'o' {\n            if state == 0 {\n\
    \                current_beat = 4\n            } else {\n                beats\
    \ = append(beats, current_beat)\n                current_beat = 4\n          \
    \  }\n            state = 0\n        } else if char == '.' {\n            if state\
    \ == 0 {\n                current_beat = 1\n            } else {\n           \
    \     beats = append(beats, current_beat)\n                current_beat = 1\n\
    \            }\n            state = 0\n        } else if char == '|' {\n     \
    \       state = 1\n        }\n    }\n    if current_beat != 0 {\n        beats\
    \ = append(beats, current_beat)\n    }\n    return beats\n}\n", "    return []int{}\n\
    }\n", "    var parsed_music []int\n    var music_chars []rune\n    var beats int\n\
    \    var next_rune_is_beat bool\n    var last_rune rune\n\n    music_chars = []rune(music_string)\n\
    \    beats = 0\n    next_rune_is_beat = false\n    last_rune = ' '\n\n    for\
    \ _, char := range music_chars {\n        if char == 'o' {\n            if last_rune\
    \ == ' ' {\n                beats = 4\n            } else {\n                beats\
    \ += 4\n            }\n            next_rune_is_beat = true\n        } else if\
    \ char == '|' {\n            if last_rune == 'o' {\n                beats = 2\n\
    \            } else {\n                beats += 2\n            }\n           \
    \ next_rune_is_beat = true\n        } else if char == '.' {\n            beats\
    \ += 1\n            next_rune_is_beat = true\n        } else if char == ' ' {\n\
    \            if next_rune_is_beat {\n                parsed_music = append(parsed_music,\
    \ beats)\n                beats = 0\n                next_rune_is_beat = false\n\
    \            }\n        }\n        last_rune = char\n    }\n\n    return parsed_music\n\
    }\n", "    return nil\n}\n", "    return nil\n}\n", "    var result []int\n  \
    \  for _, ch := range music_string {\n        switch ch {\n        case 'o':\n\
    \            result = append(result, 4)\n        case '|':\n            result[len(result)-1]\
    \ = result[len(result)-1] / 2\n        }\n    }\n    return result\n}\n", "  \
    \  res := make([]int, 0)\n    for i := 0; i < len(music_string); i++ {\n     \
    \   if music_string[i] == 'o' {\n            if music_string[i+1] == ' ' {\n \
    \               res = append(res, 4)\n            } else {\n                res\
    \ = append(res, 2)\n                i++\n            }\n        } else {\n   \
    \         res = append(res, 1)\n            i++\n        }\n    }\n    return\
    \ res\n}\n", "    var res []int\n    return res\n}\n", "    return []int{}\n}\n",
  "    beats := make([]int, 0)\n    for _, r := range music_string {\n        switch\
    \ r {\n        case 'o':\n            beats = append(beats, 4)\n        case '.':\n\
    \            beats = append(beats, 1)\n        }\n    }\n    return beats\n}\n",
  "    var result []int\n    var beat int\n    for _, ch := range music_string {\n\
    \        switch ch {\n        case 'o':\n            beat = 4\n        case '.':\n\
    \            beat = 1\n        case '|':\n            result = append(result,\
    \ beat)\n            beat = 0\n        }\n    }\n    return result\n}\n", "  \
    \  var result []int\n    r := []rune(music_string)\n    for i, v := range r {\n\
    \        if v == 'o' {\n            result = append(result, 4)\n        }\n  \
    \      if v == '|' {\n            result[i-1] = result[i-1] / 2\n        }\n \
    \   }\n    return result\n}\n", "    var res []int\n    return res\n}\n", "  \
    \  song := make([]int, len(music_string))\n    return song\n}\n", "    // Your\
    \ code goes here.\n    return nil\n}\n", "    var res []int\n    array := make([]string,0)\n\
    \    for _, v := range music_string {\n        array = append(array, string(v))\n\
    \    }\n    n := 0\n    m := 0\n    for _, v := range array {\n        m++\n \
    \       if v == \" \" {\n            n = n + 1\n            res = append(res,\
    \ m)\n            m = 0\n        }\n    }\n    return res\n}\n", "    var beats\
    \ []int\n    beat := 0\n    for _, char := range music_string {\n        switch\
    \ char {\n        case 'o':\n            beat = 4\n        case '|':\n       \
    \     beat /= 2\n        case '.':\n            continue\n        case ' ':\n\
    \            beats = append(beats, beat)\n            beat = 0\n        }\n  \
    \  }\n    beats = append(beats, beat)\n    return beats\n}\n", "    var result\
    \ []int\n    var current_index int = 0\n    var current_char string\n    var prev_char\
    \ string\n    var current_value int\n    var prev_value int\n\n    // convert\
    \ string into a slice of ints\n    for _, char := range music_string {\n     \
    \   current_char = string(char)\n        if current_char == \"|\" && prev_char\
    \ == \"o\" {\n            result = append(result, 4)\n            prev_value =\
    \ 4\n        } else if current_char == \"|\" && prev_char == \".\" {\n       \
    \     result = append(result, 1)\n            prev_value = 1\n        } else if\
    \ current_char == \" \" {\n            result = append(result, prev_value)\n \
    \       } else if current_char == \"o\" {\n            prev_value = 4\n      \
    \  } else if current_char == \".\" {\n            prev_value = 1\n        }\n\
    \        prev_char = current_char\n    }\n    result = append(result, prev_value)\n\
    \    return result\n}\n", "    var notes = make([]int, 0)\n    note_map := map[string]int{\"\
    o\": 4, \"o|\": 2, \".|\": 1}\n    for _, v := range music_string {\n        note\
    \ := string(v)\n        if _, ok := note_map[note]; ok {\n            notes =\
    \ append(notes, note_map[note])\n        }\n    }\n    return notes\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
