name: HumanEval_156_int_to_mini_roman
language: go_test.go
prompt: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
  )\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
  // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
  // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\
  \n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int)\
  \ string {\n"
tests: "func TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
  \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
  \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     {\
  \ actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
  \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
  \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
  \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual:\
  \ candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected:\
  \ \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual:\
  \ candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected:\
  \ \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual:\
  \ candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
  t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
  %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
  \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    mini_roman := \"\"\n    for _, roman_numeral := range \"ixcm\"\
    \ {\n        value := number % 10\n        number /= 10\n        if value == 0\
    \ {\n            continue\n        }\n        if value < 4 {\n            mini_roman\
    \ = strings.Repeat(string(roman_numeral), value) + mini_roman\n        } else\
    \ if value == 4 {\n            mini_roman = string(roman_numeral) + string(roman_numeral\
    \ + 1) + mini_roman\n        } else if value == 5 {\n            mini_roman =\
    \ string(roman_numeral + 1) + mini_roman\n        } else if value < 9 {\n    \
    \        mini_roman = string(roman_numeral + 1) + strings.Repeat(string(roman_numeral),\
    \ value - 5) + mini_roman\n        } else {\n            mini_roman = string(roman_numeral)\
    \ + string(roman_numeral + 2) + mini_roman\n        }\n    }\n    return mini_roman\n\
    }\n", "    if number > 1000 || number < 1 {\n        return \"input out of range\"\
    \n    }\n    var result string\n    for number > 0 {\n        switch {\n     \
    \   case number >= 1000:\n            result += \"m\"\n            number -= 1000\n\
    \        case number >= 900:\n            result += \"cm\"\n            number\
    \ -= 900\n        case number >= 500:\n            result += \"d\"\n         \
    \   number -= 500\n        case number >= 400:\n            result += \"cd\"\n\
    \            number -= 400\n        case number >= 100:\n            result +=\
    \ \"c\"\n            number -= 100\n        case number >= 90:\n            result\
    \ += \"xc\"\n            number -= 90\n        case number >= 50:\n          \
    \  result += \"l\"\n            number -= 50\n        case number >= 40:\n   \
    \         result += \"xl\"\n            number -= 40\n        case number >= 10:\n\
    \            result += \"x\"\n            number -= 10\n        case number >=\
    \ 9:\n            result += \"ix\"\n            number -= 9\n        case number\
    \ >= 5:\n            result += \"v\"\n            number -= 5\n        case number\
    \ >= 4:\n            result += \"iv\"\n            number -= 4\n        case number\
    \ >= 1:\n            result += \"i\"\n            number -= 1\n        }\n   \
    \ }\n    return result\n}\n", "    // your code here\n    return \"\"\n}\n", " \
    \   // your code here\n    return \"\"\n}\n", "    // Define a map of integer/roman\
    \ values\n    // TODO: define map of ordered list of integer/roman values from\
    \ highest to lowest\n    var roman map[int]string = map[int]string{\n        //\
    \ TODO: 1,000\n        100: \"c\",\n        90: \"xc\",\n        50: \"l\",\n\
    \        40: \"xl\",\n        10: \"x\",\n        9: \"ix\",\n        5: \"v\"\
    ,\n        4: \"iv\",\n        1: \"i\",\n    }\n\n    // TODO: Initialize value\
    \ to store roman numeral equivalent\n    var result string\n\n    // TODO: Determine\
    \ if number is 1 or greater than 1000, if so, return an error.\n    if number\
    \ < 1 || number > 1000 {\n        fmt.Println(\"Invalid input.\")\n        return\
    \ result\n    }\n\n    // TODO: Iterate through map of ordered list of integer/roman\
    \ values from highest to lowest\n    for key, value := range roman {\n       \
    \ // TODO: Divide number by current integer.\n        // TODO: Add current roman\
    \ value to result string, by quotient amount of times.\n        for number >=\
    \ key {\n            result += value\n            number -= key\n        }\n \
    \   }\n\n    // TODO: Return result in lowercase.\n    return result\n}\n", " \
    \   // Your code here\n    return \"\"\n}\n", "    var numeral string\n\n    romanNumerals\
    \ := map[int]string{\n        1: \"i\",\n        4: \"iv\",\n        5: \"v\"\
    ,\n        9: \"ix\",\n        10: \"x\",\n        40: \"xl\",\n        50: \"\
    l\",\n        90: \"xc\",\n        100: \"c\",\n        400: \"cd\",\n       \
    \ 500: \"d\",\n        900: \"cm\",\n        1000: \"m\",\n    }\n\n    for i\
    \ := 1000; i > 0; i /= 10 {\n        digit := number/i\n        number %= i\n\n\
    \        if digit > 0 {\n            numeral += strings.Repeat(romanNumerals[i],\
    \ digit)\n        }\n    }\n\n    return numeral\n}\n", "    if number <= 0 ||\
    \ number > 1000 {\n        return \"\"\n    }\n\n    numerals := []string{\n \
    \       \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"\
    ,\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"\
    xc\",\n        \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\"\
    , \"cm\",\n        \"m\", \"mm\", \"mmm\", \"miv\", \"mxv\", \"mxvi\", \"mxvii\"\
    , \"mxviii\", \"mxxix\",\n    }\n\n    return numerals[number - 1]\n}\n", "  \
    \  numeral := []string{}\n    numeral_map := map[int]string{1: \"i\", 5: \"v\"\
    , 10: \"x\", 50: \"l\", 100: \"c\", 500: \"d\", 1000: \"m\"}\n    num_arr := []int{1,\
    \ 5, 10, 50, 100, 500, 1000}\n    for _, num := range num_arr {\n        if number\
    \ >= num {\n            count := number / num\n            for i := 0; i < count;\
    \ i++ {\n                numeral = append(numeral, numeral_map[num])\n       \
    \     }\n            number -= num * count\n        }\n    }\n    for i := 0;\
    \ i < len(numeral); i++ {\n        if i != len(numeral) - 1 {\n            //\
    \ fmt.Println(numeral[i], numeral[i+1])\n            if numeral[i] == \"i\" &&\
    \ numeral[i+1] == \"v\" {\n                numeral[i] = \"iv\"\n             \
    \   numeral = append(numeral[:i+1], numeral[i+2:]...)\n            } else if numeral[i]\
    \ == \"i\" && numeral[i+1] == \"x\" {\n                numeral[i] = \"ix\"\n \
    \               numeral = append(numeral[:i+1], numeral[i+2:]...)\n          \
    \  } else if numeral[i] == \"x\" && numeral[i+1] == \"l\" {\n                numeral[i]\
    \ = \"xl\"\n                numeral = append(numeral[:i+1], numeral[i+2:]...)\n\
    \            } else if numeral[i] == \"x\" && numeral[i+1] == \"c\" {\n      \
    \          numeral[i] = \"xc\"\n                numeral = append(numeral[:i+1],\
    \ numeral[i+2:]...)\n            } else if numeral[i] == \"c\" && numeral[i+1]\
    \ == \"d\" {\n                numeral[i] = \"cd\"\n                numeral = append(numeral[:i+1],\
    \ numeral[i+2:]...)\n            } else if", "    roman := []string{\"i\", \"\
    v\", \"x\", \"l\", \"c\", \"d\", \"m\"}\n    result := \"\"\n    rem := number\n\
    \n    for i := 0; rem > 0; i += 2 {\n        digit := rem % 10\n        rem /=\
    \ 10\n\n        result = evaluate(roman[i], roman[i+1], roman[i+2], digit) + result\n\
    \    }\n\n    return result\n}\n", "    // check for invalid number\n    if number\
    \ < 1 || number > 1000 {\n        panic(\"invalid number provided\")\n    }\n\n\
    \    // split number into thousands, hundreds, tens, and ones\n    // and convert\
    \ each group into their roman numeral equivalent\n    var numeral string\n   \
    \ numeral += thousands(number)\n    numeral += hundreds(number)\n    numeral +=\
    \ tens(number)\n    numeral += ones(number)\n\n    return numeral\n}\n", "   \
    \ var romanNumber string\n    romanNumbers := []string{\"m\", \"cm\", \"d\", \"\
    cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"}\n   \
    \ divisors := []int{1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}\n  \
    \  for _, divisor := range divisors {\n        for number >= divisor {\n     \
    \       romanNumber += romanNumbers[divisors.Index(divisor)]\n            number\
    \ -= divisor\n        }\n    }\n    return romanNumber\n}\n", "    return \"\"\
    \n}\n", "    // Set up a map of roman numerals\n    romans := map[int]string{\n\
    \            1:    \"i\",\n            5:    \"v\",\n            10:   \"x\",\n\
    \            50:   \"l\",\n            100:  \"c\",\n            500:  \"d\",\n\
    \            1000: \"m\",\n    }\n\n    // Set up a map for subtractive notation\n\
    \    subtractives := map[int]string{\n            4:    \"iv\",\n            9:\
    \    \"ix\",\n            40:   \"xl\",\n            90:   \"xc\",\n         \
    \   400:  \"cd\",\n            900:  \"cm\",\n    }\n\n    // Set up an array\
    \ of possible values to convert to\n    values := []int{1000, 900, 500, 400, 100,\
    \ 90, 50, 40, 10, 9, 5, 4, 1}\n\n    // Set up a string to return\n    ret :=\
    \ \"\"\n\n    // Generate a roman numeral string\n    for _, value := range values\
    \ {\n        for number >= value {\n            number -= value\n            ret\
    \ += romans[value]\n        }\n    }\n\n    // Convert subtractive notation to\
    \ regular notation\n    for _, value := range values {\n        ret = strings.Replace(ret,\
    \ subtractives[value], romans[value] + romans[value - value / 10], -1)\n    }\n\
    \n    return ret\n}\n", "    // initialize the return value\n    roman_numeral\
    \ := \"\"\n\n    // loop over each roman numeral from highest to lowest\n    for\
    \ _, numeral := range roman_numerals {\n        for number >= numeral.value {\n\
    \            // add numeral to the return value\n            roman_numeral +=\
    \ numeral.glyph\n            // subtract numeral value from the number\n     \
    \       number -= numeral.value\n        }\n    }\n\n    return roman_numeral\n\
    }\n\ntype roman_numeral ", "    roman_numerals := map[int]string{\n        1000:\
    \ \"m\",\n        900: \"cm\",\n        500: \"d\",\n        400: \"cd\",\n  \
    \      100: \"c\",\n        90: \"xc\",\n        50: \"l\",\n        40: \"xl\"\
    ,\n        10: \"x\",\n        9: \"ix\",\n        5: \"v\",\n        4: \"iv\"\
    ,\n        1: \"i\",\n    }\n\n    numerals := \"\"\n    for key, value := range\
    \ roman_numerals {\n        for number >= key {\n            numerals += value\n\
    \            number -= key\n        }\n    }\n\n    return numerals\n}\n", " \
    \   return \"\"\n}\n", "    if number < 1 || number > 1000 {\n        return \"\
    \"\n    }\n\n    res := \"\"\n    for number > 0 {\n        if number >= 1000\
    \ {\n            res += \"m\"\n            number -= 1000\n        } else if number\
    \ >= 900 {\n            res += \"cm\"\n            number -= 900\n        } else\
    \ if number >= 500 {\n            res += \"d\"\n            number -= 500\n  \
    \      } else if number >= 400 {\n            res += \"cd\"\n            number\
    \ -= 400\n        } else if number >= 100 {\n            res += \"c\"\n      \
    \      number -= 100\n        } else if number >= 90 {\n            res += \"\
    xc\"\n            number -= 90\n        } else if number >= 50 {\n           \
    \ res += \"l\"\n            number -= 50\n        } else if number >= 40 {\n \
    \           res += \"xl\"\n            number -= 40\n        } else if number\
    \ >= 10 {\n            res += \"x\"\n            number -= 10\n        } else\
    \ if number >= 9 {\n            res += \"ix\"\n            number -= 9\n     \
    \   } else if number >= 5 {\n            res += \"v\"\n            number -= 5\n\
    \        } else if number >= 4 {\n            res += \"iv\"\n            number\
    \ -= 4\n        } else if number >= 1 {\n            res += \"i\"\n          \
    \  number -= 1\n        }\n    }\n\n    return res\n}\n", "    romanNumeral :=\
    \ \"\"\n    for number > 0 {\n        if number >= 100 {\n            romanNumeral\
    \ += \"c\"\n            number -= 100\n        } else if number >= 90 {\n    \
    \        romanNumeral += \"xc\"\n            number -= 90\n        } else if number\
    \ >= 50 {\n            romanNumeral += \"l\"\n            number -= 50\n     \
    \   } else if number >= 40 {\n            romanNumeral += \"xl\"\n           \
    \ number -= 40\n        } else if number >= 10 {\n            romanNumeral +=\
    \ \"x\"\n            number -= 10\n        } else if number >= 9 {\n         \
    \   romanNumeral += \"ix\"\n            number -= 9\n        } else if number\
    \ >= 5 {\n            romanNumeral += \"v\"\n            number -= 5\n       \
    \ } else if number >= 4 {\n            romanNumeral += \"iv\"\n            number\
    \ -= 4\n        } else if number >= 1 {\n            romanNumeral += \"i\"\n \
    \           number -= 1\n        }\n    }\n    return romanNumeral\n}\n", "  \
    \  if number < 1 || number > 1000 {\n        return \"\";\n    }\n\n    var roman\
    \ []string\n    var romanInts = map[int]string{\n        1: \"i\", 4: \"iv\",\
    \ 5: \"v\", 9: \"ix\",\n        10: \"x\", 40: \"xl\", 50: \"l\", 90: \"xc\",\n\
    \        100: \"c\", 400: \"cd\", 500: \"d\", 900: \"cm\",\n        1000: \"m\"\
    ,\n    }\n\n    for i := 1000; i > 0; i /= 10 {\n        digit := number / i;\n\
    \        number %= i;\n\n        var s string;\n        if digit == 4 || digit\
    \ == 9 {\n            s = romanInts[i*digit];\n        } else {\n            if\
    \ digit >= 5 {\n                s = romanInts[i*5];\n                digit -=\
    \ 5;\n            }\n            for digit > 0 {\n                s += romanInts[i];\n\
    \                digit--;\n            }\n        }\n        roman = append(roman,\
    \ s);\n    }\n\n    return fmt.Sprintf(\"%s\", roman);\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
