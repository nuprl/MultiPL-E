language: go_test.go
name: HumanEval_17_parse_music
results:
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    var duration []int\n    if len(music_string) == 0 {\n \
    \       return duration\n    }\n    for i := 0; i < len(music_string); i++ {\n\
    \        if music_string[i] == 'o' {\n            duration = append(duration,\
    \ 4)\n        } else if music_string[i] == '.' {\n            duration = append(duration,\
    \ 1)\n        }\n        if i + 1 < len(music_string) && music_string[i+1] ==\
    \ '|' {\n            duration[len(duration)-1] /= 2\n            i++\n       \
    \ }\n    }\n    return duration\n}\n\nfunc TestParse_Music(t *testing.T) {\n \
    \ candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"\
    ), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__2\
    \ (0.00s)\n        tmp0_x_d9x4_test.go:53: expected '[%!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL:\
    \ TestParse_Music/test_num__3 (0.00s)\n        tmp0_x_d9x4_test.go:53: expected\
    \ '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=2) %!s(int=2) %!s(int=0) %!s(int=0) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n\
    \        tmp0_x_d9x4_test.go:53: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1)\
    \ %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=2) %!s(int=0) %!s(int=2)\
    \ %!s(int=0) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074873
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    beats := make([]int, 0)\n    state := 0\n    current_beat\
    \ := 1\n    for _, char := range music_string {\n        if char == 'o' {\n  \
    \          if state == 0 {\n                current_beat = 4\n            } else\
    \ {\n                beats = append(beats, current_beat)\n                current_beat\
    \ = 4\n            }\n            state = 0\n        } else if char == '.' {\n\
    \            if state == 0 {\n                current_beat = 1\n            }\
    \ else {\n                beats = append(beats, current_beat)\n              \
    \  current_beat = 1\n            }\n            state = 0\n        } else if char\
    \ == '|' {\n            state = 1\n        }\n    }\n    if current_beat != 0\
    \ {\n        beats = append(beats, current_beat)\n    }\n    return beats\n}\n\
    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual:\
    \ candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\"\
    .| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o|\
    \ o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual:\
    \ candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__0\
    \ (0.00s)\n        tmpp3f8l2xf_test.go:65: expected '[]', got '[%!s(int=1)]'\n\
    \    --- FAIL: TestParse_Music/test_num__1 (0.00s)\n        tmpp3f8l2xf_test.go:65:\
    \ expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4)]'\n\
    \    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpp3f8l2xf_test.go:65:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=1) %!s(int=1) %!s(int=4)]'\n\
    \    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n        tmpp3f8l2xf_test.go:65:\
    \ expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2)\
    \ %!s(int=4) %!s(int=2)]', got '[%!s(int=4) %!s(int=1) %!s(int=4) %!s(int=1) %!s(int=4)\
    \ %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074873
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    return []int{}\n}\n\nfunc TestParse_Music(t *testing.T)\
    \ {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpqorsmevh_test.go:38: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpqorsmevh_test.go:38: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpqorsmevh_test.go:38:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpqorsmevh_test.go:38: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074654
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    var parsed_music []int\n    var music_chars []rune\n  \
    \  var beats int\n    var next_rune_is_beat bool\n    var last_rune rune\n\n \
    \   music_chars = []rune(music_string)\n    beats = 0\n    next_rune_is_beat =\
    \ false\n    last_rune = ' '\n\n    for _, char := range music_chars {\n     \
    \   if char == 'o' {\n            if last_rune == ' ' {\n                beats\
    \ = 4\n            } else {\n                beats += 4\n            }\n     \
    \       next_rune_is_beat = true\n        } else if char == '|' {\n          \
    \  if last_rune == 'o' {\n                beats = 2\n            } else {\n  \
    \              beats += 2\n            }\n            next_rune_is_beat = true\n\
    \        } else if char == '.' {\n            beats += 1\n            next_rune_is_beat\
    \ = true\n        } else if char == ' ' {\n            if next_rune_is_beat {\n\
    \                parsed_music = append(parsed_music, beats)\n                beats\
    \ = 0\n                next_rune_is_beat = false\n            }\n        }\n \
    \       last_rune = char\n    }\n\n    return parsed_music\n}\n\nfunc TestParse_Music(t\
    \ *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"\
    ), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"),\
    \ expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o\
    \ o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"\
    o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmp9r6c7s_t_test.go:77: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__2\
    \ (0.00s)\n        tmp9r6c7s_t_test.go:77: expected '[%!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1)]', got '[%!s(int=3) %!s(int=3) %!s(int=3)]'\n    --- FAIL: TestParse_Music/test_num__3\
    \ (0.00s)\n        tmp9r6c7s_t_test.go:77: expected '[%!s(int=2) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=2) %!s(int=2)\
    \ %!s(int=3) %!s(int=3) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmp9r6c7s_t_test.go:77: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=2) %!s(int=3)\
    \ %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=2) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074873
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    return nil\n}\n\nfunc TestParse_Music(t *testing.T) {\n\
    \  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"\
    ), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpv8cxx1gh_test.go:38: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpv8cxx1gh_test.go:38: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpv8cxx1gh_test.go:38:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpv8cxx1gh_test.go:38: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074654
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    return nil\n}\n\nfunc TestParse_Music(t *testing.T) {\n\
    \  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"\
    ), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpv8cxx1gh_test.go:38: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpv8cxx1gh_test.go:38: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpv8cxx1gh_test.go:38:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpv8cxx1gh_test.go:38: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074654
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    var result []int\n    for _, ch := range music_string {\n\
    \        switch ch {\n        case 'o':\n            result = append(result, 4)\n\
    \        case '|':\n            result[len(result)-1] = result[len(result)-1]\
    \ / 2\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T)\
    \ {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\npanic: runtime error: index out of range\
    \ [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine\
    \ 6 [running]:\ntesting.tRunner.func1.2({0x5136e0, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x5136e0, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.parse_music(...)\n\t/tmp/tmp1b8zaen7_test.go:24\n\
    command-line-arguments_test.TestParse_Music(0x0?)\n\t/tmp/tmp1b8zaen7_test.go:39\
    \ +0xbe5\ntesting.tRunner(0xc0000da340, 0x529038)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074873
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    res := make([]int, 0)\n    for i := 0; i < len(music_string);\
    \ i++ {\n        if music_string[i] == 'o' {\n            if music_string[i+1]\
    \ == ' ' {\n                res = append(res, 4)\n            } else {\n     \
    \           res = append(res, 2)\n                i++\n            }\n       \
    \ } else {\n            res = append(res, 1)\n            i++\n        }\n   \
    \ }\n    return res\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate :=\
    \ parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n\
    \     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual:\
    \ candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4}\
    \ },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2,\
    \ 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpr_3t_sei_test.go:52: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=4) %!s(int=1) %!s(int=1) %!s(int=1)]'\n    --- FAIL:\
    \ TestParse_Music/test_num__2 (0.00s)\n        tmpr_3t_sei_test.go:52: expected\
    \ '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[%!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]'\n    --- FAIL: TestParse_Music/test_num__3\
    \ (0.00s)\n        tmpr_3t_sei_test.go:52: expected '[%!s(int=2) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=1) %!s(int=1)\
    \ %!s(int=1)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n        tmpr_3t_sei_test.go:52:\
    \ expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2)\
    \ %!s(int=4) %!s(int=2)]', got '[%!s(int=2) %!s(int=1) %!s(int=1) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=4) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=1) %!s(int=1)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074873
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    var res []int\n    return res\n}\n\nfunc TestParse_Music(t\
    \ *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"\
    ), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"),\
    \ expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o\
    \ o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"\
    o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmp15fzfgvx_test.go:39: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmp15fzfgvx_test.go:39: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmp15fzfgvx_test.go:39:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmp15fzfgvx_test.go:39: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074873
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    return []int{}\n}\n\nfunc TestParse_Music(t *testing.T)\
    \ {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpqorsmevh_test.go:38: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpqorsmevh_test.go:38: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpqorsmevh_test.go:38:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpqorsmevh_test.go:38: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074654
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    beats := make([]int, 0)\n    for _, r := range music_string\
    \ {\n        switch r {\n        case 'o':\n            beats = append(beats,\
    \ 4)\n        case '.':\n            beats = append(beats, 1)\n        }\n   \
    \ }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate\
    \ := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4,\
    \ 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1}\
    \ },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2,\
    \ 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected:\
    \ []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__3\
    \ (0.00s)\n        tmpjf0o7htk_test.go:47: expected '[%!s(int=2) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=4)\
    \ %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    ---\
    \ FAIL: TestParse_Music/test_num__4 (0.00s)\n        tmpjf0o7htk_test.go:47: expected\
    \ '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4)\
    \ %!s(int=2)]', got '[%!s(int=4) %!s(int=1) %!s(int=4) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074873
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    var result []int\n    var beat int\n    for _, ch := range\
    \ music_string {\n        switch ch {\n        case 'o':\n            beat = 4\n\
    \        case '.':\n            beat = 1\n        case '|':\n            result\
    \ = append(result, beat)\n            beat = 0\n        }\n    }\n    return result\n\
    }\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual:\
    \ candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\"\
    .| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o|\
    \ o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual:\
    \ candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmp9bmn1w4q_test.go:51: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n\
    \        tmp9bmn1w4q_test.go:51: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1)\
    \ %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=1)\
    \ %!s(int=1)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n        tmp9bmn1w4q_test.go:51:\
    \ expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2)\
    \ %!s(int=4) %!s(int=2)]', got '[%!s(int=4) %!s(int=1) %!s(int=4) %!s(int=1) %!s(int=4)\
    \ %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074873
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    var result []int\n    r := []rune(music_string)\n    for\
    \ i, v := range r {\n        if v == 'o' {\n            result = append(result,\
    \ 4)\n        }\n        if v == '|' {\n            result[i-1] = result[i-1]\
    \ / 2\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T)\
    \ {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x5136e0,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x5136e0, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.parse_music(...)\n\t/tmp/tmpk9fbiotp_test.go:25\n\
    command-line-arguments_test.TestParse_Music(0xc0000da340?)\n\t/tmp/tmpk9fbiotp_test.go:40\
    \ +0x970\ntesting.tRunner(0xc0000da340, 0x529038)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074873
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    var res []int\n    return res\n}\n\nfunc TestParse_Music(t\
    \ *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"\
    ), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"),\
    \ expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o\
    \ o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"\
    o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmp15fzfgvx_test.go:39: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmp15fzfgvx_test.go:39: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmp15fzfgvx_test.go:39:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmp15fzfgvx_test.go:39: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074873
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    song := make([]int, len(music_string))\n    return song\n\
    }\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual:\
    \ candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\"\
    .| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o|\
    \ o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual:\
    \ candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpajbht7lj_test.go:39: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmpajbht7lj_test.go:39:\
    \ expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[%!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n\
    \        tmpajbht7lj_test.go:39: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1)\
    \ %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n\
    \        tmpajbht7lj_test.go:39: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1)\
    \ %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074873
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    // Your code goes here.\n    return nil\n}\n\nfunc TestParse_Music(t\
    \ *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"\
    ), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"),\
    \ expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o\
    \ o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"\
    o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmp_2kls16f_test.go:39: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmp_2kls16f_test.go:39: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmp_2kls16f_test.go:39:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmp_2kls16f_test.go:39: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074873
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    var res []int\n    array := make([]string,0)\n    for _,\
    \ v := range music_string {\n        array = append(array, string(v))\n    }\n\
    \    n := 0\n    m := 0\n    for _, v := range array {\n        m++\n        if\
    \ v == \" \" {\n            n = n + 1\n            res = append(res, m)\n    \
    \        m = 0\n        }\n    }\n    return res\n}\n\nfunc TestParse_Music(t\
    \ *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"\
    ), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"),\
    \ expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o\
    \ o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"\
    o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmp_80a0ul7_test.go:53: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=2) %!s(int=2) %!s(int=2)]'\n    --- FAIL: TestParse_Music/test_num__2\
    \ (0.00s)\n        tmp_80a0ul7_test.go:53: expected '[%!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1)]', got '[%!s(int=3) %!s(int=3) %!s(int=3)]'\n    --- FAIL: TestParse_Music/test_num__3\
    \ (0.00s)\n        tmp_80a0ul7_test.go:53: expected '[%!s(int=2) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=3) %!s(int=3)\
    \ %!s(int=3) %!s(int=3) %!s(int=2) %!s(int=2) %!s(int=2)]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmp_80a0ul7_test.go:53: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=3) %!s(int=3)\
    \ %!s(int=3) %!s(int=3) %!s(int=2) %!s(int=3) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074873
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    var beats []int\n    beat := 0\n    for _, char := range\
    \ music_string {\n        switch char {\n        case 'o':\n            beat =\
    \ 4\n        case '|':\n            beat /= 2\n        case '.':\n           \
    \ continue\n        case ' ':\n            beats = append(beats, beat)\n     \
    \       beat = 0\n        }\n    }\n    beats = append(beats, beat)\n    return\
    \ beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n \
    \    { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual:\
    \ candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4}\
    \ },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2,\
    \ 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__0\
    \ (0.00s)\n        tmpf3rwyocz_test.go:54: expected '[]', got '[%!s(int=0)]'\n\
    \    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmpf3rwyocz_test.go:54:\
    \ expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[%!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n\
    \        tmpf3rwyocz_test.go:54: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1)\
    \ %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=2) %!s(int=2) %!s(int=0)\
    \ %!s(int=0) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpf3rwyocz_test.go:54: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=2) %!s(int=0)\
    \ %!s(int=2) %!s(int=0) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074873
- exit_code: 2
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    var result []int\n    var current_index int = 0\n    var\
    \ current_char string\n    var prev_char string\n    var current_value int\n \
    \   var prev_value int\n\n    // convert string into a slice of ints\n    for\
    \ _, char := range music_string {\n        current_char = string(char)\n     \
    \   if current_char == \"|\" && prev_char == \"o\" {\n            result = append(result,\
    \ 4)\n            prev_value = 4\n        } else if current_char == \"|\" && prev_char\
    \ == \".\" {\n            result = append(result, 1)\n            prev_value =\
    \ 1\n        } else if current_char == \" \" {\n            result = append(result,\
    \ prev_value)\n        } else if current_char == \"o\" {\n            prev_value\
    \ = 4\n        } else if current_char == \".\" {\n            prev_value = 1\n\
    \        }\n        prev_char = current_char\n    }\n    result = append(result,\
    \ prev_value)\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n\
    \  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"\
    ), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpz5s_jd2h_test.go:19:9: current_index declared but not used

    /tmp/tmpz5s_jd2h_test.go:22:9: current_value declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074873
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    var notes = make([]int, 0)\n    note_map := map[string]int{\"\
    o\": 4, \"o|\": 2, \".|\": 1}\n    for _, v := range music_string {\n        note\
    \ := string(v)\n        if _, ok := note_map[note]; ok {\n            notes =\
    \ append(notes, note_map[note])\n        }\n    }\n    return notes\n}\n\nfunc\
    \ TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"\
    o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .|\
    \ .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .|\
    \ o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"\
    o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__2\
    \ (0.00s)\n        tmpaih94e30_test.go:46: expected '[%!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n\
    \        tmpaih94e30_test.go:46: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1)\
    \ %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpaih94e30_test.go:46: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074873
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    // TODO: Implement parsing algorithm.\n    return nil\n\
    }\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual:\
    \ candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\"\
    .| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o|\
    \ o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual:\
    \ candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmp2egze7sv_test.go:39: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmp2egze7sv_test.go:39: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmp2egze7sv_test.go:39:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmp2egze7sv_test.go:39: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660074873
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    var res []int\n    for i := 0; i < len(music_string); i\
    \ += 2 {\n        switch music_string[i:i+2] {\n        case \"o \":\n       \
    \     res = append(res, 4)\n        case \"o|\":\n            res = append(res,\
    \ 2)\n        case \".|\":\n            res = append(res, 1)\n        default:\n\
    \            panic(\"Invalid input\")\n        }\n    }\n    return res\n}\n\n\
    func TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual:\
    \ candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\"\
    .| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o|\
    \ o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual:\
    \ candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\npanic: runtime error: slice bounds out\
    \ of range [:8] with length 7 [recovered]\n\tpanic: runtime error: slice bounds\
    \ out of range [:8] with length 7\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x5136e0,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x5136e0, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.parse_music(...)\n\t/tmp/tmpohebgao8_test.go:20\n\
    command-line-arguments_test.TestParse_Music(0x0?)\n\t/tmp/tmpohebgao8_test.go:42\
    \ +0xc08\ntesting.tRunner(0xc0000d04e0, 0x529048)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074873
- exit_code: 0
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    var res = make([]int, 0)\n    for i := 0; i < len(music_string);\
    \ i++ {\n        if music_string[i] == 'o' {\n            if i + 1 < len(music_string)\
    \ && music_string[i + 1] == '|' {\n                res = append(res, 2)\n    \
    \            i++\n            } else {\n                res = append(res, 4)\n\
    \            }\n        } else if music_string[i] == '.' {\n            res =\
    \ append(res, 1)\n            i++\n        }\n    }\n    return res\n}\n\nfunc\
    \ TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"\
    o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .|\
    \ .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .|\
    \ o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"\
    o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074873
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    var result []int\n    var i int\n    for i = 0; i < len(music_string);\
    \ i++ {\n        switch music_string[i] {\n        case 'o':\n            if music_string[i+1]\
    \ == ' ' {\n                result = append(result, 4)\n            } else {\n\
    \                result = append(result, 2)\n                i += 1\n        \
    \    }\n        case '.':\n            result = append(result, 1)\n          \
    \  i += 1\n        case ' ':\n            continue\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n \
    \    { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual:\
    \ candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4}\
    \ },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2,\
    \ 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\npanic: runtime error: index out of range\
    \ [7] with length 7 [recovered]\n\tpanic: runtime error: index out of range [7]\
    \ with length 7\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x5136e0,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x5136e0, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.parse_music(...)\n\t/tmp/tmp2pa07ddj_test.go:23\n\
    command-line-arguments_test.TestParse_Music(0x0?)\n\t/tmp/tmp2pa07ddj_test.go:47\
    \ +0xc26\ntesting.tRunner(0xc0000da340, 0x529038)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074873
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    return nil\n}\n\nfunc TestParse_Music(t *testing.T) {\n\
    \  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"\
    ), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpv8cxx1gh_test.go:38: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpv8cxx1gh_test.go:38: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpv8cxx1gh_test.go:38:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpv8cxx1gh_test.go:38: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074654
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    var list_of_beats []int\n\n    return list_of_beats\n}\n\
    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual:\
    \ candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\"\
    .| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o|\
    \ o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual:\
    \ candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpdrhxuuk8_test.go:40: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpdrhxuuk8_test.go:40: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpdrhxuuk8_test.go:40:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpdrhxuuk8_test.go:40: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074873
- exit_code: 0
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    var new_string string\n    length := len(music_string)\n\
    \    for i := 0; i < length; i++ {\n        if music_string[i] == ' ' {\n    \
    \        continue\n        } else {\n            new_string += string(music_string[i])\n\
    \        }\n    }\n    fmt.Println(new_string)\n    length = len(new_string)\n\
    \    list := make([]int, 0)\n    for i := 0; i < length; i++ {\n        if new_string[i]\
    \ == 'o' {\n            if i + 1 == length {\n                list = append(list,\
    \ 4)\n            } else if new_string[i + 1] == '|' {\n                list =\
    \ append(list, 2)\n                i += 1\n            } else {\n            \
    \    list = append(list, 4)\n            }\n        } else if new_string[i] ==\
    \ '.' {\n            list = append(list, 1)\n            i += 1\n        }\n \
    \   }\n    return list\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate\
    \ := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4,\
    \ 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1}\
    \ },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2,\
    \ 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected:\
    \ []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074873
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    return []int{}\n}\n\nfunc TestParse_Music(t *testing.T)\
    \ {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpqorsmevh_test.go:38: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpqorsmevh_test.go:38: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpqorsmevh_test.go:38:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpqorsmevh_test.go:38: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074654
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    var beats []int\n    var note_dict = map[string]int{\n\
    \        \"o\": 4,\n        \"o|\": 2,\n        \".|\": 1,\n    }\n    for _,\
    \ note := range music_string {\n        beats = append(beats, note_dict[string(note)])\n\
    \    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate\
    \ := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4,\
    \ 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1}\
    \ },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2,\
    \ 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected:\
    \ []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmporbbddl4_test.go:47: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=4) %!s(int=0) %!s(int=4) %!s(int=0) %!s(int=4) %!s(int=0)\
    \ %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmporbbddl4_test.go:47:\
    \ expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[%!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n\
    \        tmporbbddl4_test.go:47: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1)\
    \ %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=0) %!s(int=0)\
    \ %!s(int=4) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=4) %!s(int=0) %!s(int=4) %!s(int=0) %!s(int=4)\
    \ %!s(int=0) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n\
    \        tmporbbddl4_test.go:47: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1)\
    \ %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=4) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=4) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=4) %!s(int=0) %!s(int=4) %!s(int=0) %!s(int=0)\
    \ %!s(int=4) %!s(int=0) %!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074873
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    var beats []int\n    var map_rune_beat = map[rune]int{\n\
    \        'o': 4,\n        '|': 2,\n        '.': 1,\n    }\n    var cur_beat int\n\
    \    for _, r := range music_string {\n        if r == ' ' {\n            beats\
    \ = append(beats, cur_beat)\n            cur_beat = 0\n        } else {\n    \
    \        cur_beat += map_rune_beat[r]\n        }\n    }\n    beats = append(beats,\
    \ cur_beat)\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate\
    \ := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4,\
    \ 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1}\
    \ },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2,\
    \ 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected:\
    \ []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__0\
    \ (0.00s)\n        tmp2xsldiiz_test.go:54: expected '[]', got '[%!s(int=0)]'\n\
    \    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmp2xsldiiz_test.go:54:\
    \ expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[%!s(int=3) %!s(int=3)\
    \ %!s(int=3) %!s(int=3)]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n\
    \        tmp2xsldiiz_test.go:54: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1)\
    \ %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=6) %!s(int=6) %!s(int=3)\
    \ %!s(int=3) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmp2xsldiiz_test.go:54: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=6) %!s(int=3)\
    \ %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=4) %!s(int=6)]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074873
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    return nil\n}\n\nfunc TestParse_Music(t *testing.T) {\n\
    \  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"\
    ), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpv8cxx1gh_test.go:38: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpv8cxx1gh_test.go:38: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpv8cxx1gh_test.go:38:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpv8cxx1gh_test.go:38: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074654
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    var result []int\n\n    return result\n}\n\nfunc TestParse_Music(t\
    \ *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"\
    ), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"),\
    \ expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o\
    \ o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"\
    o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmp1v1x3s8k_test.go:40: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmp1v1x3s8k_test.go:40: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmp1v1x3s8k_test.go:40:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmp1v1x3s8k_test.go:40: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074875
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    var res = make([]int, 0)\n    var lastInd = 0\n    for\
    \ i := 0; i < len(music_string); i++ {\n        if music_string[i] == ' ' {\n\
    \            res = append(res, i - lastInd)\n            lastInd = i + 1\n   \
    \     }\n    }\n    res = append(res, len(music_string) - lastInd)\n    return\
    \ res\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n \
    \    { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual:\
    \ candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4}\
    \ },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2,\
    \ 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__0\
    \ (0.00s)\n        tmpce1yjr1a_test.go:47: expected '[]', got '[%!s(int=0)]'\n\
    \    --- FAIL: TestParse_Music/test_num__1 (0.00s)\n        tmpce1yjr1a_test.go:47:\
    \ expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1)]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpce1yjr1a_test.go:47: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[%!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2)]'\n    --- FAIL: TestParse_Music/test_num__3\
    \ (0.00s)\n        tmpce1yjr1a_test.go:47: expected '[%!s(int=2) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=2) %!s(int=2)\
    \ %!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]'\n    ---\
    \ FAIL: TestParse_Music/test_num__4 (0.00s)\n        tmpce1yjr1a_test.go:47: expected\
    \ '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4)\
    \ %!s(int=2)]', got '[%!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074876
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    return nil\n}\n\nfunc TestParse_Music(t *testing.T) {\n\
    \  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"\
    ), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpv8cxx1gh_test.go:38: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpv8cxx1gh_test.go:38: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpv8cxx1gh_test.go:38:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpv8cxx1gh_test.go:38: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074654
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    return nil\n}\n\nfunc TestParse_Music(t *testing.T) {\n\
    \  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"\
    ), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpv8cxx1gh_test.go:38: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpv8cxx1gh_test.go:38: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpv8cxx1gh_test.go:38:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpv8cxx1gh_test.go:38: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074654
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    var beats = make([]int, 0)\n    for i := 0; i < len(music_string);\
    \ i++ {\n        if music_string[i] == 'o' {\n            beats = append(beats,\
    \ 4)\n        } else if music_string[i] == '.' {\n            beats = append(beats,\
    \ 1)\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T)\
    \ {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__3\
    \ (0.00s)\n        tmpc7rhtb7y_test.go:46: expected '[%!s(int=2) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=4)\
    \ %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    ---\
    \ FAIL: TestParse_Music/test_num__4 (0.00s)\n        tmpc7rhtb7y_test.go:46: expected\
    \ '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4)\
    \ %!s(int=2)]', got '[%!s(int=4) %!s(int=1) %!s(int=4) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074876
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    return nil\n}\n\nfunc TestParse_Music(t *testing.T) {\n\
    \  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"\
    ), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpv8cxx1gh_test.go:38: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpv8cxx1gh_test.go:38: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpv8cxx1gh_test.go:38:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpv8cxx1gh_test.go:38: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074654
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    m := []int{}\n    var tmp int\n    for _, v := range music_string\
    \ {\n        if v == 'o' {\n            tmp = 4\n        } else if v == '|' {\n\
    \            tmp--\n        }\n        if tmp != 0 {\n            m = append(m,\
    \ tmp)\n        }\n    }\n    return m\n}\n\nfunc TestParse_Music(t *testing.T)\
    \ {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpqt5o8gva_test.go:50: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmpqt5o8gva_test.go:50:\
    \ expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[%!s(int=-1)\
    \ %!s(int=-1) %!s(int=-1) %!s(int=-2) %!s(int=-2) %!s(int=-2) %!s(int=-3) %!s(int=-3)\
    \ %!s(int=-3) %!s(int=-4)]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n\
    \        tmpqt5o8gva_test.go:50: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1)\
    \ %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=3)\
    \ %!s(int=4) %!s(int=3) %!s(int=3) %!s(int=3) %!s(int=2) %!s(int=2) %!s(int=2)\
    \ %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n\
    \        tmpqt5o8gva_test.go:50: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1)\
    \ %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=4) %!s(int=3) %!s(int=3)\
    \ %!s(int=3) %!s(int=2) %!s(int=2) %!s(int=4) %!s(int=3) %!s(int=3) %!s(int=3)\
    \ %!s(int=2) %!s(int=2) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=3) %!s(int=3)\
    \ %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074876
- exit_code: 2
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    var result []int\n    tmp := \"\"\n    for i := 0; i <\
    \ len(music_string); i++ {\n        if music_string[i] == ' ' {\n            result\
    \ = append(result, how_many_beats(tmp))\n            tmp = \"\"\n        } else\
    \ {\n            tmp += string(music_string[i])\n        }\n    }\n    result\
    \ = append(result, how_many_beats(tmp))\n    return result\n}\n\nfunc TestParse_Music(t\
    \ *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"\
    ), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"),\
    \ expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o\
    \ o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"\
    o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp32zuzblo_test.go:22:37: undefined: how_many_beats

    /tmp/tmp32zuzblo_test.go:28:29: undefined: how_many_beats

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074875
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    // write your code here\n    return []int{}\n}\n\nfunc\
    \ TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"\
    o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .|\
    \ .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .|\
    \ o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"\
    o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpzvpb44nq_test.go:39: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpzvpb44nq_test.go:39: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpzvpb44nq_test.go:39:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpzvpb44nq_test.go:39: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074876
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    ret := make([]int, 0)\n    var beats int\n    for _,v :=\
    \ range music_string {\n        switch string(v) {\n        case \"o\":\n    \
    \        beats = 4\n        case \"o|\":\n            beats = 2\n        case\
    \ \".|\":\n            beats = 1\n        }\n        ret = append(ret, beats)\n\
    \    }\n    return ret\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate\
    \ := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4,\
    \ 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1}\
    \ },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2,\
    \ 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected:\
    \ []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpt0gxl45j_test.go:51: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmpt0gxl45j_test.go:51:\
    \ expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[%!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n\
    \        tmpt0gxl45j_test.go:51: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1)\
    \ %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n\
    \        tmpt0gxl45j_test.go:51: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1)\
    \ %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074876
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    if music_string == \"\" {\n        return []int{}\n   \
    \ }\n    slice := []rune(music_string)\n    result := []int{}\n    for i := 0;\
    \ i < len(slice); i++ {\n        switch slice[i] {\n        case 'o':\n      \
    \      result = append(result, 4)\n        case '.':\n            result = append(result,\
    \ 1)\n        }\n        if slice[i] == 'o' || slice[i] == '.' {\n           \
    \ i++\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T)\
    \ {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__3\
    \ (0.00s)\n        tmpe5em_4hx_test.go:54: expected '[%!s(int=2) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=4)\
    \ %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    ---\
    \ FAIL: TestParse_Music/test_num__4 (0.00s)\n        tmpe5em_4hx_test.go:54: expected\
    \ '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4)\
    \ %!s(int=2)]', got '[%!s(int=4) %!s(int=1) %!s(int=4) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074876
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    return []int{}\n}\n\nfunc TestParse_Music(t *testing.T)\
    \ {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpqorsmevh_test.go:38: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpqorsmevh_test.go:38: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpqorsmevh_test.go:38:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpqorsmevh_test.go:38: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074654
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    beats := []int{}\n    for _, char := range music_string\
    \ {\n        switch char {\n        case 'o':\n            beats = append(beats,\
    \ 4)\n        case '|':\n            if beats[len(beats)-1] == 4 {\n         \
    \       beats[len(beats)-1] = 2\n            } else {\n                beats =\
    \ append(beats, 1)\n            }\n        case '.':\n            if beats[len(beats)-1]\
    \ == 4 {\n                beats[len(beats)-1] = 1\n            } else {\n    \
    \            beats = append(beats, 1)\n            }\n        }\n    }\n    return\
    \ beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n \
    \    { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual:\
    \ candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4}\
    \ },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2,\
    \ 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\npanic: runtime error: index out of range\
    \ [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine\
    \ 6 [running]:\ntesting.tRunner.func1.2({0x5136e0, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x5136e0, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.parse_music(...)\n\t/tmp/tmp4gysst9t_test.go:30\n\
    command-line-arguments_test.TestParse_Music(0x0?)\n\t/tmp/tmp4gysst9t_test.go:49\
    \ +0x11c6\ntesting.tRunner(0xc0000da340, 0x529038)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074876
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    beats := []int{}\n    for _, value := range music_string\
    \ {\n        if value == 'o' {\n            beats = append(beats, 4)\n       \
    \ } else if value == '|' {\n            beats = append(beats, 2)\n        } else\
    \ if value == '.' {\n            beats = append(beats, 1)\n        }\n    }\n\
    \    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n \
    \    { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual:\
    \ candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4}\
    \ },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2,\
    \ 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__2\
    \ (0.00s)\n        tmp4onzvff5_test.go:48: expected '[%!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=2)]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n\
    \        tmp4onzvff5_test.go:48: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1)\
    \ %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=2) %!s(int=4)\
    \ %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n\
    \        tmp4onzvff5_test.go:48: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1)\
    \ %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=4) %!s(int=2) %!s(int=1)\
    \ %!s(int=2) %!s(int=4) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=4) %!s(int=4)\
    \ %!s(int=2) %!s(int=4) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074876
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    beats := []int{}\n    for _, char := range music_string\
    \ {\n        switch char {\n        case 'o':\n            beats = append(beats,\
    \ 4)\n        case '|':\n            if beats[len(beats)-1] == 4 {\n         \
    \       beats[len(beats)-1] = 2\n            } else {\n                beats =\
    \ append(beats, 1)\n            }\n        }\n    }\n    return beats\n}\n\nfunc\
    \ TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"\
    o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .|\
    \ .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .|\
    \ o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"\
    o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\npanic: runtime error: index out of range\
    \ [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine\
    \ 18 [running]:\ntesting.tRunner.func1.2({0x5136e0, 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x5136e0, 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.parse_music(...)\n\t/tmp/tmpgxktt_e1_test.go:24\n\
    command-line-arguments_test.TestParse_Music(0x0?)\n\t/tmp/tmpgxktt_e1_test.go:43\
    \ +0xe65\ntesting.tRunner(0xc000103520, 0x529038)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074876
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    m := []rune(music_string)\n    ret := make([]int, 0)\n\
    \    for _, r := range m {\n        if r == 'o' {\n            ret = append(ret,\
    \ 4)\n        } else if r == '|' {\n            ret[len(ret)-1] /= 2\n       \
    \ }\n    }\n    return ret\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate\
    \ := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4,\
    \ 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1}\
    \ },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2,\
    \ 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected:\
    \ []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\npanic: runtime error: index out of range\
    \ [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine\
    \ 6 [running]:\ntesting.tRunner.func1.2({0x5136e0, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x5136e0, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.parse_music(...)\n\t/tmp/tmpbtv606ct_test.go:24\n\
    command-line-arguments_test.TestParse_Music(0xc0000da340?)\n\t/tmp/tmpbtv606ct_test.go:39\
    \ +0x99d\ntesting.tRunner(0xc0000da340, 0x529038)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074876
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    // If a whole note is parsed, add 4 to the list and continue.\n\
    \    // If a half note is parsed, add 2 to the list and continue.\n    // If a\
    \ quater note is parsed, add 1 to the list and continue.\n    // Otherwise, return\
    \ nil.\n    return nil\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate\
    \ := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4,\
    \ 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1}\
    \ },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2,\
    \ 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected:\
    \ []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpb3q5ot4c_test.go:42: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpb3q5ot4c_test.go:42: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpb3q5ot4c_test.go:42:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpb3q5ot4c_test.go:42: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074876
- exit_code: null
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    l := len(music_string)\n    var res []int\n    i := 0\n\
    \    for i < l {\n        switch music_string[i] {\n        case 'o':\n      \
    \      res = append(res, 4)\n            i++\n        case '.':\n            res\
    \ = append(res, 1)\n            i += 2\n        }\n    }\n    return res\n}\n\n\
    func TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual:\
    \ candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\"\
    .| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o|\
    \ o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual:\
    \ candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660074888
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    beats := []int{}\n    var note string\n    var beat int\n\
    \    for _, char := range music_string {\n        switch char {\n        case\
    \ ' ':\n            if note == \"o\" {\n                beat = 4\n           \
    \ } else if note == \"o|\" {\n                beat = 2\n            } else if\
    \ note == \".|\" {\n                beat = 1\n            }\n            beats\
    \ = append(beats, beat)\n            note = \"\"\n        default:\n         \
    \   note += string(char)\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t\
    \ *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"\
    ), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"),\
    \ expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o\
    \ o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"\
    o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmp9v71fdgj_test.go:57: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__2\
    \ (0.00s)\n        tmp9v71fdgj_test.go:57: expected '[%!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1)]', got '[%!s(int=1) %!s(int=1) %!s(int=1)]'\n    --- FAIL: TestParse_Music/test_num__3\
    \ (0.00s)\n        tmp9v71fdgj_test.go:57: expected '[%!s(int=2) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=2) %!s(int=2)\
    \ %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmp9v71fdgj_test.go:57: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=2) %!s(int=1)\
    \ %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074876
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    m := make([]int, 0)\n    return m\n}\n\nfunc TestParse_Music(t\
    \ *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"\
    ), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"),\
    \ expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o\
    \ o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"\
    o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmp0atj2uph_test.go:39: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmp0atj2uph_test.go:39: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmp0atj2uph_test.go:39:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmp0atj2uph_test.go:39: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074876
- exit_code: 0
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    var result []int\n    for _, note := range music_string\
    \ {\n        switch {\n        case note == 'o':\n            result = append(result,\
    \ 4)\n        case note == '|':\n            if result[len(result)-1] == 4 {\n\
    \                result[len(result)-1] = 2\n            } else {\n           \
    \     result[len(result)-1] = 1\n            }\n        case note == '.':\n  \
    \          result = append(result, 1)\n        }\n    }\n    return result\n}\n\
    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual:\
    \ candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\"\
    .| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o|\
    \ o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual:\
    \ candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.008s\n"
  timestamp: 1660074876
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    var res []int\n    notes := make(map[string]int)\n    notes[\"\
    o\"] = 4\n    notes[\"o|\"] = 2\n    notes[\".|\"] = 1\n    for _, v := range\
    \ music_string {\n        res = append(res, notes[string(v)])\n    }\n    return\
    \ res\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n \
    \    { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual:\
    \ candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4}\
    \ },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2,\
    \ 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpdvpprw3f_test.go:46: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=4) %!s(int=0) %!s(int=4) %!s(int=0) %!s(int=4) %!s(int=0)\
    \ %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmpdvpprw3f_test.go:46:\
    \ expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[%!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n\
    \        tmpdvpprw3f_test.go:46: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1)\
    \ %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=0) %!s(int=0)\
    \ %!s(int=4) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=4) %!s(int=0) %!s(int=4) %!s(int=0) %!s(int=4)\
    \ %!s(int=0) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n\
    \        tmpdvpprw3f_test.go:46: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1)\
    \ %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=4) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=4) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=4) %!s(int=0) %!s(int=4) %!s(int=0) %!s(int=0)\
    \ %!s(int=4) %!s(int=0) %!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074876
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    return []int{}\n}\n\nfunc TestParse_Music(t *testing.T)\
    \ {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpqorsmevh_test.go:38: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpqorsmevh_test.go:38: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpqorsmevh_test.go:38:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpqorsmevh_test.go:38: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074654
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    return nil\n}\n\nfunc TestParse_Music(t *testing.T) {\n\
    \  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"\
    ), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpv8cxx1gh_test.go:38: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpv8cxx1gh_test.go:38: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpv8cxx1gh_test.go:38:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpv8cxx1gh_test.go:38: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074654
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    var b []int\n    for _, c := range music_string {\n   \
    \     switch c {\n        case 'o':\n            b = append(b, 4)\n        case\
    \ '|':\n            if len(b) == 0 {\n                b = append(b, 2)\n     \
    \       } else {\n                b[len(b)-1] = b[len(b)-1]/2\n            }\n\
    \        case '.':\n            if len(b) == 0 {\n                b = append(b,\
    \ 1)\n            } else {\n                b[len(b)-1] = b[len(b)-1]/2\n    \
    \        }\n        }\n    }\n    return b\n}\n\nfunc TestParse_Music(t *testing.T)\
    \ {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__2\
    \ (0.00s)\n        tmpmq10fiem_test.go:57: expected '[%!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1)]', got '[%!s(int=0)]'\n    --- FAIL: TestParse_Music/test_num__3\
    \ (0.00s)\n        tmpmq10fiem_test.go:57: expected '[%!s(int=2) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=2) %!s(int=0)\
    \ %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpmq10fiem_test.go:57: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=0) %!s(int=0)\
    \ %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074876
- exit_code: 2
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n\tbs := []byte(music_string)\n\tresult := make([]int, len(bs))\n\
    \tcurrent_position := 0\n\tfor _, char := range bs {\n\t\tif current_position\
    \ == len(bs) - 1 {\n\t\t\treturn result\n\t\t}\n\t\tswitch char {\n\t\tcase 'o':\n\
    \t\t\tresult[current_position] = 4\n\t\t\tcurrent_position += 2\n\t\tcase 'o':\n\
    \t\t\tresult[current_position] = 2\n\t\t\tcurrent_position += 2\n\t\tcase '.':\n\
    \t\t\tresult[current_position] = 1\n\t\t\tcurrent_position += 2\n\t\tdefault:\n\
    \t\t\tcurrent_position += 1\n\t\t}\n\t}\n\treturn result\n}\n\nfunc TestParse_Music(t\
    \ *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"\
    ), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"),\
    \ expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o\
    \ o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"\
    o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl1yqahj2_test.go:29:8:\
    \ duplicate case 'o' (constant 111 of type byte) in expression switch\n\t/tmp/tmpl1yqahj2_test.go:26:8:\
    \ previous case\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074875
- exit_code: 2
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    var note_values = map[string]int {\n        \"o\": 4,\n\
    \        \"o|\": 2,\n        \".|\": 1,\n    }\n    var notes []int\n    var notes_by_string\
    \ = []string{\"o\", \"o|\", \".|\"}\n    for _, note_string := range notes_by_string\
    \ {\n        for {\n            index := strings.Index(music_string, note_string)\n\
    \            if index < 0 {\n                break\n            }\n          \
    \  notes = append(notes, note_values[note_string])\n            music_string =\
    \ music_string[index + len(note_string):]\n        }\n    }\n    return notes\n\
    }\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual:\
    \ candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\"\
    .| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o|\
    \ o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual:\
    \ candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcadihwwv_test.go:27:22: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074875
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    return []int{}\n}\n\nfunc TestParse_Music(t *testing.T)\
    \ {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpqorsmevh_test.go:38: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpqorsmevh_test.go:38: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpqorsmevh_test.go:38:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpqorsmevh_test.go:38: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074654
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    return []int{}\n}\n\nfunc TestParse_Music(t *testing.T)\
    \ {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpqorsmevh_test.go:38: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpqorsmevh_test.go:38: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpqorsmevh_test.go:38:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpqorsmevh_test.go:38: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074654
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    var notes_info []int\n    notes_info = append(notes_info,\
    \ 0)\n\n    for i := 0; i < len(music_string); i++ {\n        var beats_count\
    \ int\n        var ch string\n\n        if i == len(music_string) - 1 {\n    \
    \        ch = music_string[i:i+1]\n        } else {\n            ch = music_string[i:i+2]\n\
    \        }\n\n        switch ch {\n        case \"o\":\n            beats_count\
    \ = 4\n        case \"o|\":\n            beats_count = 2\n        case \".|\"\
    :\n            beats_count = 1\n        default:\n            panic(\"Error\"\
    )\n        }\n\n        notes_info = append(notes_info, beats_count)\n    }\n\n\
    \    return notes_info\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate\
    \ := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4,\
    \ 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1}\
    \ },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2,\
    \ 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected:\
    \ []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\npanic: Error [recovered]\n\tpanic: Error\n\
    \ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x4fde20, 0x549ce8})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x4fde20, 0x549ce8})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.parse_music({0x51eb1d, 0x7})\n\t/tmp/tmpsblis5qf_test.go:39\
    \ +0x172\ncommand-line-arguments_test.TestParse_Music(0x0?)\n\t/tmp/tmpsblis5qf_test.go:56\
    \ +0x73\ntesting.tRunner(0xc0000da1a0, 0x529038)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074876
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    return nil\n}\n\nfunc TestParse_Music(t *testing.T) {\n\
    \  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"\
    ), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpv8cxx1gh_test.go:38: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpv8cxx1gh_test.go:38: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpv8cxx1gh_test.go:38:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpv8cxx1gh_test.go:38: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074654
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    // check whether input is empty\n    if len(music_string)\
    \ == 0 {\n        return []int{}\n    }\n\n    // check whether the end of the\
    \ string is valid\n    last_char := music_string[len(music_string) - 1]\n    if\
    \ last_char != 'o' && last_char != '|' {\n        panic(\"invalid input\")\n \
    \   }\n\n    // parse string\n    result := []int{}\n    cur_note := 0\n    for\
    \ i := 0; i < len(music_string); i++ {\n        switch music_string[i] {\n   \
    \     case 'o':\n            if cur_note == 0 {\n                cur_note = 4\n\
    \            } else {\n                result = append(result, cur_note)\n   \
    \             cur_note = 4\n            }\n        case '|':\n            if i\
    \ > 0 && music_string[i - 1] == '.' {\n                cur_note = 1\n        \
    \    } else if i > 0 && music_string[i - 1] == 'o' {\n                cur_note\
    \ = 2\n            } else {\n                panic(\"invalid input\")\n      \
    \      }\n        case ' ':\n            if cur_note > 0 {\n                result\
    \ = append(result, cur_note)\n                cur_note = 0\n            }\n  \
    \      default:\n            panic(\"invalid input\")\n        }\n    }\n    result\
    \ = append(result, cur_note)\n    return result\n}\n\nfunc TestParse_Music(t *testing.T)\
    \ {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\npanic: invalid input [recovered]\n\t\
    panic: invalid input\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x4fde20,\
    \ 0x549cf8})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x4fde20, 0x549cf8})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.parse_music({0x51f7a9, 0xb})\n\t/tmp/tmp820dhi9f_test.go:55\
    \ +0x20e\ncommand-line-arguments_test.TestParse_Music(0x0?)\n\t/tmp/tmp820dhi9f_test.go:71\
    \ +0xa2\ntesting.tRunner(0xc0001031e0, 0x529048)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074876
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    var res []int\n    bpm := 1\n\n    for _, c := range music_string\
    \ {\n        switch c {\n        case 'o':\n            res = append(res, bpm\
    \ * 4)\n        case '|':\n            bpm /= 2\n        case '.':\n         \
    \   res = append(res, bpm)\n        }\n    }\n\n    return res\n}\n\nfunc TestParse_Music(t\
    \ *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"\
    ), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"),\
    \ expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o\
    \ o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"\
    o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__2\
    \ (0.00s)\n        tmpxmf255t4_test.go:52: expected '[%!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1)]', got '[%!s(int=1) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL:\
    \ TestParse_Music/test_num__3 (0.00s)\n        tmpxmf255t4_test.go:52: expected\
    \ '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=4) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n\
    \        tmpxmf255t4_test.go:52: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1)\
    \ %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=4) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074877
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    return []int{}\n}\n\nfunc TestParse_Music(t *testing.T)\
    \ {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpqorsmevh_test.go:38: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpqorsmevh_test.go:38: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpqorsmevh_test.go:38:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpqorsmevh_test.go:38: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074654
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    beats := []int{}\n    running := true\n    i := 0\n   \
    \ curr := 0\n    for running {\n        fmt.Println(i)\n        fmt.Println(len(music_string))\n\
    \        if i < len(music_string) {\n            fmt.Println(i)\n            fmt.Println(string(music_string[i]))\n\
    \            fmt.Println(string(music_string[i+1]))\n            if string(music_string[i])\
    \ == \" \" {\n                i++\n            } else if string(music_string[i])\
    \ == \"o\" {\n                curr = 4\n                i++\n            } else\
    \ if string(music_string[i]) == \".\" {\n                curr = 1\n          \
    \      i++\n            } else if string(music_string[i]) == \"|\" {\n       \
    \         beats = append(beats, curr)\n                curr = 0\n            \
    \    i++\n            } else {\n                i++\n            }\n        }\
    \ else {\n            running = false\n        }\n    }\n    return beats\n}\n\
    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual:\
    \ candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\"\
    .| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o|\
    \ o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual:\
    \ candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "0\n0\n0\n7\n0\no\n \n1\n7\n1\n \no\n2\n7\n2\no\n \n3\n7\n3\n \no\n4\n7\n\
    4\no\n \n5\n7\n5\n \no\n6\n7\n6\no\n--- FAIL: TestParse_Music (0.00s)\npanic:\
    \ runtime error: index out of range [7] with length 7 [recovered]\n\tpanic: runtime\
    \ error: index out of range [7] with length 7\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x5136e0,\
    \ 0xc0001ce000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x5136e0, 0xc0001ce000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.parse_music({0x51eb1d, 0x7})\n\t/tmp/tmp_4tyh1fh_test.go:28\
    \ +0x429\ncommand-line-arguments_test.TestParse_Music(0x0?)\n\t/tmp/tmp_4tyh1fh_test.go:59\
    \ +0x73\ntesting.tRunner(0xc00019b040, 0x529038)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074878
- exit_code: 2
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    music_slice := make([]int, 0)\n    splitted_by_note :=\
    \ strings.Split(music_string, \" \")\n    for _, note := range splitted_by_note\
    \ {\n        note_duration := note[:len(note)-1]\n        switch note_duration\
    \ {\n        case \"o\":\n            music_slice = append(music_slice, 4)\n \
    \       case \"o|\":\n            music_slice = append(music_slice, 2)\n     \
    \   case \".|\":\n            music_slice = append(music_slice, 1)\n        }\n\
    \    }\n    return music_slice\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate\
    \ := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4,\
    \ 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1}\
    \ },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2,\
    \ 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected:\
    \ []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4w4jkegc_test.go:19:25: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074877
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    return nil\n}\n\nfunc TestParse_Music(t *testing.T) {\n\
    \  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"\
    ), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpv8cxx1gh_test.go:38: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpv8cxx1gh_test.go:38: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpv8cxx1gh_test.go:38:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpv8cxx1gh_test.go:38: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074654
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    beats := []int{}\n    count := 0\n    for _, c := range\
    \ music_string {\n        if c == 'o' {\n            beats = append(beats, 4)\n\
    \        } else if c == '|' {\n            beats[count] /= 2\n        } else if\
    \ c == '.' {\n            beats[count] /= 2\n            count++\n        }\n\
    \    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate\
    \ := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4,\
    \ 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1}\
    \ },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2,\
    \ 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected:\
    \ []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 34 [running]:\ntesting.tRunner.func1.2({0x5136e0,\
    \ 0xc0001ce000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x5136e0, 0xc0001ce000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.parse_music(...)\n\t/tmp/tmpwa15_drn_test.go:26\n\
    command-line-arguments_test.TestParse_Music(0x0?)\n\t/tmp/tmpwa15_drn_test.go:42\
    \ +0xdbb\ntesting.tRunner(0xc000184ea0, 0x529038)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074878
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    beats := make([]int, 0)\n    r := []rune(music_string)\n\
    \    last_beat := 0\n    for _, c := range r {\n        if c == '.' {\n      \
    \      beats = append(beats, 1)\n            last_beat = 1\n        } else if\
    \ c == 'o' {\n            if last_beat == 1 {\n                beats[len(beats)-1]\
    \ = 2\n            } else {\n                beats = append(beats, 2)\n      \
    \      }\n            last_beat = 2\n        } else if c == '|' {\n          \
    \  if last_beat == 2 {\n                beats[len(beats)-1] = 4\n            }\
    \ else {\n                beats = append(beats, 4)\n            }\n          \
    \  last_beat = 4\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t\
    \ *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"\
    ), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"),\
    \ expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o\
    \ o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"\
    o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmp4xfhj96e_test.go:61: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2)]'\n    --- FAIL:\
    \ TestParse_Music/test_num__2 (0.00s)\n        tmp4xfhj96e_test.go:61: expected\
    \ '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[%!s(int=1) %!s(int=4)\
    \ %!s(int=1) %!s(int=4) %!s(int=1) %!s(int=4) %!s(int=1) %!s(int=4)]'\n    ---\
    \ FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmp4xfhj96e_test.go:61: expected\
    \ '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=1) %!s(int=4) %!s(int=1) %!s(int=4)\
    \ %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2)]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmp4xfhj96e_test.go:61: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=4) %!s(int=1)\
    \ %!s(int=4) %!s(int=4) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)\
    \ %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074878
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    beats := []int{}\n    for _, char := range music_string\
    \ {\n        switch string(char) {\n        case \"o\":\n            beats = append(beats,\
    \ 4)\n        case \"o|\":\n            beats = append(beats, 2)\n        case\
    \ \".|\":\n            beats = append(beats, 1)\n        case \" \":\n       \
    \     // Do nothing\n        default:\n            panic(fmt.Sprintf(\"Unknown\
    \ character: %s\", string(char)))\n        }\n    }\n    return beats\n}\n\nfunc\
    \ TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"\
    o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .|\
    \ .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .|\
    \ o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"\
    o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\npanic: Unknown character: . [recovered]\n\
    \tpanic: Unknown character: .\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x4fde20,\
    \ 0xc000092530})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x4fde20, 0xc000092530})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.parse_music({0x51f7a9, 0xb})\n\t/tmp/tmpolu_n91m_test.go:30\
    \ +0x239\ncommand-line-arguments_test.TestParse_Music(0x0?)\n\t/tmp/tmpolu_n91m_test.go:45\
    \ +0xa2\ntesting.tRunner(0xc0000cc4e0, 0x529050)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074878
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    var res = make([]int,0)\n    var temp = make([]int,0)\n\
    \    var state = ' '\n    var j int = 0\n    for i := 0; i < len(music_string);\
    \ i++ {\n        switch {\n        case music_string[i] == 'o':\n            if\
    \ music_string[i+1] == '|' {\n                temp = append(temp, 2)\n       \
    \         state = '|'\n            } else {\n                temp = append(temp,\
    \ 4)\n                state = ' '\n            }\n        case music_string[i]\
    \ == '.':\n            if music_string[i+1] == '|' {\n                temp = append(temp,\
    \ 1)\n                state = '|'\n            } else {\n                temp\
    \ = append(temp, 0)\n                state = ' '\n            }\n        case\
    \ music_string[i] == '|':\n            if state == '|' {\n                res\
    \ = append(res, temp[j])\n                j++\n            }\n        }\n    }\n\
    \    return res\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n \
    \    { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual:\
    \ candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4}\
    \ },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2,\
    \ 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\npanic: runtime error: index out of range\
    \ [7] with length 7 [recovered]\n\tpanic: runtime error: index out of range [7]\
    \ with length 7\n\ngoroutine 4 [running]:\ntesting.tRunner.func1.2({0x5136e0,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x5136e0, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.parse_music({0x51eb1d, 0x7})\n\t/tmp/tmpd56ami44_test.go:25\
    \ +0x3a5\ncommand-line-arguments_test.TestParse_Music(0x0?)\n\t/tmp/tmpd56ami44_test.go:58\
    \ +0x73\ntesting.tRunner(0xc0000e01a0, 0x529038)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074878
- exit_code: 0
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    // Your code here.\n    // Note: this is a tricky problem,\
    \ usually not easy to solve using only strings and loops.\n    //       If you\
    \ can't do it, then you should use `strings.Fields` and slices.\n\n    // And\
    \ here is one of the possible solutions:\n    var result []int\n    for i := 0;\
    \ i < len(music_string); i++ {\n        if music_string[i] == 'o' {\n        \
    \    if (i < len(music_string) - 1) && (music_string[i+1] == '|') {\n        \
    \        result = append(result, 2)\n                i++\n            } else {\n\
    \                result = append(result, 4)\n            }\n        } else if\
    \ music_string[i] == '.' {\n            result = append(result, 1)\n         \
    \   i++\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T)\
    \ {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074878
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    var res []int\n    for _, val := range(music_string) {\n\
    \        switch val {\n        case 'o':\n            res = append(res, 4)\n \
    \       case '|':\n            // do nothing\n        case '.':\n            res\
    \ = append(res, 1)\n        }\n    }\n    return res\n}\n\nfunc TestParse_Music(t\
    \ *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"\
    ), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"),\
    \ expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o\
    \ o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"\
    o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__3\
    \ (0.00s)\n        tmps39iyhuq_test.go:49: expected '[%!s(int=2) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=4)\
    \ %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    ---\
    \ FAIL: TestParse_Music/test_num__4 (0.00s)\n        tmps39iyhuq_test.go:49: expected\
    \ '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4)\
    \ %!s(int=2)]', got '[%!s(int=4) %!s(int=1) %!s(int=4) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074878
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    var result []int\n    current_beat := 0\n    current_note\
    \ := \"\"\n    for _, char := range music_string {\n        current_note += string(char)\n\
    \        switch current_note {\n        case \"o\":\n            current_beat\
    \ = 4\n        case \"o|\":\n            current_beat = 2\n        case \".|\"\
    :\n            current_beat = 1\n        default:\n            result = append(result,\
    \ current_beat)\n            current_note = \"\"\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n \
    \    { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual:\
    \ candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4}\
    \ },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2,\
    \ 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpiktc6vlt_test.go:55: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__2\
    \ (0.00s)\n        tmpiktc6vlt_test.go:55: expected '[%!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Music/test_num__3\
    \ (0.00s)\n        tmpiktc6vlt_test.go:55: expected '[%!s(int=2) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=2) %!s(int=2)\
    \ %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n\
    \        tmpiktc6vlt_test.go:55: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1)\
    \ %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=2) %!s(int=2) %!s(int=2)\
    \ %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=4) %!s(int=2)\
    \ %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074878
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    fmt.Println(music_string)\n    return []int{}\n}\n\nfunc\
    \ TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"\
    o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .|\
    \ .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .|\
    \ o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"\
    o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "\no o o o\n.| .| .| .|\no| o| .| .| o o o o\no| .| o| .| o o| o o|\n---\
    \ FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1 (0.00s)\n\
    \        tmpd8tgnydq_test.go:39: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmpd8tgnydq_test.go:39:\
    \ expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[]'\n    ---\
    \ FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpd8tgnydq_test.go:39: expected\
    \ '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n\
    \        tmpd8tgnydq_test.go:39: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1)\
    \ %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074878
- exit_code: 0
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n\tresult := make([]int, 0)\n\tfor i := 0; i < len(music_string);\
    \ i++ {\n\t\tswitch music_string[i] {\n\t\tcase 'o':\n\t\t\tif i + 1 < len(music_string)\
    \ && music_string[i+1] == '|' {\n\t\t\t\tresult = append(result, 2)\n\t\t\t\t\
    i++\n\t\t\t} else {\n\t\t\t\tresult = append(result, 4)\n\t\t\t}\n\t\tcase '.':\n\
    \t\t\tif i + 1 < len(music_string) && music_string[i+1] == '|' {\n\t\t\t\tresult\
    \ = append(result, 1)\n\t\t\t\ti++\n\t\t\t}\n\t\t}\n\t}\n\treturn result\n}\n\n\
    func TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual:\
    \ candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\"\
    .| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o|\
    \ o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual:\
    \ candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.013s\n"
  timestamp: 1660074878
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    note_duration := map[string]int{\n        \"o\": 4,\n \
    \       \"o|\": 2,\n        \".|\": 1,\n    }\n    notes := []int{}\n    for _,\
    \ note := range music_string {\n        if note == ' ' {\n            continue\n\
    \        }\n        notes = append(notes, note_duration[string(note)])\n    }\n\
    \    return notes\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n \
    \    { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual:\
    \ candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4}\
    \ },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2,\
    \ 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__2\
    \ (0.00s)\n        tmpsgvr9oqd_test.go:50: expected '[%!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n\
    \        tmpsgvr9oqd_test.go:50: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1)\
    \ %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=0) %!s(int=4)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n\
    \        tmpsgvr9oqd_test.go:50: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1)\
    \ %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=4) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=4) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=4) %!s(int=4)\
    \ %!s(int=0) %!s(int=4) %!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074878
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    // TODO: implement here\n    return nil\n}\n\nfunc TestParse_Music(t\
    \ *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"\
    ), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"),\
    \ expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o\
    \ o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"\
    o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpujyy27lc_test.go:39: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpujyy27lc_test.go:39: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpujyy27lc_test.go:39:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpujyy27lc_test.go:39: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074878
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    fmt.Println(music_string)\n    beats := make([]int, 0)\n\
    \    i := 0\n    for i < len(music_string) {\n        switch music_string[i] {\n\
    \        case 'o':\n            if music_string[i + 1] == ' ' {\n            \
    \    beats = append(beats, 4)\n                i += 2\n            } else {\n\
    \                beats = append(beats, 2)\n                i += 3\n          \
    \  }\n        case '.':\n            beats = append(beats, 1)\n            i +=\
    \ 3\n        default:\n            i += 1\n        }\n    }\n    return beats\n\
    }\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual:\
    \ candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\"\
    .| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o|\
    \ o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual:\
    \ candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "\no o o o\n--- FAIL: TestParse_Music (0.00s)\npanic: runtime error: index\
    \ out of range [7] with length 7 [recovered]\n\tpanic: runtime error: index out\
    \ of range [7] with length 7\n\ngoroutine 34 [running]:\ntesting.tRunner.func1.2({0x5136e0,\
    \ 0xc0001d8000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x5136e0, 0xc0001d8000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.parse_music({0x51eb1d, 0x7})\n\t/tmp/tmp172iam7o_test.go:24\
    \ +0x1d5\ncommand-line-arguments_test.TestParse_Music(0x0?)\n\t/tmp/tmp172iam7o_test.go:49\
    \ +0x73\ntesting.tRunner(0xc000199040, 0x529038)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.010s\nFAIL\n"
  timestamp: 1660074878
- exit_code: 2
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    var r []int\n    var len_str int = len(music_string)\n\
    \    var index int = 0\n    for i := 0; i < len_str; i++ {\n        if music_string[i]\
    \ == 'o' {\n            if i+1 < len_str && music_string[i+1] == '|' {\n     \
    \           r = append(r, 2)\n                i++\n            } else {\n    \
    \            r = append(r, 4)\n            }\n        } else if music_string[i]\
    \ == '.' {\n            if i+1 < len_str && music_string[i+1] == '|' {\n     \
    \           r = append(r, 1)\n                i++\n            }\n        }\n\
    \    }\n    return r\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate :=\
    \ parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n\
    \     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual:\
    \ candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4}\
    \ },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2,\
    \ 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3nfwh4g1_test.go:20:9: index declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074878
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    beats := make([]int, 0)\n    return beats\n}\n\nfunc TestParse_Music(t\
    \ *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"\
    ), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"),\
    \ expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o\
    \ o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"\
    o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmp9vcc2t3n_test.go:39: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmp9vcc2t3n_test.go:39: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmp9vcc2t3n_test.go:39:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmp9vcc2t3n_test.go:39: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074878
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    runes := []rune(music_string)\n    result := make([]int,\
    \ 0)\n    for index, note := range runes {\n        if string(note) == \"o\" {\n\
    \            result = append(result, 4)\n        } else if string(note) == \"\
    .\" {\n            result = append(result, 1)\n        } else if string(note)\
    \ == \"|\" {\n            if index > 0 && string(runes[index-1]) == \"o\" {\n\
    \                result = append(result, 2)\n            } else if index > 0 &&\
    \ string(runes[index-1]) == \".\" {\n                result = append(result, 1)\n\
    \            }\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t\
    \ *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"\
    ), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"),\
    \ expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o\
    \ o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"\
    o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__2\
    \ (0.00s)\n        tmp3n98f910_test.go:53: expected '[%!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1)]', got '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1)]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n\
    \        tmp3n98f910_test.go:53: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1)\
    \ %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=2) %!s(int=4)\
    \ %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n\
    \        tmp3n98f910_test.go:53: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1)\
    \ %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=4) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=2) %!s(int=4) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.008s\nFAIL\n"
  timestamp: 1660074878
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    return []int{}\n}\n\nfunc TestParse_Music(t *testing.T)\
    \ {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpqorsmevh_test.go:38: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpqorsmevh_test.go:38: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpqorsmevh_test.go:38:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpqorsmevh_test.go:38: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074654
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    return []int{}\n}\n\nfunc TestParse_Music(t *testing.T)\
    \ {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpqorsmevh_test.go:38: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpqorsmevh_test.go:38: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpqorsmevh_test.go:38:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpqorsmevh_test.go:38: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074654
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    // split by whitespace\n    var music_list []string = make([]string,\
    \ 0)\n    for i, ch := range music_string {\n        if ch == ' ' {\n        \
    \    music_list = append(music_list, music_string[:i])\n            music_string\
    \ = music_string[i+1:]\n        }\n    }\n    music_list = append(music_list,\
    \ music_string)\n\n    // parse & return\n    beats := make([]int, 0)\n    for\
    \ _, music := range music_list {\n        switch music {\n        case \"o\":\n\
    \            beats = append(beats, 4)\n        case \"o|\":\n            beats\
    \ = append(beats, 2)\n        case \".|\":\n            beats = append(beats,\
    \ 1)\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T)\
    \ {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\npanic: runtime error: slice bounds out\
    \ of range [:5] with length 1 [recovered]\n\tpanic: runtime error: slice bounds\
    \ out of range [:5] with length 1\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x5146e0,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x5146e0, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.parse_music(...)\n\t/tmp/tmp57_joufb_test.go:22\n\
    command-line-arguments_test.TestParse_Music(0x0?)\n\t/tmp/tmp57_joufb_test.go:51\
    \ +0x15d3\ntesting.tRunner(0xc0000da340, 0x52a038)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074878
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    var res = make([]int, 0)\n    var c rune\n\n    c = []rune(music_string)[0]\n\
    \    if c == 'o' {\n        res = append(res, 4)\n    } else if c == 'o' {\n \
    \       res = append(res, 2)\n    } else if c == '.' {\n        res = append(res,\
    \ 1)\n    }\n\n    return res\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate\
    \ := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4,\
    \ 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1}\
    \ },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2,\
    \ 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected:\
    \ []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x5136e0,\
    \ 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x5136e0, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.parse_music(...)\n\t/tmp/tmph5ysxjm1_test.go:21\n\
    command-line-arguments_test.TestParse_Music(0x0?)\n\t/tmp/tmph5ysxjm1_test.go:40\
    \ +0x83c\ntesting.tRunner(0xc000103380, 0x529038)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074878
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    return []int{1, 2, 3}\n}\n\nfunc TestParse_Music(t *testing.T)\
    \ {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__0\
    \ (0.00s)\n        tmpdkbj3crh_test.go:38: expected '[]', got '[%!s(int=1) %!s(int=2)\
    \ %!s(int=3)]'\n    --- FAIL: TestParse_Music/test_num__1 (0.00s)\n        tmpdkbj3crh_test.go:38:\
    \ expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=1) %!s(int=2)\
    \ %!s(int=3)]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmpdkbj3crh_test.go:38:\
    \ expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[%!s(int=1) %!s(int=2)\
    \ %!s(int=3)]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpdkbj3crh_test.go:38:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=3)]'\n    --- FAIL:\
    \ TestParse_Music/test_num__4 (0.00s)\n        tmpdkbj3crh_test.go:38: expected\
    \ '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4)\
    \ %!s(int=2)]', got '[%!s(int=1) %!s(int=2) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074878
- exit_code: 2
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    noteMap := map[string]int{\n        \"o\": 4,\n       \
    \ \"o|\": 2,\n        \".|\": 1,\n    }\n    notes := strings.Split(music_string,\
    \ \" \")\n    result := make([]int, len(notes))\n    for i, note := range notes\
    \ {\n        result[i] = noteMap[note]\n    }\n    return result\n}\n\nfunc TestParse_Music(t\
    \ *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"\
    ), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"),\
    \ expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o\
    \ o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"\
    o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfkluk8hp_test.go:23:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074878
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    beats := make([]int,0)\n    var beat int\n    for _, v\
    \ := range music_string {\n        if v == 'o' {\n            beat = 4\n     \
    \   } else if v == '|' {\n            beat -= 1\n        } else if v == '.' {\n\
    \            beat -= 2\n        } else if v == ' ' {\n            beats = append(beats,\
    \ beat)\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T)\
    \ {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpci9s200r_test.go:51: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__2\
    \ (0.00s)\n        tmpci9s200r_test.go:51: expected '[%!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1)]', got '[%!s(int=-3) %!s(int=-6) %!s(int=-9)]'\n    --- FAIL: TestParse_Music/test_num__3\
    \ (0.00s)\n        tmpci9s200r_test.go:51: expected '[%!s(int=2) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=3) %!s(int=3)\
    \ %!s(int=0) %!s(int=-3) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpci9s200r_test.go:51: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=3) %!s(int=0)\
    \ %!s(int=3) %!s(int=0) %!s(int=4) %!s(int=3) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074879
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    panic(\"Not Implemented\")\n}\n\nfunc TestParse_Music(t\
    \ *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"\
    ), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"),\
    \ expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o\
    \ o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"\
    o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\npanic: Not Implemented [recovered]\n\
    \tpanic: Not Implemented\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x4fcd60,\
    \ 0x548930})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x4fcd60, 0x548930})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.parse_music(...)\n\t/tmp/tmpo4ohk0vf_test.go:18\n\
    command-line-arguments_test.TestParse_Music(0x0?)\n\t/tmp/tmpo4ohk0vf_test.go:28\
    \ +0x27\ntesting.tRunner(0xc0001031e0, 0x527d48)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074879
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    return []int{}\n}\n\nfunc TestParse_Music(t *testing.T)\
    \ {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpqorsmevh_test.go:38: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpqorsmevh_test.go:38: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpqorsmevh_test.go:38:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpqorsmevh_test.go:38: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074654
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    var result []int\n    for i := 0; i < len(music_string);\
    \ i++ {\n        switch music_string[i] {\n        case 'o':\n            result\
    \ = append(result, 4)\n        case '.':\n            result = append(result,\
    \ 1)\n        case '|':\n            result[len(result)-1] /= 2\n        }\n \
    \   }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate\
    \ := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4,\
    \ 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1}\
    \ },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2,\
    \ 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected:\
    \ []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__2\
    \ (0.00s)\n        tmpj558hyp9_test.go:49: expected '[%!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL:\
    \ TestParse_Music/test_num__3 (0.00s)\n        tmpj558hyp9_test.go:49: expected\
    \ '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=2) %!s(int=2) %!s(int=0) %!s(int=0) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n\
    \        tmpj558hyp9_test.go:49: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1)\
    \ %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=2) %!s(int=0) %!s(int=2)\
    \ %!s(int=0) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074762
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    var result []int\n    for _, char := range music_string\
    \ {\n        switch char {\n        case 'o':\n            result = append(result,\
    \ 4)\n        case '|':\n            result[len(result)-1] = result[len(result)-1]\
    \ / 2\n        case '.':\n            result[len(result)-1] = result[len(result)-1]\
    \ / 4\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T)\
    \ {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\npanic: runtime error: index out of range\
    \ [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine\
    \ 20 [running]:\ntesting.tRunner.func1.2({0x5136e0, 0xc000164000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x5136e0, 0xc000164000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.parse_music(...)\n\t/tmp/tmpiagbf780_test.go:26\n\
    command-line-arguments_test.TestParse_Music(0x0?)\n\t/tmp/tmpiagbf780_test.go:41\
    \ +0xd26\ntesting.tRunner(0xc0001036c0, 0x529038)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074879
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    beats := []int{}\n    for _, c := range music_string {\n\
    \        if c == 'o' {\n            beats = append(beats, 4)\n        } else if\
    \ c == '|' {\n            last_beat := beats[len(beats) - 1]\n            beats[len(beats)\
    \ - 1] = last_beat / 2\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t\
    \ *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"\
    ), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"),\
    \ expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o\
    \ o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"\
    o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\npanic: runtime error: index out of range\
    \ [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine\
    \ 6 [running]:\ntesting.tRunner.func1.2({0x5136e0, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x5136e0, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.parse_music(...)\n\t/tmp/tmpdvblfx5v_test.go:23\n\
    command-line-arguments_test.TestParse_Music(0x0?)\n\t/tmp/tmpdvblfx5v_test.go:39\
    \ +0xbe5\ntesting.tRunner(0xc0000da340, 0x529038)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074879
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    fmt.Println(music_string)\n    return nil\n}\n\nfunc TestParse_Music(t\
    \ *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"\
    ), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"),\
    \ expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o\
    \ o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"\
    o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "\no o o o\n.| .| .| .|\no| o| .| .| o o o o\no| .| o| .| o o| o o|\n---\
    \ FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1 (0.00s)\n\
    \        tmpybcs_0l9_test.go:39: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmpybcs_0l9_test.go:39:\
    \ expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[]'\n    ---\
    \ FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpybcs_0l9_test.go:39: expected\
    \ '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n\
    \        tmpybcs_0l9_test.go:39: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1)\
    \ %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074880
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n\t\n\tvar music []int\n\n\tfor i := 0; i < len(music_string);\
    \ i++ {\n\t\tif music_string[i] == 'o' {\n\t\t\tmusic = append(music, 4)\n\t\t\
    } else if music_string[i] == '.' {\n\t\t\tmusic = append(music, 1)\n\t\t}\n\t\
    }\n\n\treturn music\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate :=\
    \ parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n\
    \     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual:\
    \ candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4}\
    \ },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2,\
    \ 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__3\
    \ (0.00s)\n        tmp268wgc3z_test.go:49: expected '[%!s(int=2) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=4)\
    \ %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    ---\
    \ FAIL: TestParse_Music/test_num__4 (0.00s)\n        tmp268wgc3z_test.go:49: expected\
    \ '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4)\
    \ %!s(int=2)]', got '[%!s(int=4) %!s(int=1) %!s(int=4) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074880
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    //TODO: Implement function here\n    return nil\n}\n\n\
    func TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual:\
    \ candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\"\
    .| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o|\
    \ o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual:\
    \ candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmp6boggr3c_test.go:39: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmp6boggr3c_test.go:39: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmp6boggr3c_test.go:39:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmp6boggr3c_test.go:39: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074880
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    return nil\n}\n\nfunc TestParse_Music(t *testing.T) {\n\
    \  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"\
    ), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpv8cxx1gh_test.go:38: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpv8cxx1gh_test.go:38: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpv8cxx1gh_test.go:38:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpv8cxx1gh_test.go:38: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074654
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    note_durations := make([]int, 0)\n    duration := 4\n \
    \   last_char := \"\"\n    for i, _ := range music_string {\n        switch music_string[i]\
    \ {\n        case '|':\n            if last_char == \"o\" {\n                duration\
    \ = 2\n            } else {\n                duration = 1\n            }\n   \
    \     case 'o':\n            duration = 4\n        case '.':\n            duration\
    \ = 1\n        }\n        last_char = string(music_string[i])\n        note_durations\
    \ = append(note_durations, duration)\n    }\n    return note_durations\n}\n\n\
    func TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual:\
    \ candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\"\
    .| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o|\
    \ o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual:\
    \ candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmp4ll_8yb2_test.go:57: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmp4ll_8yb2_test.go:57:\
    \ expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[%!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1)]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n\
    \        tmp4ll_8yb2_test.go:57: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1)\
    \ %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=2) %!s(int=2)\
    \ %!s(int=4) %!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n\
    \        tmp4ll_8yb2_test.go:57: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1)\
    \ %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=4) %!s(int=2) %!s(int=2)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=2) %!s(int=2)\
    \ %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074880
- exit_code: 2
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    r := []rune(music_string)\n    var beats []int\n    var\
    \ t []rune\n    for i := 0; i < len(r); i++ {\n        if string(r[i]) == \"o\"\
    \ {\n            // o o| .| o| o| .| .| .| .| o o\n            if i < len(r) -\
    \ 1 && string(r[i+1]) == \" \" {\n                beats = append(beats, 4)\n \
    \           } else if i < len(r) - 2 && string(r[i+1]) == \"|\" && string(r[i+2])\
    \ == \" \" {\n                beats = append(beats, 2)\n                i += 2\n\
    \            } else if i < len(r) - 1 && string(r[i+1]) == \"|\" {\n         \
    \       beats = append(beats, 4)\n                i += 1\n            }\n    \
    \    } else if string(r[i]) == \".\" {\n            if i < len(r) - 2 && string(r[i+1])\
    \ == \"|\" && string(r[i+2]) == \" \" {\n                beats = append(beats,\
    \ 1)\n                i += 2\n            } else if i < len(r) - 1 && string(r[i+1])\
    \ == \"|\" {\n                beats = append(beats, 2)\n                i += 1\n\
    \            }\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t\
    \ *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"\
    ), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"),\
    \ expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o\
    \ o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"\
    o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpn0i_di9u_test.go:20:9: t declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074880
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    return []int{}\n}\n\nfunc TestParse_Music(t *testing.T)\
    \ {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpqorsmevh_test.go:38: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpqorsmevh_test.go:38: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpqorsmevh_test.go:38:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpqorsmevh_test.go:38: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074654
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    music_string_length := len(music_string)\n    if music_string_length\
    \ == 0 {\n        return []int{}\n    }\n    music_string_copy := music_string\n\
    \    counts := []int{}\n    if string(music_string_copy[0]) == \"o\" {\n     \
    \   counts = append(counts, 4)\n        music_string_copy = music_string_copy[1:]\n\
    \    } else if string(music_string_copy[0]) == \"o\" && string(music_string_copy[1])\
    \ == \"|\" {\n        counts = append(counts, 2)\n        music_string_copy =\
    \ music_string_copy[2:]\n    } else if string(music_string_copy[0]) == \".\" &&\
    \ string(music_string_copy[1]) == \"|\" {\n        counts = append(counts, 1)\n\
    \        music_string_copy = music_string_copy[2:]\n    }\n    return append(counts,\
    \ parse_music(music_string_copy)...)\n}\n\nfunc TestParse_Music(t *testing.T)\
    \ {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160380\
    \ stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x52041a?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\nruntime.intstring(0xc0201603e4?, 0x20?)\n\t\
    /home/a.guha/.conda/envs/polyglot/go/src/runtime/string.go:253 +0xb5 fp=0xc020160390\
    \ sp=0xc020160388 pc=0x44e075\ncommand-line-arguments_test.parse_music({0x51eb1e,\
    \ 0x6})\n\t/tmp/tmp1ii4z0qy_test.go:24 +0x54 fp=0xc020160428 sp=0xc020160390 pc=0x4ef6b4\n\
    command-line-arguments_test.parse_music({0x51eb1e, 0x6})\n\t/tmp/tmp1ii4z0qy_test.go:34\
    \ +0x28d fp=0xc0201604c0 sp=0xc020160428 pc=0x4ef8ed\ncommand-line-arguments_test.parse_music({0x51eb1e,\
    \ 0x6})\n\t/tmp/tmp1ii4z0qy_test.go:34 +0x28d fp=0xc020160558 sp=0xc0201604c0\
    \ pc=0x4ef8ed\ncommand-line-arguments_test.parse_music({0x51eb1e, 0x6})\n\t/tmp/tmp1ii4z0qy_test.go:34\
    \ +0x28d fp=0xc0201605f0 sp=0xc020160558 pc=0x4ef8ed\ncommand-line-arguments_test.parse_music({0x51eb1e,\
    \ 0x6})\n\t/tmp/tmp1ii4z0qy_test.go:34 +0x28d fp=0xc020160688 sp=0xc0201605f0\
    \ pc=0x4ef8ed\ncommand-line-arguments_test.parse_music({0x51eb1e, 0x6})\n\t/tmp/tmp1ii4z0qy_test.go:34\
    \ +0x28d fp=0xc020160720 sp=0xc020160688 pc=0x4ef8ed\ncommand-line-arguments_test.parse_music({0x51eb1e,\
    \ 0x6})\n\t/tmp/tmp1ii4z0qy_test.go:34 +0x28d fp=0xc0201607b8 sp=0xc020160720\
    \ pc=0x4ef8ed\ncommand-line-arguments_test.parse_music({0x51eb1e, 0x6})\n\t/tmp/tmp1ii4z0qy_test.go:34\
    \ +0x28d fp=0xc020160850 sp=0xc0201607b8 pc=0x4ef8ed\ncommand-line-arguments_test.parse_music({0x51eb1e,\
    \ 0x6})\n\t/tmp/tmp1ii4z0qy_test.go:34 +0x28d fp=0xc0201608e8 sp=0xc020160850\
    \ pc=0x4ef8ed\ncommand-line-arguments_test.parse_music({0x51eb1e, 0x6})\n\t/tmp/tmp1ii4z0qy_test.go:34\
    \ +0x28d fp=0xc020160980 sp=0xc0201608e8 pc=0x4ef8ed\ncommand-line-arguments_test.parse_music({0x51eb1e,\
    \ 0x"
  timestamp: 1660074881
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    var beats []int\n\n    for _, r := range music_string {\n\
    \        switch r {\n        case 'o':\n            beats = append(beats, 4)\n\
    \        case '.':\n            beats = append(beats, 1)\n        }\n    }\n\n\
    \    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n \
    \    { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual:\
    \ candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4}\
    \ },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2,\
    \ 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__3\
    \ (0.00s)\n        tmpugj4ltdr_test.go:49: expected '[%!s(int=2) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=4)\
    \ %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    ---\
    \ FAIL: TestParse_Music/test_num__4 (0.00s)\n        tmpugj4ltdr_test.go:49: expected\
    \ '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4)\
    \ %!s(int=2)]', got '[%!s(int=4) %!s(int=1) %!s(int=4) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074880
- exit_code: 0
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    var result []int\n    var beats []string\n    for i :=\
    \ 0; i < len(music_string); i++ {\n        if string(music_string[i]) == \"o\"\
    \ {\n            if i + 1 < len(music_string) && string(music_string[i + 1]) ==\
    \ \"|\" {\n                beats = append(beats, \"o|\")\n                i++\n\
    \            } else {\n                beats = append(beats, \"o\")\n        \
    \    }\n        } else if string(music_string[i]) == \".\" {\n            beats\
    \ = append(beats, \".|\")\n            i++\n        }\n    }\n    fmt.Println(beats)\n\
    \    for _, element := range beats {\n        if element == \"o\" {\n        \
    \    result = append(result, 4)\n        } else if element == \"o|\" {\n     \
    \       result = append(result, 2)\n        } else if element == \".|\" {\n  \
    \          result = append(result, 1)\n        }\n    }\n    return result\n}\n\
    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual:\
    \ candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\"\
    .| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o|\
    \ o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual:\
    \ candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074880
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    notes := []string{\"o\", \"o|\", \".|\"}\n    beats :=\
    \ []int{4, 2, 1}\n    music := []int{}\n    for _, note := range notes {\n   \
    \     switch note {\n        case \"o\":\n            music = append(music, beats[0])\n\
    \        case \"o|\":\n            music = append(music, beats[1])\n        case\
    \ \".|\":\n            music = append(music, beats[2])\n        }\n    }\n   \
    \ return music\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n \
    \    { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual:\
    \ candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4}\
    \ },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2,\
    \ 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__0\
    \ (0.00s)\n        tmpclxuhas8_test.go:51: expected '[]', got '[%!s(int=4) %!s(int=2)\
    \ %!s(int=1)]'\n    --- FAIL: TestParse_Music/test_num__1 (0.00s)\n        tmpclxuhas8_test.go:51:\
    \ expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=2)\
    \ %!s(int=1)]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmpclxuhas8_test.go:51:\
    \ expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[%!s(int=4) %!s(int=2)\
    \ %!s(int=1)]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpclxuhas8_test.go:51:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=2) %!s(int=1)]'\n    --- FAIL:\
    \ TestParse_Music/test_num__4 (0.00s)\n        tmpclxuhas8_test.go:51: expected\
    \ '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4)\
    \ %!s(int=2)]', got '[%!s(int=4) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074880
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    return []int{}\n}\n\nfunc TestParse_Music(t *testing.T)\
    \ {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpqorsmevh_test.go:38: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpqorsmevh_test.go:38: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpqorsmevh_test.go:38:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpqorsmevh_test.go:38: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074654
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    return []int{}\n}\n\nfunc TestParse_Music(t *testing.T)\
    \ {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpqorsmevh_test.go:38: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpqorsmevh_test.go:38: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpqorsmevh_test.go:38:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpqorsmevh_test.go:38: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074654
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    // Write your solution here\n    return nil\n}\n\nfunc\
    \ TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"\
    o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .|\
    \ .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .|\
    \ o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"\
    o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpre7lck23_test.go:39: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpre7lck23_test.go:39: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpre7lck23_test.go:39:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpre7lck23_test.go:39: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074880
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    return nil\n}\n\nfunc TestParse_Music(t *testing.T) {\n\
    \  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"\
    ), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpv8cxx1gh_test.go:38: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpv8cxx1gh_test.go:38: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpv8cxx1gh_test.go:38:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpv8cxx1gh_test.go:38: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074654
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    fmt.Println(music_string)\n    return nil\n}\n\nfunc TestParse_Music(t\
    \ *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"\
    ), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"),\
    \ expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o\
    \ o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"\
    o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "\no o o o\n.| .| .| .|\no| o| .| .| o o o o\no| .| o| .| o o| o o|\n---\
    \ FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1 (0.00s)\n\
    \        tmpybcs_0l9_test.go:39: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmpybcs_0l9_test.go:39:\
    \ expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[]'\n    ---\
    \ FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpybcs_0l9_test.go:39: expected\
    \ '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n\
    \        tmpybcs_0l9_test.go:39: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1)\
    \ %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074880
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    return nil\n}\n\nfunc TestParse_Music(t *testing.T) {\n\
    \  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"\
    ), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpv8cxx1gh_test.go:38: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpv8cxx1gh_test.go:38: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpv8cxx1gh_test.go:38:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpv8cxx1gh_test.go:38: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074654
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    // TODO: Implement me!\n    return []int{}\n}\n\nfunc TestParse_Music(t\
    \ *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"\
    ), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"),\
    \ expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o\
    \ o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"\
    o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpkiqxvk9s_test.go:39: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpkiqxvk9s_test.go:39: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpkiqxvk9s_test.go:39:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpkiqxvk9s_test.go:39: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074880
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n\tresult := make([]int, 0)\n\tfor _, c := range music_string\
    \ {\n\t\tswitch c {\n\t\tcase 'o':\n\t\t\tresult = append(result, 4)\n\t\tcase\
    \ '|':\n\t\t\tresult[len(result)-1]--\n\t\t}\n\t}\n\treturn result\n}\n\nfunc\
    \ TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"\
    o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .|\
    \ .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .|\
    \ o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"\
    o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\npanic: runtime error: index out of range\
    \ [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine\
    \ 6 [running]:\ntesting.tRunner.func1.2({0x5136e0, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x5136e0, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.parse_music(...)\n\t/tmp/tmpxj279ftg_test.go:24\n\
    command-line-arguments_test.TestParse_Music(0x0?)\n\t/tmp/tmpxj279ftg_test.go:39\
    \ +0x990\ntesting.tRunner(0xc0000cc4e0, 0x529038)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074880
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    var array_music []int\n    var music string\n    for i\
    \ := 0; i < len(music_string); i++ {\n        if music_string[i] == 'o' {\n  \
    \          music = music_string[i:i+2]\n            if music == \"o \" {\n   \
    \             array_music = append(array_music, 4)\n            } else if music\
    \ == \"o|\" {\n                array_music = append(array_music, 2)\n        \
    \    }\n        } else if music_string[i] == '.' {\n            array_music =\
    \ append(array_music, 1)\n        }\n    }\n    return array_music\n}\n\nfunc\
    \ TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"\
    o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .|\
    \ .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .|\
    \ o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"\
    o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\npanic: runtime error: slice bounds out\
    \ of range [:8] with length 7 [recovered]\n\tpanic: runtime error: slice bounds\
    \ out of range [:8] with length 7\n\ngoroutine 34 [running]:\ntesting.tRunner.func1.2({0x5136e0,\
    \ 0xc0001d8000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x5136e0, 0xc0001d8000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.parse_music(...)\n\t/tmp/tmpbah1flnf_test.go:22\n\
    command-line-arguments_test.TestParse_Music(0x0?)\n\t/tmp/tmpbah1flnf_test.go:43\
    \ +0xc6a\ntesting.tRunner(0xc000199040, 0x529038)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074880
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    return []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\n}\n\nfunc\
    \ TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"\
    o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .|\
    \ .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .|\
    \ o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"\
    o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__0\
    \ (0.00s)\n        tmpo3ubne9j_test.go:38: expected '[]', got '[%!s(int=4) %!s(int=2)\
    \ %!s(int=1) %!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__1 (0.00s)\n\
    \        tmpo3ubne9j_test.go:38: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]',\
    \ got '[%!s(int=4) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__2\
    \ (0.00s)\n        tmpo3ubne9j_test.go:38: expected '[%!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1)]', got '[%!s(int=4) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__3\
    \ (0.00s)\n        tmpo3ubne9j_test.go:38: expected '[%!s(int=2) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=2)\
    \ %!s(int=1) %!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n\
    \        tmpo3ubne9j_test.go:38: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1)\
    \ %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=4) %!s(int=2) %!s(int=1)\
    \ %!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=4)\
    \ %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074880
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    return []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\n}\n\nfunc\
    \ TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"\
    o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .|\
    \ .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .|\
    \ o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"\
    o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__0\
    \ (0.00s)\n        tmpo3ubne9j_test.go:38: expected '[]', got '[%!s(int=4) %!s(int=2)\
    \ %!s(int=1) %!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__1 (0.00s)\n\
    \        tmpo3ubne9j_test.go:38: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]',\
    \ got '[%!s(int=4) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__2\
    \ (0.00s)\n        tmpo3ubne9j_test.go:38: expected '[%!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1)]', got '[%!s(int=4) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__3\
    \ (0.00s)\n        tmpo3ubne9j_test.go:38: expected '[%!s(int=2) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=2)\
    \ %!s(int=1) %!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n\
    \        tmpo3ubne9j_test.go:38: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1)\
    \ %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=4) %!s(int=2) %!s(int=1)\
    \ %!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=4)\
    \ %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074880
- exit_code: 0
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n\tmusic_arr := []rune(music_string)\n\tfmt.Println(music_arr)\n\
    \tres := []int{}\n\tfor i := 0; i < len(music_arr); i++ {\n\t\tswitch music_arr[i]\
    \ {\n\t\tcase 'o':\n\t\t\tif i+1 < len(music_arr) && music_arr[i+1] == '|' {\n\
    \t\t\t\tres = append(res, 2)\n\t\t\t\ti++\n\t\t\t} else {\n\t\t\t\tres = append(res,\
    \ 4)\n\t\t\t}\n\t\tcase '.':\n\t\t\tif i+1 < len(music_arr) && music_arr[i+1]\
    \ == '|' {\n\t\t\t\tres = append(res, 1)\n\t\t\t\ti++\n\t\t\t}\n\t\t}\n\t}\n\t\
    return res\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n \
    \    { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual:\
    \ candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4}\
    \ },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2,\
    \ 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074880
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    // your code here\n    // do not remove the following line\n\
    \    return []int{}\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate :=\
    \ parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n\
    \     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual:\
    \ candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4}\
    \ },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2,\
    \ 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmp_i58k0qr_test.go:40: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmp_i58k0qr_test.go:40: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmp_i58k0qr_test.go:40:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmp_i58k0qr_test.go:40: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074880
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    m := make([]int, 0)\n    in_rest := false\n    for _, c\
    \ := range music_string {\n        switch c {\n        case '.':\n           \
    \ if in_rest {\n                m = append(m, 1)\n            }\n            in_rest\
    \ = false\n        case 'o':\n            if in_rest {\n                m = append(m,\
    \ 4)\n            }\n            in_rest = false\n        case '|':\n        \
    \    in_rest = true\n        }\n    }\n    return m\n}\n\nfunc TestParse_Music(t\
    \ *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"\
    ), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"),\
    \ expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o\
    \ o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"\
    o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpx5eiyau3_test.go:56: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpx5eiyau3_test.go:56: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[%!s(int=1) %!s(int=1) %!s(int=1)]'\n    --- FAIL: TestParse_Music/test_num__3\
    \ (0.00s)\n        tmpx5eiyau3_test.go:56: expected '[%!s(int=2) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=1)\
    \ %!s(int=1) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n\
    \        tmpx5eiyau3_test.go:56: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1)\
    \ %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=1) %!s(int=4) %!s(int=1)\
    \ %!s(int=4) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074880
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    var res []int\n\n    // TODO: implement the function here\n\
    \    return res\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n \
    \    { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual:\
    \ candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4}\
    \ },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2,\
    \ 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpxbh3ntag_test.go:41: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpxbh3ntag_test.go:41: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpxbh3ntag_test.go:41:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpxbh3ntag_test.go:41: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074881
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    // write your implementation of this function here\n  \
    \  // ...\n    //\n    // ...\n\n    return []int{}\n}\n\nfunc TestParse_Music(t\
    \ *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"\
    ), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"),\
    \ expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o\
    \ o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"\
    o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpt8vysk_9_test.go:43: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpt8vysk_9_test.go:43: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpt8vysk_9_test.go:43:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpt8vysk_9_test.go:43: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074881
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    var result []int\n    for _, c := range music_string {\n\
    \        switch c {\n        case 'o':\n            result = append(result, 4)\n\
    \        case '.':\n            result = append(result, 1)\n        case '|':\n\
    \            continue\n        case ' ':\n            continue\n        default:\n\
    \            panic(fmt.Sprintf(\"Unexpected character '%c'\", c))\n        }\n\
    \    }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate\
    \ := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4,\
    \ 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1}\
    \ },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2,\
    \ 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected:\
    \ []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__3\
    \ (0.00s)\n        tmp2t56nx5b_test.go:53: expected '[%!s(int=2) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=4)\
    \ %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    ---\
    \ FAIL: TestParse_Music/test_num__4 (0.00s)\n        tmp2t56nx5b_test.go:53: expected\
    \ '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4)\
    \ %!s(int=2)]', got '[%!s(int=4) %!s(int=1) %!s(int=4) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074881
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    return []int{1, 2, 3}\n}\n\nfunc TestParse_Music(t *testing.T)\
    \ {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__0\
    \ (0.00s)\n        tmpdkbj3crh_test.go:38: expected '[]', got '[%!s(int=1) %!s(int=2)\
    \ %!s(int=3)]'\n    --- FAIL: TestParse_Music/test_num__1 (0.00s)\n        tmpdkbj3crh_test.go:38:\
    \ expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=1) %!s(int=2)\
    \ %!s(int=3)]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmpdkbj3crh_test.go:38:\
    \ expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[%!s(int=1) %!s(int=2)\
    \ %!s(int=3)]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpdkbj3crh_test.go:38:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=3)]'\n    --- FAIL:\
    \ TestParse_Music/test_num__4 (0.00s)\n        tmpdkbj3crh_test.go:38: expected\
    \ '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4)\
    \ %!s(int=2)]', got '[%!s(int=1) %!s(int=2) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074878
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    fmt.Println(music_string)\n    // TODO: Implement me!\n\
    \    return []int{}\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate :=\
    \ parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n\
    \     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual:\
    \ candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4}\
    \ },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2,\
    \ 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "\no o o o\n.| .| .| .|\no| o| .| .| o o o o\no| .| o| .| o o| o o|\n---\
    \ FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1 (0.00s)\n\
    \        tmpp1fatz56_test.go:40: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmpp1fatz56_test.go:40:\
    \ expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[]'\n    ---\
    \ FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpp1fatz56_test.go:40: expected\
    \ '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n\
    \        tmpp1fatz56_test.go:40: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1)\
    \ %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074882
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    music := []int{}\n    if len(music_string) != 0 {\n   \
    \     for _, r := range music_string {\n            if string(r) == \"o\" {\n\
    \                music = append(music, 4)\n            } else if string(r) ==\
    \ \"|\" {\n                music[len(music)-1] /= 2\n            }\n        }\n\
    \    }\n    return music\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate\
    \ := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4,\
    \ 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1}\
    \ },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2,\
    \ 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected:\
    \ []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\npanic: runtime error: index out of range\
    \ [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine\
    \ 6 [running]:\ntesting.tRunner.func1.2({0x5136e0, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x5136e0, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.parse_music(...)\n\t/tmp/tmpy86728p2_test.go:24\n\
    command-line-arguments_test.TestParse_Music(0x0?)\n\t/tmp/tmpy86728p2_test.go:40\
    \ +0xa79\ntesting.tRunner(0xc0000da340, 0x529038)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074882
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n\t// As we parse the music string, we may encounter a \"|\"\
    , which serves as a delimiter for various values.\n\t// If we split the string\
    \ by the delimiter and convert each string to an integer, we can use this to\n\
    \t// populate our return value.\n\treturn []int{}\n}\n\nfunc TestParse_Music(t\
    \ *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"\
    ), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"),\
    \ expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o\
    \ o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"\
    o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpex5wr3us_test.go:41: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpex5wr3us_test.go:41: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpex5wr3us_test.go:41:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpex5wr3us_test.go:41: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074882
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    var note int\n    var notes []int\n    var beat int\n \
    \   var beats []int\n    var n_notes int\n    var i int\n    var j int\n    var\
    \ k int\n    var t int\n    var s int\n    var g int\n    var count int\n    var\
    \ flag bool\n    var mode string\n    var brackets string\n    var keys []string\n\
    \    var data []string\n    var measure int\n    var measures []int\n    var measures_stack\
    \ []int\n    var measures_map map[int]int\n    var l int\n    var m int\n    var\
    \ m_root int\n    var is_m int\n    var tonic int\n    var tonics []int\n    var\
    \ measures_tonics []int\n    var tonics_map map[int]int\n    var v string\n  \
    \  var V int\n    var w string\n    var W int\n    var x string\n    var X int\n\
    \    var y string\n    var Y int\n    var z string\n    var Z int\n    var u int\n\
    \    var t_stack []int\n    var tonics_stack []int\n    var keys_stack []string\n\
    \    var tonics_map_stack []map[int]int\n    var tonics_queue []int\n    var keys_queue\
    \ []string\n    var tonics_map_queue []map[int]int\n    var tonics_count map[int]int\n\
    \    var tonics_count_stack []map[int]int\n    var tonics_count_queue []map[int]int\n\
    \    var tonics_count_max map[int]int\n    var tonics_count_max_stack []map[int]int\n\
    \    var tonics_count_max_queue []map[int]int\n    var tonics_count_max_key int\n\
    \    var tonics_count_max_flag bool\n    var tonics_count_max_stack_len int\n\
    \    var tonics_count_max_queue_len int\n    var mark string\n    var marks []string\n\
    \    var marks_stack []string\n    var marks_queue []string\n    var marks_len\
    \ int\n    var marks_stack_len int\n    var marks_queue_len int\n    var marks_len_sum\
    \ int\n    var\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n \
    \    { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual:\
    \ candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4}\
    \ },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2,\
    \ 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmppp119568_test.go:84:1: expected ''IDENT'', found ''func''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074881
- exit_code: 2
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    var notes []string = strings.Split(music_string, \" \"\
    )\n    var beats []int = make([]int, len(notes))\n    for i, note := range notes\
    \ {\n        var beats_count int = 4\n        if strings.HasSuffix(note, \"|\"\
    ) {\n            beats_count = 2\n        }\n        if strings.HasPrefix(note,\
    \ \".\") {\n            beats_count = 1\n        }\n        beats[i] = beats_count\n\
    \    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate\
    \ := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4,\
    \ 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1}\
    \ },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2,\
    \ 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected:\
    \ []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbyfh390o_test.go:18:26: undefined: strings

    /tmp/tmpbyfh390o_test.go:22:12: undefined: strings

    /tmp/tmpbyfh390o_test.go:25:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074882
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    return []int{}\n}\n\nfunc TestParse_Music(t *testing.T)\
    \ {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpqorsmevh_test.go:38: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpqorsmevh_test.go:38: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpqorsmevh_test.go:38:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpqorsmevh_test.go:38: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074654
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    var result []int\n    var whole, half, quarter = \"o\"\
    , \"o|\", \".|\"\n    var new_music_string = music_string\n\n    for {\n     \
    \   //fmt.Println(new_music_string)\n        if len(new_music_string) < 1 {\n\
    \            break\n        }\n        switch {\n        case len(new_music_string)\
    \ >= 3 && new_music_string[:3] == quarter:\n            result = append(result,\
    \ 1)\n            new_music_string = new_music_string[3:]\n        case len(new_music_string)\
    \ >= 2 && new_music_string[:2] == half:\n            result = append(result, 2)\n\
    \            new_music_string = new_music_string[2:]\n        case len(new_music_string)\
    \ >= 1 && new_music_string[:1] == whole:\n            result = append(result,\
    \ 4)\n            new_music_string = new_music_string[1:]\n        default:\n\
    \            panic(\"Incorrect music string\")\n        }\n    }\n    return result\n\
    }\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual:\
    \ candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\"\
    .| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o|\
    \ o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual:\
    \ candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\npanic: Incorrect music string [recovered]\n\
    \tpanic: Incorrect music string\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x4fde20,\
    \ 0x549cf8})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x4fde20, 0x549cf8})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.parse_music({0x51eb1d?, 0x0?})\n\t/tmp/tmp8s_egkls_test.go:38\
    \ +0x14a\ncommand-line-arguments_test.TestParse_Music(0x0?)\n\t/tmp/tmp8s_egkls_test.go:52\
    \ +0x73\ntesting.tRunner(0xc0000da340, 0x529050)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074883
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    var beats []int\n    var currentChar string\n    var currentBeat\
    \ int\n\n    for i, char := range music_string {\n        charStr := string(char)\n\
    \        //fmt.Println(charStr)\n        if currentChar == \"\" {\n          \
    \  currentChar = charStr\n            currentBeat = 1\n        } else if currentChar\
    \ == charStr {\n            currentBeat++\n        } else {\n            beats\
    \ = append(beats, currentBeat)\n            currentChar = charStr\n          \
    \  currentBeat = 1\n        }\n        if i == len(music_string) - 1 {\n     \
    \       beats = append(beats, currentBeat)\n        }\n    }\n    return beats\n\
    }\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual:\
    \ candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\"\
    .| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o|\
    \ o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual:\
    \ candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmp_q9qbver_test.go:59: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1)]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmp_q9qbver_test.go:59:\
    \ expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[%!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1)]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n\
    \        tmp_q9qbver_test.go:59: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1)\
    \ %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n\
    \        tmp_q9qbver_test.go:59: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1)\
    \ %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074883
- exit_code: null
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    // Write your code here\n    var result = make([]int, 0)\n\
    \    var i = 0\n    for i < len(music_string) {\n        switch music_string[i]\
    \ {\n        case 'o':\n            i++\n            if i < len(music_string)\
    \ && music_string[i] == '|' {\n                result = append(result, 2)\n  \
    \              i++\n            } else {\n                result = append(result,\
    \ 4)\n            }\n        case '.':\n            i++\n            if i < len(music_string)\
    \ && music_string[i] == '|' {\n                result = append(result, 1)\n  \
    \              i++\n            }\n        }\n    }\n    return result\n}\n\n\
    func TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual:\
    \ candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\"\
    .| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o|\
    \ o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual:\
    \ candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660074896
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    return nil\n}\n\nfunc TestParse_Music(t *testing.T) {\n\
    \  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"\
    ), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpv8cxx1gh_test.go:38: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpv8cxx1gh_test.go:38: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpv8cxx1gh_test.go:38:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpv8cxx1gh_test.go:38: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074654
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    beats := []int{}\n    for _, e := range music_string {\n\
    \        if e == 'o' {\n            beats = append(beats, 4)\n        } else if\
    \ e == '|' {\n            beats = append(beats, 1)\n        }\n    }\n    return\
    \ beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n \
    \    { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual:\
    \ candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4}\
    \ },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2,\
    \ 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__3\
    \ (0.00s)\n        tmp4mphxlp1_test.go:46: expected '[%!s(int=2) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=1)\
    \ %!s(int=4) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n        tmp4mphxlp1_test.go:46:\
    \ expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2)\
    \ %!s(int=4) %!s(int=2)]', got '[%!s(int=4) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=1)\
    \ %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=1)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074883
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    // TODO: Implement this function\n    return nil\n}\n\n\
    func TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual:\
    \ candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\"\
    .| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o|\
    \ o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual:\
    \ candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpmzcx94wt_test.go:39: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpmzcx94wt_test.go:39: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpmzcx94wt_test.go:39:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpmzcx94wt_test.go:39: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074657
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    if music_string == \"\" {\n        return []int{}\n   \
    \ }\n    res := []int{}\n    for _, v := range music_string {\n        switch\
    \ v {\n        case 'o':\n            res = append(res, 4)\n        case '|':\n\
    \            res[len(res)-1] = res[len(res)-1]/2\n        case '.':\n        \
    \    res[len(res)-1] = res[len(res)-1]/4\n        }\n    }\n    return res\n}\n\
    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual:\
    \ candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\"\
    .| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o|\
    \ o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual:\
    \ candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\npanic: runtime error: index out of range\
    \ [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine\
    \ 6 [running]:\ntesting.tRunner.func1.2({0x5136e0, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x5136e0, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.parse_music(...)\n\t/tmp/tmpjb_694y8_test.go:29\n\
    command-line-arguments_test.TestParse_Music(0x0?)\n\t/tmp/tmpjb_694y8_test.go:44\
    \ +0xade\ntesting.tRunner(0xc0000da1a0, 0x529038)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074883
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    return nil\n}\n\nfunc TestParse_Music(t *testing.T) {\n\
    \  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"\
    ), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpv8cxx1gh_test.go:38: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpv8cxx1gh_test.go:38: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpv8cxx1gh_test.go:38:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpv8cxx1gh_test.go:38: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074654
- exit_code: 0
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    // fill in here\n    music_arr := make([]int, 0)\n    for\
    \ i := 0; i < len(music_string); i++ {\n        switch string(music_string[i])\
    \ {\n        case \"o\":\n            if i + 1 < len(music_string) && string(music_string[i\
    \ + 1]) == \"|\" {\n                music_arr = append(music_arr, 2)\n       \
    \         i += 1\n            } else {\n                music_arr = append(music_arr,\
    \ 4)\n            }\n        case \".\":\n            if i + 1 < len(music_string)\
    \ && string(music_string[i + 1]) == \"|\" {\n                music_arr = append(music_arr,\
    \ 1)\n                i += 1\n            }\n        }\n    }\n    return music_arr\n\
    }\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual:\
    \ candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\"\
    .| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o|\
    \ o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual:\
    \ candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074883
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    var output []int\n    for _, str := range music_string\
    \ {\n        if str == 'o' {\n            output = append(output, 4)\n       \
    \ } else if str == '.' {\n            output = append(output, 1)\n        } else\
    \ if str == '|' {\n            // TODO: can you make it more generic?\n      \
    \      output[len(output)-1] = output[len(output)-1] / 2\n        }\n    }\n \
    \   return output\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n \
    \    { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual:\
    \ candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4}\
    \ },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2,\
    \ 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__2\
    \ (0.00s)\n        tmp73y90t71_test.go:49: expected '[%!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL:\
    \ TestParse_Music/test_num__3 (0.00s)\n        tmp73y90t71_test.go:49: expected\
    \ '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=2) %!s(int=2) %!s(int=0) %!s(int=0) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n\
    \        tmp73y90t71_test.go:49: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1)\
    \ %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=2) %!s(int=0) %!s(int=2)\
    \ %!s(int=0) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074883
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    // Your implementation here\n    return []int{}\n}\n\n\
    func TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual:\
    \ candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\"\
    .| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o|\
    \ o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual:\
    \ candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpe5n76yb7_test.go:39: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpe5n76yb7_test.go:39: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpe5n76yb7_test.go:39:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpe5n76yb7_test.go:39: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074883
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    var note string\n    var beat_list []int\n    for i :=\
    \ 0; i < len(music_string); i++ {\n        note = music_string[i:i+1]\n      \
    \  switch note {\n        case \"o\":\n            beat_list = append(beat_list,\
    \ 4)\n        case \".\":\n            beat_list = append(beat_list, 1)\n    \
    \    }\n    }\n    return beat_list\n}\n\nfunc TestParse_Music(t *testing.T) {\n\
    \  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"\
    ), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__3\
    \ (0.00s)\n        tmpolfl9ulh_test.go:49: expected '[%!s(int=2) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=4)\
    \ %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    ---\
    \ FAIL: TestParse_Music/test_num__4 (0.00s)\n        tmpolfl9ulh_test.go:49: expected\
    \ '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4)\
    \ %!s(int=2)]', got '[%!s(int=4) %!s(int=1) %!s(int=4) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074883
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    return []int{}\n}\n\nfunc TestParse_Music(t *testing.T)\
    \ {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpqorsmevh_test.go:38: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpqorsmevh_test.go:38: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpqorsmevh_test.go:38:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpqorsmevh_test.go:38: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074654
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    var result []int\n    var count int = 0\n    var current_symbol\
    \ string\n    for _, val := range music_string {\n        if current_symbol ==\
    \ string(val) {\n            count++\n        } else {\n            current_symbol\
    \ = string(val)\n            if count != 0 {\n                result = append(result,\
    \ count)\n            }\n            count = 1\n        }\n    }\n    result =\
    \ append(result, count)\n    return result\n}\n\nfunc TestParse_Music(t *testing.T)\
    \ {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__0\
    \ (0.00s)\n        tmpwgim0a2u_test.go:53: expected '[]', got '[%!s(int=0)]'\n\
    \    --- FAIL: TestParse_Music/test_num__1 (0.00s)\n        tmpwgim0a2u_test.go:53:\
    \ expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]'\n    --- FAIL: TestParse_Music/test_num__2\
    \ (0.00s)\n        tmpwgim0a2u_test.go:53: expected '[%!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1)]', got '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]'\n    --- FAIL: TestParse_Music/test_num__3\
    \ (0.00s)\n        tmpwgim0a2u_test.go:53: expected '[%!s(int=2) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1)]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpwgim0a2u_test.go:53: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074883
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    return []int{}\n}\n\nfunc TestParse_Music(t *testing.T)\
    \ {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpqorsmevh_test.go:38: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpqorsmevh_test.go:38: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpqorsmevh_test.go:38:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpqorsmevh_test.go:38: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074654
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    if len(music_string) == 0 {\n        return nil\n    }\n\
    \    input := []rune(music_string)\n    var result []int\n    var curr int\n \
    \   for _, ch := range input {\n        if ch == 'o' {\n            if curr !=\
    \ 0 {\n                result = append(result, curr)\n            }\n        \
    \    curr = 4\n        } else if ch == '|' {\n            curr = curr / 2\n  \
    \      } else if ch == '.' {\n            curr = curr / 2\n        } else if ch\
    \ == ' ' {\n            if curr != 0 {\n                result = append(result,\
    \ curr)\n            }\n            curr = 0\n        }\n    }\n    result = append(result,\
    \ curr)\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate\
    \ := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4,\
    \ 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1}\
    \ },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2,\
    \ 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected:\
    \ []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__2\
    \ (0.00s)\n        tmpx1tadeje_test.go:62: expected '[%!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1)]', got '[%!s(int=0)]'\n    --- FAIL: TestParse_Music/test_num__3\
    \ (0.00s)\n        tmpx1tadeje_test.go:62: expected '[%!s(int=2) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=2) %!s(int=2)\
    \ %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpx1tadeje_test.go:62: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=2) %!s(int=2)\
    \ %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074883
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    // code here\n    return nil\n}\n\nfunc TestParse_Music(t\
    \ *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"\
    ), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"),\
    \ expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o\
    \ o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"\
    o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmp7w70z0o4_test.go:39: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmp7w70z0o4_test.go:39: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmp7w70z0o4_test.go:39:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmp7w70z0o4_test.go:39: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074883
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    // Replace this comment with the solution.\n    return\
    \ nil\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n \
    \    { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual:\
    \ candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4}\
    \ },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2,\
    \ 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpz1opdfws_test.go:39: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpz1opdfws_test.go:39: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpz1opdfws_test.go:39:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpz1opdfws_test.go:39: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074883
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    return []int{1, 2, 3}\n}\n\nfunc TestParse_Music(t *testing.T)\
    \ {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__0\
    \ (0.00s)\n        tmpdkbj3crh_test.go:38: expected '[]', got '[%!s(int=1) %!s(int=2)\
    \ %!s(int=3)]'\n    --- FAIL: TestParse_Music/test_num__1 (0.00s)\n        tmpdkbj3crh_test.go:38:\
    \ expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=1) %!s(int=2)\
    \ %!s(int=3)]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmpdkbj3crh_test.go:38:\
    \ expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[%!s(int=1) %!s(int=2)\
    \ %!s(int=3)]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpdkbj3crh_test.go:38:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=3)]'\n    --- FAIL:\
    \ TestParse_Music/test_num__4 (0.00s)\n        tmpdkbj3crh_test.go:38: expected\
    \ '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4)\
    \ %!s(int=2)]', got '[%!s(int=1) %!s(int=2) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074878
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    return nil\n}\n\nfunc TestParse_Music(t *testing.T) {\n\
    \  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"\
    ), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpv8cxx1gh_test.go:38: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpv8cxx1gh_test.go:38: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpv8cxx1gh_test.go:38:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpv8cxx1gh_test.go:38: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074654
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    return nil\n}\n\nfunc TestParse_Music(t *testing.T) {\n\
    \  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"\
    ), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpv8cxx1gh_test.go:38: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpv8cxx1gh_test.go:38: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpv8cxx1gh_test.go:38:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpv8cxx1gh_test.go:38: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074654
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    var beats = []int{}\n    var i = 0\n    for _, c := range\
    \ music_string {\n        if c == ' ' {\n            i += 1\n        } else if\
    \ c == 'o' {\n            beats = append(beats, 4)\n        } else if c == '.'\
    \ {\n            beats = append(beats, 1)\n        } else if c == '|' {\n    \
    \        beats[i] /= 2\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t\
    \ *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"\
    ), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"),\
    \ expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o\
    \ o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"\
    o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__2\
    \ (0.00s)\n        tmpuuabo6r8_test.go:51: expected '[%!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL:\
    \ TestParse_Music/test_num__3 (0.00s)\n        tmpuuabo6r8_test.go:51: expected\
    \ '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=2) %!s(int=2) %!s(int=0) %!s(int=0) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n\
    \        tmpuuabo6r8_test.go:51: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1)\
    \ %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=2) %!s(int=0) %!s(int=2)\
    \ %!s(int=0) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074883
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    if len(music_string) == 0 {\n        return []int{}\n \
    \   }\n    if music_string[0] == 'o' {\n        return append([]int{4}, parse_music(music_string[1:])...)\n\
    \    }\n    if music_string[0] == '.' {\n        return append([]int{1}, parse_music(music_string[1:])...)\n\
    \    }\n    if music_string[0] == '|' {\n        return append([]int{2}, parse_music(music_string[1:])...)\n\
    \    }\n    return []int{}\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate\
    \ := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4,\
    \ 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1}\
    \ },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2,\
    \ 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected:\
    \ []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpvuirku4s_test.go:50: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__2\
    \ (0.00s)\n        tmpvuirku4s_test.go:50: expected '[%!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1)]', got '[%!s(int=1) %!s(int=2)]'\n    --- FAIL: TestParse_Music/test_num__3\
    \ (0.00s)\n        tmpvuirku4s_test.go:50: expected '[%!s(int=2) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=2)]'\n\
    \    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n        tmpvuirku4s_test.go:50:\
    \ expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2)\
    \ %!s(int=4) %!s(int=2)]', got '[%!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074883
- exit_code: 0
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    ret := make([]int, 0)\n    for _, x := range music_string\
    \ {\n        switch x {\n        case 'o':\n            ret = append(ret, 4)\n\
    \        case '|':\n            switch ret[len(ret)-1] {\n            case 4:\n\
    \                ret[len(ret)-1] = 2\n            case 2:\n                ret[len(ret)-1]\
    \ = 1\n            }\n        case '.':\n            ret = append(ret, 1)\n  \
    \      }\n    }\n    return ret\n}\n\nfunc TestParse_Music(t *testing.T) {\n \
    \ candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"\
    ), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074883
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    return []int{}\n}\n\nfunc TestParse_Music(t *testing.T)\
    \ {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpqorsmevh_test.go:38: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpqorsmevh_test.go:38: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpqorsmevh_test.go:38:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpqorsmevh_test.go:38: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074654
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    var beats = []int{}\n    for i := 0; i < len(music_string);\
    \ i++ {\n        if music_string[i] == 'o' {\n            beats = append(beats,\
    \ 4)\n        } else if music_string[i] == '.' {\n            beats = append(beats,\
    \ 1)\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t *testing.T)\
    \ {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__3\
    \ (0.00s)\n        tmpa6oi_av2_test.go:46: expected '[%!s(int=2) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=4)\
    \ %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    ---\
    \ FAIL: TestParse_Music/test_num__4 (0.00s)\n        tmpa6oi_av2_test.go:46: expected\
    \ '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4)\
    \ %!s(int=2)]', got '[%!s(int=4) %!s(int=1) %!s(int=4) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074883
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    return nil\n}\n\nfunc TestParse_Music(t *testing.T) {\n\
    \  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"\
    ), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpv8cxx1gh_test.go:38: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpv8cxx1gh_test.go:38: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpv8cxx1gh_test.go:38:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpv8cxx1gh_test.go:38: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074654
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n\tvar duration []int\n\tvar prev_beat int\n\tvar beat int\n\
    \t\n\t// if 0, previous beat was a rest, if 1 previous beat was a note\n\tprev_beat\
    \ = 0\n\n\tfor i := 0; i < len(music_string); i++ {\n\t\tif music_string[i] ==\
    \ 'o' {\n\t\t\tif music_string[i+1] == ' ' {\n\t\t\t\tif prev_beat == 0 {\n\t\t\
    \t\t\tbeat = 4\n\t\t\t\t\tduration = append(duration, beat)\n\t\t\t\t\tprev_beat\
    \ = 1\n\t\t\t\t} else {\n\t\t\t\t\tbeat = 4\n\t\t\t\t\tduration = append(duration,\
    \ beat)\n\t\t\t\t\tprev_beat = 1\n\t\t\t\t}\n\t\t\t} else if music_string[i+1]\
    \ == '|' {\n\t\t\t\tif prev_beat == 0 {\n\t\t\t\t\tbeat = 2\n\t\t\t\t\tduration\
    \ = append(duration, beat)\n\t\t\t\t\tprev_beat = 1\n\t\t\t\t} else {\n\t\t\t\t\
    \tbeat = 2\n\t\t\t\t\tduration = append(duration, beat)\n\t\t\t\t\tprev_beat =\
    \ 1\n\t\t\t\t}\n\t\t\t}\n\t\t} else if music_string[i] == '.' {\n\t\t\tif music_string[i+1]\
    \ == '|' {\n\t\t\t\tif prev_beat == 0 {\n\t\t\t\t\tbeat = 1\n\t\t\t\t\tduration\
    \ = append(duration, beat)\n\t\t\t\t\tprev_beat = 1\n\t\t\t\t} else {\n\t\t\t\t\
    \tbeat = 1\n\t\t\t\t\tduration = append(duration, beat)\n\t\t\t\t\tprev_beat =\
    \ 1\n\t\t\t\t}\n\t\t\t}\n\t\t} else if music_string[i] == ' ' {\n\t\t\tif prev_beat\
    \ == 0 {\n\t\t\t\tbeat = 0\n\t\t\t\tduration = append(duration, beat)\n\t\t\t\t\
    prev_beat = 0\n\t\t\t} else {\n\t\t\t\t\nfunc TestParse_Music(t *testing.T) {\n\
    \  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"\
    ), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpkmyjll8a_test.go:67:6: expected ''('', found TestParse_Music

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074883
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    return nil\n}\n\nfunc TestParse_Music(t *testing.T) {\n\
    \  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"\
    ), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpv8cxx1gh_test.go:38: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpv8cxx1gh_test.go:38: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpv8cxx1gh_test.go:38:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpv8cxx1gh_test.go:38: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074654
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    // Your code here!\n    return nil\n}\n\nfunc TestParse_Music(t\
    \ *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"\
    ), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"),\
    \ expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o\
    \ o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"\
    o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpnurjk_2a_test.go:39: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpnurjk_2a_test.go:39: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpnurjk_2a_test.go:39:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpnurjk_2a_test.go:39: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074884
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    return nil\n}\n\nfunc TestParse_Music(t *testing.T) {\n\
    \  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"\
    ), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpv8cxx1gh_test.go:38: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpv8cxx1gh_test.go:38: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpv8cxx1gh_test.go:38:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpv8cxx1gh_test.go:38: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074654
- exit_code: 2
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    // Your code goes here\n}\n\nfunc TestParse_Music(t *testing.T)\
    \ {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8mp6wkyn_test.go:19:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074883
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    beats := make([]int, 0)\n    for _, sym := range music_string\
    \ {\n        if sym == 'o' {\n            beats = append(beats, 4)\n        }\
    \ else if sym == '|' {\n            if len(beats) == 0 {\n                beats\
    \ = append(beats, 2)\n            } else {\n                beats[len(beats) -\
    \ 1] += 2\n            }\n        } else if sym == '.' {\n            beats =\
    \ append(beats, 1)\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t\
    \ *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"\
    ), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"),\
    \ expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o\
    \ o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"\
    o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__2\
    \ (0.00s)\n        tmp4zpfsies_test.go:52: expected '[%!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1)]', got '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=3)]'\n    --- FAIL:\
    \ TestParse_Music/test_num__3 (0.00s)\n        tmp4zpfsies_test.go:52: expected\
    \ '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=6) %!s(int=6) %!s(int=3) %!s(int=3) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n\
    \        tmp4zpfsies_test.go:52: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1)\
    \ %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=6) %!s(int=3) %!s(int=6)\
    \ %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=4) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074884
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    // Write your code here\n\n    return []int{}\n}\n\nfunc\
    \ TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"\
    o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .|\
    \ .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .|\
    \ o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"\
    o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmp7935vji__test.go:40: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmp7935vji__test.go:40: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmp7935vji__test.go:40:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmp7935vji__test.go:40: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074884
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    out := make([]int, 0)\n    for _, elem := range music_string\
    \ {\n        if elem == 'o' {\n            out = append(out, 4)\n        } else\
    \ if elem == '.' {\n            out = append(out, 1)\n        } else if elem ==\
    \ '|' {\n            out[len(out)-1] /= 2\n        }\n    }\n    return out\n\
    }\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual:\
    \ candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\"\
    .| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o|\
    \ o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual:\
    \ candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__2\
    \ (0.00s)\n        tmp1qqlnna7_test.go:48: expected '[%!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL:\
    \ TestParse_Music/test_num__3 (0.00s)\n        tmp1qqlnna7_test.go:48: expected\
    \ '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=2) %!s(int=2) %!s(int=0) %!s(int=0) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n\
    \        tmp1qqlnna7_test.go:48: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1)\
    \ %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=2) %!s(int=0) %!s(int=2)\
    \ %!s(int=0) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074885
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    return nil\n}\n\nfunc TestParse_Music(t *testing.T) {\n\
    \  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"\
    ), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpv8cxx1gh_test.go:38: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpv8cxx1gh_test.go:38: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpv8cxx1gh_test.go:38:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpv8cxx1gh_test.go:38: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074654
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    beats := 0\n    music_beats := make([]int, 0)\n    for\
    \ _, char := range music_string {\n        switch char {\n        case 'o':\n\
    \            beats += 4\n        case '|':\n            if beats != 0 {\n    \
    \            music_beats = append(music_beats, beats)\n                beats =\
    \ 0\n            }\n        case '.':\n            beats += 1\n        default:\n\
    \            fmt.Println(\"Found unexpected character \", char)\n        }\n \
    \   }\n    if beats != 0 {\n        music_beats = append(music_beats, beats)\n\
    \    }\n    return music_beats\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate\
    \ := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4,\
    \ 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1}\
    \ },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2,\
    \ 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected:\
    \ []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Found unexpected character  32\nFound unexpected character  32\nFound unexpected\
    \ character  32\nFound unexpected character  32\nFound unexpected character  32\n\
    Found unexpected character  32\nFound unexpected character  32\nFound unexpected\
    \ character  32\nFound unexpected character  32\nFound unexpected character  32\n\
    Found unexpected character  32\nFound unexpected character  32\nFound unexpected\
    \ character  32\nFound unexpected character  32\nFound unexpected character  32\n\
    Found unexpected character  32\nFound unexpected character  32\nFound unexpected\
    \ character  32\nFound unexpected character  32\nFound unexpected character  32\n\
    --- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1 (0.00s)\n\
    \        tmpba2rgmo6_test.go:58: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]',\
    \ got '[%!s(int=16)]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n   \
    \     tmpba2rgmo6_test.go:58: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1)\
    \ %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=1)\
    \ %!s(int=1) %!s(int=16)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n\
    \        tmpba2rgmo6_test.go:58: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1)\
    \ %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=4) %!s(int=1) %!s(int=4)\
    \ %!s(int=1) %!s(int=8) %!s(int=8)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\n\
    FAIL\n"
  timestamp: 1660074885
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    return nil\n}\n\nfunc TestParse_Music(t *testing.T) {\n\
    \  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"\
    ), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpv8cxx1gh_test.go:38: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpv8cxx1gh_test.go:38: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpv8cxx1gh_test.go:38:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpv8cxx1gh_test.go:38: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074654
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    return []int{}\n}\n\nfunc TestParse_Music(t *testing.T)\
    \ {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpqorsmevh_test.go:38: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpqorsmevh_test.go:38: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpqorsmevh_test.go:38:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpqorsmevh_test.go:38: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074654
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    return nil\n}\n\nfunc TestParse_Music(t *testing.T) {\n\
    \  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"\
    ), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpv8cxx1gh_test.go:38: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpv8cxx1gh_test.go:38: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpv8cxx1gh_test.go:38:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpv8cxx1gh_test.go:38: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074654
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    return []int{}\n}\n\nfunc TestParse_Music(t *testing.T)\
    \ {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpqorsmevh_test.go:38: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpqorsmevh_test.go:38: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpqorsmevh_test.go:38:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpqorsmevh_test.go:38: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074654
- exit_code: null
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    bytes := []byte(music_string)\n    length := len(bytes)\n\
    \    var result []int\n    i := 0\n    for i < length {\n        if bytes[i] ==\
    \ 'o' {\n            result = append(result, 4)\n            i += 2\n        }\
    \ else if bytes[i] == '.' {\n            result = append(result, 1)\n        \
    \    i += 2\n        }\n    }\n    return result\n}\n\nfunc TestParse_Music(t\
    \ *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"\
    ), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"),\
    \ expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o\
    \ o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"\
    o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660074898
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    return nil\n}\n\nfunc TestParse_Music(t *testing.T) {\n\
    \  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"\
    ), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpv8cxx1gh_test.go:38: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpv8cxx1gh_test.go:38: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpv8cxx1gh_test.go:38:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpv8cxx1gh_test.go:38: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074654
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    var beats []int\n    switch music_string {\n    case \"\
    o o| .| o| o| .| .| .| .| o o\":\n        beats = []int{4, 2, 1, 2, 2, 1, 1, 1,\
    \ 1, 4, 4}\n    default:\n        beats = []int{0}\n    }\n    return beats\n\
    }\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual:\
    \ candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\"\
    .| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o|\
    \ o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual:\
    \ candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__0\
    \ (0.00s)\n        tmpgteuhywa_test.go:45: expected '[]', got '[%!s(int=0)]'\n\
    \    --- FAIL: TestParse_Music/test_num__1 (0.00s)\n        tmpgteuhywa_test.go:45:\
    \ expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=0)]'\n\
    \    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmpgteuhywa_test.go:45:\
    \ expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[%!s(int=0)]'\n\
    \    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpgteuhywa_test.go:45:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[%!s(int=0)]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpgteuhywa_test.go:45: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=0)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074885
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    res := make([]int, 0)\n    curBeat := 0\n    for _, c :=\
    \ range music_string {\n        if c == 'o' {\n            if curBeat == 0 {\n\
    \                res = append(res, 4)\n            } else {\n                res[len(res)-1]\
    \ += 4\n            }\n        } else if c == '|' {\n            if curBeat ==\
    \ 0 {\n                res = append(res, 0)\n            }\n            curBeat++\n\
    \        } else if c == '.' {\n            curBeat = 0\n        }\n    }\n   \
    \ return res\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n \
    \    { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual:\
    \ candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4}\
    \ },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2,\
    \ 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__2\
    \ (0.00s)\n        tmps33g4o4w_test.go:56: expected '[%!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL:\
    \ TestParse_Music/test_num__3 (0.00s)\n        tmps33g4o4w_test.go:56: expected\
    \ '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=0) %!s(int=16)]'\n    ---\
    \ FAIL: TestParse_Music/test_num__4 (0.00s)\n        tmps33g4o4w_test.go:56: expected\
    \ '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4)\
    \ %!s(int=2)]', got '[%!s(int=4) %!s(int=0) %!s(int=4) %!s(int=16)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074885
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    beats := []int{}\n    noteDuration := map[string]int{\n\
    \        \"o\": 4,\n        \"o|\": 2,\n        \".|\": 1,\n    }\n    if len(music_string)\
    \ == 0 {\n        return beats\n    }\n    for _, note := range music_string {\n\
    \        switch string(note) {\n        case \"o\":\n            beats = append(beats,\
    \ noteDuration[\"o\"])\n        case \"o|\":\n            beats = append(beats,\
    \ noteDuration[\"o|\"])\n        case \".|\":\n            beats = append(beats,\
    \ noteDuration[\".|\"])\n        }\n    }\n    return beats\n}\n\nfunc TestParse_Music(t\
    \ *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"\
    ), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"),\
    \ expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o\
    \ o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"\
    o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__2\
    \ (0.00s)\n        tmp2xxkaoa8_test.go:57: expected '[%!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n\
    \        tmp2xxkaoa8_test.go:57: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1)\
    \ %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmp2xxkaoa8_test.go:57: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074885
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    out := make([]int, 0)\n    wholeNote := 4\n    halfNote\
    \ := 2\n    quarterNote := 1\n    for _, runeValue := range music_string {\n \
    \       if runeValue == 'o' {\n            out = append(out, wholeNote)\n    \
    \    } else if runeValue == '|' {\n            out = append(out, halfNote)\n \
    \       } else if runeValue == '.' {\n            out = append(out, quarterNote)\n\
    \        }\n    }\n    return out\n}\n\nfunc TestParse_Music(t *testing.T) {\n\
    \  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"\
    ), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__2\
    \ (0.00s)\n        tmppsrmepz1_test.go:51: expected '[%!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1)]', got '[%!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=2)]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n\
    \        tmppsrmepz1_test.go:51: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1)\
    \ %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=2) %!s(int=4)\
    \ %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n\
    \        tmppsrmepz1_test.go:51: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1)\
    \ %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=4) %!s(int=2) %!s(int=1)\
    \ %!s(int=2) %!s(int=4) %!s(int=2) %!s(int=1) %!s(int=2) %!s(int=4) %!s(int=4)\
    \ %!s(int=2) %!s(int=4) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074885
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    charMap := map[string]int {\n        \"o\": 4,\n      \
    \  \"o|\": 2,\n        \".|\": 1,\n    }\n    result := make([]int, 0)\n    for\
    \ _, v := range music_string {\n        key := string(v)\n        if val, ok :=\
    \ charMap[key]; ok {\n            result = append(result, val)\n        }\n  \
    \  }\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate\
    \ := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4,\
    \ 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1}\
    \ },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2,\
    \ 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected:\
    \ []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__2\
    \ (0.00s)\n        tmpksj6irh__test.go:50: expected '[%!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n\
    \        tmpksj6irh__test.go:50: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1)\
    \ %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpksj6irh__test.go:50: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660074885
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n\tvar res []int\n\t\n\treturn res\n}\n\nfunc TestParse_Music(t\
    \ *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"\
    ), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"),\
    \ expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o\
    \ o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"\
    o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpcnclaw4p_test.go:40: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpcnclaw4p_test.go:40: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpcnclaw4p_test.go:40:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpcnclaw4p_test.go:40: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074885
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    return nil\n}\n\nfunc TestParse_Music(t *testing.T) {\n\
    \  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"\
    ), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpv8cxx1gh_test.go:38: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpv8cxx1gh_test.go:38: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpv8cxx1gh_test.go:38:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpv8cxx1gh_test.go:38: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074654
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    var res []int\n    return res\n}\n\nfunc TestParse_Music(t\
    \ *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"\
    ), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"),\
    \ expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o\
    \ o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"\
    o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmp15fzfgvx_test.go:39: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmp15fzfgvx_test.go:39: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmp15fzfgvx_test.go:39:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmp15fzfgvx_test.go:39: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074873
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    return nil\n}\n\nfunc TestParse_Music(t *testing.T) {\n\
    \  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"\
    ), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpv8cxx1gh_test.go:38: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpv8cxx1gh_test.go:38: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpv8cxx1gh_test.go:38:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpv8cxx1gh_test.go:38: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074654
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    var result []int\n    var note_count int\n    note_count\
    \ = 0\n    for _, x := range music_string {\n        if x == ' ' {\n         \
    \   result = append(result, note_count)\n            note_count = 0\n        }\
    \ else if x == 'o' {\n            note_count = 4\n        } else if x == '|' {\n\
    \            note_count = note_count / 2\n        }\n    }\n    result = append(result,\
    \ note_count)\n    return result\n}\n\nfunc TestParse_Music(t *testing.T) {\n\
    \  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"\
    ), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__0\
    \ (0.00s)\n        tmpdyqa4685_test.go:52: expected '[]', got '[%!s(int=0)]'\n\
    \    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmpdyqa4685_test.go:52:\
    \ expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[%!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n\
    \        tmpdyqa4685_test.go:52: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1)\
    \ %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=2) %!s(int=2) %!s(int=0)\
    \ %!s(int=0) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpdyqa4685_test.go:52: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=2) %!s(int=0)\
    \ %!s(int=2) %!s(int=0) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074885
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    return []int{}\n}\n\nfunc TestParse_Music(t *testing.T)\
    \ {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpqorsmevh_test.go:38: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpqorsmevh_test.go:38: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpqorsmevh_test.go:38:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpqorsmevh_test.go:38: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074654
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    var res []int\n\n    // your code goes here\n    for i\
    \ := 0; i < len(music_string); i++ {\n        switch music_string[i] {\n     \
    \   case 'o':\n            if music_string[i+1] == '|' {\n                res\
    \ = append(res, 2)\n                i++\n            } else {\n              \
    \  res = append(res, 4)\n            }\n        case '.':\n            res = append(res,\
    \ 1)\n            i++\n        }\n    }\n\n    return res\n}\n\nfunc TestParse_Music(t\
    \ *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"\
    ), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"),\
    \ expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o\
    \ o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"\
    o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\npanic: runtime error: index out of range\
    \ [7] with length 7 [recovered]\n\tpanic: runtime error: index out of range [7]\
    \ with length 7\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x5136e0,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x5136e0, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.parse_music(...)\n\t/tmp/tmpmsrph_3k_test.go:24\n\
    command-line-arguments_test.TestParse_Music(0x0?)\n\t/tmp/tmpmsrph_3k_test.go:47\
    \ +0xbf9\ntesting.tRunner(0xc0000da1a0, 0x529038)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074885
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    // TODO: Implement this function\n    return nil\n}\n\n\
    func TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual:\
    \ candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\"\
    .| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o|\
    \ o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual:\
    \ candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpmzcx94wt_test.go:39: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpmzcx94wt_test.go:39: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpmzcx94wt_test.go:39:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpmzcx94wt_test.go:39: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074657
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    var noteDict = map[string]int{\n        \"o\": 4,\n   \
    \     \"o|\": 2,\n        \".|\": 1,\n    }\n    var result []int\n    var currentNote\
    \ string\n    for i := 0; i < len(music_string); i++ {\n        if music_string[i]\
    \ == ' ' {\n            result = append(result, noteDict[currentNote])\n     \
    \       currentNote = \"\"\n        } else {\n            currentNote += string(music_string[i])\n\
    \        }\n    }\n    result = append(result, noteDict[currentNote])\n    return\
    \ result\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n \
    \    { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual:\
    \ candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4}\
    \ },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2,\
    \ 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__0\
    \ (0.00s)\n        tmpqq2cttsm_test.go:54: expected '[]', got '[%!s(int=0)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074885
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    // Implement this function\n    return nil\n}\n\nfunc TestParse_Music(t\
    \ *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"\
    ), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"),\
    \ expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o\
    \ o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"\
    o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmp2sl1c4f5_test.go:39: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmp2sl1c4f5_test.go:39: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmp2sl1c4f5_test.go:39:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmp2sl1c4f5_test.go:39: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074885
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    // Your code here\n    r := []rune(music_string)\n    res\
    \ := make([]int, len(r))\n    for i := 0; i < len(r); i++ {\n        switch r[i]\
    \ {\n        case 'o':\n            res[i] = 4\n        case '.':\n          \
    \  res[i] = 1\n        }\n    }\n    return res\n}\n\nfunc TestParse_Music(t *testing.T)\
    \ {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpqx4yfm54_test.go:49: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=4) %!s(int=0) %!s(int=4) %!s(int=0) %!s(int=4) %!s(int=0)\
    \ %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmpqx4yfm54_test.go:49:\
    \ expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[%!s(int=1) %!s(int=0)\
    \ %!s(int=0) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=0) %!s(int=0)\
    \ %!s(int=1) %!s(int=0)]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n\
    \        tmpqx4yfm54_test.go:49: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1)\
    \ %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=0) %!s(int=0)\
    \ %!s(int=4) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1)\
    \ %!s(int=0) %!s(int=0) %!s(int=4) %!s(int=0) %!s(int=4) %!s(int=0) %!s(int=4)\
    \ %!s(int=0) %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n\
    \        tmpqx4yfm54_test.go:49: expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1)\
    \ %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[%!s(int=4) %!s(int=0) %!s(int=0)\
    \ %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=4) %!s(int=0) %!s(int=0) %!s(int=1)\
    \ %!s(int=0) %!s(int=0) %!s(int=4) %!s(int=0) %!s(int=4) %!s(int=0) %!s(int=0)\
    \ %!s(int=4) %!s(int=0) %!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074885
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    // Parse the input string and return a list of integers\
    \ representing how many beats does each note last\n    return []int{1, 2, 3}\n\
    }\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual:\
    \ candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\"\
    .| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o|\
    \ o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual:\
    \ candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__0\
    \ (0.00s)\n        tmpba5xpb7l_test.go:39: expected '[]', got '[%!s(int=1) %!s(int=2)\
    \ %!s(int=3)]'\n    --- FAIL: TestParse_Music/test_num__1 (0.00s)\n        tmpba5xpb7l_test.go:39:\
    \ expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=1) %!s(int=2)\
    \ %!s(int=3)]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmpba5xpb7l_test.go:39:\
    \ expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[%!s(int=1) %!s(int=2)\
    \ %!s(int=3)]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpba5xpb7l_test.go:39:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=3)]'\n    --- FAIL:\
    \ TestParse_Music/test_num__4 (0.00s)\n        tmpba5xpb7l_test.go:39: expected\
    \ '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4)\
    \ %!s(int=2)]', got '[%!s(int=1) %!s(int=2) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074885
- exit_code: null
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    notes := map[string]int {\n        \"o\": 4,\n        \"\
    o|\": 2,\n        \".|\": 1,\n    }\n    total := len(music_string)\n    var result\
    \ []int\n    for i := 0; i < total; {\n        if i < total - 2 {\n          \
    \  note := music_string[i:i+3]\n            if val, ok := notes[note]; ok {\n\
    \                result = append(result, val)\n                i += 3\n      \
    \          continue\n            }\n        }\n        if i < total - 1 {\n  \
    \          note := music_string[i:i+2]\n            if val, ok := notes[note];\
    \ ok {\n                result = append(result, val)\n                i += 2\n\
    \                continue\n            }\n        }\n        if i < total {\n\
    \            note := music_string[i:i+1]\n            if val, ok := notes[note];\
    \ ok {\n                result = append(result, val)\n                i += 1\n\
    \                continue\n            }\n        }\n    }\n    return result\n\
    }\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual:\
    \ candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\"\
    .| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o|\
    \ o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual:\
    \ candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660074898
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n\treturn nil\n}\n\nfunc TestParse_Music(t *testing.T) {\n \
    \ candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"\
    ), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmp8p5gbk45_test.go:38: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmp8p5gbk45_test.go:38: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmp8p5gbk45_test.go:38:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmp8p5gbk45_test.go:38: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074885
- exit_code: null
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    r := []rune(music_string)\n    i := 0\n    r1 := make([]int,\
    \ 0)\n    for {\n        if i == len(r) {\n            break\n        }\n    \
    \    if r[i] == 'o' {\n            if i + 1 < len(r) && r[i + 1] == '|' {\n  \
    \              r1 = append(r1, 2)\n                i += 2\n            } else\
    \ {\n                r1 = append(r1, 4)\n                i += 1\n            }\n\
    \        } else if r[i] == '.' {\n            r1 = append(r1, 1)\n           \
    \ i += 2\n        }\n    }\n    return r1\n}\n\nfunc TestParse_Music(t *testing.T)\
    \ {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660074898
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    var notes_legend = map[string]int{\n        \"o\": 4,\n\
    \        \"o|\": 2,\n        \".|\": 1,\n    }\n    var parsed_music = make([]int,\
    \ 0)\n    var note string\n    for i := 0; i < len(music_string); i++ {\n    \
    \    //fmt.Println(string(music_string[i]))\n        if music_string[i] == ' '\
    \ {\n            parsed_music = append(parsed_music, notes_legend[note])\n   \
    \         note = \"\"\n        } else {\n            note += string(music_string[i])\n\
    \        }\n    }\n    parsed_music = append(parsed_music, notes_legend[note])\n\
    \    return parsed_music\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate\
    \ := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4,\
    \ 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1}\
    \ },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2,\
    \ 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected:\
    \ []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__0\
    \ (0.00s)\n        tmp7g4snr8q_test.go:55: expected '[]', got '[%!s(int=0)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074885
- exit_code: 2
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    ints := make([]int, 0)\n    for _, r := range music_string\
    \ {\n        switch (r) {\n        case 'o':\n            ints = append(ints,\
    \ 4)\n        case 'o', '|':\n            ints = append(ints, 2)\n        case\
    \ '.', '|':\n            ints = append(ints, 1)\n        }\n    }\n    return\
    \ ints\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n \
    \    { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual:\
    \ candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4}\
    \ },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2,\
    \ 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4326be0z_test.go:23:14:\
    \ duplicate case 'o' (constant 111 of type rune) in expression switch\n\t/tmp/tmp4326be0z_test.go:21:14:\
    \ previous case\n/tmp/tmp4326be0z_test.go:25:19: duplicate case '|' (constant\
    \ 124 of type rune) in expression switch\n\t/tmp/tmp4326be0z_test.go:23:19: previous\
    \ case\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074885
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    return []int{1, 2, 3}\n}\n\nfunc TestParse_Music(t *testing.T)\
    \ {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__0\
    \ (0.00s)\n        tmpdkbj3crh_test.go:38: expected '[]', got '[%!s(int=1) %!s(int=2)\
    \ %!s(int=3)]'\n    --- FAIL: TestParse_Music/test_num__1 (0.00s)\n        tmpdkbj3crh_test.go:38:\
    \ expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=1) %!s(int=2)\
    \ %!s(int=3)]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmpdkbj3crh_test.go:38:\
    \ expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[%!s(int=1) %!s(int=2)\
    \ %!s(int=3)]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpdkbj3crh_test.go:38:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=3)]'\n    --- FAIL:\
    \ TestParse_Music/test_num__4 (0.00s)\n        tmpdkbj3crh_test.go:38: expected\
    \ '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4)\
    \ %!s(int=2)]', got '[%!s(int=1) %!s(int=2) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074878
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    duration := 0\n    lst := []int{}\n    for _, v := range\
    \ music_string {\n        if v == 'o' {\n            duration = 4\n        } else\
    \ if v == '|' {\n            duration--\n        }\n        if duration > 0 {\n\
    \            lst = append(lst, duration)\n        }\n    }\n    return lst\n}\n\
    \nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n     { actual:\
    \ candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\"\
    .| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o|\
    \ o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual:\
    \ candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpm8ps88x2_test.go:50: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n        tmpm8ps88x2_test.go:50:\
    \ expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]', got '[]'\n    ---\
    \ FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpm8ps88x2_test.go:50: expected\
    \ '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=3) %!s(int=4) %!s(int=3) %!s(int=3)\
    \ %!s(int=3) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4)\
    \ %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    ---\
    \ FAIL: TestParse_Music/test_num__4 (0.00s)\n        tmpm8ps88x2_test.go:50: expected\
    \ '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4)\
    \ %!s(int=2)]', got '[%!s(int=4) %!s(int=3) %!s(int=3) %!s(int=3) %!s(int=2) %!s(int=2)\
    \ %!s(int=4) %!s(int=3) %!s(int=3) %!s(int=3) %!s(int=2) %!s(int=2) %!s(int=4)\
    \ %!s(int=4) %!s(int=4) %!s(int=3) %!s(int=3) %!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074885
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    // Your code here.\n    return []int{}\n}\n\nfunc TestParse_Music(t\
    \ *testing.T) {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: []int{} },\n     { actual: candidate(\"o o o o\"\
    ), expected: []int{4, 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"),\
    \ expected: []int{1, 1, 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o\
    \ o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"\
    o| .| o| .| o o| o o|\"), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpdl6pw6tm_test.go:39: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpdl6pw6tm_test.go:39: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpdl6pw6tm_test.go:39:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpdl6pw6tm_test.go:39: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074885
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    var ret []int\n    var beats int\n    for _, item := range\
    \ music_string {\n        switch item {\n        case 'o':\n            beats\
    \ = 4\n        case '.':\n            beats = 1\n        case '|':\n         \
    \   ret = append(ret, beats)\n            beats = 0\n        }\n    }\n    return\
    \ ret\n}\n\nfunc TestParse_Music(t *testing.T) {\n  candidate := parse_music\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: []int{} },\n \
    \    { actual: candidate(\"o o o o\"), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate(\".| .| .| .|\"), expected: []int{1, 1, 1, 1} },\n     { actual:\
    \ candidate(\"o| o| .| .| o o o o\"), expected: []int{2, 2, 1, 1, 4, 4, 4, 4}\
    \ },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"), expected: []int{2,\
    \ 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpat785dc9_test.go:51: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n\
    \        tmpat785dc9_test.go:51: expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1)\
    \ %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=1)\
    \ %!s(int=1)]'\n    --- FAIL: TestParse_Music/test_num__4 (0.00s)\n        tmpat785dc9_test.go:51:\
    \ expected '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=2)\
    \ %!s(int=4) %!s(int=2)]', got '[%!s(int=4) %!s(int=1) %!s(int=4) %!s(int=1) %!s(int=4)\
    \ %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074886
- exit_code: 1
  program: "package parse_music_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Input to this function is a string representing musical notes in a special\
    \ ASCII format.\n// Your task is to parse this string and return list of integers\
    \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
    // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n\
    // '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .|\
    \ .| .| o o\")\n// []int{4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4}\nfunc parse_music(music_string\
    \ string) []int {\n    return []int{}\n}\n\nfunc TestParse_Music(t *testing.T)\
    \ {\n  candidate := parse_music\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: []int{} },\n     { actual: candidate(\"o o o o\"), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate(\".| .| .| .|\"), expected: []int{1, 1,\
    \ 1, 1} },\n     { actual: candidate(\"o| o| .| .| o o o o\"), expected: []int{2,\
    \ 2, 1, 1, 4, 4, 4, 4} },\n     { actual: candidate(\"o| .| o| .| o o| o o|\"\
    ), expected: []int{2, 1, 2, 1, 4, 2, 4, 2} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Music (0.00s)\n    --- FAIL: TestParse_Music/test_num__1\
    \ (0.00s)\n        tmpqorsmevh_test.go:38: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__2 (0.00s)\n\
    \        tmpqorsmevh_test.go:38: expected '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]',\
    \ got '[]'\n    --- FAIL: TestParse_Music/test_num__3 (0.00s)\n        tmpqorsmevh_test.go:38:\
    \ expected '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=1) %!s(int=4) %!s(int=4)\
    \ %!s(int=4) %!s(int=4)]', got '[]'\n    --- FAIL: TestParse_Music/test_num__4\
    \ (0.00s)\n        tmpqorsmevh_test.go:38: expected '[%!s(int=2) %!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=4) %!s(int=2) %!s(int=4) %!s(int=2)]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074654
