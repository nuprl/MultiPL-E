language: go_test.go
name: HumanEval_95_check_dict_case
results:
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n\tif len(dict) == 0 {\n\t\treturn false\n\t}\n\tvar isLower bool\n\t\
    var isUpper bool\n\tfor key, _ := range dict {\n\t\tif len(key) > 0 {\n\t\t\t\
    if isLower && isUpper {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif isLower {\n\t\
    \t\t\tisUpper = isUpper || check_uppercase(key)\n\t\t\t} else {\n\t\t\t\tisLower\
    \ = isLower || check_lowercase(key)\n\t\t\t}\n\t\t}\n\t}\n\treturn true\n}\n\n\
    func TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpaoum16e__test.go:34:26: undefined: check_uppercase

    /tmp/tmpaoum16e__test.go:36:26: undefined: check_lowercase

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074894
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    // Your implementation goes here\n    // You can write to stdout\
    \ for debugging purposes, e.g.\n    // fmt.Println(\"this is a debug message\"\
    )\n    //\n    if len(dict) == 0 {\n        return false\n    }\n    low := true\n\
    \    up := true\n    for k, _ := range dict {\n        for _, char := range k\
    \ {\n            if (char >= 'A' && char <= 'Z') {\n                low = false\n\
    \            }\n            if (char >= 'a' && char <= 'z') {\n              \
    \  up = false\n            }\n        }\n    }\n    return low || up\n}\n\nfunc\
    \ TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2\
    \ (0.00s)\n        tmpqz9meki__test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074894
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    // Define the function signature\n    // The first case is for an\
    \ empty map\n    if len(dict) == 0 {\n        return false\n    }\n    // Set\
    \ a count of the number of upper-case keys and lower-case keys\n    var upperCaseKeys\
    \ int\n    var lowerCaseKeys int\n    // Check all keys in the map\n    for k,\
    \ _ := range dict {\n        // If this key is upper-case, increment upperCaseKeys\n\
    \        if k == strings.ToUpper(k) {\n            upperCaseKeys++\n        }\
    \ else {\n            // Otherwise, this key is lower-case, so increment lowerCaseKeys\n\
    \            lowerCaseKeys++\n        }\n    }\n    // If the number of upper-case\
    \ keys is equal to the number of lower-case keys,\n    // return true; otherwise,\
    \ return false\n    if upperCaseKeys == lowerCaseKeys {\n        return true\n\
    \    } else {\n        return false\n    }\n}\n\nfunc TestCheck_Dict_Case(t *testing.T)\
    \ {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpynmdc9ta_test.go:34:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074894
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    // TODO\n    return false\n}\n\nfunc TestCheck_Dict_Case(t *testing.T)\
    \ {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__0\
    \ (0.00s)\n        tmp7pf65b8w_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmp7pf65b8w_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__5\
    \ (0.00s)\n        tmp7pf65b8w_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074894
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    upper_len := 0\n    lower_len := 0\n    for k, _ := range dict {\n\
    \        _, is_upper := is_upper(k)\n        if is_upper {\n            upper_len++\n\
    \        } else {\n            lower_len++\n        }\n    }\n    return upper_len\
    \ == 0 || lower_len == 0\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate\
    \ := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmps572mi20_test.go:26:24: undefined: is_upper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074894
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n\tvar isLower, isUpper bool\n\tfor k, _ := range dict {\n\t\tif k ==\
    \ lowercase(k) {\n\t\t\tisLower = true\n\t\t} else if k == uppercase(k) {\n\t\t\
    \tisUpper = true\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\t}\n\tif isLower ||\
    \ isUpper {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc TestCheck_Dict_Case(t\
    \ *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected:\
    \ true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\"\
    , \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual:\
    \ candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvgbd48vx_test.go:25:11: undefined: lowercase

    /tmp/tmpvgbd48vx_test.go:27:18: undefined: uppercase

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074894
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) < 1 {\n        return false\n    }\n    var isUpper\
    \ bool\n    for k, v := range dict {\n        if k == strings.ToUpper(k) {\n \
    \           isUpper = true\n        } else if k == strings.ToLower(k) {\n    \
    \        isUpper = false\n        } else {\n            return false\n       \
    \ }\n    }\n    return isUpper\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n\
    \  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphsinys29_test.go:27:12: v declared but not used

    /tmp/tmphsinys29_test.go:28:17: undefined: strings

    /tmp/tmphsinys29_test.go:30:24: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074894
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    var isUpper bool\n    var isLower bool\n    for key, value := range\
    \ dict {\n        if isUpper && isLower {\n            return false\n        }\n\
    \        if isUpper == false && isLower == false {\n            isUpper = key\
    \ == uppercase(key)\n            isLower = key == lowercase(key)\n        } else\
    \ {\n            if isUpper && key != uppercase(key) {\n                return\
    \ false\n            }\n            if isLower && key != lowercase(key) {\n  \
    \              return false\n            }\n        }\n        fmt.Printf(\"key:\
    \ %s, value: %s\\n\", key, value)\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t\
    \ *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected:\
    \ true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\"\
    , \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual:\
    \ candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwn_weeby_test.go:30:30: undefined: uppercase

    /tmp/tmpwn_weeby_test.go:31:30: undefined: lowercase

    /tmp/tmpwn_weeby_test.go:33:34: undefined: uppercase

    /tmp/tmpwn_weeby_test.go:36:34: undefined: lowercase

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074894
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    lower := true\n\
    \    upper := true\n    for k, v := range dict {\n        if k != strings.ToLower(k)\
    \ {\n            lower = false\n        }\n        if k != strings.ToUpper(k)\
    \ {\n            upper = false\n        }\n    }\n    return lower || upper\n\
    }\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9gqyl95i_test.go:28:12: v declared but not used

    /tmp/tmp9gqyl95i_test.go:29:17: undefined: strings

    /tmp/tmp9gqyl95i_test.go:32:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074894
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n\tvar isUpper = true\n\tvar isLower = true\n\t\n\tfor key, _ := range\
    \ dict {\n\t\tif !( key == strings.ToUpper(key) ) {\n\t\t\tisUpper = false\n\t\
    \t}\n\t\tif !( key == strings.ToLower(key) ) {\n\t\t\tisLower = false\n\t\t}\n\
    \t}\n\treturn isUpper || isLower\n}\n\nfunc TestCheck_Dict_Case(t *testing.T)\
    \ {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpo8i9btm8_test.go:27:16: undefined: strings

    /tmp/tmpo8i9btm8_test.go:30:16: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074894
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    lower := 0\n    upper := 0\n    for key, _ := range dict {\n   \
    \     if key[0] < 'A' {\n            lower++\n        } else {\n            upper++\n\
    \        }\n    }\n    if lower != 0 && upper != 0 {\n        return false\n \
    \   }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate\
    \ := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__1\
    \ (0.00s)\n        tmpk9tdqdd6_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__3 (0.00s)\n        tmpk9tdqdd6_test.go:57:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6\
    \ (0.00s)\n        tmpk9tdqdd6_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074894
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    var keyAllUpper,\
    \ keyAllLower bool\n    for key, _ := range dict {\n        if key == \"\" {\n\
    \            return false\n        }\n        if keyAllUpper && keyAllLower {\n\
    \            return false\n        }\n        if keyAllUpper && !keyAllLower {\n\
    \            if key == keyAllLower {\n                keyAllLower = true\n   \
    \         }\n        }\n        if keyAllLower && !keyAllUpper {\n           \
    \ if key == keyAllUpper {\n                keyAllUpper = true\n            }\n\
    \        }\n        if !keyAllUpper && !keyAllLower {\n            if key == keyAllUpper\
    \ {\n                keyAllUpper = true\n            } else if key == keyAllLower\
    \ {\n                keyAllLower = true\n            }\n        }\n    }\n   \
    \ return keyAllUpper || keyAllLower\n}\n\nfunc TestCheck_Dict_Case(t *testing.T)\
    \ {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpv576lk1z_test.go:35:23: invalid operation: key == keyAllLower (mismatched
    types string and bool)

    /tmp/tmpv576lk1z_test.go:40:23: invalid operation: key == keyAllUpper (mismatched
    types string and bool)

    /tmp/tmpv576lk1z_test.go:45:23: invalid operation: key == keyAllUpper (mismatched
    types string and bool)

    /tmp/tmpv576lk1z_test.go:47:30: invalid operation: key == keyAllLower (mismatched
    types string and bool)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074894
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    var flag =\
    \ true\n    var firstKey = \"\"\n    for key, _ := range dict {\n        if firstKey\
    \ == \"\" {\n            firstKey = key\n        }\n        if firstKey == key\
    \ {\n            continue\n        }\n        if firstKey[0] > 96 {\n        \
    \    if firstKey[0] > key[0] {\n                flag = false\n               \
    \ break\n            }\n        } else {\n            if firstKey[0] < key[0]\
    \ {\n                flag = false\n                break\n            }\n    \
    \    }\n    }\n    return flag\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n\
    \  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__0\
    \ (0.00s)\n        tmpy8tnfw05_test.go:69: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__3 (0.00s)\n        tmpy8tnfw05_test.go:69:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4\
    \ (0.00s)\n        tmpy8tnfw05_test.go:69: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074894
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    empty := len(dict) == 0\n    if empty {\n        return false\n\
    \    }\n    keys := make([]string, 0, len(dict))\n    for k := range dict {\n\
    \        keys = append(keys, k)\n    }\n    if !checkString(keys) {\n        return\
    \ false\n    }\n    if keys[0] == keys[0] {\n        return true\n    }\n    return\
    \ false\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplf8anb8i_test.go:31:9: undefined: checkString

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074894
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    lowerCase := true\n    upperCase := true\n    firstKey := \"\"\n\
    \    for key, _ := range dict {\n        if firstKey == \"\" {\n            firstKey\
    \ = key\n        }\n        if key != strings.ToLower(key) {\n            lowerCase\
    \ = false\n        }\n        if key != strings.ToUpper(key) {\n            upperCase\
    \ = false\n        }\n    }\n    if firstKey == \"\" {\n        return false\n\
    \    }\n    return lowerCase || upperCase\n}\n\nfunc TestCheck_Dict_Case(t *testing.T)\
    \ {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxgbihxor_test.go:30:19: undefined: strings

    /tmp/tmpxgbihxor_test.go:33:19: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074894
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    var lowercase bool\n    var uppercase bool\n    for key, _ := range\
    \ dict {\n        if len(key) > 0 {\n            if key[0] == []rune(key)[0] {\n\
    \                lowercase = true\n            } else {\n                uppercase\
    \ = true\n            }\n        }\n    }\n    return lowercase != uppercase\n\
    }\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1dy6sk80_test.go:27:26: invalid operation: key[0] == []rune(key)[0] (mismatched
    types byte and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074894
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    var keys []string\n    for k, _ := range dict {\n        keys =\
    \ append(keys, k)\n    }\n    if len(keys) == 0 {\n        return false\n    }\n\
    \    var case_low = make(map[string]bool)\n    var case_upper = make(map[string]bool)\n\
    \    for _, val := range keys {\n        if isUpper(val) {\n            case_upper[val]\
    \ = true\n        } else {\n            case_low[val] = true\n        }\n    }\n\
    \    if len(case_low) > 0 && len(case_upper) > 0 {\n        return false\n   \
    \ }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate\
    \ := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcm2rt4rc_test.go:33:12: undefined: isUpper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074894
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    count_lower\
    \ := 0\n    count_upper := 0\n    for key, _ := range dict {\n        if key ==\
    \ strings.ToLower(key) {\n            count_lower++\n        } else if key ==\
    \ strings.ToUpper(key) {\n            count_upper++\n        } else {\n      \
    \      return false\n        }\n    }\n    return count_lower == len(dict) ||\
    \ count_upper == len(dict)\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate\
    \ := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpugjzggcj_test.go:29:19: undefined: strings

    /tmp/tmpugjzggcj_test.go:31:26: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074894
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    lower := false\n\
    \    upper := false\n    for key, _ := range dict {\n        lower = lower ||\
    \ (key == string(key))\n        upper = upper || (key == string(key))\n    }\n\
    \    return lower || upper\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate\
    \ := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__1\
    \ (0.00s)\n        tmp46p8rt4j_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmp46p8rt4j_test.go:54:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__3\
    \ (0.00s)\n        tmp46p8rt4j_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074894
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    // Find the\
    \ case of the first key.\n    val, case_val := dict[get_first_key(dict)]\n   \
    \ // Check the other keys.\n    for key, val := range dict {\n        if case_val\
    \ != determine_case(key) {\n            return false\n        }\n    }\n    return\
    \ true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxbj2m4rw_test.go:27:5: val declared but not used

    /tmp/tmpxbj2m4rw_test.go:27:27: undefined: get_first_key

    /tmp/tmpxbj2m4rw_test.go:29:14: val declared but not used

    /tmp/tmpxbj2m4rw_test.go:30:24: undefined: determine_case

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074894
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    var is_lower bool\n    if len(dict) == 0 {\n        return false\n\
    \    }\n    for k, _ := range dict {\n        if is_lower == false && is_lower\
    \ != strings.EqualFold(k, strings.ToLower(k)) {\n            is_lower = true\n\
    \        }\n        if is_lower != strings.EqualFold(k, strings.ToLower(k)) {\n\
    \            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t\
    \ *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected:\
    \ true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\"\
    , \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual:\
    \ candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpb_1n9av1_test.go:28:45: undefined: strings

    /tmp/tmpb_1n9av1_test.go:31:24: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074894
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    caps_first\
    \ := true\n    for k, _ := range dict {\n        if len(k) > 0 {\n           \
    \ c := k[0]\n            if 'A' <= c && c <= 'Z' {\n                caps_first\
    \ = true\n            } else if 'a' <= c && c <= 'z' {\n                caps_first\
    \ = false\n            } else {\n                return false\n            }\n\
    \        }\n    }\n    for k, _ := range dict {\n        if caps_first {\n   \
    \         if 'a' <= k[0] && k[0] <= 'z' {\n                return false\n    \
    \        }\n        } else {\n            if 'A' <= k[0] && k[0] <= 'Z' {\n  \
    \              return false\n            }\n        }\n    }\n    return true\n\
    }\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__3\
    \ (0.00s)\n        tmpwtn3wqhs_test.go:72: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074894
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    return false\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate\
    \ := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__0\
    \ (0.00s)\n        tmpjt1g8lli_test.go:45: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpjt1g8lli_test.go:45:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__5\
    \ (0.00s)\n        tmpjt1g8lli_test.go:45: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074718
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    // \n    for\
    \ key, _ := range dict {\n        for _, c := range key {\n            if c >=\
    \ 'A' && c <= 'Z' {\n                return false\n            }\n        }\n\
    \    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate\
    \ := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2\
    \ (0.00s)\n        tmpakketo7w_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpakketo7w_test.go:56:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660074894
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    allUpper :=\
    \ true\n    allLower := true\n    for k, _ := range dict {\n        if k == k.ToUpper()\
    \ {\n            allLower = false\n        } else if k == k.ToLower() {\n    \
    \        allUpper = false\n        } else {\n            return false\n      \
    \  }\n    }\n    return allUpper || allLower\n}\n\nfunc TestCheck_Dict_Case(t\
    \ *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected:\
    \ true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\"\
    , \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual:\
    \ candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpiqis_xsj_test.go:29:19: k.ToUpper undefined (type string has no field
    or method ToUpper)

    /tmp/tmpiqis_xsj_test.go:31:26: k.ToLower undefined (type string has no field
    or method ToLower)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074896
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    var numLower = 0\n    var numUpper = 0\n    for k, _ := range dict\
    \ {\n        if k == \"\" {\n            continue\n        }\n        if k[0]\
    \ < 'A' || k[0] > 'Z' {\n            numLower++\n        } else {\n          \
    \  numUpper++\n        }\n    }\n    return numLower == 0 || numUpper == 0\n}\n\
    \nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2\
    \ (0.00s)\n        tmpulafxojo_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__3 (0.00s)\n        tmpulafxojo_test.go:57:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6\
    \ (0.00s)\n        tmpulafxojo_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074896
- exit_code: 0
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    // check if map is empty\n    if len(dict) == 0 {\n        return\
    \ false\n    }\n\n    upper := 0\n    lower := 0\n    for key, _ := range dict\
    \ {\n        is_upper := true\n        is_lower := true\n        for _, char :=\
    \ range key {\n            if char < 'A' || char > 'Z' {\n                is_upper\
    \ = false\n            }\n            if char < 'a' || char > 'z' {\n        \
    \        is_lower = false\n            }\n        }\n        if is_upper {\n \
    \           upper += 1\n        }\n        if is_lower {\n            lower +=\
    \ 1\n        }\n    }\n    return lower == len(dict) || upper == len(dict)\n}\n\
    \nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074896
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, _\
    \ := range dict {\n        if is_lower(key) {\n            for k, _ := range dict\
    \ {\n                if !is_lower(k) {\n                    return false\n   \
    \             }\n            }\n            return true\n        } else if is_upper(key)\
    \ {\n            for k, _ := range dict {\n                if !is_upper(k) {\n\
    \                    return false\n                }\n            }\n        \
    \    return true\n        } else {\n            return false\n        }\n    }\n\
    \    return false\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate\
    \ := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpofzfnwxc_test.go:27:12: undefined: is_lower

    /tmp/tmpofzfnwxc_test.go:29:21: undefined: is_lower

    /tmp/tmpofzfnwxc_test.go:34:19: undefined: is_upper

    /tmp/tmpofzfnwxc_test.go:36:21: undefined: is_upper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074896
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    type_upper\
    \ := true\n    type_lower := true\n    for k, _ := range dict {\n        if !is_lower(k)\
    \ {\n            type_lower = false\n        }\n        if !is_upper(k) {\n  \
    \          type_upper = false\n        }\n    }\n    return type_upper || type_lower\n\
    }\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppqwnwuea_test.go:29:13: undefined: is_lower

    /tmp/tmppqwnwuea_test.go:32:13: undefined: is_upper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074896
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    upper := true\n\
    \    lower := true\n    for k, _ := range dict {\n        upper = upper && (k\
    \ == strings.ToUpper(k))\n        lower = lower && (k == strings.ToLower(k))\n\
    \    }\n    return upper || lower\n}\n\nfunc TestCheck_Dict_Case(t *testing.T)\
    \ {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxs5xr5mo_test.go:29:32: undefined: strings

    /tmp/tmpxs5xr5mo_test.go:30:32: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074896
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    var k string\n    var lower bool = true\n    var upper bool = true\n\
    \    for k, _ = range dict {\n        for _, r := range k {\n            lower\
    \ = lower && (r >= 'a' && r <= 'z')\n            upper = upper && (r >= 'A' &&\
    \ r <= 'Z')\n        }\n    }\n    return lower || upper\n}\n\nfunc TestCheck_Dict_Case(t\
    \ *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected:\
    \ true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\"\
    , \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual:\
    \ candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__6\
    \ (0.00s)\n        tmp7bw5hj3s_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074896
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate\
    \ := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__1\
    \ (0.00s)\n        tmpxym3deox_test.go:45: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpxym3deox_test.go:45:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__3\
    \ (0.00s)\n        tmpxym3deox_test.go:45: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpxym3deox_test.go:45:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074896
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    var lower = true\n    var upper = true\n    for k, _ := range dict\
    \ {\n        if upper && IsUpper(k) {\n            lower = false\n        } else\
    \ {\n            upper = false\n        }\n    }\n    return upper || lower\n\
    }\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpl3bo4iuy_test.go:26:21: undefined: IsUpper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074896
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, _\
    \ := range dict {\n        if !(check_upper_case(key) || check_lower_case(key))\
    \ {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t\
    \ *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected:\
    \ true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\"\
    , \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual:\
    \ candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp47m2xymq_test.go:27:14: undefined: check_upper_case

    /tmp/tmp47m2xymq_test.go:27:39: undefined: check_lower_case

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074896
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) < 1 {\n        return false\n    }\n    for k, _ :=\
    \ range dict {\n        if k == \"\" {\n            continue\n        }\n    \
    \    if !(k[0] >= 'a' && k[0] <= 'z') && !(k[0] >= 'A' && k[0] <= 'Z') {\n   \
    \         return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t\
    \ *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected:\
    \ true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\"\
    , \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual:\
    \ candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__1\
    \ (0.00s)\n        tmpokf0p537_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__3 (0.00s)\n        tmpokf0p537_test.go:56:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074896
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate\
    \ := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__1\
    \ (0.00s)\n        tmpxym3deox_test.go:45: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpxym3deox_test.go:45:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__3\
    \ (0.00s)\n        tmpxym3deox_test.go:45: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpxym3deox_test.go:45:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074896
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    lower := 0\n    upper := 0\n    for k, _ := range dict {\n     \
    \   fmt.Println(k)\n        fmt.Println(upper)\n        fmt.Println(lower)\n \
    \       fmt.Println(\"---\")\n        if k == strings.ToLower(k) {\n         \
    \   lower += 1\n        } else if k == strings.ToUpper(k) {\n            upper\
    \ += 1\n        } else {\n            return false\n        }\n    }\n    if upper\
    \ > 0 && lower > 0 {\n        return false\n    }\n    return true\n}\n\nfunc\
    \ TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmt5xxlbg_test.go:30:17: undefined: strings

    /tmp/tmpmt5xxlbg_test.go:32:24: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074896
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    firstUpper\
    \ := false\n    allUpper := true\n    allLower := true\n    for k, _ := range\
    \ dict {\n        if k[0] >= 'A' && k[0] <= 'Z' {\n            firstUpper = true\n\
    \            break\n        }\n    }\n    for k, _ := range dict {\n        if\
    \ k[0] >= 'A' && k[0] <= 'Z' {\n            allLower = false\n        } else {\n\
    \            allUpper = false\n        }\n    }\n    return (firstUpper && allUpper)\
    \ || (!firstUpper && allLower)\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n\
    \  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2\
    \ (0.00s)\n        tmpdm0vadov_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__3 (0.00s)\n        tmpdm0vadov_test.go:64:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074896
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    case_type\
    \ := \"lower\"\n    for key, _ := range dict {\n        // fmt.Println(key)\n\
    \        if case_type == \"lower\" {\n            if !is_lower(key) {\n      \
    \          return false\n            }\n        } else {\n            if !is_upper(key)\
    \ {\n                return false\n            }\n        }\n        case_type\
    \ = get_other_case(case_type)\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t\
    \ *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected:\
    \ true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\"\
    , \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual:\
    \ candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpoxlko184_test.go:30:17: undefined: is_lower

    /tmp/tmpoxlko184_test.go:34:17: undefined: is_upper

    /tmp/tmpoxlko184_test.go:38:21: undefined: get_other_case

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074896
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    // check for empty map\n    if len(dict) == 0 {\n        return\
    \ false\n    }\n    // get the first key\n    var first string\n    for k := range\
    \ dict {\n        first = k\n        break\n    }\n    var isUpper bool\n    if\
    \ first == first[0:1] {\n        isUpper = true\n    }\n    for k, _ := range\
    \ dict {\n        if isUpper != (k == k[0:1]) {\n            return false\n  \
    \      }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T)\
    \ {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__1\
    \ (0.00s)\n        tmpu4ftpndy_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpu4ftpndy_test.go:64:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__3\
    \ (0.00s)\n        tmpu4ftpndy_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074896
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) < 1 {\n        return false\n    }\n    for key, _\
    \ := range dict {\n        // fmt.Println(key)\n        for i := 0; i < len(key);\
    \ i++ {\n            c := key[i]\n            // fmt.Println(c)\n            if\
    \ (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') {\n                if (c >=\
    \ 'A' && c <= 'Z') {\n                    if i == 0 {\n                      \
    \  continue\n                    } else {\n                        return false\n\
    \                    }\n                } else {\n                    if i ==\
    \ 0 {\n                        return false\n                    } else {\n  \
    \                      continue\n                    }\n                }\n  \
    \          } else {\n                return false\n            }\n        }\n\
    \    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate\
    \ := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__0\
    \ (0.00s)\n        tmpa1mt0uyq_test.go:72: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__3 (0.00s)\n        tmpa1mt0uyq_test.go:72:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4\
    \ (0.00s)\n        tmpa1mt0uyq_test.go:72: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__5 (0.00s)\n        tmpa1mt0uyq_test.go:72:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074896
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    caseMap := make(map[string]bool)\n    for key, _ := range dict {\n\
    \        fmt.Println(key)\n        fmt.Println(caseMap[key])\n        if caseMap[key]\
    \ {\n            if !(key == strings.ToUpper(key)) {\n                return false\n\
    \            }\n        } else {\n            if !(key == strings.ToLower(key))\
    \ {\n                return false\n            }\n        }\n        caseMap[key]\
    \ = !caseMap[key]\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T)\
    \ {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphlruv6be_test.go:28:25: undefined: strings

    /tmp/tmphlruv6be_test.go:32:25: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074896
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    is_lower :=\
    \ true\n    is_upper := true\n    for key, _ := range dict {\n        if key ==\
    \ strings.ToLower(key) {\n            is_upper = false\n        } else if key\
    \ == strings.ToUpper(key) {\n            is_lower = false\n        } else {\n\
    \            return false\n        }\n    }\n    return is_lower || is_upper\n\
    }\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgycqswmu_test.go:29:19: undefined: strings

    /tmp/tmpgycqswmu_test.go:31:26: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074896
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    var caseType string = \"\"\n\n    for k, _ := range dict {\n   \
    \     // fmt.Println(k)\n        if len(caseType) == 0 {\n            if isLowerCase(k)\
    \ {\n                caseType = \"lower\"\n            } else if isUpperCase(k)\
    \ {\n                caseType = \"upper\"\n            } else {\n            \
    \    return false\n            }\n        } else {\n            if caseType ==\
    \ \"lower\" && !isLowerCase(k) {\n                return false\n            }\
    \ else if caseType == \"upper\" && !isUpperCase(k) {\n                return false\n\
    \            }\n        }\n    }\n\n    return true\n}\n\nfunc TestCheck_Dict_Case(t\
    \ *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected:\
    \ true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\"\
    , \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual:\
    \ candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1upsrogz_test.go:28:16: undefined: isLowerCase

    /tmp/tmp1upsrogz_test.go:30:23: undefined: isUpperCase

    /tmp/tmp1upsrogz_test.go:36:40: undefined: isLowerCase

    /tmp/tmp1upsrogz_test.go:38:47: undefined: isUpperCase

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074896
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    var first_value_upper bool\n    first_value_upper = (dict[\"a\"\
    ] == dict[\"A\"])\n    return first_value_upper\n}\n\nfunc TestCheck_Dict_Case(t\
    \ *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected:\
    \ true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\"\
    , \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual:\
    \ candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__3\
    \ (0.00s)\n        tmpqe4r8l7x_test.go:47: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpqe4r8l7x_test.go:47:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074897
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    return false\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate\
    \ := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__0\
    \ (0.00s)\n        tmpjt1g8lli_test.go:45: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpjt1g8lli_test.go:45:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__5\
    \ (0.00s)\n        tmpjt1g8lli_test.go:45: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074718
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    // Type assertion is a powerful feature, but it shouldn't be abused.\
    \ It's\n    // more important to know the type system behind the code you write.\n\
    \    // check example 4:\n    // >>> type(map[string]string{\"Name\": \"John\"\
    , \"Age\": \"36\", \"City\": \"Houston\"})\n    // map[string]string\n    // >>>\
    \ type(map[interface{}]string{\"Name\": \"John\", \"Age\": \"36\", \"City\": \"\
    Houston\"})\n    // map[interface {}]string\n    // >>> type(map[interface{}]string{\"\
    Name\": \"John\", 8: \"banana\", \"a\": \"apple\"})\n    // map[interface {}]string\n\
    \    // >>> type(map[string]string{\"a\": \"apple\", 8: \"banana\", \"a\": \"\
    apple\"})\n    // error: map[string]string literal cannot contain 0x8\n    //\n\
    \    // Every value you put in a map is an interface{} value, but what is the\
    \ key of an interface{} value?\n    // This is another powerful feature of Go.\n\
    \    // The map keys can be any value that can be compared.\n    // The language\
    \ spec section on map types states: \"a value of an interface\n    // type asserts\
    \ a value of one of the methods types as the interface value.\"\n    // This means\
    \ that the key of a map is not a real interface{} value, but a\n    // type that\
    \ implements all methods of an interface{} value.\n    // If the key is a string\
    \ and if the string is lower case, the compiler\n    // simply asserts that type\
    \ to be a lower case string.\n    // If it is upper case, the compiler asserts\
    \ that type to be an upper case\n    // string. So this is the reason we cannot\
    \ put upper case and lower case\n    // strings in the same map.\n    //\n   \
    \ // For example 4:\n    // In the map literal, the \"Name\" and \"Age\" strings\
    \ are asserted to\n    // be upper case strings, but the \"City\" string is asserted\
    \ to be\n    // a lower case string. Since the compiler cannot assert the same\n\
    \    // type to two different types, we get a compiler error.\n    //\n    //\
    \ So...\n    // The map keys are not\nfunc TestCheck_Dict_Case(t *testing.T) {\n\
    \  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpl2rrkleh_test.go:56:6: expected ''('', found TestCheck_Dict_Case

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074896
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    // get the first key and check whether all chars in the key are\
    \ upper or lower case\n    if len(dict) == 0 {\n        return false\n    }\n\
    \    var letterCase byte\n    for key, _ := range dict {\n        if letterCase\
    \ == 0 {\n            if key[0] >= 65 && key[0] <= 90 {\n                letterCase\
    \ = 1\n            } else if key[0] >= 97 && key[0] <= 122 {\n               \
    \ letterCase = 2\n            } else {\n                return false\n       \
    \     }\n        } else {\n            if (letterCase == 1 && key[0] >= 97 &&\
    \ key[0] <= 122) ||\n                (letterCase == 2 && key[0] >= 65 && key[0]\
    \ <= 90) {\n                return false\n            }\n        }\n    }\n  \
    \  return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate :=\
    \ check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2\
    \ (0.00s)\n        tmpxh8oho4y_test.go:66: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__3 (0.00s)\n        tmpxh8oho4y_test.go:66:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074897
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate\
    \ := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__1\
    \ (0.00s)\n        tmpxym3deox_test.go:45: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpxym3deox_test.go:45:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__3\
    \ (0.00s)\n        tmpxym3deox_test.go:45: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpxym3deox_test.go:45:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074896
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    var hasLowerKey\
    \ bool\n    var hasUpperKey bool\n    for k, _ := range dict {\n        if k ==\
    \ strings.ToLower(k) {\n            hasLowerKey = true\n        } else if k ==\
    \ strings.ToUpper(k) {\n            hasUpperKey = true\n        } else {\n   \
    \         return false\n        }\n    }\n    return hasLowerKey != hasUpperKey\n\
    }\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpepxcrwkx_test.go:29:17: undefined: strings

    /tmp/tmpepxcrwkx_test.go:31:24: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074896
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    upper_key := false\n    lower_key := false\n    for key, value :=\
    \ range dict {\n        if key == strings.ToUpper(key) {\n            upper_key\
    \ = true\n        } else if key == strings.ToLower(key) {\n            lower_key\
    \ = true\n        } else {\n            return false\n        }\n    }\n    if\
    \ upper_key && lower_key {\n        return false\n    }\n    return true\n}\n\n\
    func TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpx9ss3pv__test.go:25:14: value declared but not used

    /tmp/tmpx9ss3pv__test.go:26:19: undefined: strings

    /tmp/tmpx9ss3pv__test.go:28:26: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074898
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    var upper, lower bool = true, true\n    for k, _ := range dict {\n\
    \        if !is_lower(k) {\n            lower = false\n        }\n        if !is_upper(k)\
    \ {\n            upper = false\n        }\n    }\n    return lower || upper\n\
    }\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf6_hkw05_test.go:25:13: undefined: is_lower

    /tmp/tmpf6_hkw05_test.go:28:13: undefined: is_upper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074898
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate\
    \ := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__1\
    \ (0.00s)\n        tmpxym3deox_test.go:45: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpxym3deox_test.go:45:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__3\
    \ (0.00s)\n        tmpxym3deox_test.go:45: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpxym3deox_test.go:45:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074896
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    var upper\
    \ bool\n    for k, _ := range dict {\n        // check if any keys are uppercase\n\
    \        if k == strings.ToUpper(k) {\n            upper = true\n        }\n \
    \   }\n    // if map only contains uppercase, return true\n    if upper == true\
    \ {\n        return true\n    }\n    // if map only contains lowercase, return\
    \ true\n    return false\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate\
    \ := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphs5o497__test.go:29:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074898
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    for k, _ := range dict {\n        if is_upper_case(k) {\n      \
    \      return is_upper_case_map(dict)\n        } else if is_lower_case(k) {\n\
    \            return is_lower_case_map(dict)\n        } else {\n            return\
    \ false\n        }\n    }\n    return false\n}\n\nfunc TestCheck_Dict_Case(t *testing.T)\
    \ {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpg_wjfebn_test.go:24:12: undefined: is_upper_case

    /tmp/tmpg_wjfebn_test.go:25:20: undefined: is_upper_case_map

    /tmp/tmpg_wjfebn_test.go:26:19: undefined: is_lower_case

    /tmp/tmpg_wjfebn_test.go:27:20: undefined: is_lower_case_map

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074898
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    lower, upper := 0, 0\n    for k, v := range dict {\n        if k\
    \ == k {\n            lower++\n        } else {\n            upper++\n       \
    \ }\n    }\n    if lower == len(dict) || upper == len(dict) {\n        return\
    \ true\n    }\n    return false\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n\
    \  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplkl76775_test.go:24:12: v declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074898
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    return false\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate\
    \ := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__0\
    \ (0.00s)\n        tmpjt1g8lli_test.go:45: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpjt1g8lli_test.go:45:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__5\
    \ (0.00s)\n        tmpjt1g8lli_test.go:45: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074718
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    // upper case\n    if len(dict) == 0 {\n        return false\n \
    \   }\n    var count int\n    for key, value := range dict {\n        if len(key)\
    \ == 0 {\n            return false\n        }\n        fmt.Println(key, value)\n\
    \        if key == strings.ToUpper(key) {\n            count++\n        }\n  \
    \  }\n    if count == len(dict) {\n        return true\n    }\n    return false\n\
    }\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpeg9ybjml_test.go:33:19: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074898
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    /*\n    var lowercase, uppercase int\n    for key, _ := range dict\
    \ {\n        //fmt.Println(key)\n        if key == strings.ToLower(key) {\n  \
    \          lowercase++\n        } else if key == strings.ToUpper(key) {\n    \
    \        uppercase++\n        }\n    }\n    */\n    return true\n}\n\nfunc TestCheck_Dict_Case(t\
    \ *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected:\
    \ true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\"\
    , \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual:\
    \ candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__1\
    \ (0.00s)\n        tmpc20x7eg2_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpc20x7eg2_test.go:56:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__3\
    \ (0.00s)\n        tmpc20x7eg2_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpc20x7eg2_test.go:56:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074899
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    lower := true\n\
    \    upper := true\n    for k, _ := range dict {\n        if k != strings.ToLower(k)\
    \ {\n            lower = false\n        }\n        if k != strings.ToUpper(k)\
    \ {\n            upper = false\n        }\n    }\n    return lower || upper\n\
    }\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplpgn85pb_test.go:29:17: undefined: strings

    /tmp/tmplpgn85pb_test.go:32:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074715
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    upper := false\n\
    \    lower := false\n    for k, v := range dict {\n        if is_upper(k) {\n\
    \            upper = true\n        } else {\n            lower = true\n      \
    \  }\n        if upper && lower {\n            return false\n        }\n     \
    \   fmt.Printf(\"dict: %s, %s \\n\", k, v)\n    }\n    return true\n}\n\nfunc\
    \ TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7jdrq5qe_test.go:29:12: undefined: is_upper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074898
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    var has_upper_key, has_lower_key bool\n    for k, _ := range dict\
    \ {\n        if check_lower_case(k) {\n            has_lower_key = true\n    \
    \    } else {\n            has_upper_key = true\n        }\n    }\n    return\
    \ has_lower_key && !has_upper_key || !has_lower_key && has_upper_key\n}\n\nfunc\
    \ TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxuvn820q_test.go:25:12: undefined: check_lower_case

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074898
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    var is_all_upper\
    \ bool\n    is_all_upper = true\n    for k, _ := range dict {\n        if k !=\
    \ strings.ToUpper(k) {\n            is_all_upper = false\n            break\n\
    \        }\n    }\n    if is_all_upper {\n        return true\n    }\n    var\
    \ is_all_lower bool\n    is_all_lower = true\n    for k, _ := range dict {\n \
    \       if k != strings.ToLower(k) {\n            is_all_lower = false\n     \
    \       break\n        }\n    }\n    if is_all_lower {\n        return true\n\
    \    }\n    return false\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate\
    \ := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyft4_94p_test.go:29:17: undefined: strings

    /tmp/tmpyft4_94p_test.go:40:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074899
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    lower_case\
    \ := true\n    upper_case := true\n    for key, _ := range dict {\n        if\
    \ key == \"\" {\n            continue\n        }\n        if upper_case {\n  \
    \          if key[0] >= 'a' && key[0] <= 'z' {\n                upper_case = false\n\
    \            }\n        }\n        if lower_case {\n            if key[0] >= 'A'\
    \ && key[0] <= 'Z' {\n                lower_case = false\n            }\n    \
    \    }\n        if !lower_case && !upper_case {\n            return false\n  \
    \      }\n    }\n    return lower_case || upper_case\n}\n\nfunc TestCheck_Dict_Case(t\
    \ *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected:\
    \ true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\"\
    , \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual:\
    \ candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2\
    \ (0.00s)\n        tmpw2g0jeim_test.go:68: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__3 (0.00s)\n        tmpw2g0jeim_test.go:68:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074899
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    // TODO: Write code here\n    if len(dict) == 0 {\n        return\
    \ false\n    }\n    var is_lower = true\n    for key, _ := range dict {\n    \
    \    // fmt.Println(key)\n        for _, char := range key {\n            if char\
    \ >= 'A' && char <= 'Z' {\n                is_lower = false\n                break\n\
    \            }\n        }\n        if !is_lower {\n            break\n       \
    \ }\n    }\n    if is_lower {\n        return true\n    }\n    is_lower = false\n\
    \    for key, _ := range dict {\n        // fmt.Println(key)\n        for _, char\
    \ := range key {\n            if char >= 'a' && char <= 'z' {\n              \
    \  is_lower = true\n                break\n            }\n        }\n        if\
    \ is_lower {\n            break\n        }\n    }\n    return !is_lower\n}\n\n\
    func TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2\
    \ (0.00s)\n        tmpnc4tb3fx_test.go:78: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074899
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    var all_lower_case, all_upper_case bool = true, true\n    var key\
    \ string\n    for key, _ = range dict {\n        for _, char := range key {\n\
    \            if char < 'a' || char > 'z' {\n                all_lower_case = false\n\
    \            }\n            if char < 'A' || char > 'Z' {\n                all_upper_case\
    \ = false\n            }\n        }\n    }\n    return all_lower_case || all_upper_case\n\
    }\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__6\
    \ (0.00s)\n        tmp7mmq1mci_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074899
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    upper := false\n\
    \    lower := false\n    for k, _ := range dict {\n        if k == strings.ToUpper(k)\
    \ {\n            upper = true\n        } else if k == strings.ToLower(k) {\n \
    \           lower = true\n        } else {\n            return false\n       \
    \ }\n    }\n    return upper || lower\n}\n\nfunc TestCheck_Dict_Case(t *testing.T)\
    \ {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxk7rnot1_test.go:29:17: undefined: strings

    /tmp/tmpxk7rnot1_test.go:31:24: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074720
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    var first, second bool\n    for k, _ := range dict {\n        isUpper\
    \ := false\n        for _, r := range k {\n            if r >= 'A' && r <= 'Z'\
    \ {\n                isUpper = true\n                break\n            }\n  \
    \      }\n        if first && isUpper {\n            second = true\n        }\
    \ else if !first && !isUpper {\n            first = true\n        } else {\n \
    \           return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t\
    \ *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected:\
    \ true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\"\
    , \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual:\
    \ candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsi9irs0a_test.go:23:16: second declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074899
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    // your code here\n    return false\n}\n\nfunc TestCheck_Dict_Case(t\
    \ *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected:\
    \ true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\"\
    , \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual:\
    \ candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__0\
    \ (0.00s)\n        tmpc4uzthnr_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpc4uzthnr_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__5\
    \ (0.00s)\n        tmpc4uzthnr_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074899
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    // set the\
    \ value to the first key\n    var case_first string\n    for key, _ := range dict\
    \ {\n        case_first = key\n        break\n    }\n    var case_string string\n\
    \    if case_first == strings.ToLower(case_first) {\n        case_string = \"\
    lower\"\n    } else {\n        case_string = \"upper\"\n    }\n    for key, _\
    \ := range dict {\n        if key == strings.ToLower(key) && case_string == \"\
    upper\" {\n            return false\n        } else if key == strings.ToUpper(key)\
    \ && case_string == \"lower\" {\n            return false\n        }\n    }\n\
    \    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate :=\
    \ check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqgfit0zc_test.go:33:22: undefined: strings

    /tmp/tmpqgfit0zc_test.go:39:19: undefined: strings

    /tmp/tmpqgfit0zc_test.go:41:26: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074899
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    var allLowercase bool = true\n    var allUppercase bool = true\n\
    \    var result bool = false\n    if len(dict) == 0 {\n        return false\n\
    \    }\n    for key, _ := range dict {\n        //fmt.Println(key)\n        if\
    \ key == \"a\" {\n            fmt.Println(\"a\")\n        }\n        if key ==\
    \ \"A\" {\n            fmt.Println(\"A\")\n        }\n        if key == \"z\"\
    \ {\n            fmt.Println(\"z\")\n        }\n        if key == \"Z\" {\n  \
    \          fmt.Println(\"Z\")\n        }\n        if key == \"0\" {\n        \
    \    fmt.Println(\"0\")\n        }\n        if key == \"9\" {\n            fmt.Println(\"\
    9\")\n        }\n        if key == \".\" {\n            fmt.Println(\".\")\n \
    \       }\n        if key == \"_\" {\n            fmt.Println(\"_\")\n       \
    \ }\n        if key == \" \" {\n            fmt.Println(\" \")\n        }\n  \
    \      if key >= \"a\" && key <= \"z\" {\n            fmt.Println(\"lowercase\"\
    )\n            allUppercase = false\n        } else if key >= \"A\" && key <=\
    \ \"Z\" {\n            fmt.Println(\"uppercase\")\n            allLowercase =\
    \ false\n        } else {\n            return false\n        }\n    }\n    if\
    \ allLowercase || allUppercase {\n        result = true\n    }\n    return result\n\
    }\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "lowercase\nlowercase\nlowercase\nA\nuppercase\nuppercase\nlowercase\nuppercase\n\
    uppercase\nuppercase\nlowercase\nlowercase\n--- FAIL: TestCheck_Dict_Case (0.00s)\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__3 (0.00s)\n        tmpxxlkv7r1_test.go:93:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__4\
    \ (0.00s)\n        tmpxxlkv7r1_test.go:93: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074899
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    upper := true\n    lower := true\n    // empty dictionary\n    if\
    \ len(dict) == 0 {\n        return false\n    }\n    for key, _ := range dict\
    \ {\n        if !is_all_upper(key) {\n            upper = false\n        }\n \
    \       if !is_all_lower(key) {\n            lower = false\n        }\n    }\n\
    \    return (upper || lower)\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n\
    \  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8p8w9xc5_test.go:30:13: undefined: is_all_upper

    /tmp/tmp8p8w9xc5_test.go:33:13: undefined: is_all_lower

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074899
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate\
    \ := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__1\
    \ (0.00s)\n        tmpxym3deox_test.go:45: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpxym3deox_test.go:45:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__3\
    \ (0.00s)\n        tmpxym3deox_test.go:45: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpxym3deox_test.go:45:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074896
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if dict == nil {\n        return false\n    }\n    var upper bool\n\
    \    var lower bool\n    for key, value := range dict {\n        if key != strings.ToUpper(key)\
    \ {\n            lower = true\n        }\n        if key != strings.ToLower(key)\
    \ {\n            upper = true\n        }\n        if lower && upper {\n      \
    \      return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t\
    \ *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected:\
    \ true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\"\
    , \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual:\
    \ candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqqm_n7p__test.go:28:14: value declared but not used

    /tmp/tmpqqm_n7p__test.go:29:19: undefined: strings

    /tmp/tmpqqm_n7p__test.go:32:19: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074899
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    upper_case := false\n    for key, _ := range dict {\n        if\
    \ 64 < key[0] && key[0] < 91 {\n            upper_case = true\n        } else\
    \ if 96 < key[0] && key[0] < 123 {\n            if upper_case {\n            \
    \    return false\n            }\n        } else {\n            return false\n\
    \        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T)\
    \ {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__1\
    \ (0.00s)\n        tmpm1rf0n84_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__3 (0.00s)\n        tmpm1rf0n84_test.go:57:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6\
    \ (0.00s)\n        tmpm1rf0n84_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074899
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    // only lower\n\
    \    lower := true\n    for k, _ := range dict {\n        if (k != k || k != k)\
    \ {\n            return false\n        }\n        if (k == k) {\n            lower\
    \ = false\n        }\n    }\n    return lower\n}\n\nfunc TestCheck_Dict_Case(t\
    \ *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected:\
    \ true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\"\
    , \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual:\
    \ candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test

    /tmp/tmpvkt8lwvf_test.go:29:13: redundant or: k != k || k != k

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074899
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n\tupper, lower := true, true\n\tfor k, _ := range dict {\n\t\tif is_lower(k)\
    \ {\n\t\t\tupper = false\n\t\t} else {\n\t\t\tlower = false\n\t\t}\n\t}\n\treturn\
    \ upper || lower\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate :=\
    \ check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvx9jt2mz_test.go:25:6: undefined: is_lower

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074899
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    var (\n        lower_case, upper_case, mixed_case bool\n    )\n\
    \    for k, _ := range dict {\n        lower_case = is_lower_case(k)\n       \
    \ upper_case = is_upper_case(k)\n        mixed_case = is_mixed_case(k)\n     \
    \   if mixed_case {\n            return false\n        }\n        if lower_case\
    \ && upper_case {\n            return false\n        }\n    }\n    return true\n\
    }\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmn6ipgpu_test.go:27:22: undefined: is_lower_case

    /tmp/tmpmn6ipgpu_test.go:28:22: undefined: is_upper_case

    /tmp/tmpmn6ipgpu_test.go:29:22: undefined: is_mixed_case

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074899
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    keys := make([]string, len(dict))\n    for k := range dict {\n \
    \       keys = append(keys, k)\n    }\n    if len(keys) == 0 {\n        return\
    \ false\n    }\n    first := keys[0]\n    upper := first == strings.ToUpper(first)\n\
    \    for _, k := range keys {\n        if upper != (k == strings.ToUpper(k)) {\n\
    \            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t\
    \ *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected:\
    \ true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\"\
    , \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual:\
    \ candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpni2xkxod_test.go:31:23: undefined: strings

    /tmp/tmpni2xkxod_test.go:33:27: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074900
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    // Returns false for empty dict\n    if len(dict) == 0 {\n     \
    \   return false\n    }\n\n    // If a key has a lower-case letter, then it is\
    \ a lower-case \n    // string. The same goes for upper-case.\n    isUpper :=\
    \ true\n    isLower := true\n    for key, _ := range dict {\n        if key !=\
    \ toUpper(key) {\n            isUpper = false\n        }\n        if key != toLower(key)\
    \ {\n            isLower = false\n        }\n    }\n\n    // If either of these\
    \ conditions is true, it is all upper or \n    // all lower case\n    return isUpper\
    \ || isLower\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8_l230lf_test.go:33:19: undefined: toUpper

    /tmp/tmp8_l230lf_test.go:36:19: undefined: toLower

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074900
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    is_lower, is_upper := true, true\n    for k, _ := range dict {\n\
    \        if k != strings.ToLower(k) {\n            is_lower = false\n        }\n\
    \        if k != strings.ToUpper(k) {\n            is_upper = false\n        }\n\
    \    }\n    return is_lower || is_upper\n}\n\nfunc TestCheck_Dict_Case(t *testing.T)\
    \ {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppgr_d6x8_test.go:25:17: undefined: strings

    /tmp/tmppgr_d6x8_test.go:28:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074900
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    var lower_count int = 0\n    var upper_count int = 0\n    var no_count\
    \ int = 0\n    for key, _ := range dict {\n        if string(key[0]) == string(key[0]\
    \ + 32) {\n            lower_count += 1\n        } else if string(key[0]) == string(key[0]\
    \ - 32) {\n            upper_count += 1\n        } else {\n            no_count\
    \ += 1\n        }\n    }\n    if lower_count > 0 && upper_count > 0 {\n      \
    \  return false\n    } else if lower_count == 0 && upper_count == 0 {\n      \
    \  return false\n    } else {\n        return true\n    }\n}\n\nfunc TestCheck_Dict_Case(t\
    \ *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected:\
    \ true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\"\
    , \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual:\
    \ candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__0\
    \ (0.00s)\n        tmposl4xjh2_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmposl4xjh2_test.go:63:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__5\
    \ (0.00s)\n        tmposl4xjh2_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074901
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    var upper_cnt, lower_cnt int\n    for key, _ := range dict {\n \
    \       for _, c := range key {\n            if c >= 'A' && c <= 'Z' {\n     \
    \           upper_cnt++\n            } else if c >= 'a' && c <= 'z' {\n      \
    \          lower_cnt++\n            }\n        }\n    }\n    if upper_cnt == 0\
    \ && lower_cnt == 0 {\n        return false\n    }\n    return upper_cnt == 0\
    \ || lower_cnt == 0\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate\
    \ := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2\
    \ (0.00s)\n        tmp6tzm3o26_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074901
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    for k, _ := range dict {\n        if len(k) == 0 {\n           \
    \ return false\n        }\n        if k[0] >= 'A' && k[0] <= 'Z' {\n         \
    \   for j := 1; j < len(k); j++ {\n                if k[j] < 'A' || k[j] > 'Z'\
    \ {\n                    return false\n                }\n            }\n    \
    \    } else if k[0] >= 'a' && k[0] <= 'z' {\n            for j := 1; j < len(k);\
    \ j++ {\n                if k[j] < 'a' || k[j] > 'z' {\n                    return\
    \ false\n                }\n            }\n        } else {\n            return\
    \ false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T)\
    \ {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__1\
    \ (0.00s)\n        tmp4jc76ee__test.go:65: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmp4jc76ee__test.go:65:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074901
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    if len(dict)\
    \ == 1 {\n        return true\n    }\n    for _, val := range dict {\n       \
    \ for _, val1 := range dict {\n            if val != val1 {\n                return\
    \ false\n            }\n        }\n    }\n    for k, _ := range dict {\n     \
    \   for k1, _ := range dict {\n            if k != k1 {\n                return\
    \ false\n            }\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t\
    \ *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected:\
    \ true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\"\
    , \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual:\
    \ candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__0\
    \ (0.00s)\n        tmphdr5339t_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmphdr5339t_test.go:65:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__5\
    \ (0.00s)\n        tmphdr5339t_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074901
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    is_upper :=\
    \ true\n    is_lower := true\n    for k, _ := range dict {\n        if k != strings.ToUpper(k)\
    \ {\n            is_upper = false\n        }\n        if k != strings.ToLower(k)\
    \ {\n            is_lower = false\n        }\n    }\n    return is_upper || is_lower\n\
    }\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpu5iq22zj_test.go:29:17: undefined: strings

    /tmp/tmpu5iq22zj_test.go:32:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074718
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    // if len(dict) == 0 {\n    //     return false\n    // }\n    is_lower_case\
    \ := false\n    is_upper_case := false\n    for k, _ := range dict {\n       \
    \ if k == to_lower_case(k) {\n            is_lower_case = true\n        } else\
    \ if k == to_upper_case(k) {\n            is_upper_case = true\n        } else\
    \ {\n            return false\n        }\n    }\n    return is_lower_case || is_upper_case\n\
    }\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1rksr5v3_test.go:29:17: undefined: to_lower_case

    /tmp/tmp1rksr5v3_test.go:31:24: undefined: to_upper_case

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074900
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    lowercase := true\n    uppercase := true\n    for key, _ := range\
    \ dict {\n        if (key != strings.ToLower(key)) {\n            lowercase =\
    \ false\n        }\n        if (key != strings.ToUpper(key)) {\n            uppercase\
    \ = false\n        }\n    }\n    return lowercase || uppercase\n}\n\nfunc TestCheck_Dict_Case(t\
    \ *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected:\
    \ true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\"\
    , \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual:\
    \ candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpli05kypk_test.go:26:20: undefined: strings

    /tmp/tmpli05kypk_test.go:29:20: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074901
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    upper := true\n\
    \    lower := true\n    for k, _ := range dict {\n        if k == strings.ToUpper(k)\
    \ {\n            lower = false\n        } else if k == strings.ToLower(k) {\n\
    \            upper = false\n        } else {\n            return false\n     \
    \   }\n    }\n    return upper || lower\n}\n\nfunc TestCheck_Dict_Case(t *testing.T)\
    \ {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpu82kkiws_test.go:29:17: undefined: strings

    /tmp/tmpu82kkiws_test.go:31:24: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074901
- exit_code: 0
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    isUpper :=\
    \ func(s string) bool {\n        for _, c := range s {\n            if c >= 'a'\
    \ && c <= 'z' {\n                return false\n            }\n        }\n    \
    \    return true\n    }\n    isLower := func(s string) bool {\n        for _,\
    \ c := range s {\n            if c >= 'A' && c <= 'Z' {\n                return\
    \ false\n            }\n        }\n        return true\n    }\n    for k, _ :=\
    \ range dict {\n        if !isUpper(k) && !isLower(k) {\n            return false\n\
    \        }\n    }\n    for k, _ := range dict {\n        if isUpper(k) {\n   \
    \         for k, _ := range dict {\n                if !isUpper(k) {\n       \
    \             return false\n                }\n            }\n            return\
    \ true\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T)\
    \ {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074901
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    if len(dict)\
    \ == 1 {\n        return true\n    }\n    lower := true\n    upper := true\n \
    \   for key, _ := range dict {\n        if !is_lower(key) {\n            lower\
    \ = false\n        }\n        if !is_upper(key) {\n            upper = false\n\
    \        }\n    }\n    return lower || upper\n}\n\nfunc TestCheck_Dict_Case(t\
    \ *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected:\
    \ true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\"\
    , \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual:\
    \ candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6osqsbwi_test.go:32:13: undefined: is_lower

    /tmp/tmp6osqsbwi_test.go:35:13: undefined: is_upper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074901
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    return false\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate\
    \ := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__0\
    \ (0.00s)\n        tmpjt1g8lli_test.go:45: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpjt1g8lli_test.go:45:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__5\
    \ (0.00s)\n        tmpjt1g8lli_test.go:45: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074718
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    var lower,\
    \ upper bool\n    for k, _ := range dict {\n        if k == lc(k) {\n        \
    \    lower = true\n        } else if k == uc(k) {\n            upper = true\n\
    \        } else {\n            return false\n        }\n    }\n    return lower\
    \ || upper\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprwowku8r_test.go:28:17: undefined: lc

    /tmp/tmprwowku8r_test.go:30:24: undefined: uc

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074901
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    lower_case\
    \ := false\n    upper_case := false\n    for k, _ := range dict {\n        if\
    \ k == strings.ToLower(k) {\n            lower_case = true\n        } else if\
    \ k == strings.ToUpper(k) {\n            upper_case = true\n        } else {\n\
    \            return false\n        }\n    }\n    return lower_case || upper_case\n\
    }\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7oedcdbm_test.go:29:17: undefined: strings

    /tmp/tmp7oedcdbm_test.go:31:24: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074901
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for k, _ :=\
    \ range dict {\n        switch {\n        case k[0] >= 'a' && k[0] <= 'z':\n \
    \           for _, v := range k {\n                if v < 'a' || v > 'z' {\n \
    \                   return false\n                }\n            }\n        case\
    \ k[0] >= 'A' && k[0] <= 'Z':\n            for _, v := range k {\n           \
    \     if v < 'A' || v > 'Z' {\n                    return false\n            \
    \    }\n            }\n        default:\n            return false\n        }\n\
    \    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate\
    \ := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__1\
    \ (0.00s)\n        tmpleizdpd5_test.go:66: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074902
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    var allUpper bool\n    var allLower bool\n    for key, value :=\
    \ range dict {\n        if allUpper && allLower {\n            return false\n\
    \        }\n        if allUpper && !isUpper(key) {\n            return false\n\
    \        }\n        if allLower && !isLower(key) {\n            return false\n\
    \        }\n        if allUpper && isUpper(key) {\n            allUpper = true\n\
    \        } else {\n            allUpper = false\n        }\n        if allLower\
    \ && isLower(key) {\n            allLower = true\n        } else {\n         \
    \   allLower = false\n        }\n        fmt.Println(key, \" => \", value)\n \
    \   }\n    return allUpper || allLower\n}\n\nfunc TestCheck_Dict_Case(t *testing.T)\
    \ {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpd6n4egc3_test.go:29:25: undefined: isUpper

    /tmp/tmpd6n4egc3_test.go:32:25: undefined: isLower

    /tmp/tmpd6n4egc3_test.go:35:24: undefined: isUpper

    /tmp/tmpd6n4egc3_test.go:40:24: undefined: isLower

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074901
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    var isEmpty bool = true\n    var upperOrLower bool = false\n\n \
    \   for k, _ := range dict {\n        if isEmpty == true {\n            isEmpty\
    \ = false\n            // First key is uppercase\n            if k == k + \" \"\
    \ {\n                upperOrLower = true\n            }\n        } else {\n  \
    \          // if upperOrLower is true, then we should ensure all other keys are\
    \ upper\n            if upperOrLower == true {\n                if k != k + \"\
    \ \" {\n                    return false\n                }\n            } else\
    \ {\n                if k == k + \" \" {\n                    return false\n \
    \               }\n            }\n        }\n    }\n    return !isEmpty\n}\n\n\
    func TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__1\
    \ (0.00s)\n        tmplpn_i5kh_test.go:68: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmplpn_i5kh_test.go:68:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__3\
    \ (0.00s)\n        tmplpn_i5kh_test.go:68: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074902
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    is_lower := false\n    is_upper := false\n    if len(dict) == 0\
    \ {\n        return false\n    }\n\n    for key, _ := range dict {\n        //\
    \ is_lower = false\n        // is_upper = false\n        fmt.Println(key)\n  \
    \      if key == key {\n            fmt.Println(\"1 \", key)\n            is_lower\
    \ = true\n        } else {\n            fmt.Println(\"2 \", key)\n           \
    \ is_upper = true\n        }\n    }\n    fmt.Println(is_lower, is_upper)\n   \
    \ if is_lower == true && is_upper == false {\n        return true\n    } else\
    \ if is_lower == false && is_upper == true {\n        return true\n    }\n   \
    \ return false\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate :=\
    \ check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "p\n1  p\nb\n1  b\ntrue false\np\n1  p\nA\n1  A\nB\n1  B\ntrue false\np\n\
    1  p\n5\n1  5\na\n1  a\ntrue false\nName\n1  Name\nAge\n1  Age\nCity\n1  City\n\
    true false\nZIP\n1  ZIP\nSTATE\n1  STATE\ntrue false\nfruit\n1  fruit\ntaste\n\
    1  taste\ntrue false\n--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__1\
    \ (0.00s)\n        tmp__mw9mvj_test.go:69: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmp__mw9mvj_test.go:69:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__3\
    \ (0.00s)\n        tmp__mw9mvj_test.go:69: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074902
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    for k, v := range dict {\n        fmt.Println(k, v)\n    }\n   \
    \ return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "p pineapple\nb banana\np pineapple\nA banana\nB banana\np pineapple\n5\
    \ banana\na apple\nName John\nAge 36\nCity Houston\nSTATE NC\nZIP 12345\nfruit\
    \ Orange\ntaste Sweet\n--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__1\
    \ (0.00s)\n        tmpgh1qvtav_test.go:48: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpgh1qvtav_test.go:48:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__3\
    \ (0.00s)\n        tmpgh1qvtav_test.go:48: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpgh1qvtav_test.go:48:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074902
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n   \
    \ //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n\
    \    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n\
    \    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n\
    \    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n\
    \    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n\
    \    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n\
    \    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n\
    \    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n\
    \    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n\
    \    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n\
    \    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n\
    \    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n\
    \    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n\
    \    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n\
    \    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n\
    \    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n\
    \    //\n    //\n   \nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate :=\
    \ check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjb4bx00p_test.go:194:6: expected ''('', found TestCheck_Dict_Case

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074901
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    allUpper := true\n    allLower := true\n    for k, v := range dict\
    \ {\n        fmt.Println(k, v)\n        if isUpperCase(k) {\n            allLower\
    \ = false\n        } else {\n            allUpper = false\n        }\n    }\n\
    \    return allUpper || allLower\n}\n\nfunc TestCheck_Dict_Case(t *testing.T)\
    \ {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_zro__9__test.go:27:12: undefined: isUpperCase

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074901
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    if (len(dict)\
    \ % 2) == 0 {\n        // odd number of elements\n        return false\n    }\n\
    \    isUpper := false\n    isLower := false\n    for key, _ := range dict {\n\
    \        if isUpper {\n            if isUpperCase(key) {\n                continue\n\
    \            } else {\n                return false\n            }\n        }\
    \ else if isLower {\n            if isLowerCase(key) {\n                continue\n\
    \            } else {\n                return false\n            }\n        }\
    \ else {\n            // First key not evaluated\n            if isUpperCase(key)\
    \ {\n                isUpper = true\n            } else if isLowerCase(key) {\n\
    \                isLower = true\n            } else {\n                return\
    \ false\n            }\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t\
    \ *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected:\
    \ true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\"\
    , \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual:\
    \ candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptilaiulx_test.go:34:16: undefined: isUpperCase

    /tmp/tmptilaiulx_test.go:40:16: undefined: isLowerCase

    /tmp/tmptilaiulx_test.go:47:16: undefined: isUpperCase

    /tmp/tmptilaiulx_test.go:49:23: undefined: isLowerCase

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074901
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    keys := make([]string, len(dict))\n    i := 0\n    for k := range\
    \ dict {\n        keys[i] = k\n        i++\n    }\n    //fmt.Println(keys)\n \
    \   upper := false\n    lower := false\n    for _, v := range keys {\n       \
    \ isUpper := false\n        isLower := false\n        for _, b := range v {\n\
    \            if b >= 'A' && b <= 'Z' {\n                isUpper = true\n     \
    \       }\n            if b >= 'a' && b <= 'z' {\n                isLower = true\n\
    \            }\n        }\n        if isUpper && isLower {\n            return\
    \ false\n        }\n        if isUpper {\n            upper = true\n        }\n\
    \        if isLower {\n            lower = true\n        }\n    }\n    return\
    \ !(upper && lower)\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate\
    \ := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2\
    \ (0.00s)\n        tmpjmxjgluk_test.go:75: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpjmxjgluk_test.go:75:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074902
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate\
    \ := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__1\
    \ (0.00s)\n        tmpxym3deox_test.go:45: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpxym3deox_test.go:45:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__3\
    \ (0.00s)\n        tmpxym3deox_test.go:45: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpxym3deox_test.go:45:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074896
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    var lower_check = true\n    var upper_check = true\n    for key,\
    \ _ := range dict {\n        if lower_check {\n            lower_check = key ==\
    \ to_lower_case(key)\n        }\n        if upper_check {\n            upper_check\
    \ = key == to_upper_case(key)\n        }\n    }\n    return lower_check || upper_check\n\
    }\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1maha649_test.go:27:34: undefined: to_lower_case

    /tmp/tmp1maha649_test.go:30:34: undefined: to_upper_case

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074902
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    var upper\
    \ bool\n    for k, _ := range dict {\n        if k == strings.ToUpper(k) {\n \
    \           upper = true\n        } else {\n            upper = false\n      \
    \      break\n        }\n    }\n    if upper {\n        return true\n    }\n \
    \   var lower bool\n    for k, _ := range dict {\n        if k == strings.ToLower(k)\
    \ {\n            lower = true\n        } else {\n            lower = false\n \
    \           break\n        }\n    }\n    if lower {\n        return true\n   \
    \ }\n    return false\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate\
    \ := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjw7drl6k_test.go:28:17: undefined: strings

    /tmp/tmpjw7drl6k_test.go:40:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074716
- exit_code: 0
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    isUpper :=\
    \ true\n    isLower := true\n    for k, _ := range dict {\n        if (k == \"\
    \") {\n            return false\n        }\n        for _, c := range k {\n  \
    \          if (c >= 'A' && c <= 'Z') {\n                isLower = false\n    \
    \        } else if (c >= 'a' && c <= 'z') {\n                isUpper = false\n\
    \            } else {\n                return false\n            }\n        }\n\
    \    }\n    return isUpper || isLower\n}\n\nfunc TestCheck_Dict_Case(t *testing.T)\
    \ {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074903
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    caseUp :=\
    \ true\n    caseDown := true\n    for k, _ := range dict {\n        if caseUp\
    \ {\n            if k != string([]rune(k)[0] + 32) {\n                caseUp =\
    \ false\n            }\n        }\n        if caseDown {\n            if k !=\
    \ string([]rune(k)[0] - 32) {\n                caseDown = false\n            }\n\
    \        }\n    }\n    return caseUp || caseDown\n}\n\nfunc TestCheck_Dict_Case(t\
    \ *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected:\
    \ true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\"\
    , \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual:\
    \ candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__0\
    \ (0.00s)\n        tmpfhjldrly_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpfhjldrly_test.go:62:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__5\
    \ (0.00s)\n        tmpfhjldrly_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074903
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    // check if\
    \ all keys are in upper case\n    for k, _ := range dict {\n        if k != toUpper(k)\
    \ {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t\
    \ *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected:\
    \ true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\"\
    , \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual:\
    \ candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1pji43tk_test.go:28:17: undefined: toUpper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074902
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    all_low :=\
    \ true\n    all_up := true\n    for k, _ := range dict {\n        if k != strings.ToLower(k)\
    \ {\n            all_low = false\n        }\n        if k != strings.ToUpper(k)\
    \ {\n            all_up = false\n        }\n    }\n    return all_low || all_up\n\
    }\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf1y2kx4x_test.go:29:17: undefined: strings

    /tmp/tmpf1y2kx4x_test.go:32:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074903
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if dict == nil {\n        return false\n    }\n    var lowerCaseKeys\
    \ bool\n    var upperCaseKeys bool\n    for key, _ := range dict {\n        if\
    \ key == \"\" {\n            continue\n        }\n        if upperCaseKeys &&\
    \ lowerCaseKeys {\n            return false\n        }\n        if !upperCaseKeys\
    \ && key == strings.ToUpper(key) {\n            upperCaseKeys = true\n       \
    \ }\n        if !lowerCaseKeys && key == strings.ToLower(key) {\n            lowerCaseKeys\
    \ = true\n        }\n    }\n    return lowerCaseKeys || upperCaseKeys\n}\n\nfunc\
    \ TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpktw_c0eq_test.go:35:37: undefined: strings

    /tmp/tmpktw_c0eq_test.go:38:37: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074903
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for k, _ :=\
    \ range dict {\n        for i := 0; i < len(k); i++ {\n            if k[i] >=\
    \ 'A' && k[i] <= 'Z' {\n                return false\n            }\n        }\n\
    \    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate\
    \ := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2\
    \ (0.00s)\n        tmp2wlyhy_q_test.go:55: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmp2wlyhy_q_test.go:55:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074903
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    l := len(dict)\n    if l == 0 {\n        return false\n    }\n \
    \   lower_keys := 0\n    upper_keys := 0\n    all_are_strings := true\n    for\
    \ k, v := range dict {\n        if k != \"\" && v != \"\" {\n            if string(k[0])\
    \ == strings.ToLower(string(k[0])) {\n                lower_keys += 1\n      \
    \      } else if string(k[0]) == strings.ToUpper(string(k[0])) {\n           \
    \     upper_keys += 1\n            }\n        } else {\n            all_are_strings\
    \ = false\n        }\n    }\n    if all_are_strings {\n        if lower_keys ==\
    \ l {\n            return true\n        } else if upper_keys == l {\n        \
    \    return true\n        }\n    }\n    return false\n}\n\nfunc TestCheck_Dict_Case(t\
    \ *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected:\
    \ true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\"\
    , \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual:\
    \ candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7qmbifcj_test.go:32:32: undefined: strings

    /tmp/tmp7qmbifcj_test.go:34:39: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074903
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    // your code here\n    return false\n}\n\nfunc TestCheck_Dict_Case(t\
    \ *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected:\
    \ true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\"\
    , \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual:\
    \ candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__0\
    \ (0.00s)\n        tmpc4uzthnr_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpc4uzthnr_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__5\
    \ (0.00s)\n        tmpc4uzthnr_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074899
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    var (\n  \
    \      all_lower = true\n        all_upper = true\n    )\n    for k, _ := range\
    \ dict {\n        if all_lower && !is_lower_case(k) {\n            all_lower =\
    \ false\n        }\n        if all_upper && !is_upper_case(k) {\n            all_upper\
    \ = false\n        }\n    }\n    return all_lower || all_upper\n}\n\nfunc TestCheck_Dict_Case(t\
    \ *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected:\
    \ true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\"\
    , \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual:\
    \ candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmple49427g_test.go:31:26: undefined: is_lower_case

    /tmp/tmple49427g_test.go:34:26: undefined: is_upper_case

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074903
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    upper := 0\n    lower := 0\n    total := 0\n    for k, _ := range\
    \ dict {\n        total++\n        if k == k {\n            upper++\n        }\
    \ else {\n            lower++\n        }\n    }\n    return upper == total ||\
    \ lower == total\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate :=\
    \ check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__1\
    \ (0.00s)\n        tmp6vq9pdch_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmp6vq9pdch_test.go:56:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__3\
    \ (0.00s)\n        tmp6vq9pdch_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmp6vq9pdch_test.go:56:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074903
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    allUpper :=\
    \ true\n    allLower := true\n    for key, _ := range dict {\n        if key ==\
    \ \"\" {\n            continue\n        }\n        if key[0] >= 'a' && key[0]\
    \ <= 'z' {\n            allUpper = false\n        } else if key[0] >= 'A' && key[0]\
    \ <= 'Z' {\n            allLower = false\n        } else {\n            return\
    \ false\n        }\n    }\n    return allUpper || allLower\n}\n\nfunc TestCheck_Dict_Case(t\
    \ *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected:\
    \ true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\"\
    , \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual:\
    \ candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__3\
    \ (0.00s)\n        tmpj9g6jghg_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074903
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    var type_key\
    \ string\n    for key, _ := range dict {\n        if len(type_key) == 0 {\n  \
    \          if key == ToUpper(key) {\n                type_key = \"upper\"\n  \
    \          } else if key == ToLower(key) {\n                type_key = \"lower\"\
    \n            } else {\n                return false\n            }\n        }\
    \ else {\n            if type_key == \"upper\" && key != ToUpper(key) {\n    \
    \            return false\n            } else if type_key == \"lower\" && key\
    \ != ToLower(key) {\n                return false\n            }\n        }\n\
    \    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate\
    \ := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdvx9jtfv_test.go:29:23: undefined: ToUpper

    /tmp/tmpdvx9jtfv_test.go:31:30: undefined: ToLower

    /tmp/tmpdvx9jtfv_test.go:37:46: undefined: ToUpper

    /tmp/tmpdvx9jtfv_test.go:39:53: undefined: ToLower

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074903
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    all_keys_are_lowercase := true\n    all_keys_are_uppercase := true\n\
    \    for key, _ := range dict {\n        all_keys_are_lowercase = all_keys_are_lowercase\
    \ && (key == strings.ToLower(key))\n        all_keys_are_uppercase = all_keys_are_uppercase\
    \ && (key == strings.ToUpper(key))\n    }\n    return all_keys_are_lowercase ||\
    \ all_keys_are_uppercase\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate\
    \ := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3nwsz9bl_test.go:26:68: undefined: strings

    /tmp/tmp3nwsz9bl_test.go:27:68: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074903
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    return false\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate\
    \ := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__0\
    \ (0.00s)\n        tmpjt1g8lli_test.go:45: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpjt1g8lli_test.go:45:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__5\
    \ (0.00s)\n        tmpjt1g8lli_test.go:45: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074718
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    isLower :=\
    \ false\n    isUpper := false\n    for key, _ := range dict {\n        if key\
    \ == \"\" {\n            return false\n        }\n        if key == strings.ToLower(key)\
    \ {\n            isLower = true\n        } else if key == strings.ToUpper(key)\
    \ {\n            isUpper = true\n        } else {\n            return false\n\
    \        }\n    }\n    return isLower != isUpper\n}\n\nfunc TestCheck_Dict_Case(t\
    \ *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected:\
    \ true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\"\
    , \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual:\
    \ candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvju26hej_test.go:32:19: undefined: strings

    /tmp/tmpvju26hej_test.go:34:26: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074903
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    is_all_upper := true\n    is_all_lower := true\n    for key, _ :=\
    \ range dict {\n        if is_all_upper && key != keyUpper(key) {\n          \
    \  is_all_upper = false\n        }\n        if is_all_lower && key != keyLower(key)\
    \ {\n            is_all_lower = false\n        }\n    }\n    return is_all_upper\
    \ || is_all_lower\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate\
    \ := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7b3qgslu_test.go:26:35: undefined: keyUpper

    /tmp/tmp7b3qgslu_test.go:29:35: undefined: keyLower

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074903
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    if check_upper_case(dict)\
    \ && check_lower_case(dict) {\n        return false\n    }\n    return true\n\
    }\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpd6_ksjs5_test.go:26:8: undefined: check_upper_case

    /tmp/tmpd6_ksjs5_test.go:26:34: undefined: check_lower_case

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074903
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    return false\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate\
    \ := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__0\
    \ (0.00s)\n        tmpjt1g8lli_test.go:45: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpjt1g8lli_test.go:45:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__5\
    \ (0.00s)\n        tmpjt1g8lli_test.go:45: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074718
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n\treturn false\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate\
    \ := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__0\
    \ (0.00s)\n        tmpzl_zaog__test.go:45: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpzl_zaog__test.go:45:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__5\
    \ (0.00s)\n        tmpzl_zaog__test.go:45: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074904
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    var is_lower\
    \ bool\n    for key, _ := range dict {\n        if key[0] >= 'a' && key[0] <=\
    \ 'z' {\n            is_lower = true\n            break\n        }\n    }\n  \
    \  if is_lower {\n        for key, _ := range dict {\n            if key[0] <\
    \ 'a' || key[0] > 'z' {\n                return false\n            }\n       \
    \ }\n    } else {\n        for key, _ := range dict {\n            if key[0] <\
    \ 'A' || key[0] > 'Z' {\n                return false\n            }\n       \
    \ }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n \
    \ candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__3\
    \ (0.00s)\n        tmp0j6pbmvd_test.go:68: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074904
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    upper := true\n\
    \    lower := true\n    for k, _ := range dict {\n        if k != strings.ToUpper(k)\
    \ {\n            upper = false\n        }\n        if k != strings.ToLower(k)\
    \ {\n            lower = false\n        }\n    }\n    return upper || lower\n\
    }\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphz_b4asu_test.go:29:17: undefined: strings

    /tmp/tmphz_b4asu_test.go:32:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074716
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    for key, _ := range dict {\n        if (key == strings.ToLower(key))\
    \ {\n            fmt.Println(\"All keys should be lowercase\")\n            return\
    \ false\n        } else if (key == strings.ToUpper(key)) {\n            fmt.Println(\"\
    All keys should be uppercase\")\n            return false\n        }\n    }\n\
    \    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate :=\
    \ check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpklhzk3hl_test.go:24:20: undefined: strings

    /tmp/tmpklhzk3hl_test.go:27:27: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074904
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    var isLower bool\n    for k, _ := range dict {\n        for _, c\
    \ := range k {\n            if c >= 'A' && c <= 'Z' {\n                if isLower\
    \ {\n                    return false\n                }\n                isLower\
    \ = false\n            } else if c >= 'a' && c <= 'z' {\n                if !isLower\
    \ {\n                    return false\n                }\n                isLower\
    \ = true\n            } else {\n                return false\n            }\n\
    \        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T)\
    \ {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__0\
    \ (0.00s)\n        tmp_s5zusk8_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__5 (0.00s)\n        tmp_s5zusk8_test.go:63:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6\
    \ (0.00s)\n        tmp_s5zusk8_test.go:63: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074904
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n\treturn false\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate\
    \ := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__0\
    \ (0.00s)\n        tmpzl_zaog__test.go:45: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpzl_zaog__test.go:45:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__5\
    \ (0.00s)\n        tmpzl_zaog__test.go:45: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074904
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    // Empty maps are not accepted.\n    if len(dict) == 0 {\n     \
    \   return false\n    }\n\n    // Lower case?\n    lower_case := true\n    for\
    \ key, _ := range dict {\n        if key != to_lower(key) {\n            lower_case\
    \ = false\n            break\n        }\n    }\n\n    // Upper case?\n    upper_case\
    \ := true\n    for key, _ := range dict {\n        if key != to_upper(key) {\n\
    \            upper_case = false\n            break\n        }\n    }\n\n    return\
    \ lower_case || upper_case\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate\
    \ := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9n2jjn5c_test.go:31:19: undefined: to_lower

    /tmp/tmp9n2jjn5c_test.go:40:19: undefined: to_upper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074904
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if dict == nil {\n        return false\n    }\n    if len(dict)\
    \ == 0 {\n        return false\n    }\n    var up bool\n    for k, _ := range\
    \ dict {\n        if k == \"\" {\n            continue\n        }\n        //\
    \ Check if the first char is upper case.\n        // If so, all key should be\
    \ upper case.\n        if is_upper(k[0]) {\n            if !up {\n           \
    \     up = true\n            }\n            if !is_upper(k) {\n              \
    \  return false\n            }\n        } else {\n            if up {\n      \
    \          return false\n            }\n        }\n    }\n    return true\n}\n\
    \nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpt5fhn6hn_test.go:36:12: undefined: is_upper

    /tmp/tmpt5fhn6hn_test.go:40:17: undefined: is_upper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074904
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    lower, upper\
    \ := 0, 0\n    for k, v := range dict {\n        if k == strings.ToLower(k) {\n\
    \            lower += 1\n        } else if k == strings.ToUpper(k) {\n       \
    \     upper += 1\n        } else {\n            return false\n        }\n    }\n\
    \    return lower == len(dict) || upper == len(dict)\n}\n\nfunc TestCheck_Dict_Case(t\
    \ *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected:\
    \ true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\"\
    , \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual:\
    \ candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7tfmgpqt_test.go:27:12: v declared but not used

    /tmp/tmp7tfmgpqt_test.go:28:17: undefined: strings

    /tmp/tmp7tfmgpqt_test.go:30:24: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074904
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    var is_lowercase, is_uppercase bool\n    for key, _ := range dict\
    \ {\n        if IsLower(key) {\n            is_lowercase = true\n        } else\
    \ if IsUpper(key) {\n            is_uppercase = true\n        } else {\n     \
    \       return false\n        }\n    }\n    return is_lowercase || is_uppercase\n\
    }\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3uft4zbt_test.go:25:12: undefined: IsLower

    /tmp/tmp3uft4zbt_test.go:27:19: undefined: IsUpper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074904
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    var first_key\
    \ string\n    for k, _ := range dict {\n        first_key = k\n        break\n\
    \    }\n    var is_first_upper bool\n    if first_key == first_key {\n       \
    \ is_first_upper = true\n    } else {\n        is_first_upper = false\n    }\n\
    \    for k, _ := range dict {\n        if is_first_upper && k != k {\n       \
    \     return false\n        } else if !is_first_upper && k == k {\n          \
    \  return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t\
    \ *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected:\
    \ true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\"\
    , \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual:\
    \ candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__1\
    \ (0.00s)\n        tmp70xsws2s_test.go:66: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmp70xsws2s_test.go:66:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__3\
    \ (0.00s)\n        tmp70xsws2s_test.go:66: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074905
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    isLower :=\
    \ false\n    isUpper := false\n    for k, _ := range dict {\n        isLower =\
    \ isLower || (k == strings.ToLower(k))\n        isUpper = isUpper || (k == strings.ToUpper(k))\n\
    \    }\n    return (isLower && !isUpper) || (!isLower && isUpper)\n}\n\nfunc TestCheck_Dict_Case(t\
    \ *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected:\
    \ true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\"\
    , \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual:\
    \ candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjr_6zty4_test.go:29:36: undefined: strings

    /tmp/tmpjr_6zty4_test.go:30:36: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074905
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    lowerCase\
    \ := true\n    upperCase := true\n    for key, _ := range dict {\n        if key\
    \ == strings.ToLower(key) {\n            upperCase = false\n        } else if\
    \ key == strings.ToUpper(key) {\n            lowerCase = false\n        } else\
    \ {\n            return false\n        }\n    }\n    return upperCase || lowerCase\n\
    }\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7z04c56r_test.go:29:19: undefined: strings

    /tmp/tmp7z04c56r_test.go:31:26: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074905
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for k, _ :=\
    \ range dict {\n        if k == \"\" {\n            return false\n        }\n\
    \        for _, c := range k {\n            if (c >= 'A' && c <= 'Z') || (c >=\
    \ 'a' && c <= 'z') {\n                continue\n            }\n            return\
    \ false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T)\
    \ {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__1\
    \ (0.00s)\n        tmprwfxicf5_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__3 (0.00s)\n        tmprwfxicf5_test.go:59:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074905
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    is_lower_case\
    \ := false\n    for k, _ := range dict {\n        if k == strings.ToLower(k) {\n\
    \            is_lower_case = true\n            break\n        }\n    }\n    for\
    \ k, _ := range dict {\n        if (is_lower_case && k != strings.ToLower(k))\
    \ ||\n            (!is_lower_case && k != strings.ToUpper(k)) {\n            return\
    \ false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T)\
    \ {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpw0xeawce_test.go:28:17: undefined: strings

    /tmp/tmpw0xeawce_test.go:34:35: undefined: strings

    /tmp/tmpw0xeawce_test.go:35:37: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074905
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    upper := true\n\
    \    lower := true\n    for k, _ := range dict {\n        if k != strings.ToUpper(k)\
    \ {\n            upper = false\n        }\n        if k != strings.ToLower(k)\
    \ {\n            lower = false\n        }\n    }\n    return upper || lower\n\
    }\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphz_b4asu_test.go:29:17: undefined: strings

    /tmp/tmphz_b4asu_test.go:32:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074716
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for key, _\
    \ := range dict {\n        if key != strings.ToLower(key) && key != strings.ToUpper(key)\
    \ {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t\
    \ *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected:\
    \ true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\"\
    , \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual:\
    \ candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_1kfs813_test.go:27:19: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074718
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    upper_case\
    \ := false\n    for key, _ := range dict {\n        if key[0] >= 'A' && key[0]\
    \ <= 'Z' {\n            upper_case = true\n            break\n        }\n    }\n\
    \    for key, _ := range dict {\n        if upper_case && (key[0] < 'A' || key[0]\
    \ > 'Z') {\n            return false\n        }\n        if !upper_case && (key[0]\
    \ < 'a' || key[0] > 'z') {\n            return false\n        }\n    }\n    return\
    \ true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__3\
    \ (0.00s)\n        tmpj1tf0feg_test.go:63: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074905
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    var lowercase,\
    \ uppercase bool\n    for k, _ := range dict {\n        if k == strings.ToLower(k)\
    \ {\n            lowercase = true\n        } else if k == strings.ToUpper(k) {\n\
    \            uppercase = true\n        } else {\n            return false\n  \
    \      }\n    }\n    return lowercase && uppercase\n}\n\nfunc TestCheck_Dict_Case(t\
    \ *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected:\
    \ true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\"\
    , \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual:\
    \ candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbrqy4z58_test.go:28:17: undefined: strings

    /tmp/tmpbrqy4z58_test.go:30:24: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074905
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for k, _ :=\
    \ range dict {\n        if k != strings.ToLower(k) && k != strings.ToUpper(k)\
    \ {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t\
    \ *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected:\
    \ true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\"\
    , \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual:\
    \ candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplizqk2gp_test.go:27:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074715
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    is_upper :=\
    \ false\n    is_lower := false\n    for key, _ := range dict {\n        if key\
    \ == strings.ToUpper(key) {\n            is_upper = true\n        } else if key\
    \ == strings.ToLower(key) {\n            is_lower = true\n        } else {\n \
    \           return false\n        }\n    }\n    return is_upper || is_lower\n\
    }\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpx8jwp831_test.go:29:19: undefined: strings

    /tmp/tmpx8jwp831_test.go:31:26: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074905
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    isLower :=\
    \ false\n    isUpper := false\n    for key, _ := range dict {\n        if isLower\
    \ && isUpper {\n            return false\n        }\n        if key == \"\" {\n\
    \            return false\n        }\n        if isLower == false && key == strings.ToLower(key)\
    \ {\n            isLower = true\n        }\n        if isUpper == false && key\
    \ == strings.ToUpper(key) {\n            isUpper = true\n        }\n    }\n  \
    \  return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate :=\
    \ check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvjqtj6nf_test.go:35:39: undefined: strings

    /tmp/tmpvjqtj6nf_test.go:38:39: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074905
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    // Check if map is empty.\n    if len(dict) == 0 {\n        return\
    \ false\n    }\n\n    // Check if all keys are upper or lower case.\n    is_all_upper_case\
    \ := true\n    is_all_lower_case := true\n    for key, _ := range dict {\n   \
    \     if key != \"\" {\n            if is_all_upper_case {\n                is_all_upper_case\
    \ = (key == upper(key))\n            }\n            if is_all_lower_case {\n \
    \               is_all_lower_case = (key == lower(key))\n            }\n     \
    \   }\n    }\n\n    return is_all_upper_case || is_all_lower_case\n}\n\nfunc TestCheck_Dict_Case(t\
    \ *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected:\
    \ true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\"\
    , \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual:\
    \ candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphq_9gnih_test.go:34:45: undefined: upper

    /tmp/tmphq_9gnih_test.go:37:45: undefined: lower

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074905
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    fmt.Println(dict)\n    if len(dict) == 0 {\n        return false\n\
    \    }\n    upper_keys := 0\n    lower_keys := 0\n    for k, _ := range dict {\n\
    \        if k == string(k) {\n            fmt.Println(k)\n            fmt.Println(string(k))\n\
    \            if k == string(k) {\n                return false\n            }\n\
    \            for i := 0; i < len(k); i++ {\n                if k[i] >= 65 && k[i]\
    \ <= 90 {\n                    upper_keys += 1\n                } else if k[i]\
    \ >= 97 && k[i] <= 122 {\n                    lower_keys += 1\n              \
    \  }\n            }\n        }\n    }\n    if upper_keys == 0 || lower_keys ==\
    \ 0 {\n        return true\n    }\n    return false\n}\n\nfunc TestCheck_Dict_Case(t\
    \ *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected:\
    \ true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\"\
    , \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual:\
    \ candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "map[b:banana p:pineapple]\np\np\nmap[A:banana B:banana p:pineapple]\nA\n\
    A\nmap[5:banana a:apple p:pineapple]\n5\n5\nmap[Age:36 City:Houston Name:John]\n\
    Name\nName\nmap[STATE:NC ZIP:12345]\nSTATE\nSTATE\nmap[fruit:Orange taste:Sweet]\n\
    fruit\nfruit\nmap[]\n--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__0\
    \ (0.00s)\n        tmpp36zzpw4_test.go:70: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpp36zzpw4_test.go:70:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__5\
    \ (0.00s)\n        tmpp36zzpw4_test.go:70: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074906
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    len_dict := len(dict)\n    if len_dict == 0 {\n        return false\n\
    \    }\n\n    // Check the first key if it is all lowercase.\n    // If the first\
    \ key is lowercase then we check that all other keys are lowercase\n    // otherwise\
    \ we check that all other keys are uppercase.\n    is_first_key_lower := true\n\
    \    for _, c := range dict {\n        if c == string(c) {\n            is_first_key_lower\
    \ = false\n            break\n        }\n    }\n\n    // Loop through all keys\n\
    \    for key, _ := range dict {\n        if is_first_key_lower {\n           \
    \ if key != string(key) {\n                return false\n            }\n     \
    \   } else {\n            if key == string(key) {\n                return false\n\
    \            }\n        }\n    }\n\n    return true\n}\n\nfunc TestCheck_Dict_Case(t\
    \ *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected:\
    \ true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\"\
    , \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual:\
    \ candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__0\
    \ (0.00s)\n        tmpj859jtwn_test.go:74: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpj859jtwn_test.go:74:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__5\
    \ (0.00s)\n        tmpj859jtwn_test.go:74: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074906
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    return false\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate\
    \ := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__0\
    \ (0.00s)\n        tmpjt1g8lli_test.go:45: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpjt1g8lli_test.go:45:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__5\
    \ (0.00s)\n        tmpjt1g8lli_test.go:45: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074718
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    check_all_upper\
    \ := false\n    check_all_lower := false\n    for key, _ := range dict {\n   \
    \     if key == key[0] {\n            check_all_upper = true\n        } else {\n\
    \            check_all_lower = true\n        }\n    }\n    return check_all_upper\
    \ != check_all_lower\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate\
    \ := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpam1snox__test.go:29:19: invalid operation: key == key[0] (mismatched types
    string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074905
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    isUpper :=\
    \ false\n    isLower := false\n    for key, _ := range dict {\n        if isUpper\
    \ == false && isLower == false {\n            isUpper = key == strings.ToUpper(key)\n\
    \            isLower = key == strings.ToLower(key)\n        } else {\n       \
    \     if isUpper != (key == strings.ToUpper(key)) {\n                return false\n\
    \            }\n            if isLower != (key == strings.ToLower(key)) {\n  \
    \              return false\n            }\n        }\n    }\n    return true\n\
    }\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmkrnmv_d_test.go:30:30: undefined: strings

    /tmp/tmpmkrnmv_d_test.go:31:30: undefined: strings

    /tmp/tmpmkrnmv_d_test.go:33:35: undefined: strings

    /tmp/tmpmkrnmv_d_test.go:36:35: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074905
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    if dict[\"\
    a\"] != \"\" {\n        // dict has key in lower case\n        for k, _ := range\
    \ dict {\n            if k != \"\" && k != strings.ToLower(k) {\n            \
    \    return false\n            }\n        }\n    } else {\n        // dict has\
    \ key in upper case\n        for k, _ := range dict {\n            if k != \"\"\
    \ && k != strings.ToUpper(k) {\n                return false\n            }\n\
    \        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T)\
    \ {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3yuhbqfn_test.go:29:32: undefined: strings

    /tmp/tmp3yuhbqfn_test.go:36:32: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074905
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    lower := true\n    upper := true\n    // There are two cases:\n\
    \    // 1. The dictionary has a lowercase and an uppercase key\n    // 2. The\
    \ dictionary has a number as a key\n    // Loop through the keys, check if any\
    \ key is not all lowercase, if\n    // so, set lower to false. Do the same thing\
    \ for uppercase.\n    for key := range dict {\n        // Check if it's all lowercase\n\
    \        if (key != key) {\n            lower = false\n        }\n        // Check\
    \ if it's all uppercase\n        if (key != key) {\n            upper = false\n\
    \        }\n    }\n    // Return true if either both lower and upper are false\
    \ or both are true.\n    // Otherwise, return false.\n    return (lower == upper)\n\
    }\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__1\
    \ (0.00s)\n        tmpi11gbs_y_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpi11gbs_y_test.go:64:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__3\
    \ (0.00s)\n        tmpi11gbs_y_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpi11gbs_y_test.go:64:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074906
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    // check if key is all upper or lower\n    if len(dict) == 0 {\n\
    \        return false\n    }\n    isLower := false\n    for k, _ := range dict\
    \ {\n        if isLower {\n            if ( k == k ) {\n                isLower\
    \ = true\n            } else {\n                return false\n            }\n\
    \        } else {\n            if ( k == k ) {\n                isLower = true\n\
    \            } else {\n                isLower = false\n            }\n      \
    \  }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n\
    \  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__1\
    \ (0.00s)\n        tmpdur4loh3_test.go:65: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpdur4loh3_test.go:65:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__3\
    \ (0.00s)\n        tmpdur4loh3_test.go:65: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074906
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    count, _ := check_dict_type(dict)\n    if count == 0 {\n       \
    \ return false\n    }\n    if count == 2 {\n        return false\n    }\n    return\
    \ true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppmyqws3g_test.go:23:17: undefined: check_dict_type

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074906
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    var all_lower\
    \ bool\n    var all_upper bool\n    for k, _ := range dict {\n        all_lower\
    \ = all_lower || (k == string([]rune(k)[0]) + strings.ToLower(string([]rune(k)[1:])))\n\
    \        all_upper = all_upper || (k == strings.ToUpper(k))\n    }\n    return\
    \ all_lower || all_upper\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate\
    \ := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqr4u8ujz_test.go:29:63: undefined: strings

    /tmp/tmpqr4u8ujz_test.go:30:40: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074906
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    var is_capitalized bool = false\n    var is_lowercase bool = false\n\
    \    for key, value := range dict {\n        if len(key) > 0 {\n            if\
    \ key[0] >= 'A' && key[0] <= 'Z' {\n                is_capitalized = true\n  \
    \          } else {\n                is_lowercase = true\n            }\n    \
    \    }\n        if is_capitalized && is_lowercase {\n            return false\n\
    \        }\n        fmt.Printf(\"%s: %s\\n\", key, value)\n    }\n    return true\n\
    }\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "p: pineapple\nb: banana\np: pineapple\n5: banana\na: apple\np: pineapple\n\
    Name: John\nAge: 36\nCity: Houston\nSTATE: NC\nZIP: 12345\nfruit: Orange\ntaste:\
    \ Sweet\n--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2\
    \ (0.00s)\n        tmph04ef5ep_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__3 (0.00s)\n        tmph04ef5ep_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6\
    \ (0.00s)\n        tmph04ef5ep_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074906
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    lower := true\n\
    \    upper := true\n    for k, _ := range dict {\n        if k == \"\" {\n   \
    \         return false\n        }\n        if k[0] < 'a' || k[0] > 'z' {\n   \
    \         lower = false\n        }\n        if k[0] < 'A' || k[0] > 'Z' {\n  \
    \          upper = false\n        }\n    }\n    return lower || upper\n}\n\nfunc\
    \ TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__3\
    \ (0.00s)\n        tmpksjunrbz_test.go:61: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074906
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    // set is_upper\
    \ to true if the first key is upper case\n    is_upper := false\n    for k, _\
    \ := range dict {\n        if k == k[0:1] + k[1:len(k):len(k)].ToLower() {\n \
    \           is_upper = true\n            break\n        }\n    }\n    // check\
    \ if all keys are in the same case\n    for k, _ := range dict {\n        if is_upper\
    \ {\n            if k != k[0:1] + k[1:len(k):len(k)].ToUpper() {\n           \
    \     return false\n            }\n        } else {\n            if k != k[0:1]\
    \ + k[1:len(k):len(k)].ToLower() {\n                return false\n           \
    \ }\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T)\
    \ {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvcne_2cz_test.go:29:37: invalid operation: 3-index slice of string

    /tmp/tmpvcne_2cz_test.go:37:41: invalid operation: 3-index slice of string

    /tmp/tmpvcne_2cz_test.go:41:41: invalid operation: 3-index slice of string

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074906
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    for k, v :=\
    \ range dict {\n        if k != strings.ToLower(k) && k != strings.ToUpper(k)\
    \ {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t\
    \ *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected:\
    \ true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\"\
    , \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual:\
    \ candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpiypc52y4_test.go:26:12: v declared but not used

    /tmp/tmpiypc52y4_test.go:27:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074906
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    for key, _ := range dict {\n        if key == strings.ToLower(key)\
    \ {\n            for key2, _ := range dict {\n                if key2 != strings.ToLower(key2)\
    \ {\n                    return false\n                }\n            }\n    \
    \    } else if key == strings.ToUpper(key) {\n            for key2, _ := range\
    \ dict {\n                if key2 != strings.ToUpper(key2) {\n               \
    \     return false\n                }\n            }\n        } else {\n     \
    \       return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t\
    \ *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected:\
    \ true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\"\
    , \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual:\
    \ candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp06maxcng_test.go:24:19: undefined: strings

    /tmp/tmp06maxcng_test.go:26:28: undefined: strings

    /tmp/tmp06maxcng_test.go:30:26: undefined: strings

    /tmp/tmp06maxcng_test.go:32:28: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074907
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n\tif len(dict) == 0 {\n\t\treturn false\n\t}\n\tfor k, v := range dict\
    \ {\n\t\tif k == v {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc\
    \ TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__1\
    \ (0.00s)\n        tmpw_7aas9r_test.go:53: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpw_7aas9r_test.go:53:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__3\
    \ (0.00s)\n        tmpw_7aas9r_test.go:53: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074907
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    has_lower\
    \ := false\n    has_upper := false\n    for k, _ := range dict {\n        if k\
    \ == strings.ToLower(k) {\n            has_lower = true\n        } else if k ==\
    \ strings.ToUpper(k) {\n            has_upper = true\n        } else {\n     \
    \       return false\n        }\n    }\n    return has_lower != has_upper\n}\n\
    \nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplwkj07y7_test.go:29:17: undefined: strings

    /tmp/tmplwkj07y7_test.go:31:24: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074907
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n\treturn false\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate\
    \ := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__0\
    \ (0.00s)\n        tmpzl_zaog__test.go:45: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpzl_zaog__test.go:45:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__5\
    \ (0.00s)\n        tmpzl_zaog__test.go:45: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074904
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    c := 0\n    for k, v := range dict {\n        fmt.Println(k, v)\n\
    \        if 0 != c && 0 != c-('A'-'a') {\n            return false\n        }\n\
    \        if 0 == c {\n            c = k[0]\n        }\n    }\n    return true\n\
    }\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0maylxd6_test.go:30:17: cannot use k[0] (value of type byte) as type int
    in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074907
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    upper_keys\
    \ := 0\n    lower_keys := 0\n    for key, _ := range dict {\n        if is_upper(key)\
    \ {\n            upper_keys++\n        } else {\n            lower_keys++\n  \
    \      }\n    }\n    if upper_keys == 0 || lower_keys == 0 {\n        return true\n\
    \    }\n    return false\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate\
    \ := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp49ee983x_test.go:29:12: undefined: is_upper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074907
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    allLower :=\
    \ true\n    allUpper := true\n    for k, _ := range dict {\n        if k != strings.ToLower(k)\
    \ {\n            allLower = false\n        }\n        if k != strings.ToUpper(k)\
    \ {\n            allUpper = false\n        }\n    }\n    return allLower || allUpper\n\
    }\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1b4k3ljl_test.go:29:17: undefined: strings

    /tmp/tmp1b4k3ljl_test.go:32:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074907
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    is_upper_case\
    \ := false\n    for k, v := range dict {\n        if is_upper_case == false {\n\
    \            if v == strings.ToUpper(v) {\n                is_upper_case = true\n\
    \            }\n        } else {\n            if v != strings.ToUpper(v) {\n \
    \               return false\n            }\n        }\n    }\n    return true\n\
    }\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxtciwtjv_test.go:27:9: k declared but not used

    /tmp/tmpxtciwtjv_test.go:29:21: undefined: strings

    /tmp/tmpxtciwtjv_test.go:33:21: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074907
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    var is_lower\
    \ bool\n    for key, _ := range dict {\n        if key[0] >= 'a' && key[0] <=\
    \ 'z' {\n            is_lower = true\n            break\n        }\n    }\n  \
    \  if is_lower {\n        for key, _ := range dict {\n            if key[0] <\
    \ 'a' || key[0] > 'z' {\n                return false\n            }\n       \
    \ }\n    } else {\n        for key, _ := range dict {\n            if key[0] <\
    \ 'A' || key[0] > 'Z' {\n                return false\n            }\n       \
    \ }\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n \
    \ candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__3\
    \ (0.00s)\n        tmp0j6pbmvd_test.go:68: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074904
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    isLower :=\
    \ true\n    isUpper := true\n    for k, _ := range dict {\n        if isLower\
    \ {\n            isLower = isLower && (k == strings.ToLower(k))\n        }\n \
    \       if isUpper {\n            isUpper = isUpper && (k == strings.ToUpper(k))\n\
    \        }\n    }\n    return isLower || isUpper\n}\n\nfunc TestCheck_Dict_Case(t\
    \ *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected:\
    \ true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\"\
    , \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual:\
    \ candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpasp4plqj_test.go:30:40: undefined: strings

    /tmp/tmpasp4plqj_test.go:33:40: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074907
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    is_lower_case := true\n    is_upper_case := true\n    for key, _\
    \ := range dict {\n        if is_lower_case && key != strings.ToLower(key) {\n\
    \            is_lower_case = false\n        }\n        if is_upper_case && key\
    \ != strings.ToUpper(key) {\n            is_upper_case = false\n        }\n  \
    \  }\n    return is_lower_case || is_upper_case\n}\n\nfunc TestCheck_Dict_Case(t\
    \ *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected:\
    \ true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\"\
    , \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual:\
    \ candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp00e9rg4w_test.go:26:36: undefined: strings

    /tmp/tmp00e9rg4w_test.go:29:36: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074907
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    lower_count\
    \ := 0\n    upper_count := 0\n    for k, _ := range dict {\n        if is_upper(k)\
    \ {\n            upper_count++\n        } else {\n            lower_count++\n\
    \        }\n    }\n    return lower_count == 0 || upper_count == 0\n}\n\nfunc\
    \ TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpi1hqfvct_test.go:29:12: undefined: is_upper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074907
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    // upper case\n\
    \    for k, _ := range dict {\n        if k == k {\n            continue\n   \
    \     }\n        // lower case\n        for k, _ := range dict {\n           \
    \ if k == k {\n                continue\n            }\n            // something\
    \ different\n            return false\n        }\n    }\n    return true\n}\n\n\
    func TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__1\
    \ (0.00s)\n        tmpnjtyvxmn_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpnjtyvxmn_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__3\
    \ (0.00s)\n        tmpnjtyvxmn_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074908
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) < 1 {\n        return false\n    }\n    is_upper :=\
    \ func(v string) bool {\n        for _, val := range v {\n            if val >=\
    \ 97 && val <= 122 {\n                return false\n            }\n        }\n\
    \        return true\n    }\n    is_lower := func(v string) bool {\n        for\
    \ _, val := range v {\n            if val >= 65 && val <= 90 {\n             \
    \   return false\n            }\n        }\n        return true\n    }\n    var\
    \ lower int\n    var upper int\n    for k, v := range dict {\n        //fmt.Println(k,\
    \ v)\n        if is_upper(k) {\n            upper++\n        } else if is_lower(k)\
    \ {\n            lower++\n        } else {\n            return false\n       \
    \ }\n        if is_upper(v) {\n            upper++\n        } else if is_lower(v)\
    \ {\n            lower++\n        } else {\n            return false\n       \
    \ }\n    }\n    if lower == 0 || upper == 0 {\n        return true\n    }\n  \
    \  return false\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate :=\
    \ check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__5\
    \ (0.00s)\n        tmp42aibra9_test.go:86: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074908
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    lower, upper\
    \ := true, true\n    for k, _ := range dict {\n        if k != strings.ToLower(k)\
    \ {\n            lower = false\n        }\n        if k != strings.ToUpper(k)\
    \ {\n            upper = false\n        }\n    }\n    return lower || upper\n\
    }\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptfrjljt0_test.go:28:17: undefined: strings

    /tmp/tmptfrjljt0_test.go:31:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074907
- exit_code: 0
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    lower := true\n\
    \    upper := true\n    for k, _ := range dict {\n        for _, v := range k\
    \ {\n            if 'a' <= v && v <= 'z' {\n                upper = false\n  \
    \          } else if 'A' <= v && v <= 'Z' {\n                lower = false\n \
    \           } else {\n                return false\n            }\n        }\n\
    \    }\n    return lower || upper\n}\n\nfunc TestCheck_Dict_Case(t *testing.T)\
    \ {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074908
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    var isUpper bool\n    var isLower bool\n    for k, _ := range dict\
    \ {\n        if k == k {\n            isUpper = true\n        }\n        if k\
    \ == k {\n            isLower = true\n        }\n    }\n    if isUpper == true\
    \ && isLower == true {\n        return false\n    }\n    return true\n}\n\nfunc\
    \ TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__0\
    \ (0.00s)\n        tmpy5i1kugo_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpy5i1kugo_test.go:58:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__5\
    \ (0.00s)\n        tmpy5i1kugo_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpy5i1kugo_test.go:58:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074908
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate\
    \ := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__1\
    \ (0.00s)\n        tmpxym3deox_test.go:45: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpxym3deox_test.go:45:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__3\
    \ (0.00s)\n        tmpxym3deox_test.go:45: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__6 (0.00s)\n        tmpxym3deox_test.go:45:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074896
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n\t\n\treturn false\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n\
    \  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__0\
    \ (0.00s)\n        tmpw7ykj2b1_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpw7ykj2b1_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__5\
    \ (0.00s)\n        tmpw7ykj2b1_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074908
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    is_lower := false\n    is_upper := false\n    is_lower_or_upper\
    \ := false\n    for k, _ := range dict {\n        fmt.Println(k)\n        fmt.Println(k\
    \ == strings.ToLower(k))\n        fmt.Println(k == strings.ToUpper(k))\n     \
    \   if k == strings.ToLower(k) {\n            is_lower = true\n        }\n   \
    \     if k == strings.ToUpper(k) {\n            is_upper = true\n        }\n \
    \       if is_lower && is_upper {\n            return false\n        }\n    }\n\
    \    if is_lower || is_upper {\n        is_lower_or_upper = true\n    }\n    return\
    \ is_lower_or_upper\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate\
    \ := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpn53amifb_test.go:28:26: undefined: strings

    /tmp/tmpn53amifb_test.go:29:26: undefined: strings

    /tmp/tmpn53amifb_test.go:30:17: undefined: strings

    /tmp/tmpn53amifb_test.go:33:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074908
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    is_lower :=\
    \ true\n    is_upper := true\n    for k, _ := range dict {\n        is_lower =\
    \ is_lower && (k == string([]rune(k)[0]) + strings.ToLower(string([]rune(k)[1:])))\n\
    \        is_upper = is_upper && (k == strings.ToUpper(k))\n    }\n    return is_lower\
    \ || is_upper\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsfp6s_w4_test.go:29:61: undefined: strings

    /tmp/tmpsfp6s_w4_test.go:30:38: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074908
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    // Initialize with true so the first key will change it \n    //\
    \ to either true or false, and the next keys will check \n    // if the case is\
    \ consistent.\n    // If the map is empty, true is returned and the code \n  \
    \  // will panic on the next loop, which is the desired behavior.\n    all_lower\
    \ := true\n\n    for key, _ := range dict {\n        if all_lower {\n        \
    \    if key != lower(key) {\n                all_lower = false\n            }\n\
    \        } else {\n            if key != upper(key) {\n                return\
    \ false\n            }\n        }\n    }\n\n    return true\n}\n\nfunc TestCheck_Dict_Case(t\
    \ *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected:\
    \ true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\"\
    , \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual:\
    \ candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmw40d4bt_test.go:32:23: undefined: lower

    /tmp/tmpmw40d4bt_test.go:36:23: undefined: upper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074908
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    var all_upper\
    \ bool\n    var all_lower bool\n    for key, _ := range dict {\n        if all_upper\
    \ && all_lower {\n            return false\n        }\n        if all_upper {\n\
    \            if key == key {\n                all_upper = true\n            }\
    \ else {\n                all_upper = false\n            }\n        } else if\
    \ all_lower {\n            if key == key {\n                all_lower = true\n\
    \            } else {\n                all_lower = false\n            }\n    \
    \    } else {\n            if key == key {\n                all_upper = true\n\
    \            } else {\n                all_lower = true\n            }\n     \
    \   }\n    }\n    return all_upper || all_lower\n}\n\nfunc TestCheck_Dict_Case(t\
    \ *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected:\
    \ true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\"\
    , \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual:\
    \ candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__1\
    \ (0.00s)\n        tmpjjw34py3_test.go:74: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmpjjw34py3_test.go:74:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__3\
    \ (0.00s)\n        tmpjjw34py3_test.go:74: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074908
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    isLower :=\
    \ true\n    firstElement := dict[dict[0]]\n    if firstElement == firstElement.ToUpper()\
    \ {\n        isLower = false\n    }\n    for k, v := range dict {\n        if\
    \ isLower {\n            if v != v.ToLower() {\n                return false\n\
    \            }\n        } else {\n            if v != v.ToUpper() {\n        \
    \        return false\n            }\n        }\n    }\n    return true\n}\n\n\
    func TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmxvpik6e_test.go:27:31: cannot use 0 (untyped int constant) as string
    value in map index

    /tmp/tmpmxvpik6e_test.go:28:37: firstElement.ToUpper undefined (type string has
    no field or method ToUpper)

    /tmp/tmpmxvpik6e_test.go:31:9: k declared but not used

    /tmp/tmpmxvpik6e_test.go:33:23: v.ToLower undefined (type string has no field
    or method ToLower)

    /tmp/tmpmxvpik6e_test.go:37:23: v.ToUpper undefined (type string has no field
    or method ToUpper)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074908
- exit_code: 0
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    var ref_str\
    \ string\n    for k, v := range dict {\n        if ref_str == \"\" {\n       \
    \     ref_str = k\n        }\n        for _, c := range k {\n            if c\
    \ >= 'A' && c <= 'Z' {\n                if ref_str[0] >= 'a' && ref_str[0] <=\
    \ 'z' {\n                    return false\n                }\n            } else\
    \ if c >= 'a' && c <= 'z' {\n                if ref_str[0] >= 'A' && ref_str[0]\
    \ <= 'Z' {\n                    return false\n                }\n            }\
    \ else {\n                return false\n            }\n        }\n        fmt.Println(k,\
    \ v)\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n\
    \  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074909
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    first_key\
    \ := \"\"\n    for key, _ := range dict {\n        first_key = key\n        break\n\
    \    }\n    if first_key == \"\" {\n        return false\n    }\n    if is_lower_case(first_key)\
    \ {\n        return is_all_lower_case(dict)\n    } else {\n        return is_all_upper_case(dict)\n\
    \    }\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvxxic4kl_test.go:34:8: undefined: is_lower_case

    /tmp/tmpvxxic4kl_test.go:35:16: undefined: is_all_lower_case

    /tmp/tmpvxxic4kl_test.go:37:16: undefined: is_all_upper_case

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074908
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    var len_dict = len(dict)\n    var check_list []bool\n    for _,\
    \ v := range dict {\n        if v == \"\" {\n            check_list = append(check_list,\
    \ false)\n        } else {\n            check_list = append(check_list, true)\n\
    \        }\n    }\n    if len_dict == 0 {\n        return false\n    } else if\
    \ len_dict == len(check_list) {\n        return true\n    } else {\n        return\
    \ false\n    }\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate :=\
    \ check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__1\
    \ (0.00s)\n        tmplwk1rz8g_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmplwk1rz8g_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__3\
    \ (0.00s)\n        tmplwk1rz8g_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074909
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    lowerCase\
    \ := false\n    upperCase := false\n    for key, _ := range dict {\n        if\
    \ key == keyToLower(key) {\n            lowerCase = true\n        } else if key\
    \ == keyToUpper(key) {\n            upperCase = true\n        } else {\n     \
    \       return false\n        }\n    }\n    return lowerCase != upperCase\n}\n\
    \nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8ntrg6pg_test.go:29:19: undefined: keyToLower

    /tmp/tmp8ntrg6pg_test.go:31:26: undefined: keyToUpper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074909
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    lower := false\n\
    \    upper := false\n    for key, _ := range dict {\n        if key == strings.ToLower(key)\
    \ {\n            lower = true\n        } else if key == strings.ToUpper(key) {\n\
    \            upper = true\n        } else {\n            return false\n      \
    \  }\n    }\n    return lower != upper\n}\n\nfunc TestCheck_Dict_Case(t *testing.T)\
    \ {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpeyzpzalt_test.go:29:19: undefined: strings

    /tmp/tmpeyzpzalt_test.go:31:26: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074909
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    return false\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate\
    \ := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__0\
    \ (0.00s)\n        tmpjt1g8lli_test.go:45: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpjt1g8lli_test.go:45:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__5\
    \ (0.00s)\n        tmpjt1g8lli_test.go:45: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074718
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    var lower, upper bool = true, true\n    for k, v := range dict {\n\
    \        for _, c := range k {\n            if c >= 'A' && c <= 'Z' {\n      \
    \          lower = false\n            } else if c >= 'a' && c <= 'z' {\n     \
    \           upper = false\n            }\n        }\n        if lower == false\
    \ && upper == false {\n            return false\n        }\n        fmt.Printf(\"\
    %s: %s\\n\", k, v)\n    }\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T)\
    \ {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "p: pineapple\nb: banana\np: pineapple\n5: banana\na: apple\np: pineapple\n\
    ZIP: 12345\nSTATE: NC\nfruit: Orange\ntaste: Sweet\n--- FAIL: TestCheck_Dict_Case\
    \ (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__2 (0.00s)\n        tmp8gzvejn9_test.go:59:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCheck_Dict_Case/test_num__6\
    \ (0.00s)\n        tmp8gzvejn9_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074909
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    for k, v := range dict {\n        //fmt.Println(k,v)\n        if\
    \ k == strings.ToLower(k) {\n            for i, j := range dict {\n          \
    \      if i != strings.ToLower(i) {\n                    return false\n      \
    \          }\n            }\n        } else if k == strings.ToUpper(k) {\n   \
    \         for i, j := range dict {\n                if i != strings.ToUpper(i)\
    \ {\n                    return false\n                }\n            }\n    \
    \    } else {\n            return false\n        }\n    }\n    return true\n}\n\
    \nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3hbdw2gi_test.go:23:12: v declared but not used

    /tmp/tmp3hbdw2gi_test.go:25:17: undefined: strings

    /tmp/tmp3hbdw2gi_test.go:26:20: j declared but not used

    /tmp/tmp3hbdw2gi_test.go:27:25: undefined: strings

    /tmp/tmp3hbdw2gi_test.go:31:24: undefined: strings

    /tmp/tmp3hbdw2gi_test.go:32:20: j declared but not used

    /tmp/tmp3hbdw2gi_test.go:33:25: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074909
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    all_upper\
    \ := true\n    all_lower := true\n    for k, v := range dict {\n        if is_lower(k)\
    \ {\n            all_upper = false\n        } else {\n            all_lower =\
    \ false\n        }\n        fmt.Printf(\"k: %s, v: %s, all_upper: %t, all_lower:\
    \ %t\\n\", k, v, all_upper, all_lower)\n    }\n    return all_upper || all_lower\n\
    }\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprjof1696_test.go:29:12: undefined: is_lower

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074909
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    // YOUR CODE HERE\n    return false\n}\n\nfunc TestCheck_Dict_Case(t\
    \ *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected:\
    \ true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\"\
    , \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual:\
    \ candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__0\
    \ (0.00s)\n        tmp54mgtppu_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmp54mgtppu_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__5\
    \ (0.00s)\n        tmp54mgtppu_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074909
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    var keys []string\n    var upperCaseKeys []string\n    var lowerCaseKeys\
    \ []string\n    for k, _ := range dict {\n        //fmt.Println(k)\n        keys\
    \ = append(keys, k)\n    }\n    for _, k := range keys {\n        if k == k {\n\
    \            //fmt.Println(k)\n            lowerCaseKeys = append(lowerCaseKeys,\
    \ k)\n        }\n    }\n    fmt.Println(lowerCaseKeys)\n    if len(lowerCaseKeys)\
    \ == len(keys) {\n        return true\n    }\n    return false\n}\n\nfunc TestCheck_Dict_Case(t\
    \ *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected:\
    \ true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\"\
    , \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual:\
    \ candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpiq91rjzc_test.go:24:9: upperCaseKeys declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074909
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    if len(dict)\
    \ == 1 {\n        return true\n    }\n    // Check to see if dict contains key\
    \ with value of all lower case\n    isLower := true\n    for k, _ := range dict\
    \ {\n        if !isAllLower(k) {\n            isLower = false\n            break\n\
    \        }\n    }\n    // Check to see if dict contains key with value of all\
    \ upper case\n    isUpper := true\n    for k, _ := range dict {\n        if !isAllUpper(k)\
    \ {\n            isUpper = false\n            break\n        }\n    }\n    return\
    \ isLower || isUpper\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate\
    \ := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_2nwg3mm_test.go:32:13: undefined: isAllLower

    /tmp/tmp_2nwg3mm_test.go:40:13: undefined: isAllUpper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074909
- exit_code: 1
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    dict_length := len(dict)\n    if dict_length == 0 {\n        return\
    \ false\n    }\n\n    // check the string type\n    for key, value := range dict\
    \ {\n        if key != value {\n            fmt.Println(\"key = \", key, \"value\
    \ = \", value)\n            return false\n        }\n    }\n\n    // check the\
    \ uppercase or lowercase\n    for key, _ := range dict {\n        first_char :=\
    \ key[0]\n        fmt.Println(\"string = \", key, \"first char = \", first_char)\n\
    \        if first_char >= 65 && first_char <= 90 {\n            for i := 1; i\
    \ < dict_length; i++ {\n                key := key[i]\n                if key\
    \ >= 97 && key <= 122 {\n                    return false\n                }\n\
    \            }\n        } else if first_char >= 97 && first_char <= 122 {\n  \
    \          for i := 1; i < dict_length; i++ {\n                key := key[i]\n\
    \                if key >= 65 && key <= 90 {\n                    return false\n\
    \                }\n            }\n        } else {\n            return false\n\
    \        }\n    }\n\n    return true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T)\
    \ {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "key =  p value =  pineapple\nkey =  p value =  pineapple\nkey =  p value\
    \ =  pineapple\nkey =  Name value =  John\nkey =  STATE value =  NC\nkey =  fruit\
    \ value =  Orange\n--- FAIL: TestCheck_Dict_Case (0.00s)\n    --- FAIL: TestCheck_Dict_Case/test_num__0\
    \ (0.00s)\n        tmpvkca_wfo_test.go:81: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_Dict_Case/test_num__4 (0.00s)\n        tmpvkca_wfo_test.go:81:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCheck_Dict_Case/test_num__5\
    \ (0.00s)\n        tmpvkca_wfo_test.go:81: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074909
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    // The map is empty so return false\n    if len(dict) == 0 {\n \
    \       return false\n    }\n\n    // Check if all keys in map are in upper case.\n\
    \    allUpper := true\n    for key := range dict {\n        if allUpper == false\
    \ {\n            break\n        }\n        allUpper = key == strings.ToUpper(key)\n\
    \    }\n\n    // Check if all keys in map are in lower case.\n    allLower :=\
    \ true\n    for key := range dict {\n        if allLower == false {\n        \
    \    break\n        }\n        allLower = key == strings.ToLower(key)\n    }\n\
    \n    // Keys must be all upper or all lower so return true.\n    if allUpper\
    \ || allLower {\n        return true\n    }\n\n    // Keys are neither all upper\
    \ or all lower so return false.\n    return false\n}\n\nfunc TestCheck_Dict_Case(t\
    \ *testing.T) {\n  candidate := check_dict_case\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(map[string]string{\"p\": \"pineapple\", \"b\": \"banana\"}), expected:\
    \ true },\n     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"Name\": \"John\", \"Age\": \"36\"\
    , \"City\": \"Houston\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    fruit\": \"Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual:\
    \ candidate(map[string]string{}), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprvzfd_1q_test.go:34:27: undefined: strings

    /tmp/tmprvzfd_1q_test.go:43:27: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074909
- exit_code: 2
  program: "package check_dict_case_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a map, return true if all keys are strings in lower \n// case\
    \ or all keys are strings in upper case, else return false.\n// The function should\
    \ return false is the given map is empty.\n// Examples:\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"b\": \"banana\"})\n// true\n// >>> check_dict_case(map[string]string{\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"})\n// false\n// >>> check_dict_case(map[interface{}]string{\"\
    a\": \"apple\", 8: \"banana\", \"a\": \"apple\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n// false\n// >>> check_dict_case(map[string]string{\"\
    STATE\": \"NC\", \"ZIP\": \"12345\"})\n// true\nfunc check_dict_case(dict map[string]string)\
    \ bool {\n    if len(dict) == 0 {\n        return false\n    }\n    var lower\
    \ bool\n    lower = false\n    for key, _ := range dict {\n        if !lower &&\
    \ key == ToLower(key) {\n            lower = true\n        } else if lower &&\
    \ key != ToLower(key) {\n            return false\n        }\n    }\n    return\
    \ true\n}\n\nfunc TestCheck_Dict_Case(t *testing.T) {\n  candidate := check_dict_case\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(map[string]string{\"p\": \"pineapple\"\
    , \"b\": \"banana\"}), expected: true },\n     { actual: candidate(map[string]string{\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"p\": \"pineapple\", \"5\": \"banana\"\
    , \"a\": \"apple\"}), expected: false },\n     { actual: candidate(map[string]string{\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}), expected: false },\n\
    \     { actual: candidate(map[string]string{\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    }), expected: true },\n     { actual: candidate(map[string]string{\"fruit\": \"\
    Orange\", \"taste\": \"Sweet\"}), expected: true },\n     { actual: candidate(map[string]string{}),\
    \ expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph6zwp2lt_test.go:29:29: undefined: ToLower

    /tmp/tmph6zwp2lt_test.go:31:35: undefined: ToLower

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074909
