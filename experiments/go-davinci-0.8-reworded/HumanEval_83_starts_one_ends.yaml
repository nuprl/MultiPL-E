name: HumanEval_83_starts_one_ends
language: go_test.go
prompt: "package starts_one_ends_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
  )\n\n// Given a positive integer n, return the count of the numbers of n-digit\n\
  // positive integers that start or end with 1.\nfunc starts_one_ends(n int) int\
  \ {\n"
tests: "func TestStarts_One_Ends(t *testing.T) {\n  candidate := starts_one_ends\n\
  \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
  \   tests := []test{\n     { actual: candidate(1), expected: 1 },\n     { actual:\
  \ candidate(2), expected: 18 },\n     { actual: candidate(3), expected: 180 },\n\
  \     { actual: candidate(4), expected: 1800 },\n     { actual: candidate(5), expected:\
  \ 18000 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
  \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
  %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
  \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    if n == 1 {\n        return 1\n    }\n    n_minus_1 := n - 1\n\
    \    // For each possible number that starts or ends with 1 and n digits,\n  \
    \  // the rest must be filled with 0's. There are n_minus_1 ways to do this.\n\
    \    return n_minus_1 * starts_one_ends(n_minus_1)\n}\n", "    if n == 1 {\n \
    \       return 1\n    }\n    if n == 2 {\n        return 20\n    }\n    if n ==\
    \ 3 {\n        return 300\n    }\n    if n == 4 {\n        return 4000\n    }\n\
    \    if n == 5 {\n        return 50000\n    }\n    if n == 6 {\n        return\
    \ 600000\n    }\n    if n == 7 {\n        return 7000000\n    }\n    if n == 8\
    \ {\n        return 80000000\n    }\n    if n == 9 {\n        return 900000000\n\
    \    }\n    return 0\n}\n", "    total := 1\n    for i := 1; i < n; i++ {\n  \
    \      total *= 10\n    }\n    return total * 2 - 1\n}\n", "    if n < 1 {\n \
    \       return 0\n    }\n\n    return 9 * (1 + (n - 1) * 9)\n}\n", "    if n ==\
    \ 1 {\n        return 10\n    }\n\n    // \u5BF9\u4E8E\u957F\u5EA6\u4E3An\u7684\
    \u6570\u5B57\uFF0C\u5206\u6210\u957F\u5EA6\u4E3An-1\u7684\u6570\u5B57+\u6700\u540E\
    \u4E00\u4F4D\u6570\u5B57\uFF0C\u4F8B\u5982123\n    // n=3\u7684\u65F6\u5019\uFF0C\
    \u4EE51\u5F00\u5934\u7684\u53EF\u80FD\u7684\u6570\u5B57\u6709\uFF1A\n    // 1x\uFF0C\
    \ \u5176\u4E2Dx\u8868\u793A\u4EFB\u610F\u6570\u5B57\uFF0C\u7136\u540E\u5269\u4E0B\
    \u7684\u4E24\u4F4D\u4EFB\u610F\u6570\u5B57\u7EC4\u5408\u517111\u4E2A\n    // 1x2x\uFF0C\
    \u8868\u793A\u4E00\u4F4D\u6570\u5B57\u4EFB\u610F\u7EC4\u5408\u7684\u6570\u5B57\
    \uFF0C\u5269\u4E0B\u7684\u4E00\u4F4D\u6570\u5B57\u4EFB\u610F\u7EC4\u5408\u5171\
    10\u4E2A\n    // 1xx3x\uFF0C\u8868\u793A\u4E24\u4F4D\u6570\u5B57\u4EFB\u610F\u7EC4\
    \u5408\u7684\u6570\u5B57\uFF0C\u5269\u4E0B\u7684\u4E00\u4F4D\u6570\u5B57\u4EFB\
    \u610F\u7EC4\u5408\u517110\u4E2A\n    // \u6700\u540E\u52A0\u8D77\u6765\u5F97\u5230\
    10+11+10=31\n\n    // \u540C\u7406\uFF0C\u4EE51\u7ED3\u5C3E\u7684\u6570\u5B57\u6709\
    \uFF1A\n    // x1\uFF0C\u5176\u4E2Dx\u8868\u793A\u4EFB\u610F\u6570\u5B57\uFF0C\
    \u7136\u540E\u5269\u4E0B\u7684\u4E24\u4F4D\u4EFB\u610F\u6570\u5B57\u7EC4\u5408\
    \u517111\u4E2A\n    // x21\uFF0C\u8868\u793A\u4E00\u4F4D\u6570\u5B57\u4EFB\u610F\
    \u7EC4\u5408\u7684\u6570\u5B57\uFF0C\u5269\u4E0B\u7684\u4E00\u4F4D\u6570\u5B57\
    \u4EFB\u610F\u7EC4\u5408\u517110\u4E2A\n    // x3x1\uFF0C\u8868\u793A\u4E24\u4F4D\
    \u6570\u5B57\u4EFB\u610F\u7EC4", "    if n == 1 {\n        return 2\n    }\n \
    \   if n == 2 {\n        return 3\n    }\n    return starts_one_ends(n-1) + starts_one_ends(n-2)\n\
    }\n", "    if n == 1 {\n        return 2\n    }\n\n    dp := make([]int, n + 1)\n\
    \    dp[1] = 2\n    for i := 2; i <= n; i++ {\n        dp[i] = (dp[i - 1] * 10\
    \ - dp[i - 2]) % 1000000007\n    }\n\n    return dp[n]\n}\n", "    if n == 1 {\n\
    \        return 2\n    }\n    // dp[i] means the count of the numbers of i-digit\
    \ positive integers\n    // that start or end with 1.\n    dp := make([]int, n+1)\n\
    \    dp[1] = 2\n    // dp[i] = dp[i-1] + dp[i-2]\n    for i := 2; i <= n; i++\
    \ {\n        dp[i] = dp[i-1] + dp[i-2]\n    }\n    return dp[n]\n}\n", "    if\
    \ n == 1 {\n        return 2\n    }\n    return 9 * starts_one_ends(n - 1) + 2\
    \ * starts_one_ends(n - 2)\n}\n", "    if n == 1 {\n        return 1\n    }\n\n\
    \    // n >= 2\n    count, base := 1, 10\n    for i := 2; i <= n; i++ {\n    \
    \    count += base\n        base *= 10\n    }\n\n    return count\n}\n", "   \
    \ if n == 1 {\n        return 1\n    }\n    if n == 2 {\n        return 10\n \
    \   }\n    dp := make([]int, n+1)\n    dp[1] = 1\n    dp[2] = 10\n    for i :=\
    \ 3; i <= n; i++ {\n        dp[i] = 9 * power(10, i-2) + dp[i-1]\n    }\n    return\
    \ dp[n]\n}\n", "    var start, end, total int\n    for i := 1; i <= n; i++ {\n\
    \        start = 9 * (1 << uint(i - 1))\n        end = 10 - i\n        total +=\
    \ start + end\n    }\n    return total\n}\n", "    var result int\n    if n <\
    \ 1 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n   \
    \ if n == 2 {\n        return 10\n    }\n    result = 9\n    for i := 2; i < n;\
    \ i++ {\n        result *= (9 - i + 2)\n    }\n    return result\n}\n", "    if\
    \ n == 1 {\n        return 2\n    }\n    ends := starts_one_ends(n - 1)\n    starts\
    \ := 1 * 9 * 9 * (n - 2)\n    return ends + starts\n}\n", "    if n == 1 {\n \
    \       return 10\n    }\n\n    if n == 2 {\n        return 55\n    }\n\n    current_digit\
    \ := 10\n    last_digit := 9\n    for i := 3; i <= n; i++ {\n        last_digit,\
    \ current_digit = current_digit, (current_digit * 10) + last_digit\n    }\n\n\
    \    return current_digit + last_digit\n}\n", "    if n == 1 {\n        return\
    \ 1\n    }\n    // count[i] counts for i-digit number that starts or ends with\
    \ 1.\n    count := make([]int, n + 1)\n    count[1] = 1\n    for i := 2; i <=\
    \ n; i++ {\n        count[i] = 9 * count[i - 1] + 10 * count[i - 2]\n    }\n \
    \   return count[n]\n}\n", "    if n < 1 {\n        return 0\n    }\n\n    //\
    \ Count the numbers that end with 1, \n    //   the rest part has n-1 digits,\
    \ \n    //   there are 9 choices for the rest part.\n    ret := 9\n    if n >\
    \ 1 {\n        // Count the numbers that start with 1, \n        //   the rest\
    \ part has n-1 digits, \n        //   there are 10 choices for the rest part (0-9).\n\
    \        for i := 2; i <= n; i++ {\n            ret += 9 * (pow(10, i-1) - pow(9,\
    \ i-1))\n        }\n    }\n\n    return ret\n}\n", "    if n == 1 {\n        return\
    \ 1\n    }\n    // There are 9 digits to choose from and n-1 positions to choose\
    \ between\n    // them.\n    // The last digit can be chosen freely.\n    return\
    \ 9 * (1 << uint(n-1))\n}\n", "    if n == 1 {\n        return 1\n    }\n\n  \
    \  if n == 2 {\n        return 10\n    }\n\n    start, end := 10, 1\n    for i\
    \ := 1; i < n - 1; i++ {\n        end = 9 * end + start\n        start = start\
    \ * 10\n    }\n\n    return start + end\n}\n", "    if n == 1 {\n        return\
    \ 1\n    }\n    sum := 10\n    for i := 2; i <= n; i++ {\n        sum += 9 * pow(10,\
    \ i - 1)\n    }\n    return sum\n}\n", "    if n < 1 {\n        return 0\n   \
    \ }\n    if n == 1 {\n        return 1\n    }\n    return starts_one_ends(n-1)\
    \ + count(n)\n}\n", "    if n == 1 {\n        return 2\n    }\n\n    res := 1\n\
    \    m := int(1e9 + 7)\n    for i := 1; i < n; i++ {\n        a := (int(9 * math.Pow10(i\
    \ - 1)) - int(math.Pow10(i - 1))) % m\n        res = (res + a) % m\n    }\n  \
    \  return res\n}\n", "    if n == 1 {\n        return 2\n    }\n\n    if n ==\
    \ 2 {\n        return 4\n    }\n\n    // Count the number with prefix 1:\n   \
    \ count := 2 * starts_one_ends(n - 1) + (n - 2) * (n - 2)\n    return count\n\
    }\n", "    if n == 1 {\n        return 10\n    }\n\n    if n == 2 {\n        return\
    \ 90\n    }\n\n    if n == 3 {\n        return 930\n    }\n\n    if n == 4 {\n\
    \        return 9360\n    }\n\n    return starts_one_ends(n - 1) + starts_one_ends(n\
    \ - 2) + starts_one_ends(n - 3)\n}\n", "    count := 0\n    for i := 1; i <= n;\
    \ i++ {\n        for j := 1; j <= 9; j++ {\n            if i == 1 {\n        \
    \        count++\n            } else {\n                count += power(9, i -\
    \ 1)\n            }\n        }\n    }\n    return count\n}\n", "    count := 0\n\
    \    for i := 0; i < n; i++ {\n        count += (9 * pow10(i))\n    }\n    count\
    \ += 1\n    return count\n}\n", "    var cache = make(map[int]int)\n    cache[1]\
    \ = 2\n    return count_with_cache(n, cache)\n}\n", "    if n == 1 {\n       \
    \ return 2\n    }\n    return starts_one_ends(n-1) + 5 * pow10(n-2)\n}\n", " \
    \   if n < 1 {\n        return 0\n    }\n    // Number of digits\n    if n ==\
    \ 1 {\n        return 2\n    }\n    s := 9\n    res := 10\n    for i := 2; i <=\
    \ n; i++ {\n        s *= 10 - i + 1\n        res += s\n    }\n    return res\n\
    }\n", "    if n == 1 {\n        return 2\n    }\n    return 2 * (9 * pow(10, n\
    \ - 1) - pow(10, n - 1) + 1)\n}\n", "    if n < 1 {\n        return 0\n    }\n\
    \n    if n == 1 {\n        return 1\n    }\n\n    return starts_one_ends(n - 1)\
    \ + (int(math.Pow(10, float64(n - 1))) - int(math.Pow(10, float64(n - 2))))\n\
    }\n", "    if n < 1 {\n        return 0\n    }\n\n    sum, base := 0, 1\n    for\
    \ i := 0; i < n; i++ {\n        sum += base * 9\n        base *= 10\n    }\n\n\
    \    return 2 * sum + 1\n}\n", "    ret := 0\n    for i := 1; i <= n; i++ {\n\
    \        ret += (n - i + 1) * calc_first_digit(i)\n    }\n    return ret\n}\n",
  "    a, b := 0, 1\n    for i := 0; i < n; i++ {\n        a, b = b, a * 10 + 1\n\
    \    }\n    return b - a\n}\n", "    if n == 1 {\n        return 10\n    }\n\n\
    \    if n == 2 {\n        return 100\n    }\n\n    return 9 * starts_one_ends(n\
    \ - 1)\n}\n", "    if n == 1 {\n        return 2\n    }\n    return count_ones(n)\
    \ + starts_one_ends(n-1)\n}\n", "    var start_count, end_count int\n    switch\
    \ n {\n    case 1:\n        start_count = 1\n        end_count = 1\n    case 2:\n\
    \        start_count = 1\n        end_count = 2\n    default:\n        start_count\
    \ = starts_one_ends(n-1) + starts_one_ends(n-2)\n        end_count = starts_one_ends(n-1)\
    \ + starts_one_ends(n-2)\n    }\n    return start_count + end_count\n}\n", " \
    \   if n < 1 {\n        return 0\n    }\n\n    if n == 1 {\n        return 2\n\
    \    }\n\n    if n == 2 {\n        return 10\n    }\n\n    return 9 * 9 * (n -\
    \ 2) + 9 * (n - 1) + 9 * (n - 1)\n}\n", "    if n == 1 {\n        return 1\n \
    \   }\n\n    // a[i] holds the count of the number of i-digit positive integers\
    \ that\n    // start or end with 1.\n    a := make([]int, n + 1)\n    a[1] = 1\n\
    \    for i := 2; i <= n; i++ {\n        a[i] = a[i - 1] + 9 * a[i - 2]\n    }\n\
    \n    return a[n]\n}\n", "    // If the number of digits is 1, then there's only\
    \ one number that\n    // starts or ends with 1.\n    if n == 1 {\n        return\
    \ 1\n    }\n\n    // If the number of digits is 2, then the number starts with\
    \ 1, it ends\n    // with 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9, so there are 11 possibilities.\n\
    \    if n == 2 {\n        return 11\n    }\n\n    // Otherwise, if the number\
    \ of digits is > 2, then the number starts with\n    // 1, and the rest of the\
    \ number can be 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9,\n    // so there are 10 possibilities\
    \ for the rest of the number.\n    return 10 * starts_one_ends(n - 1)\n}\n", " \
    \   if n == 1 {\n        return 1\n    }\n\n    if n == 2 {\n        return 2\n\
    \    }\n\n    return starts_one_ends(n - 1) + starts_one_ends(n - 2)\n}\n", " \
    \   if n < 1 {\n        return 0\n    }\n\n    if n == 1 {\n        return 2\n\
    \    }\n\n    dp := make([]int, n+1)\n    dp[1] = 2\n    dp[2] = 3\n\n    for\
    \ i := 3; i <= n; i++ {\n        dp[i] = dp[i-1] + dp[i-2]\n    }\n\n    return\
    \ dp[n]\n}\n", "    count := 0\n    for i := 1; i <= n; i++ {\n        if i ==\
    \ 1 {\n            count++\n        } else {\n            for j := 0; j < i; j++\
    \ {\n                count += 9 * power(10, j)\n            }\n        }\n   \
    \ }\n    return count\n}\n", "    if n == 1 {\n        return 1\n    }\n\n   \
    \ res := 1\n    for i := 1; i < n; i++ {\n        res *= 9\n    }\n\n    return\
    \ res * 2\n}\n", "    if n == 1 {\n        return 1\n    }\n    if n == 2 {\n\
    \        return 10\n    }\n    return 9 + starts_one_ends(n-1)\n}\n", "    //\
    \ n should be greater than 0\n    if n < 1 {\n        return 0\n    }\n    //\
    \ tailNum[i] means the number of n-digit positive integers\n    // that end with\
    \ i\n    tailNum := make([]int, 10)\n    tailNum[0] = 0\n    tailNum[1] = 1\n\
    \    tailNum[2] = 1\n    tailNum[3] = 1\n    tailNum[4] = 1\n    tailNum[5] =\
    \ 1\n    tailNum[6] = 1\n    tailNum[7] = 1\n    tailNum[8] = 1\n    tailNum[9]\
    \ = 1\n    for i := 1; i < n; i++ {\n        for j := 0; j < 10; j++ {\n     \
    \       if tailNum[j] > 0 {\n                tailNum[j] = 0\n                for\
    \ k := 0; k < 10; k++ {\n                    tailNum[j] += tailNum[k]\n      \
    \          }\n            }\n        }\n    }\n    sum := 0\n    for i := 0; i\
    \ < 10; i++ {\n        sum += tailNum[i]\n    }\n    return sum\n}\n", "    //\
    \ return count of the numbers of n-digit positive integers that start with 1\n\
    \    if n == 1 {\n        return 1\n    }\n    return (int(float64(n) * 10) -\
    \ 10) + 1 + starts_one_ends(n - 1)\n}\n", "    if n == 1 {\n        return 1\n\
    \    }\n    if n == 2 {\n        return 10\n    }\n    if n == 3 {\n        return\
    \ 100\n    }\n    dp := make([]int, n+1)\n    dp[1] = 1\n    dp[2] = 10\n    dp[3]\
    \ = 100\n    for i := 4; i <= n; i++ {\n        dp[i] = (dp[i-1] + dp[i-2]) *\
    \ 9\n    }\n    return dp[n]\n}\n", "    var count int\n    if n == 1 {\n    \
    \    return 1\n    } else if n == 2 {\n        return 1\n    } else {\n      \
    \  count = starts_one_ends(n-1) + 1\n        for i := 2; i < n; i++ {\n      \
    \      count += starts_one_ends(n-i)\n        }\n    }\n    return count\n}\n",
  "    // Counting the numbers in zero base.\n    if n <= 1 {\n        return 1\n\
    \    }\n    // total numbers\n    total := (9 - 1) * 9\n    for i := 2; i < n;\
    \ i++ {\n        total *= 10\n    }\n    return total\n}\n", "    if n < 1 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 2\n    }\n    var count1,\
    \ count2 int\n    count1 = 10\n    count2 = 0\n    for i := 1; i < n; i++ {\n\
    \        count2 = 9 * count1\n        count1 = 9 * count1 + 10\n    }\n    return\
    \ count1 + count2\n}\n", "    count := 0\n    if n <= 0 {\n        return count\n\
    \    }\n\n    // Count numbers that start with 1.\n    count += 1\n    start_ones\
    \ := 1\n    for i := 1; i < n; i++ {\n        start_ones *= 9\n        count +=\
    \ start_ones\n    }\n\n    // Count numbers that end with 1.\n    count += 1\n\
    \    end_ones := 1\n    for i := 1; i < n; i++ {\n        end_ones *= 10\n   \
    \     count += end_ones\n    }\n\n    return count\n}\n", "    // c1: start with\
    \ 1\n    c1 := 9\n    for i := 0; i < n - 1; i++ {\n        c1 *= 9\n    }\n \
    \   // c2: end with 1\n    c2 := 1\n    for i := 0; i < n - 1; i++ {\n       \
    \ c2 *= 10\n    }\n    return c1 + c2\n}\n", "    if n == 1 {\n        return\
    \ 1\n    }\n    if n == 2 {\n        return 2\n    }\n    if n == 3 {\n      \
    \  return 4\n    }\n    if n == 4 {\n        return 8\n    }\n    if n == 5 {\n\
    \        return 16\n    }\n    if n == 6 {\n        return 32\n    }\n    return\
    \ starts_one_ends(n-2) * 3\n}\n", "    if n < 2 {\n        return 0\n    }\n \
    \   A := make([]int, n+1)\n    for i := range A {\n        A[i] = 1\n    }\n \
    \   for i := 2; i <= n; i++ {\n        if i == 2 {\n            A[i] = 11\n  \
    \      } else {\n            A[i] = (A[i-1] - A[i-2]) * 9 + A[i-1]\n        }\n\
    \    }\n    return A[n]\n}\n", "    var res int\n    if n < 1 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return 1\n    }\n    res = start_one_ends(n-1)\
    \ + start_one_ends(n-2)\n    return res\n}\n", "    c := 1\n\n    for i := 1;\
    \ i < n; i++ {\n        c = c * 10 + 1\n    }\n\n    return c\n}\n", "    count\
    \ := 0\n    for i := 1; i <= n; i++ {\n        if i == 1 {\n            count\
    \ += 1\n        } else {\n            count += 9 * factorial(i - 1)\n        }\n\
    \    }\n    return count\n}\n", "    // We can split the problem into two:\n \
    \   //\n    // 1. How many numbers start with 1 and has (n-1) digits?\n    //\
    \ 2. How many numbers end with 1 and has (n-1) digits?\n    //\n    // The first\
    \ problem is the same as we count the numbers of n-digit\n    // positive integers\
    \ that start with 1.\n    //\n    // To solve the second problem, we have to consider\
    \ the digits from 0 to 9\n    // in the first digit.\n    //\n    // For each\
    \ digit in the first digit, it will has (n-1) digits for the\n    // last digit.\n\
    \    //\n    // Because, we can only get 1 if the first digit is 1, and the second\n\
    \    // digit is 0. Therefore, we can only count the numbers of (n-2) digits\n\
    \    // positive integers that start with 0.\n    //\n    // Since the total number\
    \ of (n-1) digits positive integers that ends with\n    // 1 is the sum of the\
    \ number of (n-1) digits positive integers that starts\n    // with 0 and 1. So,\
    \ we can also solve this problem using recursion.\n    switch n {\n    case 1:\n\
    \        return 2\n    case 2:\n        return 3\n    default:\n        return\
    \ starts_one_ends(n-1) + starts_one_ends(n-2)\n    }\n}\n", "    if n == 1 {\n\
    \        return 1\n    }\n\n    return starts_one_ends(n - 1) + (9 * (n - 1))\n\
    }\n", "    if n < 2 {\n        return n\n    }\n\n    sum := 1\n    for i := 2;\
    \ i <= n; i++ {\n        sum = sum * 10 + 1\n    }\n\n    return sum * 10 - 9\n\
    }\n", "    if n < 1 {\n        return 0\n    }\n    return (n - 1) * 9\n}\n",
  "    if n == 1 {\n        return 1\n    }\n\n    if n == 2 {\n        return 10\n\
    \    }\n\n    dp := make([]int, n + 1)\n    dp[1] = 1\n    dp[2] = 10\n\n    for\
    \ i := 3; i <= n; i++ {\n        dp[i] = 10 * dp[i - 1] - dp[i - 2]\n    }\n\n\
    \    return dp[n]\n}\n", "    if n == 1 {\n        return 1\n    }\n    if n ==\
    \ 2 {\n        return 19\n    }\n    r := make([]int, n)\n    r[0] = 1\n    r[1]\
    \ = 19\n    for i := 2; i < n; i++ {\n        r[i] = r[i-1]*10 + 9*(i-1)*9\n \
    \   }\n    return r[n-1]\n}\n", "    if n == 1 {\n        return 1\n    }\n  \
    \  max := (10 - 2) * 9\n    return max * max * (n - 2)\n}\n", "    // 9x for numbers\
    \ starting with 1\n    // 9x for numbers ending with 1\n    if n < 2 {\n     \
    \   return n\n    }\n    return 9*starts_one_ends(n-1) + 9*starts_one_ends(n-2)\n\
    }\n", "    var i, count int\n\n    // Return a special value if n is not positive.\n\
    \    if n <= 0 {\n        return -1\n    }\n\n    // If n is 1, then there are\
    \ two such integers: 0 and 1.\n    if n == 1 {\n        return 2\n    }\n\n  \
    \  // Calculate the sum of the number of n-digit positive integers that start\n\
    \    // with 1.\n    for i = 0; i < n; i++ {\n        count += recurse(n, n -\
    \ i - 1)\n    }\n\n    // Add the number of n-digit positive integers that end\
    \ with 1.\n    count += recurse(n, n - 1)\n\n    return count\n}\n", "    if n\
    \ < 1 {\n        return 0\n    }\n\n    count := 1 // 0\n    for i := 1; i < n;\
    \ i++ {\n        count *= 10\n    }\n\n    return 9 * count + 1\n}\n", "    if\
    \ n == 1 {\n        return 1\n    }\n    if n == 2 {\n        return 11\n    }\n\
    \    return starts_one_ends(n-1) + starts_one_ends(n-2)\n}\n", "    // [test cases]\n\
    \    // 1301 -> 1\n    // 2372 -> 1\n    // 1234 -> 0\n    var total int = 0\n\
    \    //var by_tens int = 1\n    for i := 1; i <= n; i++ {\n        //by_tens *=\
    \ 10\n        total += n / i\n    }\n    return total\n}\n", "    if n == 1 {\n\
    \        return 2\n    }\n\n    if n == 2 {\n        return 4\n    }\n\n    return\
    \ starts_one_ends(n - 1) + starts_one_ends(n - 2)\n}\n", "    count := 0\n   \
    \ for i := 0; i < n; i++ {\n        for j := 1; j < 10; j++ {\n            count\
    \ += int(math.Pow(float64(10), float64(i)))\n        }\n    }\n    return count\n\
    }\n", "    if n < 1 {\n        return 0\n    }\n\n    var (\n        starts [1001]int\n\
    \        ends [1001]int\n    )\n\n    starts[1] = 1\n    ends[1] = 1\n\n    for\
    \ i := 2; i <= n; i++ {\n        starts[i] = ends[i - 1]\n        ends[i] = starts[i\
    \ - 1] + ends[i - 1]\n    }\n\n    return starts[n] + ends[n]\n}\n", "    if n\
    \ < 1 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n \
    \   return 9 + 9 * starts_one_ends(n - 1)\n}\n", "    if n < 2 {\n        return\
    \ 10\n    }\n    dp := make([]int, n+1)\n    dp[0] = 1\n    dp[1] = 9\n    for\
    \ i := 2; i <= n; i++ {\n        dp[i] = 10 * dp[i-1] - dp[i-2]\n    }\n    return\
    \ dp[n]\n}\n", "    if n < 1 {\n        return 0\n    }\n    if n == 1 {\n   \
    \     return 1\n    }\n    return starts_one_ends(n-1) +\n        (9 * (10 **\
    \ uint(n-2))) +\n        starts_one_ends(n-2)\n}\n", "    // Use an array to represent\
    \ an integer, so that we can\n    // deal with larger integers.\n    num := make([]int,\
    \ n)\n    // Start with the n-digit number that starts and ends with 1.\n    num[0]\
    \ = 1\n    num[n-1] = 1\n    // Count the number of n-digit numbers that start\
    \ or end with 1.\n    count := 1\n    for ; ; {\n        // Increment the number.\n\
    \        if !increment(num) {\n            break\n        }\n        // If we\
    \ are done, stop counting.\n        if starts_one_ends_done(num) {\n         \
    \   break\n        }\n        // If we don't start with a zero, count it.\n  \
    \      if num[0] != 0 {\n            count++\n        }\n        // If we don't\
    \ end with a zero, count it.\n        if num[n-1] != 0 {\n            count++\n\
    \        }\n    }\n    return count\n}\n", "    if n == 1 {\n        return 2\n\
    \    }\n    starts := 9\n    ends := 1\n    for i := 2; i <= n; i++ {\n      \
    \  starts *= (9 - i + 2)\n        ends *= 10\n    }\n    return starts + ends\n\
    }\n", "    if n < 1 {\n        return 0\n    }\n    return (9 * pow(10, n - 1))\
    \ + (pow(10, n) - pow(10, n - 1))\n}\n", "    if n < 1 {\n        return 0\n \
    \   }\n    if n == 1 {\n        return 2\n    }\n    var first, last int = 2,\
    \ 1\n    for i := 2; i <= n; i++ {\n        first = first + last\n        last\
    \ = first\n    }\n    return first + last\n}\n", "    if n < 1 {\n        return\
    \ 0\n    }\n\n    res := 1\n    base := 1\n    tmp := 0\n    for n > 1 {\n   \
    \     base *= 10\n        tmp = base + tmp * 10 + 1\n        res += tmp\n    \
    \    n--\n    }\n    return res\n}\n", "    // count start_one and end_one\n \
    \   start_one := (n - 1) * 9\n    end_one := 9\n    // count start_one_end_one\n\
    \    start_one_end_one := 0\n    if n == 1 {\n        start_one_end_one = 1\n\
    \    } else {\n        start_one_end_one = 9\n    }\n    return start_one + end_one\
    \ + start_one_end_one\n}\n", "    if n == 1 {\n        return 10\n    }\n    if\
    \ n == 2 {\n        return 100\n    }\n    ten := 1\n    for i := 1; i < n - 1;\
    \ i++ {\n        ten *= 10\n    }\n    return starts_one_ends(n - 1) + 9 * ten\n\
    }\n", "    // Write your code here\n    // n:1 => 1\n    // n:2 => 10+9 = 19\n\
    \    // n:3 => 100+10*9+9*9 = 280\n    // n:4 => 1000+100*9+10*9*9+9*9*9 = 3700\n\
    \    // n:5 => 10000+1000*9+100*9*9+10*9*9*9+9*9*9*9 = 45600\n    // ...\n   \
    \ // dp[i]: num of n-digit integers that start or end with 1.\n    dp := make([]int,\
    \ n+1)\n    dp[1] = 1\n    for i := 2; i <= n; i++ {\n        s := dp[i-1] * 9\
    \ // num of integers not start with 1\n        e := dp[i-1]     // num of integers\
    \ not end with 1\n        s += dp[i-1]     // num of integers start with 1\n \
    \       e += dp[i-1] * 9 // num of integers end with 1\n        dp[i] = s + e\n\
    \    }\n    return dp[n]\n}\n", "    if n == 1 {\n        return 2\n    }\n\n\
    \    // number of digits between first 1 and last 1\n    mid := n - 2\n    //\
    \ number of possible digit combinations of the digits in between.\n    // i.e.\
    \ we are assuming there are no leading zeros in our numbers\n    nums := int(1e9)\
    \ - int(1e8) + 1\n    // 10**(mid-1) because we know we have at least one number\
    \ between\n    // the start and end\n    return nums * int(1e9) * int(1e9) * int(1e9)\
    \ * int(1e9) * int(1e9) * int(1e9) * int(1e9) * int(1e9) * int(1e9) * int(1e9)\
    \ * int(1e9) * int(1e9) * int(1e9) * int(1e9) * int(1e9) * int(1e9) * int(1e9)\
    \ * int(1e9) * int(1e9) * int(1e9) * int(1e9) * int(1e9) * int(1e9) * int(1e9)\
    \ * int(1e9) * int(1e9) * int(1e9) * int(1e9) * int(1e9) * int(1e9) * int(1e9)\
    \ * int(1e9) * int(1e9) * int(1e9) * int(1e9) * int(1e9) * int(1e9) * int(1e9)\
    \ * int(1e9) * int(1e9) * int(1e9) * int(1e9) * int(1e9) * int(1e9) * int(1e9)\
    \ * int(1e9) * int(1e9) * int(1e9) * int(1e9) * int(1e9) * int(1e9) * int(1e9)\
    \ * int(1e9) * int(1e9) * int(1e9) * int(1e9) * int", "    if n == 1 {\n     \
    \   return 2\n    }\n\n    if n == 2 {\n        return 3\n    }\n\n    return\
    \ starts_one_ends(n - 1) + starts_one_ends(n - 2)\n}\n", "    if n == 1 {\n  \
    \      return 1\n    }\n    // Example: for n = 4, we can only start the integers\
    \ with 1, the others\n    // will end with 1.\n    return 9 * pow(10, n - 1)\n\
    }\n", "    if n == 1 {\n        return 1\n    }\n    return n * n * n + n * n\
    \ + n\n}\n", "    if n < 1 {\n        return 0\n    }\n    if n == 1 {\n     \
    \   return 1\n    }\n    if n == 2 {\n        return 4\n    }\n    return starts_one_ends(n-1)\
    \ + starts_one_ends(n-2) + 2\n}\n", "    sum := 0\n    for i := 1; i <= n; i++\
    \ {\n        count := 0\n        for j := 1; j <= i; j++ {\n            if j ==\
    \ 1 || j == i {\n                count++\n            }\n        }\n        sum\
    \ += count\n    }\n    return sum\n}\n", "    if n == 1 {\n        return 2\n\
    \    }\n    if n == 2 {\n        return 4\n    }\n    return starts_one_ends(n-1)\
    \ + starts_one_ends(n-2)\n}\n", "    if n < 1 {\n        return 0\n    }\n   \
    \ // dp[i] means count for n-digit number, that starts with one\n    dp := make([]int,\
    \ n + 1)\n    dp[1] = 1\n    for i := 2; i <= n; i++ {\n        // We can fill\
    \ the rest with any number, so the count is 9 * 10^(i-2)\n        dp[i] = 9 *\
    \ pow(10, i - 2)\n        // There are 2 numbers (1, 10) that start with one,\n\
    \        // and we can fill the rest with any number, so the count is 2 * 10^(i-2)\n\
    \        dp[i] += 2 * pow(10, i - 2)\n    }\n    return dp[n]\n}\n", "    if n\
    \ < 1 {\n        return 0\n    }\n\n    // Count the 1s.\n    ans := 1\n    for\
    \ i := 1; i < n; i++ {\n        ans += 9 * pow10(i-1)\n    }\n\n    // Count the\
    \ n-digit starts-with-1 numbers.\n    for i := 1; i < n; i++ {\n        ans +=\
    \ 9 * pow10(i-1)\n    }\n\n    return ans\n}\n", "    var ret int = 1\n    if\
    \ n <= 1 {\n        return ret\n    }\n    for i := 1; i < n; i++ {\n        ret\
    \ *= 10\n    }\n    return ret * 9 + 1\n}\n", "    if n == 1 {\n        return\
    \ 1\n    }\n    return 9 * starts_one_ends(n - 1) + 9 * digits_power(n - 1)\n\
    }\n", "    count, length := 0, 0\n    for length = 1; length <= n; length++ {\n\
    \        for i := 0; i < 10; i++ {\n            t := 0\n            if i == 1\
    \ {\n                t = 1\n            }\n            if length > 1 {\n     \
    \           count += 9 * recursive_solution(length - 1, t)\n            } else\
    \ {\n                count += 1\n            }\n        }\n    }\n    return count\n\
    }\n", "    sum := 0\n    if n == 1 {\n        return 1\n    }\n    sum += 9\n\
    \    prev := 9\n    for i := 2; i <= n; i++ {\n        sum += prev * (10 - i)\n\
    \        prev = prev * (10 - i)\n    }\n    return sum\n}\n", "    switch n {\n\
    \    case 1:\n        return 2\n    case 2:\n        return 5\n    }\n    return\
    \ 4 * starts_one_ends(n - 1) - starts_one_ends(n - 2)\n}\n", "    if n < 1 {\n\
    \        return 0\n    }\n\n    if n == 1 {\n        return 1\n    }\n\n    count\
    \ := 10\n\n    // n > 1\n    first := 1\n    last := 1\n    for i := 2; i <= n;\
    \ i++ {\n        if i == n {\n            last = 9\n        } else {\n       \
    \     last = last * 10\n        }\n        count += (last - first) * 2\n     \
    \   first = first * 10\n    }\n\n    return count\n}\n", "    if n == 1 {\n  \
    \      return 2\n    }\n\n    dp := make([]int, n+1)\n    dp[1] = 2\n    dp[2]\
    \ = 3\n\n    for i := 3; i <= n; i++ {\n        dp[i] = dp[i-1] + dp[i-2]\n  \
    \  }\n\n    return dp[n]\n}\n", "    return helper(n) - helper(n - 1)\n}\n", " \
    \   if n < 1 {\n        return 0\n    }\n    // use recursive\n    if n == 1 {\n\
    \        return 1\n    }\n    if n == 2 {\n        return 2\n    }\n    return\
    \ starts_one_ends(n-1) + starts_one_ends(n-2)\n}\n", "    return (2 + (n - 2)\
    \ * 4) * 9 * pow(10, n - 2)\n}\n", "    // Start with the first n-digit number,\
    \ which is 10**(n-1).\n    current := 1\n    for i := 1; i < n; i++ {\n      \
    \  current *= 10\n    }\n\n    // Count the number of numbers starting with 1.\n\
    \    count := current/10\n\n    // For each other digit, add the number of possibilities.\n\
    \    // (8 because there are 8 numbers that don't start with 1).\n    for i :=\
    \ 0; i < n-1; i++ {\n        count += 8*current\n        current /= 10\n    }\n\
    \n    return count\n}\n", "    if n < 1 {\n        return 0\n    }\n\n    if n\
    \ == 1 {\n        return 2\n    }\n\n    if n == 2 {\n        return 9\n    }\n\
    \n    // if n >= 3, then the number has a form as follows:\n    // 1 xyyy (1xxx)\
    \ 1\n    // This can be simplified as below:\n    // 10yy (1yy) 10\n    return\
    \ starts_one_ends(n - 1) + starts_one_ends(n - 2)\n}\n", "    cnt := 1\n    if\
    \ n < 2 {\n        return cnt\n    }\n    cnt += 9 * count_diff_digits(n - 1)\n\
    \    return cnt\n}\n", "    if n < 1 {\n        return 0\n    }\n    if n == 1\
    \ {\n        return 1\n    }\n    //\n    // n - 1 digits\n    n_less_one := n\
    \ - 1\n    // n - 2 digits\n    n_less_two := n - 2\n    // number of n - 1 digit\
    \ integers\n    nums_n_less_one := nums_n_digits(n_less_one)\n    // number of\
    \ n - 2 digit integers\n    nums_n_less_two := nums_n_digits(n_less_two)\n   \
    \ // number of n - 1 digit integers starting with 1\n    nums_n_less_one_starts_one\
    \ := nums_n_digits_starts_one(n_less_one)\n    // number of n - 2 digit integers\
    \ starting with 1\n    nums_n_less_two_starts_one := nums_n_digits_starts_one(n_less_two)\n\
    \    // number of n - 1 digit integers ending with 1\n    nums_n_less_one_ends_one\
    \ := nums_n_digits_ends_one(n_less_one)\n    // number of n - 2 digit integers\
    \ ending with 1\n    nums_n_less_two_ends_one := nums_n_digits_ends_one(n_less_two)\n\
    \    // number of n - 1 digit integers starting with 1 or ending with 1\n    nums_n_less_one_starts_one_ends_one\
    \ := nums_n_digits_starts_one_ends_one(n_less_one)\n    // number of n - 2 digit\
    \ integers starting with 1 or ending with 1\n    nums_n_less_two_starts_one_ends_one\
    \ := nums_n_digits_starts_one_ends_one(n_less_two)\n    //\n    //fmt.Printf(\"\
    n = %d, n - 1 = %d, n - 2 = %d\\n\", n, n_less_one, n_less_two)\n    //fmt.Printf(\"\
    n - 1 starting with 1 = %d\\n", "    count, x := 0, 0\n    f10, f100 := 1, 1\n\
    \    for i := 1; i < n; i++ {\n        f10 *= 10\n        f100 *= 100\n    }\n\
    \    for i := 1; i < 10; i++ {\n        count += starts_one_ends(n - 1)\n    }\n\
    \    for i := 1; i < 10; i++ {\n        x = i * f10 + 1\n        if x > f100 {\n\
    \            return count + starts_one_ends(n - 1)\n        }\n        count +=\
    \ 1\n    }\n    return count\n}\n", "    if n < 1 {\n        return 0\n    }\n\
    \n    if n == 1 {\n        return 1\n    }\n\n    if n == 2 {\n        return\
    \ 11\n    }\n\n    if n == 3 {\n        return 113\n    }\n\n    return (2 * (starts_one_ends(n\
    \ - 1) - starts_one_ends(n - 2)) + starts_one_ends(n - 1)) % 1000000007\n}\n",
  "    if n < 1 {\n        return 0\n    }\n    return 11 * starts_one_ends(n - 1)\
    \ + 9 * pow(10, n - 1)\n}\n", "    if n == 1 {\n        return 2\n    }\n    return\
    \ (n - 1) * 9\n}\n", "    // If a number ends with 1 and has n digits, it must\
    \ start with (n-1)\n    // zeros and a 1. The same number would have n-1 digits\
    \ if we remove\n    // the leading zero, so the number is a duplicate. There are,\
    \ therefore,\n    // no n-digit positive integers that end with 1.\n    //\n \
    \   // If a number starts with 1 and has n digits, it can end with any\n    //\
    \ of the other 9 digits. There are, therefore, 9*10^(n-1) numbers\n    // that\
    \ start with 1 and have n digits.\n    return 9 * (1 << uint(n-1))\n}\n", "  \
    \  if n == 1 {\n        return 2\n    }\n\n    if n == 2 {\n        return 3\n\
    \    }\n\n    start := 2\n    for i := 3; i <= n; i++ {\n        start = 2*start\
    \ + 2\n    }\n\n    return start\n}\n", "    if n == 1 {\n        return 2\n \
    \   }\n\n    // initialize\n    result := 3\n    for i := 3; i <= n; i++ {\n \
    \       result = result * 2\n    }\n\n    return result\n}\n", "    // Count is\
    \ the number of n-digit positive integers that start with 1.\n    // Count_end\
    \ is the number of n-digit positive integers that end with 1.\n    var count,\
    \ count_end int\n\n    count = 9\n    count_end = 10\n\n    // n-digit numbers\
    \ start with 1.\n    for i := 2; i <= n; i++ {\n        count *= 10 - i + 1\n\
    \        count_end = count_end * 10 + 1\n    }\n\n    // If n == 1, the number\
    \ that starts and ends with 1 is the same.\n    if n == 1 {\n        return count\n\
    \    }\n\n    return count + count_end - 10\n}\n", "    if n < 1 {\n        return\
    \ 0\n    }\n\n    // Initialize results array.\n    results := make([]int, n +\
    \ 1)\n    results[0] = 0\n    results[1] = 1\n\n    // Iterate over digits and\
    \ update results.\n    for i := 2; i <= n; i++ {\n        results[i] = (results[i\
    \ - 1] * 9) + results[i - 2]\n    }\n\n    return results[n]\n}\n", "    if n\
    \ == 1 {\n        return 2\n    }\n    if n == 2 {\n        return 9\n    }\n\
    \    return starts_one_ends(n-1) + starts_one_ends(n-2)\n}\n", "    if n < 1 {\n\
    \        return 0\n    }\n    return ends_one(n) + starts_one(n)\n}\n", "    if\
    \ n == 1 {\n        return 10\n    }\n    if n == 2 {\n        return 20\n   \
    \ }\n    return 9 * pow10(n - 2)\n}\n", "    if n == 1 {\n        return 2\n \
    \   }\n\n    if n == 2 {\n        return 3\n    }\n\n    return starts_one_ends(n\
    \ - 1) + starts_one_ends(n - 2)\n}\n", "    if n == 1 {\n        return 2\n  \
    \  }\n    return 9 * (1 << uint(n - 2))\n}\n", "    if n == 1 {\n        return\
    \ 2\n    }\n\n    if n == 2 {\n        return 4\n    }\n\n    // Recursively\n\
    \    return 3 * starts_one_ends(n - 1) - starts_one_ends(n - 2)\n}\n", "    if\
    \ n < 1 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n\
    \    if n == 2 {\n        return 2\n    }\n    s, t := 1, 2\n    i := 3\n    for\
    \ i <= n {\n        t, s = (t + s), t\n        i++\n    }\n    return t\n}\n",
  "    if n == 1 {\n        return 1\n    }\n    a, b := 1, 0\n    for i := 2; i <=\
    \ n; i++ {\n        a, b = a + 9 * b, a\n    }\n    return a + b\n}\n", "    //\
    \ @todo\n    return 0\n}\n", "    if n == 1 {\n        return 1\n    }\n    if\
    \ n <= 0 {\n        return 0\n    }\n    return starts_one_ends(n-1) + 9 * pow(10,\
    \ n-2)\n}\n", "    if n < 1 {\n        return 0\n    }\n\n    var count int\n\
    \    var base float64 = 1\n\n    for i := 1; i < n; i++ {\n        base *= 10\n\
    \    }\n\n    for i := 1; i < 10; i++ {\n        count += starts_one_ends(n -\
    \ 1)\n    }\n\n    count += int(base)\n    return count\n}\n", "    if n == 1\
    \ {\n        return 10\n    }\n    if n == 2 {\n        return 99\n    }\n   \
    \ return starts_one_ends(n-1) + starts_one_ends(n-2)\n}\n", "    digits := n\n\
    \n    if n == 1 {\n        return 10\n    }\n\n    result := 0\n    start_one\
    \ := 9\n    end_one := 9\n    others := 9\n\n    for ; digits > 2; digits-- {\n\
    \        others *= 10\n    }\n\n    if digits == 2 {\n        result += start_one\
    \ + end_one + others\n    } else {\n        result += others\n    }\n\n    return\
    \ result\n}\n", "    if n == 1 {\n        return 2\n    }\n\n    if n == 2 {\n\
    \        return 3\n    }\n\n    // f(n) = f(n-1) + f(n-2)\n    return starts_one_ends(n-1)\
    \ + starts_one_ends(n-2)\n}\n", "    if n < 1 {\n        return 0\n    }\n   \
    \ var first = 1\n    var end = 9\n    for i := 1; i < n; i++ {\n        first\
    \ *= 10\n        end = end * 10 + 9\n    }\n    return 2 * end - first + 1\n}\n",
  "    if n == 1 {\n        return 1\n    }\n    // xxxx\n    // 1xxx\n    // x1xx\n\
    \    // xx1x\n    // xxx1\n    //\n    // e.g.\n    // n = 3\n    // xxx\n   \
    \ //\n    // for x is 1, xxx starts with 1, xxx + 1 = 000,\n    // otherwise,\
    \ xxx ends with 1, xxx + 1 = 100, 101, 110, 111\n    //\n    // when n = 3, xxx\
    \ is 3-digit positive integers,\n    // xxx in [100, 999],\n    // so count =\
    \ 999 - 100 + 1 = 900\n    return 9 * pow(10, n - 1)\n}\n", "    if n == 1 {\n\
    \        return 1\n    }\n\n    var x float64 = 9\n    for i := 1; i < n; i++\
    \ {\n        x = x * (9 - float64(i))\n    }\n\n    return int(x)\n}\n", "   \
    \ return starts_one_ends_helper(n, false)\n}\n", "    // No 0-digit numbers.\n\
    \    if n == 0 {\n        return 0\n    }\n\n    // A 1-digit number can only\
    \ be 1.\n    if n == 1 {\n        return 1\n    }\n\n    count := 1\n    for i\
    \ := 2; i <= n; i++ {\n        count *= 9\n    }\n\n    return count * 2\n}\n",
  "    // Start and end with 1\n    starts_one_ends_one := func(n int) int {\n   \
    \     if n == 1 {\n            return 2\n        }\n        return 10*starts_one_ends_one(n-1)\
    \ - starts_one_ends_two(n-1)\n    }\n\n    // Start with 1 and end with other\
    \ numbers\n    starts_one_ends_two := func(n int) int {\n        if n == 1 {\n\
    \            return 1\n        }\n        return 9*starts_one_ends_one(n-1)\n\
    \    }\n\n    return starts_one_ends_one(n) + starts_one_ends_two(n)\n}\n", " \
    \   if n == 1 {\n        return 1\n    }\n    if n == 2 {\n        return 2\n\
    \    }\n    if n == 3 {\n        return 4\n    }\n    var start_one, end_one,\
    \ both_one, neither_one int = 1, 2, 0, 4\n    var tmp int\n    for i := 4; i <=\
    \ n; i++ {\n        tmp = start_one\n        start_one = both_one + end_one\n\
    \        both_one = tmp\n        end_one = neither_one\n        neither_one =\
    \ both_one + end_one\n    }\n    return start_one + end_one + both_one + neither_one\n\
    }\n", "    if n == 1 {\n        return 1\n    }\n    last_int := starts_one_ends(n\
    \ - 1)\n    return 9 * last_int + 10 * pow(10, n - 2)\n}\n", "    if n < 1 {\n\
    \        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    if n <\
    \ 4 {\n        return n - 1\n    }\n    return starts_one_ends(n - 1) + starts_one_ends(n\
    \ - 2)\n}\n", "    // edge case\n    if n == 1 {\n        return 2\n    }\n\n\
    \    // con", "    // f(n) = f(n-1) + f(n-2)\n    // f(1) = 1\n    // f(2) = 2\n\
    \    var (\n        first, second, third int = 1, 1, 0\n    )\n    if n == 1 {\n\
    \        return first\n    }\n    if n == 2 {\n        return second\n    }\n\
    \    for i := 3; i <= n; i++ {\n        third = first + second\n        first\
    \ = second\n        second = third\n    }\n    return third\n}\n", "    return\
    \ int((n + 1) * 10 / 4)\n}\n", "    if n == 1 {\n        return 1\n    }\n   \
    \ if n == 2 {\n        return 2\n    }\n    // We have the base cases, now the\
    \ rest\n    //\n    // To get the value for n, you have n-1 digits between the\
    \ start\n    // and end. You can have a 1 or 0 in each position. There are n-1\n\
    \    // positions. So the answer is 2^(n-1)\n    return 1 << (n-1)\n}\n", "  \
    \  count := 0\n    if n == 1 {\n        return 1\n    } else if n == 2 {\n   \
    \     return 10\n    } else {\n        count += starts_one_ends(n-1)\n       \
    \ count += starts_one_ends(n-2)\n    }\n    return count\n}\n", "    // Write\
    \ your code here\n    if n == 1 {\n        return 10\n    }\n    if n == 2 {\n\
    \        return 10\n    }\n    return 10 * 9 * power(10, n - 2) + starts_one_ends(n\
    \ - 1)\n}\n", "    if n < 2 {\n        return 0\n    }\n    if n == 2 {\n    \
    \    return 9\n    }\n    var nine int = 9\n    var eight int = 8\n    for i :=\
    \ 3; i <= n; i++ {\n        tmp := nine\n        nine = nine * 10 + eight\n  \
    \      eight = eight * 8\n        nine = nine + tmp\n    }\n    return nine\n\
    }\n", "    if n == 1 {\n        return 10\n    }\n\n    count := 9\n    pow :=\
    \ 1\n    for i := 1; i < n; i++ {\n        pow *= 10\n        count += pow * 9\n\
    \    }\n\n    return count\n}\n", "    // base case\n    if n == 1 {\n       \
    \ return 2\n    }\n\n    start_count := 1\n    end_count := 1\n    power := 10\n\
    \n    // To avoid duplicated computation.\n    last_count := 1\n\n    for i :=\
    \ 2; i <= n; i++ {\n        start_count = 9 * power + last_count\n        end_count\
    \ = 10 * last_count\n        last_count = start_count + end_count\n        power\
    \ *= 10\n    }\n\n    return last_count\n}\n", "    // Assume that 'n' is greater\
    \ than 0.\n    if n == 1 {\n        return 2\n    }\n\n    // The answer is equal\
    \ to the sum of all the possible length 1 numbers\n    // with the remainder of\
    \ the length 'n' numbers that do not start with 1.\n    var non_starts_one_ends\
    \ int\n    if n % 2 == 0 {\n        non_starts_one_ends = n / 2 * (n - 1)\n  \
    \  } else {\n        non_starts_one_ends = (n - 1) / 2 * n\n    }\n\n    return\
    \ n + non_starts_one_ends\n}\n", "    // This is a factorial problem.\n    if\
    \ n <= 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n\
    \    first, second := 1, 1\n    for i := 1; i < n; i++ {\n        first = first\
    \ * 9\n        second = second * 9\n    }\n    return first + second\n}\n", " \
    \   if n == 1 {\n        return 1\n    }\n\n    count := 10\n\n    for i := 2;\
    \ i <= n; i++ {\n        count += 9\n    }\n\n    return count\n}\n", "    count\
    \ := 0\n    last := 0\n    if n == 1 {\n        return 1\n    }\n    for i :=\
    \ 1; i < n; i++ {\n        last = last * 10 + 1\n        count += last\n    }\n\
    \    return count * 9 + 1\n}\n", "    res := 0\n    for _, v := range []int{1,\
    \ 9} {\n        res += get_last_digit(n - 1, v)\n    }\n    return res\n}\n",
  "    var result int\n    sum := 0\n    for i := 1; i <= n; i++ {\n        sum +=\
    \ 9 * pow(10, i - 1)\n        result += sum\n    }\n    return result\n}\n", " \
    \   if n == 1 {\n        return 2\n    }\n    if n == 2 {\n        return 2\n\
    \    }\n    return starts_one_ends(n-1) + starts_one_ends(n-2)\n}\n", "    return\
    \ 0\n}\n", "    count := 0\n    for i := 1; i <= n; i++ {\n        if i % 10 ==\
    \ 1 {\n            count++\n        }\n    }\n    return count\n}\n", "    var\
    \ ways = 0\n    for i := 1; i <= n; i++ {\n        if i == 1 {\n            ways\
    \ += 1\n        } else {\n            ways += (int(math.Pow(10, float64(i-1)))\
    \ -\n                     int(math.Pow(10, float64(i-2))))\n        }\n    }\n\
    \    return ways\n}\n", "    // Base case.\n    if n == 1 {\n        return 2\n\
    \    }\n    return starts_one_ends(n - 1) + starts_one_ends(n - 2)\n}\n", "  \
    \  if n < 1 {\n        return 0\n    }\n\n    prefix := 1\n    for i := 1; i <\
    \ n; i++ {\n        prefix *= 10\n    }\n\n    base := prefix * 10\n\n    return\
    \ (base - prefix) * 2\n}\n", "    num_str := \"\"\n    for i := 0; i < n; i++\
    \ {\n        num_str += \"1\"\n    }\n    start_num, end_num := num_str, num_str\n\
    \    count := 0\n    for ; start_num[0] == '1'; start_num = nextNum(start_num)\
    \ {\n        count++\n    }\n    for ; end_num[len(end_num)-1] == '1'; end_num\
    \ = nextNum(end_num) {\n        count++\n    }\n    return count\n}\n", "    //\
    \ Check edge cases\n    if n < 1 {\n        return 0\n    }\n    if n == 1 {\n\
    \        return 2\n    }\n\n    // As n is n-digit positive integer, n-1 digits\
    \ are 0-9,\n    // therefore, n-1 digits can have 10^(n-1) combinations.\n   \
    \ // Considering two cases: 1. the first digit is 1, and 2. the last digit is\
    \ 1.\n    // 1. For the first digit is 1, the combinations are\n    // 10^(n-2)\
    \ * 9, e.g. 100, 200, 300, ..., 900.\n    // 2. For the last digit is 1, the combinations\
    \ are\n    // 10^(n-2) * 9, e.g. 1, 11, 21, 31, ..., 91.\n    // So the answer\
    \ is 10^(n-2) * 18.\n    return int(math.Pow10(n-2)) * 18\n}\n", "    // Notice:\n\
    \    // 1. add 1, but only one\n    // 2. 9 powers\n\n    p := 1\n    for i :=\
    \ 0; i < n - 1; i++ {\n        p *= 10\n    }\n\n    return p + 9 * p / 10\n}\n",
  "    if n == 1 {\n        return 1\n    }\n\n    if n == 2 {\n        return 2\n\
    \    }\n\n    return starts_one_ends(n - 1) + (starts_one_ends(n - 2) * 10)\n\
    }\n", "    if n < 1 {\n        return 0\n    }\n\n    if n == 1 {\n        return\
    \ 1\n    }\n\n    return 9 * pow10(n - 1) + starts_one_ends(n - 1)\n}\n", "  \
    \  var count int\n    if n == 1 {\n        return 1\n    }\n    if n == 2 {\n\
    \        return 10\n    }\n    count = 11\n    // problem set 4, question 4\n\
    \    count += 10\n    for i := 2; i < n; i++ {\n        count *= 10\n    }\n \
    \   return count\n}\n", "    // 2^(n-1)\n    if n <= 0 {\n        return 0\n \
    \   }\n\n    return 1 << uint(n-1)\n}\n", "    if n < 1 {\n        return 0\n\
    \    }\n    if n == 1 {\n        return 1\n    }\n    return starts_one_ends(n-1)\
    \ + 9 * (n-1)\n}\n", "    //n = n - 1 // n could be a n-digit number starting\
    \ with 0.\n    if n == 1 {\n        return 10\n    }\n    if n == 2 {\n      \
    \  return 99\n    }\n    return starts_one_ends(n - 1) + 9 * starts_one_ends(n\
    \ - 2)\n}\n", "    return (n-1)*2 + 1\n}\n", "    // Count odd numbers.\n    return\
    \ n * 9\n}\n", "    // Split the n-digit positive integer into a \"tail\" and\
    \ a \"body\".\n    // The \"tail\" is the integer formed by the last digit and\
    \ the \"body\" is\n    // the n-1 digit integer that is not the last digit.\n\
    \    // For example, given the integer 12345, we have the \"tail\" 5 and the\n\
    \    // \"body\" 1234.\n    // The number of 1-digit positive integers that start\
    \ or end with 1 is\n    // 1.\n    // The number of 2-digit positive integers\
    \ that start or end with 1 is\n    // 5, 11, 12, 15, 21, ..., 91.\n    // Given\
    \ an n-digit positive integer, the number of n-digit positive\n    // integers\
    \ that start or end with 1 is the sum of the number of\n    // (n-1)-digit positive\
    \ integers that start or end with 1, plus the\n    // number of (n-1)-digit positive\
    \ integers that start or end with 1\n    // whose last digit is 1.\n    // This\
    \ number is simply dp[n] = dp[n-1] + dp[n-1] (the last digit is 1).\n    // A\
    \ number with the last digit 1 is just 10 times the (n-2)-digit\n    // positive\
    \ integer plus 1.\n    // For example, the integer 123 has a \"tail\" 3, so the\
    \ number of\n    // 3-digit positive integers that start or end with 1 is just\
    \ 1 more\n    // than the number of 2-digit positive integers that start or end\
    \ with\n    // 1 whose last digit is 1, which is the number of 2-digit positive\n\
    \    // integers that start or end with 1, 10, 11, 12, 13, 14, 15, 16, 17,\n \
    \   // 18, 19, i.e., 10 * dp[n-2] + 1.\n    // The initial conditions for n =\
    \ 1 is 1 and n = 2 is 10.\n    dp := make([]int, n+1)\n    dp[1] = 1\n    dp[2]\
    \ = 10\n    for i := 3; i <= n; i++ {\n        dp[i] = dp[i-1] + dp[i-1] + 9 *\
    \ dp[i-", "    if n == 1 {\n        return 10\n    }\n\n    // if n == 2, then\
    \ the count is 9, cause we dont have a number ending with\n    // 00.\n    if\
    \ n == 2 {\n        return 19\n    }\n\n    // if n == 3, then the count is 9,\
    \ cause we dont have a number ending with\n    // 000, also we can't start with\
    \ 0.\n    if n == 3 {\n        return 109\n    }\n\n    // if n > 3, then we can\
    \ take the count of start or end with 1 numbers in\n    // n-1 and add to the\
    \ count of the start or end with 1 in the first position.\n    count := starts_one_ends(n-1)\
    \ + 9*starts_one_ends(n-2)\n\n    return count\n}\n", "    // Insert your code\
    \ here\n    return 0\n}\n", "    // The number of digit n-digit positive integers\
    \ starting with 1\n    starts := 1\n    for i := 1; i < n; i++ {\n        starts\
    \ *= 9\n    }\n\n    // The number of digit n-digit positive integers ending with\
    \ 1\n    ends := 9\n    for i := 2; i < n; i++ {\n        ends *= 10\n    }\n\n\
    \    return starts + ends\n}\n", "    return count_ends(n) + count_starts(n)\n\
    }\n", "    var dp = []int{0, 1, 11, 111, 1111, 11111, 111111, 1111111, 11111111,\
    \ 111111111}\n    return dp[n]\n}\n", "    return 0\n}\n", "    // All numbers\
    \ less than 11 belong to result.\n    if n < 2 {\n        return n\n    }\n\n\
    \    // Build the 9*10^(n-1) numbers that start with 1.\n    start1 := 9 * ten(n-1)\n\
    \n    // Build the 10^(n-1) numbers that end with 1.\n    end1 := ten(n-1)\n\n\
    \    // Exclude numbers that start and end with 1.\n    return start1 + end1 -\
    \ 1\n}\n", "    if n == 1 {\n        return 2\n    }\n\n    dp := make([]int,\
    \ n+1)\n    dp[1] = 2\n    dp[2] = 3\n\n    for i := 3; i <= n; i++ {\n      \
    \  dp[i] = dp[i-1] + dp[i-2]\n    }\n\n    return dp[n]\n}\n", "    if n == 1\
    \ {\n        return 1\n    }\n\n    var (\n        low  = 10\n        high = 1\n\
    \    )\n\n    for i := 2; i <= n; i++ {\n        high = high * 10 + 1\n      \
    \  low *= 10\n    }\n\n    return high - low + 1\n}\n", "    if n < 1 {\n    \
    \    return 0\n    }\n\n    // answer = 10 * 9 * ... * 9 + (number of n-digit\
    \ number can be divided by 10)\n    //   = 9 * (10 ^ (n - 1)) + (number of n-digit\
    \ number can be divided by 10)\n    //   = 9 * (10 ^ (n - 1)) + 10 * 9 * ... *\
    \ 9\n    //   = 9 * (10 ^ (n - 1)) + 9 * (10 ^ (n - 1))\n    //   = 18 * (10 ^\
    \ (n - 1))\n    return 18 * pow(10, n - 1)\n}\n", "    if n == 1 {\n        return\
    \ 10\n    }\n    if n == 2 {\n        return 100\n    }\n    if n == 3 {\n   \
    \     return 1000\n    }\n    var result int\n    for i := 1; i < n; i++ {\n \
    \       result += 9 * nine_power(i)\n    }\n    result += 10 * nine_power(n -\
    \ 1)\n    return result\n}\n", "    // invalid input\n    if n < 1 {\n       \
    \ return 0\n    }\n\n    // Because it is a positive integer, so there will always\
    \ be one digit\n    // number.\n    if n == 1 {\n        return 1\n    }\n\n \
    \   // When n is greater than 1, there are two cases:\n    // The first digit\
    \ is 1, the others are all 9 (1xxxxxx...xx9)\n    // The first digit is 2 - 9,\
    \ the others are all 9 (2xxxxxx...xx9 - 9xxxxxx...xx9)\n    // !!! The second\
    \ case does not exist in this problem.\n\n    // For example, when n = 4, the\
    \ first digit is 1, there are three ways:\n    // 1000 - 1999\n    // 100 - 199\n\
    \    // 10 - 19\n    // We can use f(n) = f(n - 1) + f(n - 2) + f(n - 3)... to\
    \ get the result.\n    var f = make([]int, n + 1)\n    f[1] = 1\n    for i :=\
    \ 2; i <= n; i++ {\n        f[i] = f[i - 1]\n    }\n\n    return f[n]\n}\n", " \
    \   // first = array of number of n-digit number with first digit as 1\n    //\
    \ end = array of number of n-digit number with last digit as 1\n    // \n    //\
    \ first[i] = 10 * first[i-1] + 10^(i-1)\n    // end[i] = 10 * end[i-1] + 10^(i-1)\n\
    \    // total[i] = end[i] + first[i]\n    total := make([]int, n+1)\n    total[1]\
    \ = 2\n    if n == 1 {\n        return total[1]\n    }\n    first := make([]int,\
    \ n+1)\n    first[1] = 1\n    end := make([]int, n+1)\n    end[1] = 1\n    for\
    \ i := 2; i <= n; i++ {\n        // number of digit 10^(i-1)\n        expo :=\
    \ 1\n        for j := 1; j < i; j++ {\n            expo *= 10\n        }\n   \
    \     first[i] = first[i-1]*10 + expo\n        end[i] = end[i-1]*10 + expo\n \
    \       total[i] = first[i] + end[i]\n    }\n    return total[n]\n}\n", "    return\
    \ 0\n}\n", "    return 0\n}\n", "    var total int\n    for i := 0; i < n; i++\
    \ {\n        total += counts(n, i)\n    }\n    return total\n}\n", "    counter\
    \ := 0\n    for i := 0; i < n; i++ {\n        if i == 0 {\n            counter\
    \ += 9\n        } else {\n            counter *= 10\n            counter += 9\n\
    \        }\n    }\n    return counter\n}\n", "    var count int = 0\n    var base\
    \ int = int(float64(n) * math.Pow(10, float64(n - 1)))\n    var baseEndsOne int\
    \ = int(math.Pow(10, float64(n - 1)))\n\n    count += (base / 2) - 1\n    count\
    \ += baseEndsOne\n\n    return count\n}\n", "    if n == 1 {\n        return 1\n\
    \    }\n\n    if n == 2 {\n        return 9\n    }\n\n    count := 9\n    m :=\
    \ n - 2\n    for i := 0; i < m; i++ {\n        count *= 10\n    }\n\n    return\
    \ count * 2\n}\n", "    return -1\n}\n", "    table := make([]int, n+1)\n    table[0]\
    \ = 0\n    table[1] = 1\n    for i := 2; i <= n; i++ {\n        if i <= 3 {\n\
    \            table[i] = 1\n        } else {\n            table[i] = table[i-1]\
    \ + table[i-2]\n        }\n    }\n    return table[n]\n}\n", "    var result int\
    \ = 0\n    var number int = 1\n    var tmp int = 0\n    for i := 0; i < n - 1;\
    \ i++ {\n        number *= 10\n    }\n    for i := 0; i < number; i++ {\n    \
    \    tmp = i\n        if tmp % 10 == 1 {\n            result++\n        }\n  \
    \      for {\n            tmp /= 10\n            if tmp % 10 == 1 {\n        \
    \        result++\n                break\n            }\n            if tmp ==\
    \ 0 {\n                break\n            }\n        }\n    }\n    return result\n\
    }\n", "    return 1\n}\n", "    // In base 10, the number of n-digit positive\
    \ integers that start with 1 is\n    // always 10^(n-1), assuming n > 0.\n   \
    \ // But for n-digit positive integers that end with 1, it is a little tricky\n\
    \    // to get the exact number.\n    // First, let's figure out how many numbers\
    \ that end with 1 and have\n    // more than 1 digit.\n    // f(m, n) = f(m-1,\
    \ n) + f(m-1, n-1)\n    // f(1, n) = 1 for n >= 1\n    // f(m, 1) = 1 for m >=\
    \ 1\n    // f(m, n) = 0 for m <= 0 and n <= 0\n    //\n    // f(2, n) = 1\n  \
    \  // f(3, n) = 2\n    // f(4, n) = 3\n    // f(5, n) = 5\n    // f(6, n) = 8\n\
    \    // f(7, n) = 13\n    //\n    // Then we need to think about the case of a\
    \ number that is only 1 digit.\n    // In this case, it is only 1.\n    //\n \
    \   // We can also use recursion to solve this problem.\n\n    var fibonacci_arr\
    \ [20]int\n\n    fibonacci_arr[0] = 1\n    fibonacci_arr[1] = 1\n\n    for i :=\
    \ 2; i < 20; i++ {\n        fibonacci_arr[i] = fibonacci_arr[i-1] + fibonacci_arr[i-2]\n\
    \    }\n\n    return int(math.Pow(10, float64(n-1))) + fibonacci_arr[n-1]\n}\n",
  "    if n < 1 {\n        return 0\n    }\n\n    // Only 1 digit start with or end\
    \ with 1.\n    if n == 1 {\n        return 1\n    }\n\n    // `sum` is the sum\
    \ of (n-1)-digit positive integers that start with 1.\n    sum := 0\n    for i\
    \ := 2; i <= n; i++ {\n        sum += (i - 1) * starts_one_ends(n - i)\n    }\n\
    \n    // `sum` is the sum of n-digit positive integers that end with 1.\n    //\
    \ There are (n-1)-digit positive integers that can be appended to 1.\n    return\
    \ sum + (n - 1)\n}\n", "    if n == 1 {\n        return 1\n    }\n    sum := 0\n\
    \    for i := 1; i <= n; i++ {\n        sum += starts_one_ends(n - i)\n    }\n\
    \    return sum\n}\n", "    if n == 1 {\n        return 1\n    }\n\n    var count\
    \ = 0\n    for i := 1; i <= n / 2; i++ {\n        count += power_of_10(i - 1)\
    \ * 9 * power_of_10(n - i - 1)\n    }\n\n    if n % 2 == 1 {\n        count +=\
    \ power_of_10(n / 2)\n    }\n\n    return count\n}\n", "    if n == 1 {\n    \
    \    return 2\n    }\n\n    return starts_one_ends(n - 1) + 9 * (n - 1) * pow(10,\
    \ n - 2)\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
