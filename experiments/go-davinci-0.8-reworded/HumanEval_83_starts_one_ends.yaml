name: HumanEval_83_starts_one_ends
language: go_test.go
prompt: "package starts_one_ends_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
  )\n\n// Given a positive integer n, return the count of the numbers of n-digit\n\
  // positive integers that start or end with 1.\nfunc starts_one_ends(n int) int\
  \ {\n"
tests: "func TestStarts_One_Ends(t *testing.T) {\n  candidate := starts_one_ends\n\
  \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
  \   tests := []test{\n     { actual: candidate(1), expected: 1 },\n     { actual:\
  \ candidate(2), expected: 18 },\n     { actual: candidate(3), expected: 180 },\n\
  \     { actual: candidate(4), expected: 1800 },\n     { actual: candidate(5), expected:\
  \ 18000 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
  \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
  %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
  \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    if n == 1 {\n        return 1\n    }\n    n_minus_1 := n - 1\n\
    \    // For each possible number that starts or ends with 1 and n digits,\n  \
    \  // the rest must be filled with 0's. There are n_minus_1 ways to do this.\n\
    \    return n_minus_1 * starts_one_ends(n_minus_1)\n}\n", "    if n == 1 {\n \
    \       return 1\n    }\n    if n == 2 {\n        return 20\n    }\n    if n ==\
    \ 3 {\n        return 300\n    }\n    if n == 4 {\n        return 4000\n    }\n\
    \    if n == 5 {\n        return 50000\n    }\n    if n == 6 {\n        return\
    \ 600000\n    }\n    if n == 7 {\n        return 7000000\n    }\n    if n == 8\
    \ {\n        return 80000000\n    }\n    if n == 9 {\n        return 900000000\n\
    \    }\n    return 0\n}\n", "    total := 1\n    for i := 1; i < n; i++ {\n  \
    \      total *= 10\n    }\n    return total * 2 - 1\n}\n", "    if n < 1 {\n \
    \       return 0\n    }\n\n    return 9 * (1 + (n - 1) * 9)\n}\n", "    if n ==\
    \ 1 {\n        return 10\n    }\n\n    // \u5BF9\u4E8E\u957F\u5EA6\u4E3An\u7684\
    \u6570\u5B57\uFF0C\u5206\u6210\u957F\u5EA6\u4E3An-1\u7684\u6570\u5B57+\u6700\u540E\
    \u4E00\u4F4D\u6570\u5B57\uFF0C\u4F8B\u5982123\n    // n=3\u7684\u65F6\u5019\uFF0C\
    \u4EE51\u5F00\u5934\u7684\u53EF\u80FD\u7684\u6570\u5B57\u6709\uFF1A\n    // 1x\uFF0C\
    \ \u5176\u4E2Dx\u8868\u793A\u4EFB\u610F\u6570\u5B57\uFF0C\u7136\u540E\u5269\u4E0B\
    \u7684\u4E24\u4F4D\u4EFB\u610F\u6570\u5B57\u7EC4\u5408\u517111\u4E2A\n    // 1x2x\uFF0C\
    \u8868\u793A\u4E00\u4F4D\u6570\u5B57\u4EFB\u610F\u7EC4\u5408\u7684\u6570\u5B57\
    \uFF0C\u5269\u4E0B\u7684\u4E00\u4F4D\u6570\u5B57\u4EFB\u610F\u7EC4\u5408\u5171\
    10\u4E2A\n    // 1xx3x\uFF0C\u8868\u793A\u4E24\u4F4D\u6570\u5B57\u4EFB\u610F\u7EC4\
    \u5408\u7684\u6570\u5B57\uFF0C\u5269\u4E0B\u7684\u4E00\u4F4D\u6570\u5B57\u4EFB\
    \u610F\u7EC4\u5408\u517110\u4E2A\n    // \u6700\u540E\u52A0\u8D77\u6765\u5F97\u5230\
    10+11+10=31\n\n    // \u540C\u7406\uFF0C\u4EE51\u7ED3\u5C3E\u7684\u6570\u5B57\u6709\
    \uFF1A\n    // x1\uFF0C\u5176\u4E2Dx\u8868\u793A\u4EFB\u610F\u6570\u5B57\uFF0C\
    \u7136\u540E\u5269\u4E0B\u7684\u4E24\u4F4D\u4EFB\u610F\u6570\u5B57\u7EC4\u5408\
    \u517111\u4E2A\n    // x21\uFF0C\u8868\u793A\u4E00\u4F4D\u6570\u5B57\u4EFB\u610F\
    \u7EC4\u5408\u7684\u6570\u5B57\uFF0C\u5269\u4E0B\u7684\u4E00\u4F4D\u6570\u5B57\
    \u4EFB\u610F\u7EC4\u5408\u517110\u4E2A\n    // x3x1\uFF0C\u8868\u793A\u4E24\u4F4D\
    \u6570\u5B57\u4EFB\u610F\u7EC4", "    if n == 1 {\n        return 2\n    }\n \
    \   if n == 2 {\n        return 3\n    }\n    return starts_one_ends(n-1) + starts_one_ends(n-2)\n\
    }\n", "    if n == 1 {\n        return 2\n    }\n\n    dp := make([]int, n + 1)\n\
    \    dp[1] = 2\n    for i := 2; i <= n; i++ {\n        dp[i] = (dp[i - 1] * 10\
    \ - dp[i - 2]) % 1000000007\n    }\n\n    return dp[n]\n}\n", "    if n == 1 {\n\
    \        return 2\n    }\n    // dp[i] means the count of the numbers of i-digit\
    \ positive integers\n    // that start or end with 1.\n    dp := make([]int, n+1)\n\
    \    dp[1] = 2\n    // dp[i] = dp[i-1] + dp[i-2]\n    for i := 2; i <= n; i++\
    \ {\n        dp[i] = dp[i-1] + dp[i-2]\n    }\n    return dp[n]\n}\n", "    if\
    \ n == 1 {\n        return 2\n    }\n    return 9 * starts_one_ends(n - 1) + 2\
    \ * starts_one_ends(n - 2)\n}\n", "    if n == 1 {\n        return 1\n    }\n\n\
    \    // n >= 2\n    count, base := 1, 10\n    for i := 2; i <= n; i++ {\n    \
    \    count += base\n        base *= 10\n    }\n\n    return count\n}\n", "   \
    \ if n == 1 {\n        return 1\n    }\n    if n == 2 {\n        return 10\n \
    \   }\n    dp := make([]int, n+1)\n    dp[1] = 1\n    dp[2] = 10\n    for i :=\
    \ 3; i <= n; i++ {\n        dp[i] = 9 * power(10, i-2) + dp[i-1]\n    }\n    return\
    \ dp[n]\n}\n", "    var start, end, total int\n    for i := 1; i <= n; i++ {\n\
    \        start = 9 * (1 << uint(i - 1))\n        end = 10 - i\n        total +=\
    \ start + end\n    }\n    return total\n}\n", "    var result int\n    if n <\
    \ 1 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n   \
    \ if n == 2 {\n        return 10\n    }\n    result = 9\n    for i := 2; i < n;\
    \ i++ {\n        result *= (9 - i + 2)\n    }\n    return result\n}\n", "    if\
    \ n == 1 {\n        return 2\n    }\n    ends := starts_one_ends(n - 1)\n    starts\
    \ := 1 * 9 * 9 * (n - 2)\n    return ends + starts\n}\n", "    if n == 1 {\n \
    \       return 10\n    }\n\n    if n == 2 {\n        return 55\n    }\n\n    current_digit\
    \ := 10\n    last_digit := 9\n    for i := 3; i <= n; i++ {\n        last_digit,\
    \ current_digit = current_digit, (current_digit * 10) + last_digit\n    }\n\n\
    \    return current_digit + last_digit\n}\n", "    if n == 1 {\n        return\
    \ 1\n    }\n    // count[i] counts for i-digit number that starts or ends with\
    \ 1.\n    count := make([]int, n + 1)\n    count[1] = 1\n    for i := 2; i <=\
    \ n; i++ {\n        count[i] = 9 * count[i - 1] + 10 * count[i - 2]\n    }\n \
    \   return count[n]\n}\n", "    if n < 1 {\n        return 0\n    }\n\n    //\
    \ Count the numbers that end with 1, \n    //   the rest part has n-1 digits,\
    \ \n    //   there are 9 choices for the rest part.\n    ret := 9\n    if n >\
    \ 1 {\n        // Count the numbers that start with 1, \n        //   the rest\
    \ part has n-1 digits, \n        //   there are 10 choices for the rest part (0-9).\n\
    \        for i := 2; i <= n; i++ {\n            ret += 9 * (pow(10, i-1) - pow(9,\
    \ i-1))\n        }\n    }\n\n    return ret\n}\n", "    if n == 1 {\n        return\
    \ 1\n    }\n    // There are 9 digits to choose from and n-1 positions to choose\
    \ between\n    // them.\n    // The last digit can be chosen freely.\n    return\
    \ 9 * (1 << uint(n-1))\n}\n", "    if n == 1 {\n        return 1\n    }\n\n  \
    \  if n == 2 {\n        return 10\n    }\n\n    start, end := 10, 1\n    for i\
    \ := 1; i < n - 1; i++ {\n        end = 9 * end + start\n        start = start\
    \ * 10\n    }\n\n    return start + end\n}\n", "    if n == 1 {\n        return\
    \ 1\n    }\n    sum := 10\n    for i := 2; i <= n; i++ {\n        sum += 9 * pow(10,\
    \ i - 1)\n    }\n    return sum\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
