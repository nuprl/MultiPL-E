name: HumanEval_48_is_palindrome
language: go_test.go
prompt: "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
  \n// Checks if given string is a palindrome\n// >>> is_palindrome(\"\")\n// true\n\
  // >>> is_palindrome(\"aba\")\n// true\n// >>> is_palindrome(\"aaaaa\")\n// true\n\
  // >>> is_palindrome(\"zbcd\")\n// false\nfunc is_palindrome(text string) bool {\n"
tests: "func TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype\
  \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
  \ := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual:\
  \ candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected:\
  \ true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual:\
  \ candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"),\
  \ expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n\
  \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
  \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
  %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
  \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    for i := 0; i < len(text)/2; i++ {\n        if text[i] != text[len(text)-i-1]\
    \ {\n            return false\n        }\n    }\n    return true\n}\n", "    return\
    \ false\n}\n", "    // Returns true if given text is a palindrome\n    if len(text)\
    \ == 0 {\n        return true\n    }\n    left := text[0]\n    right := text[len(text)-1]\n\
    \    if left != right {\n        return false\n    }\n    return is_palindrome(text[1:len(text)-1])\n\
    }\n", "    runes := []rune(text)\n    l := len(runes)\n    for i := 0; i < l/2;\
    \ i++ {\n        if runes[i] != runes[l-i-1] {\n            return false\n   \
    \     }\n    }\n    return true\n}\n", "    for i := 0; i < len(text)/2; i++ {\n\
    \        if text[i] != text[len(text)-i-1] {\n            return false\n     \
    \   }\n    }\n    return true\n}\n", "    for i, j := 0, len(text) - 1; i < j;\
    \ i, j = i + 1, j - 1 {\n        if text[i] != text[j] {\n            return false\n\
    \        }\n    }\n    return true\n}\n", "    var start, end = 0, len(text) -\
    \ 1\n    for start < end {\n        if text[start] != text[end] {\n          \
    \  return false\n        }\n        start++\n        end--\n    }\n    return\
    \ true\n}\n", "    if len(text) == 0 {\n        return true\n    }\n    for i\
    \ := 0; i < len(text) / 2; i++ {\n        if text[i] != text[len(text) - i - 1]\
    \ {\n            return false\n        }\n    }\n    return true\n}\n", "    return\
    \ true\n}\n", "    n := len(text)\n    for i := 0; i < n / 2; i++ {\n        if\
    \ text[i] != text[n - i - 1] {\n            return false\n        }\n    }\n \
    \   return true\n}\n", "    if text == \"\" {\n        return true\n    }\n\n\
    \    size := len(text)\n    for i := 0; i < size / 2; i++ {\n        if text[i]\
    \ != text[size - i - 1] {\n            return false\n        }\n    }\n\n    return\
    \ true\n}\n", "    if len(text) == 0 {\n        return true\n    }\n    if len(text)\
    \ == 1 {\n        return true\n    }\n    if text[0] != text[len(text)-1] {\n\
    \        return false\n    }\n    return is_palindrome(text[1:len(text)-1])\n\
    }\n", "    if len(text) <= 1 {\n        return true\n    }\n    if text[0] !=\
    \ text[len(text)-1] {\n        return false\n    }\n    return is_palindrome(text[1:len(text)-1])\n\
    }\n", "    // return true\n    // start := 0\n    // end := len(text) - 1\n  \
    \  // for end > start {\n    //     if text[start] != text[end] {\n    //    \
    \     return false\n    //     }\n    //     start++\n    //     end--\n    //\
    \ }\n    // return true\n    for index, _ := range text {\n        if text[index]\
    \ != text[len(text) - index - 1] {\n            return false\n        }\n    }\n\
    \    return true\n}\n", "    if len(text) == 0 {\n        return true\n    }\n\
    \n    begin := 0\n    end := len(text) - 1\n\n    for begin < end {\n        if\
    \ text[begin] != text[end] {\n            return false\n        }\n        begin++\n\
    \        end--\n    }\n\n    return true\n}\n", "    length := len(text)\n   \
    \ if length == 0 {\n        return true\n    }\n\n    middle := length / 2\n \
    \   is_odd := length % 2 != 0\n\n    for i := 0; i < middle; i++ {\n        left\
    \ := text[i]\n        right := text[length - 1 - i]\n        if left != right\
    \ {\n            return false\n        }\n    }\n\n    if is_odd {\n        middle_char\
    \ := text[middle]\n        if middle_char != middle_char {\n            return\
    \ false\n        }\n    }\n\n    return true\n}\n", "    len := len(text)\n  \
    \  if len == 0 {\n        return true\n    }\n    mid := len / 2\n    left :=\
    \ text[:mid]\n    right := text[len-mid:]\n    right = reverse(right)\n    return\
    \ left == right\n}\n", "    if len(text) <= 1 {\n        return true\n    }\n\
    \    if text[0] != text[len(text)-1] {\n        return false\n    }\n    return\
    \ is_palindrome(text[1:len(text)-1])\n}\n", "    return false\n}\n", "    return\
    \ true\n}\n", "    return is_palindrome_slice([]rune(text))\n}\n", "    for i\
    \ := 0; i < len(text) / 2; i++ {\n        if text[i] != text[len(text) - i - 1]\
    \ {\n            return false\n        }\n    }\n    return true\n}\n", "    size\
    \ := len(text)\n    for i := 0; i < size/2; i++ {\n        if text[i] != text[size-i-1]\
    \ {\n            return false\n        }\n    }\n    return true\n}\n", "    for\
    \ i := 0; i < len(text) / 2; i++ {\n        if text[i] != text[len(text) - i -\
    \ 1] {\n            return false\n        }\n    }\n    return true\n}\n", " \
    \   for i := 0; i < len(text) / 2; i++ {\n        if text[i] != text[len(text)\
    \ - i - 1] {\n            return false\n        }\n    }\n    return true\n}\n",
  "    var length = len(text)\n    var half_length = length / 2\n    for i := 0; i\
    \ < half_length; i++ {\n        if text[i] != text[length - i - 1] {\n       \
    \     return false\n        }\n    }\n    return true\n}\n", "    length := len(text)\n\
    \    if length <= 1 {\n        return true\n    }\n\n    if text[0] != text[length-1]\
    \ {\n        return false\n    }\n\n    return is_palindrome(text[1:length-1])\n\
    }\n", "    text_len := len(text)\n    if text_len == 0 {\n        return true\n\
    \    }\n    if text_len == 1 {\n        return true\n    }\n    if text_len ==\
    \ 2 {\n        return text[0] == text[1]\n    }\n    if text[0] != text[text_len-1]\
    \ {\n        return false\n    }\n    return is_palindrome(text[1:text_len-1])\n\
    }\n", "    left := 0\n    right := len(text) - 1\n    for left < right {\n   \
    \     if text[left] != text[right] {\n            return false\n        }\n  \
    \      left += 1\n        right -= 1\n    }\n    return true\n}\n", "    if len(text)\
    \ <= 1 {\n        return true\n    }\n\n    if text[0] != text[len(text)-1] {\n\
    \        return false\n    }\n\n    return is_palindrome(text[1:len(text)-1])\n\
    }\n", "    mid := len(text) / 2\n    last := len(text) - 1\n    for i := 0; i\
    \ < mid; i++ {\n        if text[i] != text[last-i] {\n            return false\n\
    \        }\n    }\n    return true\n}\n", "    length := len(text)\n    var end\
    \ int\n    if length % 2 == 0 {\n        end = length / 2\n    } else {\n    \
    \    end = (length - 1) / 2\n    }\n    for i := 0; i < end; i++ {\n        if\
    \ text[i] != text[length - i - 1] {\n            return false\n        }\n   \
    \ }\n    return true\n}\n", "    if len(text) == 0 {\n        return true\n  \
    \  }\n    if len(text) == 1 {\n        return true\n    }\n    if text[0] != text[len(text)-1]\
    \ {\n        return false\n    }\n    return is_palindrome(text[1:len(text)-1])\n\
    }\n", "    chars := []rune(text)\n    i := 0\n    j := len(chars) - 1\n    for\
    \ i < j {\n        if chars[i] != chars[j] {\n            return false\n     \
    \   }\n        i++\n        j--\n    }\n    return true\n}\n", "    length :=\
    \ len(text)\n    if length == 0 {\n        return true\n    }\n    if length ==\
    \ 1 {\n        return true\n    }\n    return text[0] == text[length-1] && is_palindrome(text[1:length-1])\n\
    }\n", "    return true\n}\n", "    l := len(text)\n    if l < 2 {\n        return\
    \ true\n    }\n    m := l / 2\n    for i := 0; i < m; i++ {\n        if text[i]\
    \ != text[l-i-1] {\n            return false\n        }\n    }\n    return true\n\
    }\n", "    if text == \"\" {\n        return true\n    }\n\n    length := len(text)\n\
    \    for i := 0; i < length/2; i++ {\n        if text[i] != text[length-i-1] {\n\
    \            return false\n        }\n    }\n\n    return true\n}\n", "    if\
    \ len(text) == 0 {\n        return true\n    }\n    if len(text) == 1 {\n    \
    \    return true\n    }\n    if len(text) == 2 {\n        return text[0] == text[1]\n\
    \    }\n    if text[0] != text[len(text)-1] {\n        return false\n    }\n \
    \   return is_palindrome(text[1:len(text)-1])\n}\n", "    length := len(text)\n\
    \    if length == 0 {\n        return true\n    }\n\n    for i := 0; i < length/2;\
    \ i++ {\n        if text[i] != text[length-i-1] {\n            return false\n\
    \        }\n    }\n\n    return true\n}\n", "    // TODO: Implement\n    return\
    \ true\n}\n", "    if len(text) == 0 {\n        return true\n    }\n    // Remove\
    \ spaces and make string case insensitive\n    text = to_lower(remove_spaces(text))\n\
    \    // Check if first and last characters are the same.\n    // Proceed to the\
    \ next step only if they are the same\n    if text[0] == text[len(text)-1] {\n\
    \        // If we have only two characters left, it's a palindrome\n        if\
    \ len(text) == 2 {\n            return true\n        }\n        // Now we need\
    \ to check the rest of the string\n        return is_palindrome(text[1:len(text)-1])\n\
    \    }\n    return false\n}\n", "    if len(text) <= 1 {\n        return true\n\
    \    }\n\n    if text[0] != text[len(text)-1] {\n        return false\n    }\n\
    \n    return is_palindrome(text[1:len(text)-1])\n}\n", "    if len(text) == 0\
    \ {\n        return true\n    }\n    if len(text) == 1 {\n        return true\n\
    \    }\n    if text[0] != text[len(text)-1] {\n        return false\n    }\n \
    \   return is_palindrome(text[1:len(text)-1])\n}\n", "    // TODO: Implement this\
    \ function\n    return false\n}\n", "    if text == \"\" {\n        return true\n\
    \    }\n\n    for i := 0; i < len(text) / 2; i++ {\n        if text[i] != text[len(text)\
    \ - i - 1] {\n            return false\n        }\n    }\n\n    return true\n\
    }\n", "    var lo int = 0\n    var hi int = len(text) - 1\n    var r int = hi\
    \ / 2\n    for i := 0; i <= r; i++ {\n        if text[lo] != text[hi] {\n    \
    \        return false\n        }\n        lo++\n        hi--\n    }\n    return\
    \ true\n}\n", "    length := len(text)\n    if length == 0 {\n        return true\n\
    \    }\n    mid := length / 2\n    for i := 0; i < mid; i++ {\n        if text[i]\
    \ != text[length - i - 1] {\n            return false\n        }\n    }\n    return\
    \ true\n}\n", "    for i := 0; i < len(text) / 2; i++ {\n        if text[i] !=\
    \ text[len(text) - i - 1] {\n            return false\n        }\n    }\n    return\
    \ true\n}\n", "    if text == \"\" {\n        return true\n    }\n    // compare\
    \ character at the start and at the end\n    if text[0] == text[len(text)-1] {\n\
    \        // call recursively without first and last character\n        return\
    \ is_palindrome(text[1:len(text)-1])\n    }\n    return false\n}\n", "    var\
    \ length = len(text)\n    if length == 0 {\n        return true\n    }\n    var\
    \ i = 0\n    var j = length - 1\n    for i < j {\n        if text[i] != text[j]\
    \ {\n            return false\n        }\n        i++\n        j--\n    }\n  \
    \  return true\n}\n", "    for idx, ch := range text {\n        if ch != []rune(text)[len(text)\
    \ - idx - 1] {\n            return false\n        }\n    }\n    return true\n\
    }\n", "    for i := 0; i < len(text) / 2; i++ {\n        if text[i] != text[len(text)\
    \ - i - 1] {\n            return false\n        }\n    }\n    return true\n}\n",
  "    for i := 0; i < len(text) / 2; i++ {\n        if text[i] != text[len(text)\
    \ - i - 1] {\n            return false\n        }\n    }\n    return true\n}\n",
  "    for i := 0; i < len(text) / 2; i++ {\n        if text[i] != text[len(text)\
    \ - i - 1] {\n            return false\n        }\n    }\n    return true\n}\n",
  "    l := len(text)\n    for i := 0; i < l / 2; i++ {\n        if text[i] != text[l\
    \ - i - 1] {\n            return false\n        }\n    }\n    return true\n}\n",
  "    for i := 0; i < len(text) / 2; i++ {\n        if text[i] != text[len(text)\
    \ - i - 1] {\n            return false\n        }\n    }\n    return true\n}\n",
  "    i := 0\n    length := len(text) - 1\n    for ; i < len(text); i++ {\n     \
    \   if text[i] != text[length - i] {\n            return false\n        }\n  \
    \  }\n    return true\n}\n\n//", "    n := len(text)\n    for i := 0; i < n/2;\
    \ i++ {\n        if text[i] != text[n-i-1] {\n            return false\n     \
    \   }\n    }\n    return true\n}\n", "    // TODO: write code here\n    return\
    \ true\n}\n", "\trunes := []rune(text)\n\tl := len(runes)\n\tfor i := 0; i < l/2;\
    \ i++ {\n\t\tif runes[i] != runes[l-i-1] {\n\t\t\treturn false\n\t\t}\n\t}\n\t\
    return true\n}\n", "    if text == \"\" {\n        return true\n    }\n    i :=\
    \ 0\n    j := len(text) - 1\n    for i < j {\n        if text[i] != text[j] {\n\
    \            return false\n        }\n        i++\n        j--\n    }\n    return\
    \ true\n}\n", "    word_len := len(text)\n    if word_len < 2 {\n        return\
    \ true\n    }\n    last_index := word_len - 1\n    for index := 0; index < word_len\
    \ / 2; index++ {\n        if text[index] != text[last_index - index] {\n     \
    \       return false\n        }\n    }\n    return true\n}\n", "    if len(text)\
    \ <= 1 {\n        return true\n    }\n    return text[0] == text[len(text)-1]\
    \ && is_palindrome(text[1:len(text)-1])\n}\n", "    for i, j := 0, len(text) -\
    \ 1; i < j; i, j = i + 1, j - 1 {\n        if text[i] != text[j] {\n         \
    \   return false\n        }\n    }\n    return true\n}\n", "    text = normalize(text)\n\
    \    if len(text) < 2 {\n        return true\n    }\n    if text[0] != text[len(text)-1]\
    \ {\n        return false\n    }\n    return is_palindrome(text[1:len(text)-1])\n\
    }\n", "    var i int\n    var j int\n    var c int\n\n    c = len(text)\n    i\
    \ = 0\n    j = c - 1\n\n    for i < j {\n        if text[i] != text[j] {\n   \
    \         return false\n        }\n        i += 1\n        j -= 1\n    }\n\n \
    \   return true\n}\n", "    if len(text) == 0 {\n        return true\n    }\n\n\
    \    head := 0\n    tail := len(text) - 1\n\n    for head < tail {\n        if\
    \ text[head] != text[tail] {\n            return false\n        }\n        head++\n\
    \        tail--\n    }\n\n    return true\n}\n", "    length := len(text)\n  \
    \  for i := 0; i < length/2; i++ {\n        if text[i] != text[length-i-1] {\n\
    \            return false\n        }\n    }\n    return true\n}\n", "    t :=\
    \ []rune(text)\n    for i := 0; i < len(t) / 2; i++ {\n        if t[i] != t[len(t)\
    \ - i - 1] {\n            return false\n        }\n    }\n    return true\n}\n",
  "    var end int = len(text) - 1\n    for i := 0; i < len(text) / 2; i++ {\n   \
    \     if text[i] != text[end] {\n            return false\n        }\n       \
    \ end--\n    }\n    return true\n}\n", "    if text == \"\" {\n        return\
    \ true\n    }\n    rune_text := []rune(text)\n    if rune_text[0] != rune_text[len(rune_text)-1]\
    \ {\n        return false\n    }\n    return is_palindrome(string(rune_text[1:len(rune_text)-1]))\n\
    }\n", "    if len(text) <= 1 {\n        return true\n    }\n    if text[0] !=\
    \ text[len(text)-1] {\n        return false\n    }\n    return is_palindrome(text[1:len(text)-1])\n\
    }\n", "    return text == reverse(text)\n}\n", "    if text == \"\" {\n      \
    \  return true\n    }\n\n    var odd_count int\n    var letter_counts map[rune]int\n\
    \    letter_counts = make(map[rune]int)\n\n    // Count each letter in text\n\
    \    for _, letter := range text {\n        if letter_counts[letter] != 0 {\n\
    \            letter_counts[letter]++\n        } else {\n            letter_counts[letter]\
    \ = 1\n        }\n    }\n\n    // Check if there is an odd amount of a letter\n\
    \    for _, count := range letter_counts {\n        if count % 2 != 0 {\n    \
    \        odd_count++\n        }\n    }\n\n    // A palindrome must have an even\
    \ amount of letters, unless the\n    // letter is the middle letter of the palindrome\
    \ in which case\n    // there is one odd letter\n    if odd_count == 1 {\n   \
    \     return true\n    } else if odd_count == 0 {\n        return true\n    }\
    \ else {\n        return false\n    }\n}\n", "    if len(text) == 0 {\n      \
    \  return true\n    }\n    if len(text) == 1 {\n        return true\n    }\n \
    \   if len(text) == 2 {\n        return text[0] == text[1]\n    }\n    return\
    \ text[0] == text[len(text)-1] && is_palindrome(text[1:len(text)-1])\n}\n", " \
    \   if len(text) <= 1 {\n        return true\n    }\n    if text[0] != text[len(text)-1]\
    \ {\n        return false\n    }\n    return is_palindrome(text[1:len(text)-1])\n\
    }\n", "    for i := 0; i < len(text)/2; i++ {\n        if text[i] != text[len(text)-i-1]\
    \ {\n            return false\n        }\n    }\n    return true\n}\n", "    var\
    \ ch_arr []rune\n    for _, ch := range text {\n        ch_arr = append(ch_arr,\
    \ ch)\n    }\n    for i, ch := range ch_arr {\n        if ch != ch_arr[len(ch_arr)\
    \ - i - 1] {\n            return false\n        }\n    }\n    return true\n}\n",
  "    if len(text) == 0 {\n        return true\n    }\n    for i := 0; i < len(text)\
    \ / 2; i++ {\n        if text[i] != text[len(text) - i - 1] {\n            return\
    \ false\n        }\n    }\n    return true\n}\n", "    if len(text) == 0 {\n \
    \       return true\n    }\n\n    if len(text) == 1 {\n        return true\n \
    \   }\n\n    if text[0] != text[len(text)-1] {\n        return false\n    }\n\n\
    \    return is_palindrome(text[1:len(text)-1])\n}\n", "    l := len(text)\n  \
    \  // quick exit\n    if l == 0 {\n        return true\n    }\n\n    // even length\n\
    \    if l % 2 == 0 {\n        half1 := text[:l/2]\n        half2 := text[l/2:]\n\
    \        rev2 := reverse(half2)\n        if half1 == rev2 {\n            return\
    \ true\n        }\n    } else {\n        half1 := text[:l/2]\n        half2 :=\
    \ text[l/2+1:]\n        rev2 := reverse(half2)\n        if half1 == rev2 {\n \
    \           return true\n        }\n    }\n    return false\n}\n", "    size :=\
    \ len(text)\n    var c1, c2 string\n    for i := 0; i < size / 2; i++ {\n    \
    \    c1 = string(text[i])\n        c2 = string(text[size - 1 - i])\n        if\
    \ c1 != c2 {\n            return false\n        }\n    }\n    return true\n}\n",
  "    length := len(text)\n    if length == 0 {\n        return true\n    }\n\n \
    \   middle := length / 2\n    is_palindrome := true\n    for i := 0; i < middle;\
    \ i++ {\n        if text[i] != text[length - i - 1] {\n            is_palindrome\
    \ = false\n            break\n        }\n    }\n\n    return is_palindrome\n}\n",
  "    if text == \"\" {\n        return true\n    }\n\n    var res bool = true\n\
    \    var len_h int = len(text) / 2\n    for i := 0; i < len_h; i++ {\n       \
    \ if text[i] != text[len(text) - i - 1] {\n            res = false\n         \
    \   break\n        }\n    }\n    return res\n}\n", "    l := len(text)\n    if\
    \ l == 0 {\n        return true\n    }\n    if l == 1 {\n        return true\n\
    \    }\n    if l == 2 {\n        return text[0] == text[1]\n    }\n    return\
    \ text[0] == text[l-1] && is_palindrome(text[1:l-1])\n}\n", "    for i := 0; i\
    \ < len(text)/2; i++ {\n        if text[i] != text[len(text)-i-1] {\n        \
    \    return false\n        }\n    }\n    return true\n}\n", "    if len(text)\
    \ == 0 {\n        return true\n    }\n    if len(text) == 1 {\n        return\
    \ true\n    }\n    if text[0] != text[len(text)-1] {\n        return false\n \
    \   }\n    return is_palindrome(text[1:len(text)-1])\n}\n", "    if len(text)\
    \ == 0 {\n        return true\n    }\n\n    // compare the first and last letter\n\
    \    i := 0\n    j := len(text) - 1\n    for i < j {\n        if text[i] != text[j]\
    \ {\n            return false\n        }\n        i++\n        j--\n    }\n  \
    \  return true\n}\n", "    n := len(text)\n    if n == 0 {\n        return true\n\
    \    }\n    // Iterate over given text starting with the two end points and compare\n\
    \    // each character, until it reaches the center\n    for i := 0; i < n / 2;\
    \ i++ {\n        if text[i] != text[n - i - 1] {\n            return false\n \
    \       }\n    }\n    return true\n}\n", "    return text == reverse(text)\n}\n",
  "    // get the string length\n    str_len := len(text)\n    // return true if 0\
    \ or 1 character\n    if str_len <= 1 {\n        return true\n    }\n\n    //\
    \ get the first and last characters\n    first_char := text[0]\n    last_char\
    \ := text[str_len-1]\n\n    // check if the first and last characters are the\
    \ same\n    if first_char != last_char {\n        return false\n    }\n\n    //\
    \ recursively check if the text without the first and last characters\n    //\
    \ is a palindrome\n    return is_palindrome(text[1:str_len-1])\n}\n", "    if\
    \ len(text) == 0 {\n        return true\n    }\n\n    if len(text) == 1 {\n  \
    \      return true\n    }\n\n    if text[0] != text[len(text)-1] {\n        return\
    \ false\n    }\n\n    return is_palindrome(text[1:len(text)-1])\n}\n", "    if\
    \ text == \"\" {\n        return true\n    }\n\n    // If we have odd number of\
    \ characters in the string\n    // then the middle character can be ignored\n\
    \    if len(text) % 2 == 1 {\n        text = text[1:]\n    }\n\n    // Split the\
    \ string in two halves\n    mid := len(text) / 2\n    s1 := text[:mid]\n    s2\
    \ := text[mid:]\n\n    // Check if the two halves are equal\n    for i := 0; i\
    \ < mid; i++ {\n        if s1[i] != s2[mid - i - 1] {\n            return false\n\
    \        }\n    }\n\n    return true\n}\n", "    // Length of string\n    len\
    \ := len(text)\n    if len <= 1 {\n        return true\n    }\n    if len == 2\
    \ {\n        return text[0] == text[1]\n    }\n    return text[0] == text[len-1]\
    \ && is_palindrome(text[1:len-1])\n}\n", "    length := len(text)\n    var i int\
    \ = 0\n    for i = 0; i < length/2; i++ {\n        if text[i] != text[length-i-1]\
    \ {\n            return false\n        }\n    }\n    return true\n}\n", "    for\
    \ i := 0; i < len(text)/2; i++ {\n        // fmt.Println(i, len(text)-i-1)\n \
    \       if text[i] != text[len(text)-i-1] {\n            return false\n      \
    \  }\n    }\n    return true\n}\n", "    return false\n}\n", "    if text == \"\
    \" {\n        return true\n    }\n    // letters := strings.Split(text, \"\")\n\
    \    letters := []rune(text)\n    length := len(letters)\n    for i := 0; i <\
    \ length/2; i++ {\n        if letters[i] != letters[length-i-1] {\n          \
    \  return false\n        }\n    }\n    return true\n}\n", "    for i := 0; i <\
    \ len(text) / 2; i++ {\n        if text[i] != text[len(text) - i - 1] {\n    \
    \        return false\n        }\n    }\n    return true\n}\n", "    if len(text)\
    \ == 0 {\n        return true\n    }\n    if len(text) == 1 {\n        return\
    \ true\n    }\n    if text[0] != text[len(text)-1] {\n        return false\n \
    \   }\n    return is_palindrome(text[1:len(text)-1])\n}\n", "    return text ==\
    \ reverse(text)\n}\n", "\tl := len(text)\n\tfor i := 0; i < l/2; i++ {\n\t\tif\
    \ text[i] != text[l-i-1] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n",
  "    length := len(text)\n    middle := length / 2\n    for i := 0; i < middle;\
    \ i++ {\n        if text[i] != text[length - i - 1] {\n            return false\n\
    \        }\n    }\n    return true\n}\n", "    l := len(text)\n    for i := 0;\
    \ i < l / 2; i++ {\n        if text[i] != text[l - i - 1] {\n            return\
    \ false\n        }\n    }\n    return true\n}\n", "    if len(text) <= 1 {\n \
    \       return true\n    }\n\n    if text[0] != text[len(text)-1] {\n        return\
    \ false\n    }\n\n    return is_palindrome(text[1:len(text)-1])\n}\n", "    l\
    \ := len(text)\n    for i := 0; i < l / 2; i++ {\n        if text[i] != text[l\
    \ - i - 1] {\n            return false\n        }\n    }\n    return true\n}\n",
  "    if text == \"\" {\n        return true\n    }\n    if len(text) == 1 {\n  \
    \      return true\n    }\n    if text[0] == text[len(text)-1] {\n        return\
    \ is_palindrome(text[1:len(text)-1])\n    }\n    return false\n}\n", "    txt_length\
    \ := len(text)\n    if txt_length == 0 {\n        return true\n    }\n\n    for\
    \ i := 0; i < txt_length/2; i++ {\n        if text[i] != text[txt_length-i-1]\
    \ {\n            return false\n        }\n    }\n\n    return true\n}\n", "  \
    \  if len(text) == 0 {\n        return true\n    }\n    if len(text) == 1 {\n\
    \        return true\n    }\n    last := len(text) - 1\n    for i := 0; i < len(text)\
    \ / 2; i++ {\n        if text[i] != text[last - i] {\n            return false\n\
    \        }\n    }\n    return true\n}\n", "    return false\n}\n", "    for i,\
    \ j := 0, len(text) - 1; i < j; i, j = i + 1, j - 1 {\n        if text[i] != text[j]\
    \ {\n            return false\n        }\n    }\n    return true\n}\n", "    for\
    \ i := 0; i < len(text) / 2; i++ {\n        if text[i] != text[len(text) - i -\
    \ 1] {\n            return false\n        }\n    }\n    return true\n}\n", " \
    \   for i := 0; i < len(text) / 2; i++ {\n        if text[i] != text[len(text)\
    \ - i - 1] {\n            return false\n        }\n    }\n    return true\n}\n",
  "    if len(text) <= 1 {\n        return true\n    }\n    if text[0] != text[len(text)-1]\
    \ {\n        return false\n    }\n    return is_palindrome(text[1:len(text)-1])\n\
    }\n", "    // Fill me in!\n    return true\n}\n", "    str_len := len(text)\n\
    \    for i := 0; i < str_len / 2; i++ {\n        if text[i] != text[str_len -\
    \ i - 1] {\n            return false\n        }\n    }\n    return true\n}\n",
  "    // your code goes here\n    length := len(text)\n    if length == 0 {\n   \
    \     return true\n    }\n    for i:=0; i<length/2; i++ {\n        if text[i]\
    \ != text[length-i-1] {\n            return false\n        }\n    }\n    return\
    \ true\n}\n", "    n := len(text)\n    i := 0\n    for i < n/2 {\n        if text[i]\
    \ != text[n-i-1] {\n            return false\n        }\n        i += 1\n    }\n\
    \    return true\n}\n", "    if len(text) <= 1 {\n        return true\n    }\n\
    \    if text[0] != text[len(text)-1] {\n        return false\n    }\n    return\
    \ is_palindrome(text[1:len(text)-1])\n}\n", "    if len(text) <= 1 {\n       \
    \ return true\n    }\n    return text[0] == text[len(text)-1] && is_palindrome(text[1:len(text)-1])\n\
    }\n", "    if len(text) <= 1 {\n        return true\n    }\n    if text[0] !=\
    \ text[len(text)-1] {\n        return false\n    }\n    return is_palindrome(text[1:len(text)-1])\n\
    }\n", "    if len(text) == 0 {\n        return true\n    }\n    n := len(text)\n\
    \    for i := 0; i < n/2; i++ {\n        if text[i] != text[n-i-1] {\n       \
    \     return false\n        }\n    }\n    return true\n}\n", "    var l = len(text)\n\
    \    var mid int = l / 2\n    var end int = l - 1\n    for i := 0; i < mid; i++\
    \ {\n        if text[i] != text[end-i] {\n            return false\n        }\n\
    \    }\n    return true\n}\n", "    if len(text) == 0 {\n        return true\n\
    \    }\n\n    left, right := 0, len(text) - 1\n    for {\n        if left == right\
    \ {\n            return true\n        }\n        if text[left] != text[right]\
    \ {\n            return false\n        }\n        left += 1\n        right -=\
    \ 1\n    }\n}\n", "    var length = len(text)\n    var i = 0\n    var j = length\
    \ - 1\n    for i <= j {\n        if text[i] != text[j] {\n            return false\n\
    \        }\n        i++\n        j--\n    }\n    return true\n}\n", "    for i,\
    \ j := 0, len(text) - 1; i < j; i, j = i + 1, j - 1 {\n        if text[i] != text[j]\
    \ {\n            return false\n        }\n    }\n    return true\n}\n", "    chars\
    \ := []rune(text)\n    if len(chars) == 0 {\n        return true\n    }\n\n  \
    \  n := len(chars)\n    for i := 0; i < n / 2; i++ {\n        if chars[i] != chars[n\
    \ - i - 1] {\n            return false\n        }\n    }\n\n    return true\n\
    }\n", "    length := len(text)\n    for i, _ := range text {\n        if text[i]\
    \ != text[length - 1 - i] {\n            return false\n        }\n    }\n    return\
    \ true\n}\n", "    if text == \"\" {\n        return true\n    }\n    length :=\
    \ len(text)\n    return text[0] == text[length-1] && is_palindrome(text[1:length-1])\n\
    }\n", "\treturn false\n}\n", "    n := len(text)\n    for i := 0; i < n/2; i++\
    \ {\n        if text[i] != text[n-i-1] {\n            return false\n        }\n\
    \    }\n    return true\n}\n", "    if len(text) <= 1 {\n        return true\n\
    \    }\n    if text[0] != text[len(text)-1] {\n        return false\n    }\n \
    \   return is_palindrome(text[1:len(text)-1])\n}\n", "    if len(text) == 0 {\n\
    \        return true\n    }\n    for i := 0; i < len(text)/2; i++ {\n        if\
    \ text[i] != text[len(text)-i-1] {\n            return false\n        }\n    }\n\
    \    return true\n}\n", "    l := len(text)\n    for i := 0; i < l / 2; i++ {\n\
    \        if text[i] != text[l - i - 1] {\n            return false\n        }\n\
    \    }\n    return true\n}\n", "    if len(text) <= 1 {\n        return true\n\
    \    }\n\n    first := text[0]\n    last := text[len(text)-1]\n\n    if first\
    \ != last {\n        return false\n    }\n\n    return is_palindrome(text[1:len(text)-1])\n\
    }\n", "    for i, j := 0, len(text) - 1; i < j; i, j = i + 1, j - 1 {\n      \
    \  if text[i] != text[j] {\n            return false\n        }\n    }\n    return\
    \ true\n}\n", "    if text == \"\" {\n        return true\n    }\n    var text_length\
    \ = len(text)\n    var middle = text_length / 2\n    for i := 0; i < middle; i++\
    \ {\n        if text[i] != text[text_length - 1 - i] {\n            return false\n\
    \        }\n    }\n    return true\n}\n", "    if len(text) <= 1 {\n        return\
    \ true\n    }\n\n    if text[0] != text[len(text)-1] {\n        return false\n\
    \    }\n\n    return is_palindrome(text[1:len(text)-1])\n}\n", "    if len(text)\
    \ == 0 {\n        return true\n    }\n    if len(text) == 1 {\n        return\
    \ true\n    }\n    if len(text) == 2 {\n        return text[0] == text[1]\n  \
    \  }\n    i, j := 0, len(text) - 1\n    for i < j {\n        if text[i] != text[j]\
    \ {\n            return false\n        }\n        i++\n        j--\n    }\n  \
    \  return true\n}\n", "    if len(text) <= 1 {\n        return true\n    }\n \
    \   if text[0] != text[len(text)-1] {\n        return false\n    }\n    return\
    \ is_palindrome(text[1:len(text)-1])\n}\n", "    mid := len(text) / 2\n    last\
    \ := len(text) - 1\n    for i := 0; i < mid; i++ {\n        if text[i] != text[last-i]\
    \ {\n            return false\n        }\n    }\n    return true\n}\n", "    length\
    \ := len(text)\n    if length == 0 {\n        return true\n    }\n    for i :=\
    \ 0; i < length / 2; i++ {\n        if text[i] != text[length - i - 1] {\n   \
    \         return false\n        }\n    }\n    return true\n}\n", "    var a, b\
    \ = 0, len(text) - 1\n    for a < b {\n        if text[a] != text[b] {\n     \
    \       return false\n        }\n        a++\n        b--\n    }\n    return true\n\
    }\n", "    switch {\n    case len(text) == 0:\n        return true\n    case len(text)\
    \ == 1:\n        return true\n    case text[0] == text[len(text)-1]:\n       \
    \ return is_palindrome(text[1:len(text)-1])\n    default:\n        return false\n\
    \    }\n}\n", "    var length = len(text)\n    var middle = length / 2\n    var\
    \ left = 0\n    var right = length - 1\n\n    if length <= 1 {\n        return\
    \ true\n    }\n    if text[left] != text[right] {\n        return false\n    }\n\
    \    return is_palindrome(text[left+1:right])\n}\n", "    // I count in reverse,\
    \ if the first element is larger than the last,\n    // I return false right away.\
    \ I'm sure this can be done with a single\n    // loop but I'm having a hard time\
    \ wrapping my head around it\n    //\n    // The last condition is just a quick\
    \ fix for odd-length strings.\n    // Even though the length is odd, we still\
    \ have to check if the middle\n    // element is equal to itself, so we can just\
    \ return true if they\n    // equal the same and the length is odd.\n    if text[0]\
    \ != text[len(text)-1] {\n        return false\n    }\n    if len(text) <= 2 {\n\
    \        return true\n    }\n    return is_palindrome(text[1:len(text)-1])\n}\n",
  "    length := len(text)\n    if length <= 1 {\n        return true\n    }\n\n \
    \   return text[0] == text[length-1] && is_palindrome(text[1:length-1])\n}\n",
  "    text_len := len(text)\n    is_odd := text_len % 2 == 1\n    half_length :=\
    \ int(text_len / 2)\n    for i := 0; i < half_length; i++ {\n        r_i := text_len\
    \ - i - 1\n        if text[i] != text[r_i] {\n            return false\n     \
    \   }\n    }\n    return true\n}\n", "    if len(text) == 0 {\n        return\
    \ true\n    }\n    for i := 0; i < len(text) / 2; i++ {\n        if text[i] !=\
    \ text[len(text) - i - 1] {\n            return false\n        }\n    }\n    return\
    \ true\n}\n", "    // TODO: implement the function\n    return false\n}\n", " \
    \   for i := 0; i < len(text)/2; i++ {\n        if text[i] != text[len(text)-i-1]\
    \ {\n            return false\n        }\n    }\n    return true\n}\n", "    for\
    \ i := 0; i < len(text) / 2; i++ {\n        if text[i] != text[len(text) - i -\
    \ 1] {\n            return false\n        }\n    }\n    return true\n}\n", " \
    \   // TODO\n    return false\n}\n", "    if len(text) <= 1 {\n        return\
    \ true\n    }\n    if text[0] != text[len(text)-1] {\n        return false\n \
    \   }\n    return is_palindrome(text[1:len(text)-1])\n}\n", "    palindrome :=\
    \ true\n    l := len(text)\n    for i := 0; i < l / 2; i++ {\n        if text[i]\
    \ != text[l - i - 1] {\n            palindrome = false\n            break\n  \
    \      }\n    }\n    return palindrome\n}\n", "    length := len(text)\n    if\
    \ length == 0 {\n        return true\n    }\n    if length == 1 {\n        return\
    \ true\n    }\n    if length == 2 {\n        return text[0] == text[1]\n    }\n\
    \    if length == 3 {\n        return text[0] == text[2]\n    }\n    return text[0]\
    \ == text[length-1] && is_palindrome(text[1:length-1])\n}\n", "    var l = len(text)\n\
    \    if l == 0 {\n        return true\n    }\n    var s = 0\n    var e = l - 1\n\
    \    for s < e {\n        if text[s] != text[e] {\n            return false\n\
    \        }\n        s++\n        e--\n    }\n    return true\n}\n", "    if len(text)\
    \ <= 1 {\n        return true\n    }\n    return text[0] == text[len(text)-1]\
    \ && is_palindrome(text[1:len(text)-1])\n}\n", "    for i := 0; i < len(text)\
    \ / 2; i++ {\n        if text[i] != text[len(text) - i - 1] {\n            return\
    \ false\n        }\n    }\n    return true\n}\n", "    if len(text) <= 1 {\n \
    \       return true\n    }\n    if text[0] != text[len(text)-1] {\n        return\
    \ false\n    }\n    return is_palindrome(text[1:len(text)-1])\n}\n", "    for\
    \ i := 0; i < len(text) / 2; i++ {\n        j := len(text) - i - 1\n        if\
    \ text[i] != text[j] {\n            return false\n        }\n    }\n    return\
    \ true\n}\n", "    if text == \"\" {\n        return true\n    }\n    var reverse\
    \ string\n    for _, c := range text {\n        reverse = string(c) + reverse\n\
    \    }\n    return text == reverse\n}\n", "    // TODO: implement this function\n\
    \    return false\n}\n", "    size := len(text)\n    if size == 0 {\n        return\
    \ true\n    }\n\n    for i := 0; i < size / 2; i++ {\n        if text[i] != text[size\
    \ - i - 1] {\n            return false\n        }\n    }\n\n    return true\n\
    }\n", "    for i := 0; i < len(text)/2; i++ {\n        if text[i] != text[len(text)-i-1]\
    \ {\n            return false\n        }\n    }\n    return true\n}\n", "    length\
    \ := len(text)\n    if length <= 1 {\n        return true\n    }\n    for i :=\
    \ 0; i < length / 2; i++ {\n        j := length - i - 1\n        if text[i] !=\
    \ text[j] {\n            return false\n        }\n    }\n    return true\n}\n",
  "    text_len := len(text)\n    for i := 0; i < text_len / 2; i++ {\n        if\
    \ text[i] != text[text_len - i - 1] {\n            return false\n        }\n \
    \   }\n    return true\n}\n", "    len := len(text)\n    for i := 0; i < len/2;\
    \ i++ {\n        if text[i] != text[len-i-1] {\n            return false\n   \
    \     }\n    }\n    return true\n}\n", "    length := len(text)\n    if length\
    \ == 0 {\n        return true\n    }\n    for i := 0; i < length/2; i++ {\n  \
    \      if text[i] != text[length-i-1] {\n            return false\n        }\n\
    \    }\n    return true\n}\n", "    if text == \"\" {\n        return true\n \
    \   }\n    for i := 0; i < len(text) / 2; i++ {\n        if text[i] != text[len(text)\
    \ - i - 1] {\n            return false\n        }\n    }\n    return true\n}\n",
  "\tvar left, right int\n\tright = len(text) - 1\n\tfor left < right {\n\t\tif text[left]\
    \ != text[right] {\n\t\t\treturn false\n\t\t}\n\t\tleft++\n\t\tright--\n\t}\n\t\
    return true\n}\n", "    length := len(text)\n    if length == 0 {\n        return\
    \ true\n    }\n    if length == 1 {\n        return true\n    }\n    if length\
    \ == 2 {\n        return text[0] == text[1]\n    }\n    return text[0] == text[length-1]\
    \ && is_palindrome(text[1:length-1])\n}\n", "    return text == reverse(text)\n\
    }\n", "    n := len(text)\n    if n == 0 {\n        return true\n    }\n    if\
    \ n == 1 {\n        return true\n    }\n    for i := 0; i < n/2; i++ {\n     \
    \   j := n - i - 1\n        if text[i] != text[j] {\n            return false\n\
    \        }\n    }\n    return true\n}\n", "    var len = len(text)\n    if len\
    \ <= 1 {\n        return true\n    }\n\n    if text[0] != text[len-1] {\n    \
    \    return false\n    }\n\n    return is_palindrome(text[1:len-1])\n}\n", " \
    \   for index, runeValue := range text {\n        if text[index] != text[len(text)\
    \ - index - 1] {\n            return false\n        }\n    }\n    return true\n\
    }\n", "    if text == \"\" {\n        return true\n    }\n    for i := 0; i <\
    \ len(text) / 2; i++ {\n        if text[i] != text[len(text) - i - 1] {\n    \
    \        return false\n        }\n    }\n    return true\n}\n", "    b := []byte(text)\n\
    \    for i := 0; i < len(b)/2; i++ {\n        if b[i] != b[len(b)-i-1] {\n   \
    \         return false\n        }\n    }\n    return true\n}\n", "    mid := len(text)\
    \ / 2\n    last := len(text) - 1\n    for i := 0; i < mid; i++ {\n        if text[i]\
    \ != text[last-i] {\n            return false\n        }\n    }\n    return true\n\
    }\n", "    len := len(text)\n    if len <= 1 {\n        return true\n    }\n \
    \   if len % 2 == 0 {\n        return text[:len/2] == text[len/2:]\n    }\n  \
    \  return text[:len/2] == text[len/2+1:]\n}\n", "    if text == \"\" {\n     \
    \   return true\n    }\n\n    for i := 0; i < len(text)/2; i++ {\n        if text[i]\
    \ != text[len(text)-i-1] {\n            return false\n        }\n    }\n\n   \
    \ return true\n}\n", "    length := len(text)\n    for i := 0; i < length / 2;\
    \ i++ {\n        if text[i] != text[length - i - 1] {\n            return false\n\
    \        }\n    }\n    return true\n}\n", "    end := len(text) - 1\n    for i\
    \ := 0; i < len(text) / 2; i++ {\n        if text[i] != text[end] {\n        \
    \    return false\n        }\n        end--\n    }\n    return true\n}\n", " \
    \   mid := len(text) / 2\n    last := len(text) - 1\n    for i := 0; i < mid;\
    \ i++ {\n        if text[i] != text[last-i] {\n            return false\n    \
    \    }\n    }\n    return true\n}\n", "    len := len(text)\n    for i := 0; i\
    \ < len/2; i++ {\n        if text[i] != text[len-i-1] {\n            return false\n\
    \        }\n    }\n    return true\n}\n", "    // code here\n    if len(text)\
    \ == 0 {\n        return true\n    }\n\n    for i := 0; i < len(text) / 2; i++\
    \ {\n        if text[i] != text[len(text) - i - 1] {\n            return false\n\
    \        }\n    }\n\n    return true\n}\n", "    text_bytes := []byte(text)\n\
    \    text_len := len(text_bytes)\n    for i := 0; i < text_len / 2; i++ {\n  \
    \      if text_bytes[i] != text_bytes[text_len - i - 1] {\n            return\
    \ false\n        }\n    }\n    return true\n}\n", "    b := []byte(text)\n   \
    \ for i := 0; i < len(b) / 2; i++ {\n        if b[i] != b[len(b) - i - 1] {\n\
    \            return false\n        }\n    }\n    return true\n}\n", "    var strLen\
    \ = len(text)\n    var lastIndex = strLen - 1\n    var i = 0\n    var j = lastIndex\n\
    \n    for i < j {\n        if text[i] != text[j] {\n            return false\n\
    \        }\n        i += 1\n        j -= 1\n    }\n\n    return true\n}\n", " \
    \   if text == \"\" {\n        return true\n    }\n    if len(text) == 1 {\n \
    \       return true\n    }\n    if text[0] == text[len(text)-1] {\n        return\
    \ is_palindrome(text[1:len(text)-1])\n    }\n    return false\n}\n", "    var\
    \ left  int\n    var right int = len(text) - 1\n\n    for left < right {\n   \
    \     if text[left] != text[right] {\n            return false\n        }\n  \
    \      left += 1\n        right -= 1\n    }\n    return true\n}\n", "    length\
    \ := len(text)\n    if length == 0 {\n        return true\n    }\n\n    for i\
    \ := 0; i < length/2; i++ {\n        if text[i] != text[length-i-1] {\n      \
    \      return false\n        }\n    }\n\n    return true\n}\n", "    length :=\
    \ len(text)\n    for i := 0; i < length/2; i++ {\n        if text[i] != text[length-i-1]\
    \ {\n            return false\n        }\n    }\n    return true\n}\n", "    length\
    \ := len(text)\n    for i := 0; i < length / 2; i++ {\n        if text[i] != text[length\
    \ - i - 1] {\n            return false\n        }\n    }\n    return true\n}\n",
  "    length := len(text)\n    for i := 0; i < length / 2; i++ {\n        if text[i]\
    \ != text[length - i - 1] {\n            return false\n        }\n    }\n    return\
    \ true\n}\n", "    if len(text) <= 1 {\n        return true\n    }\n    if text[0]\
    \ != text[len(text)-1] {\n        return false\n    }\n    return is_palindrome(text[1:len(text)-1])\n\
    }\n", "    chars := []rune(text)\n    n := len(chars)\n    // n == 0 is also true\
    \ if text == \"\"\n    if n == 0 {\n        return true\n    }\n    for i := 0;\
    \ i < n/2; i++ {\n        if chars[i] != chars[n-i-1] {\n            return false\n\
    \        }\n    }\n    return true\n}\n", "    if len(text) == 0 {\n        return\
    \ true\n    }\n    if len(text) == 1 {\n        return true\n    }\n    if text[0]\
    \ != text[len(text)-1] {\n        return false\n    }\n    return is_palindrome(text[1:len(text)-1])\n\
    }\n", "    length := len(text)\n    for i := 0; i < length/2; i++ {\n        if\
    \ text[i] != text[length-i-1] {\n            return false\n        }\n    }\n\
    \    return true\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
