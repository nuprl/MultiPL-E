name: HumanEval_48_is_palindrome
language: go_test.go
prompt: "package is_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
  \n// Checks if given string is a palindrome\n// >>> is_palindrome(\"\")\n// true\n\
  // >>> is_palindrome(\"aba\")\n// true\n// >>> is_palindrome(\"aaaaa\")\n// true\n\
  // >>> is_palindrome(\"zbcd\")\n// false\nfunc is_palindrome(text string) bool {\n"
tests: "func TestIs_Palindrome(t *testing.T) {\n  candidate := is_palindrome\n\ttype\
  \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
  \ := []test{\n     { actual: candidate(\"\"), expected: true },\n     { actual:\
  \ candidate(\"aba\"), expected: true },\n     { actual: candidate(\"aaaaa\"), expected:\
  \ true },\n     { actual: candidate(\"zbcd\"), expected: false },\n     { actual:\
  \ candidate(\"xywyx\"), expected: true },\n     { actual: candidate(\"xywyz\"),\
  \ expected: false },\n     { actual: candidate(\"xywzx\"), expected: false },\n\
  \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
  \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
  %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
  \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    for i := 0; i < len(text)/2; i++ {\n        if text[i] != text[len(text)-i-1]\
    \ {\n            return false\n        }\n    }\n    return true\n}\n", "    return\
    \ false\n}\n", "    // Returns true if given text is a palindrome\n    if len(text)\
    \ == 0 {\n        return true\n    }\n    left := text[0]\n    right := text[len(text)-1]\n\
    \    if left != right {\n        return false\n    }\n    return is_palindrome(text[1:len(text)-1])\n\
    }\n", "    runes := []rune(text)\n    l := len(runes)\n    for i := 0; i < l/2;\
    \ i++ {\n        if runes[i] != runes[l-i-1] {\n            return false\n   \
    \     }\n    }\n    return true\n}\n", "    for i := 0; i < len(text)/2; i++ {\n\
    \        if text[i] != text[len(text)-i-1] {\n            return false\n     \
    \   }\n    }\n    return true\n}\n", "    for i, j := 0, len(text) - 1; i < j;\
    \ i, j = i + 1, j - 1 {\n        if text[i] != text[j] {\n            return false\n\
    \        }\n    }\n    return true\n}\n", "    var start, end = 0, len(text) -\
    \ 1\n    for start < end {\n        if text[start] != text[end] {\n          \
    \  return false\n        }\n        start++\n        end--\n    }\n    return\
    \ true\n}\n", "    if len(text) == 0 {\n        return true\n    }\n    for i\
    \ := 0; i < len(text) / 2; i++ {\n        if text[i] != text[len(text) - i - 1]\
    \ {\n            return false\n        }\n    }\n    return true\n}\n", "    return\
    \ true\n}\n", "    n := len(text)\n    for i := 0; i < n / 2; i++ {\n        if\
    \ text[i] != text[n - i - 1] {\n            return false\n        }\n    }\n \
    \   return true\n}\n", "    if text == \"\" {\n        return true\n    }\n\n\
    \    size := len(text)\n    for i := 0; i < size / 2; i++ {\n        if text[i]\
    \ != text[size - i - 1] {\n            return false\n        }\n    }\n\n    return\
    \ true\n}\n", "    if len(text) == 0 {\n        return true\n    }\n    if len(text)\
    \ == 1 {\n        return true\n    }\n    if text[0] != text[len(text)-1] {\n\
    \        return false\n    }\n    return is_palindrome(text[1:len(text)-1])\n\
    }\n", "    if len(text) <= 1 {\n        return true\n    }\n    if text[0] !=\
    \ text[len(text)-1] {\n        return false\n    }\n    return is_palindrome(text[1:len(text)-1])\n\
    }\n", "    // return true\n    // start := 0\n    // end := len(text) - 1\n  \
    \  // for end > start {\n    //     if text[start] != text[end] {\n    //    \
    \     return false\n    //     }\n    //     start++\n    //     end--\n    //\
    \ }\n    // return true\n    for index, _ := range text {\n        if text[index]\
    \ != text[len(text) - index - 1] {\n            return false\n        }\n    }\n\
    \    return true\n}\n", "    if len(text) == 0 {\n        return true\n    }\n\
    \n    begin := 0\n    end := len(text) - 1\n\n    for begin < end {\n        if\
    \ text[begin] != text[end] {\n            return false\n        }\n        begin++\n\
    \        end--\n    }\n\n    return true\n}\n", "    length := len(text)\n   \
    \ if length == 0 {\n        return true\n    }\n\n    middle := length / 2\n \
    \   is_odd := length % 2 != 0\n\n    for i := 0; i < middle; i++ {\n        left\
    \ := text[i]\n        right := text[length - 1 - i]\n        if left != right\
    \ {\n            return false\n        }\n    }\n\n    if is_odd {\n        middle_char\
    \ := text[middle]\n        if middle_char != middle_char {\n            return\
    \ false\n        }\n    }\n\n    return true\n}\n", "    len := len(text)\n  \
    \  if len == 0 {\n        return true\n    }\n    mid := len / 2\n    left :=\
    \ text[:mid]\n    right := text[len-mid:]\n    right = reverse(right)\n    return\
    \ left == right\n}\n", "    if len(text) <= 1 {\n        return true\n    }\n\
    \    if text[0] != text[len(text)-1] {\n        return false\n    }\n    return\
    \ is_palindrome(text[1:len(text)-1])\n}\n", "    return false\n}\n", "    return\
    \ true\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
