name: HumanEval_26_remove_duplicates
language: go_test.go
prompt: "package remove_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
  )\n\n// From a list of integers, remove all elements that occur more than once.\n\
  // Keep order of elements left the same as in the input.\n// >>> remove_duplicates([]int{1,\
  \ 2, 3, 2, 4})\n// []int{1, 3, 4}\nfunc remove_duplicates(numbers []int) []int {\n"
tests: "func TestRemove_Duplicates(t *testing.T) {\n  candidate := remove_duplicates\n\
  \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
  \   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n\
  \     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n \
  \    { actual: candidate([]int{1, 2, 3, 2, 4, 3, 5}), expected: []int{1, 4, 5} },\n\
  \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
  \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
  %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
  \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    result := []int{}\n    for _, n := range numbers {\n        if\
    \ len(result) == 0 || result[len(result)-1] != n {\n            result = append(result,\
    \ n)\n        }\n    }\n    return result\n}\n", "    if len(numbers) == 0 {\n\
    \        return numbers\n    }\n    m := make(map[int]bool)\n    result := make([]int,\
    \ 0)\n    for _, num := range numbers {\n        if _, ok := m[num]; !ok {\n \
    \           m[num] = true\n            result = append(result, num)\n        }\n\
    \    }\n    return result\n}\n", "    items := make(map[int]bool)\n    unique\
    \ := []int{}\n    for _, number := range numbers {\n        if _, exists := items[number];\
    \ !exists {\n            items[number] = true\n            unique = append(unique,\
    \ number)\n        }\n    }\n    return unique\n}\n", "    /*\n    Using a `set`\
    \ to keep track of numbers already seen, if a number has\n    been seen then don't\
    \ put it into the output list.\n    */\n    seen := make(map[int]bool)\n    output\
    \ := make([]int, 0)\n    for _, num := range numbers {\n        if !seen[num]\
    \ {\n            seen[num] = true\n            output = append(output, num)\n\
    \        }\n    }\n    return output\n}\n", "    var result []int\n    for _,\
    \ number := range numbers {\n        if !is_duplicate(result, number) {\n    \
    \        result = append(result, number)\n        }\n    }\n    return result\n\
    }\n", "    if len(numbers) == 0 {\n        return numbers\n    }\n    result :=\
    \ make([]int, 0, len(numbers))\n    start := 0\n    end := 0\n    for i := 0;\
    \ i < len(numbers); i++ {\n        end = i\n        for j := i + 1; j < len(numbers);\
    \ j++ {\n            if numbers[i] == numbers[j] {\n                end = j\n\
    \            }\n        }\n        if end == i {\n            result = append(result,\
    \ numbers[i])\n        }\n        i = end\n    }\n    return result\n}\n", " \
    \   // this map will store each number as a key\n    // and the number of occurrences\
    \ as value\n    counts := make(map[int]int)\n    // last non-duplicate number\n\
    \    // will be empty if no non-duplicate numbers are found\n    var lastNonDuplicateNumber\
    \ int\n    // append non-duplicate numbers here\n    var deduped []int\n    for\
    \ _, number := range numbers {\n        if counts[number] == 0 {\n           \
    \ counts[number] = 1\n            lastNonDuplicateNumber = number\n        } else\
    \ {\n            counts[number]++\n        }\n    }\n    // make sure the last\
    \ found number is unique\n    if counts[lastNonDuplicateNumber] == 1 {\n     \
    \   deduped = append(deduped, lastNonDuplicateNumber)\n    }\n    return deduped\n\
    }\n", "    result := []int{}\n    index := 0\n    for _, v := range numbers {\n\
    \        result = append(result, v)\n        index++\n        for i := index;\
    \ i < len(numbers); i++ {\n            if v == numbers[i] {\n                index\
    \ = i + 1\n                break\n            }\n        }\n    }\n    return\
    \ result\n}\n", "    result := []int{}\n    visited := make(map[int]bool)\n  \
    \  for _, n := range numbers {\n        if !visited[n] {\n            result =\
    \ append(result, n)\n            visited[n] = true\n        }\n    }\n    return\
    \ result\n}\n", "    if numbers == nil {\n        return nil\n    }\n    // We\
    \ assume the list is sorted.\n    var results []int\n    for i := 0; i < len(numbers);\
    \ i++ {\n        if i == 0 || results[len(results)-1] != numbers[i] {\n      \
    \      results = append(results, numbers[i])\n        }\n    }\n    return results\n\
    }\n", "    var ret []int\n    seen := make(map[int]bool)\n    for _, num := range\
    \ numbers {\n        if _, ok := seen[num]; !ok {\n            ret = append(ret,\
    \ num)\n            seen[num] = true\n        }\n    }\n    return ret\n}\n",
  '    seen := make(map[int]', "    size := len(numbers)\n    if size < 2 {\n    \
    \    return numbers\n    }\n    duplicates := map[int]bool{}\n    var unique []int\n\
    \    for _, i := range numbers {\n        if _, ok := duplicates[i]; !ok {\n \
    \           unique = append(unique, i)\n            duplicates[i] = true\n   \
    \     }\n    }\n    return unique\n}\n", "    ret := []int{}\n    seen := map[int]bool{}\n\
    \    for _, num := range numbers {\n        if _, ok := seen[num]; !ok {\n   \
    \         ret = append(ret, num)\n            seen[num] = true\n        }\n  \
    \  }\n    return ret\n}\n", "    seen := make(map[int]bool)\n    result := make([]int,\
    \ 0)\n    for _, number := range numbers {\n        if !seen[number] {\n     \
    \       seen[number] = true\n            result = append(result, number)\n   \
    \     }\n    }\n    return result\n}\n", "    seen := make(map[int]bool)\n   \
    \ unique_numbers := []int{}\n    for _, number := range numbers {\n        if\
    \ !seen[number] {\n            seen[number] = true\n            unique_numbers\
    \ = append(unique_numbers, number)\n        }\n    }\n    return unique_numbers\n\
    }\n", "    if len(numbers) < 2 {\n        return numbers\n    }\n    var i int\n\
    \    for index, item := range numbers {\n        if item != numbers[i] {\n   \
    \         i++\n            numbers[i] = item\n        }\n        fmt.Println(index,\
    \ i, item, numbers)\n    }\n    return numbers[:i+1]\n}\n", "    var newSlice\
    \ []int\n\n    for i := 0; i < len(numbers); i++ {\n        if !contains(newSlice,\
    \ numbers[i]) {\n            newSlice = append(newSlice, numbers[i])\n       \
    \ }\n    }\n\n    return newSlice\n}\n", "    result := []int{}\n    for _, n\
    \ := range numbers {\n        if count(numbers, n) == 1 {\n            result\
    \ = append(result, n)\n        }\n    }\n    return result\n}\n", "    indexes\
    \ := make(map[int]int)\n    result := make([]int, 0)\n    for _, number := range\
    \ numbers {\n        if indexes[number] == 0 {\n            indexes[number] =\
    \ 1\n            result = append(result, number)\n        }\n    }\n    return\
    \ result\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
