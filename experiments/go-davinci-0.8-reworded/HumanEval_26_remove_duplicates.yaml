name: HumanEval_26_remove_duplicates
language: go_test.go
prompt: "package remove_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
  )\n\n// From a list of integers, remove all elements that occur more than once.\n\
  // Keep order of elements left the same as in the input.\n// >>> remove_duplicates([]int{1,\
  \ 2, 3, 2, 4})\n// []int{1, 3, 4}\nfunc remove_duplicates(numbers []int) []int {\n"
tests: "func TestRemove_Duplicates(t *testing.T) {\n  candidate := remove_duplicates\n\
  \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
  \   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n\
  \     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n \
  \    { actual: candidate([]int{1, 2, 3, 2, 4, 3, 5}), expected: []int{1, 4, 5} },\n\
  \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
  \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
  %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
  \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    result := []int{}\n    for _, n := range numbers {\n        if\
    \ len(result) == 0 || result[len(result)-1] != n {\n            result = append(result,\
    \ n)\n        }\n    }\n    return result\n}\n", "    if len(numbers) == 0 {\n\
    \        return numbers\n    }\n    m := make(map[int]bool)\n    result := make([]int,\
    \ 0)\n    for _, num := range numbers {\n        if _, ok := m[num]; !ok {\n \
    \           m[num] = true\n            result = append(result, num)\n        }\n\
    \    }\n    return result\n}\n", "    items := make(map[int]bool)\n    unique\
    \ := []int{}\n    for _, number := range numbers {\n        if _, exists := items[number];\
    \ !exists {\n            items[number] = true\n            unique = append(unique,\
    \ number)\n        }\n    }\n    return unique\n}\n", "    /*\n    Using a `set`\
    \ to keep track of numbers already seen, if a number has\n    been seen then don't\
    \ put it into the output list.\n    */\n    seen := make(map[int]bool)\n    output\
    \ := make([]int, 0)\n    for _, num := range numbers {\n        if !seen[num]\
    \ {\n            seen[num] = true\n            output = append(output, num)\n\
    \        }\n    }\n    return output\n}\n", "    var result []int\n    for _,\
    \ number := range numbers {\n        if !is_duplicate(result, number) {\n    \
    \        result = append(result, number)\n        }\n    }\n    return result\n\
    }\n", "    if len(numbers) == 0 {\n        return numbers\n    }\n    result :=\
    \ make([]int, 0, len(numbers))\n    start := 0\n    end := 0\n    for i := 0;\
    \ i < len(numbers); i++ {\n        end = i\n        for j := i + 1; j < len(numbers);\
    \ j++ {\n            if numbers[i] == numbers[j] {\n                end = j\n\
    \            }\n        }\n        if end == i {\n            result = append(result,\
    \ numbers[i])\n        }\n        i = end\n    }\n    return result\n}\n", " \
    \   // this map will store each number as a key\n    // and the number of occurrences\
    \ as value\n    counts := make(map[int]int)\n    // last non-duplicate number\n\
    \    // will be empty if no non-duplicate numbers are found\n    var lastNonDuplicateNumber\
    \ int\n    // append non-duplicate numbers here\n    var deduped []int\n    for\
    \ _, number := range numbers {\n        if counts[number] == 0 {\n           \
    \ counts[number] = 1\n            lastNonDuplicateNumber = number\n        } else\
    \ {\n            counts[number]++\n        }\n    }\n    // make sure the last\
    \ found number is unique\n    if counts[lastNonDuplicateNumber] == 1 {\n     \
    \   deduped = append(deduped, lastNonDuplicateNumber)\n    }\n    return deduped\n\
    }\n", "    result := []int{}\n    index := 0\n    for _, v := range numbers {\n\
    \        result = append(result, v)\n        index++\n        for i := index;\
    \ i < len(numbers); i++ {\n            if v == numbers[i] {\n                index\
    \ = i + 1\n                break\n            }\n        }\n    }\n    return\
    \ result\n}\n", "    result := []int{}\n    visited := make(map[int]bool)\n  \
    \  for _, n := range numbers {\n        if !visited[n] {\n            result =\
    \ append(result, n)\n            visited[n] = true\n        }\n    }\n    return\
    \ result\n}\n", "    if numbers == nil {\n        return nil\n    }\n    // We\
    \ assume the list is sorted.\n    var results []int\n    for i := 0; i < len(numbers);\
    \ i++ {\n        if i == 0 || results[len(results)-1] != numbers[i] {\n      \
    \      results = append(results, numbers[i])\n        }\n    }\n    return results\n\
    }\n", "    var ret []int\n    seen := make(map[int]bool)\n    for _, num := range\
    \ numbers {\n        if _, ok := seen[num]; !ok {\n            ret = append(ret,\
    \ num)\n            seen[num] = true\n        }\n    }\n    return ret\n}\n",
  '    seen := make(map[int]', "    size := len(numbers)\n    if size < 2 {\n    \
    \    return numbers\n    }\n    duplicates := map[int]bool{}\n    var unique []int\n\
    \    for _, i := range numbers {\n        if _, ok := duplicates[i]; !ok {\n \
    \           unique = append(unique, i)\n            duplicates[i] = true\n   \
    \     }\n    }\n    return unique\n}\n", "    ret := []int{}\n    seen := map[int]bool{}\n\
    \    for _, num := range numbers {\n        if _, ok := seen[num]; !ok {\n   \
    \         ret = append(ret, num)\n            seen[num] = true\n        }\n  \
    \  }\n    return ret\n}\n", "    seen := make(map[int]bool)\n    result := make([]int,\
    \ 0)\n    for _, number := range numbers {\n        if !seen[number] {\n     \
    \       seen[number] = true\n            result = append(result, number)\n   \
    \     }\n    }\n    return result\n}\n", "    seen := make(map[int]bool)\n   \
    \ unique_numbers := []int{}\n    for _, number := range numbers {\n        if\
    \ !seen[number] {\n            seen[number] = true\n            unique_numbers\
    \ = append(unique_numbers, number)\n        }\n    }\n    return unique_numbers\n\
    }\n", "    if len(numbers) < 2 {\n        return numbers\n    }\n    var i int\n\
    \    for index, item := range numbers {\n        if item != numbers[i] {\n   \
    \         i++\n            numbers[i] = item\n        }\n        fmt.Println(index,\
    \ i, item, numbers)\n    }\n    return numbers[:i+1]\n}\n", "    var newSlice\
    \ []int\n\n    for i := 0; i < len(numbers); i++ {\n        if !contains(newSlice,\
    \ numbers[i]) {\n            newSlice = append(newSlice, numbers[i])\n       \
    \ }\n    }\n\n    return newSlice\n}\n", "    result := []int{}\n    for _, n\
    \ := range numbers {\n        if count(numbers, n) == 1 {\n            result\
    \ = append(result, n)\n        }\n    }\n    return result\n}\n", "    indexes\
    \ := make(map[int]int)\n    result := make([]int, 0)\n    for _, number := range\
    \ numbers {\n        if indexes[number] == 0 {\n            indexes[number] =\
    \ 1\n            result = append(result, number)\n        }\n    }\n    return\
    \ result\n}\n", "    // TODO: do it\n    return numbers\n}\n", "    output :=\
    \ []int{}\n    seen := map[int]bool{}\n    for _, num := range numbers {\n   \
    \     if !seen[num] {\n            output = append(output, num)\n            seen[num]\
    \ = true\n        }\n    }\n    return output\n}\n", "    m := make(map[int]bool)\n\
    \    result := make([]int, 0)\n    for _, val := range numbers {\n        if !m[val]\
    \ {\n            m[val] = true\n            result = append(result, val)\n   \
    \     }\n    }\n    return result\n}\n", "    var result []int\n    m := make(map[int]bool)\n\
    \    for _, n := range numbers {\n        if _, ok := m[n]; !ok {\n          \
    \  m[n] = true\n            result = append(result, n)\n        }\n    }\n   \
    \ return result\n}\n", "    m := make(map[int]int)\n    unique := make([]int,\
    \ 0)\n    for _, n := range numbers {\n        m[n] += 1\n    }\n    for k, v\
    \ := range m {\n        if v == 1 {\n            unique = append(unique, k)\n\
    \        }\n    }\n    return unique\n}\n", "    var result []int\n    numbersSet\
    \ := make(map[int]int)\n    for _, number := range numbers {\n        if _, ok\
    \ := numbersSet[number]; !ok {\n            numbersSet[number] = 1\n         \
    \   result = append(result, number)\n        }\n    }\n    return result\n}\n",
  "    result := []int{}\n    unique := map[int]bool{}\n    for _, number := range\
    \ numbers {\n        if !unique[number] {\n            unique[number] = true\n\
    \            result = append(result, number)\n        }\n    }\n    return result\n\
    }\n", "    var previous_numbers []int\n    var result []int\n    for _, n := range\
    \ numbers {\n        if !contains(previous_numbers, n) {\n            result =\
    \ append(result, n)\n        }\n        previous_numbers = append(previous_numbers,\
    \ n)\n    }\n    return result\n}\n", "    output := []int{}\n    duplicates :=\
    \ make(map[int]bool)\n    for _, number := range numbers {\n        if _, found\
    \ := duplicates[number]; !found {\n            output = append(output, number)\n\
    \            duplicates[number] = true\n        }\n    }\n    return output\n\
    }\n", "    m := make(map[int]int)\n    for _, number := range numbers {\n    \
    \    m[number] += 1\n    }\n    unique_numbers := []int{}\n    for number, count\
    \ := range m {\n        if count == 1 {\n            unique_numbers = append(unique_numbers,\
    \ number)\n        }\n    }\n    return unique_numbers\n}\n", "    var res []int\n\
    \    m := make(map[int]bool)\n    for _, item := range numbers {\n        if _,\
    \ ok := m[item]; !ok {\n            m[item] = true\n            res = append(res,\
    \ item)\n        }\n    }\n    return res\n}\n", "    var r []int\n    m := make(map[int]bool)\n\
    \    for _, v := range numbers {\n        if _, ok := m[v]; !ok {\n          \
    \  m[v] = true\n            r = append(r, v)\n        }\n    }\n    return r\n\
    }\n", "    result := []int{}\n    seen := make(map[int]bool)\n    for _, num :=\
    \ range numbers {\n        if _, ok := seen[num]; !ok {\n            result =\
    \ append(result, num)\n            seen[num] = true\n        }\n    }\n    return\
    \ result\n}\n", "    elements := make(map[int]bool)\n    result := []int{}\n\n\
    \    for _, v := range numbers {\n        if _, exists := elements[v]; !exists\
    \ {\n            elements[v] = true\n            result = append(result, v)\n\
    \        }\n    }\n\n    return result\n}\n", "    if len(numbers) < 2 {\n   \
    \     return numbers\n    }\n    results := []int{}\n    for i, number := range\
    \ numbers {\n        if i > 0 && number == numbers[i-1] {\n            continue\n\
    \        }\n        results = append(results, number)\n    }\n    return results\n\
    }\n", "    var uniques []int\n    var seen = make(map[int]bool)\n    for _, num\
    \ := range numbers {\n        if !seen[num] {\n            uniques = append(uniques,\
    \ num)\n            seen[num] = true\n        }\n    }\n    return uniques\n}\n",
  "    var uniqueNumbers []int\n    var alreadySeenNumbers map[int]bool\n\n    alreadySeenNumbers\
    \ = make(map[int]bool)\n\n    for _, number := range numbers {\n        if _,\
    \ present := alreadySeenNumbers[number]; !present {\n            uniqueNumbers\
    \ = append(uniqueNumbers, number)\n            alreadySeenNumbers[number] = true\n\
    \        }\n    }\n\n    return uniqueNumbers\n}\n", "    var uniques []int\n\
    \    if len(numbers) > 0 {\n        uniques = append(uniques, numbers[0])\n  \
    \  }\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] != numbers[i-1]\
    \ {\n            uniques = append(uniques, numbers[i])\n        }\n    }\n   \
    \ return uniques\n}\n", "    unique := make(map[int]bool)\n    result := make([]int,\
    \ 0)\n    for _, value := range numbers {\n        if _, exists := unique[value];\
    \ !exists {\n            unique[value] = true\n            result = append(result,\
    \ value)\n        }\n    }\n    return result\n}\n", "    if len(numbers) == 0\
    \ {\n        return []int{}\n    }\n\n    last_number := numbers[0]\n    result\
    \ := []int{last_number}\n    for _, number := range numbers[1:] {\n        if\
    \ number != last_number {\n            result = append(result, number)\n     \
    \       last_number = number\n        }\n    }\n    return result\n}\n", "   \
    \ if len(numbers) == 0 {\n        return []int{}\n    }\n    uniqueMap := make(map[int]bool)\n\
    \    result := make([]int, 0)\n    for _, number := range numbers {\n        if\
    \ uniqueMap[number] == false {\n            uniqueMap[number] = true\n       \
    \     result = append(result, number)\n        }\n    }\n    return result\n}\n",
  "    var result []int\n    set := make(map[int]bool)\n    for _, n := range numbers\
    \ {\n        if !set[n] {\n            result = append(result, n)\n          \
    \  set[n] = true\n        }\n    }\n    return result\n}\n", "    var dupes []int\n\
    \    for i, n := range numbers {\n        for j, n2 := range numbers {\n     \
    \       if i != j && n == n2 {\n                dupes = append(dupes, n)\n   \
    \         }\n        }\n    }\n    var uniques []int\n    for _, n := range numbers\
    \ {\n        var dupe = false\n        for _, d := range dupes {\n           \
    \ if n == d {\n                dupe = true\n            }\n        }\n       \
    \ if !dupe {\n            uniques = append(uniques, n)\n        }\n    }\n   \
    \ return uniques\n}\n", "    uniques := []int{}\n    for _, v := range numbers\
    \ {\n        uniques = append_unique(uniques, v)\n    }\n    return uniques\n\
    }\n", "    items := make(map[int]int)\n    result := make([]int, 0)\n    for _,\
    \ number := range numbers {\n        if _, exists := items[number]; !exists {\n\
    \            items[number] = 1\n            result = append(result, number)\n\
    \        }\n    }\n    return result\n}\n", "    m := make(map[int]bool)\n   \
    \ for _, number := range numbers {\n        if !m[number] {\n            m[number]\
    \ = true\n        }\n    }\n    var result []int\n    for number, _ := range m\
    \ {\n        result = append(result, number)\n    }\n    return result\n}\n",
  "    result := []int{}\n    length := len(numbers)\n    for i := 0; i < length;\
    \ i++ {\n        seen := false\n        for j := 0; j < length; j++ {\n      \
    \      if i != j && numbers[i] == numbers[j] {\n                seen = true\n\
    \                break\n            }\n        }\n        if !seen {\n       \
    \     result = append(result, numbers[i])\n        }\n    }\n    return result\n\
    }\n", "    used_numbers := make(map[int]bool)\n    used_numbers[numbers[0]] =\
    \ true\n    result := []int{numbers[0]}\n    for _, number := range numbers[1:]\
    \ {\n        if !used_numbers[number] {\n            result = append(result, number)\n\
    \            used_numbers[number] = true\n        }\n    }\n    return result\n\
    }\n", "    m := make(map[int]bool)\n    for _, n := range numbers {\n        m[n]\
    \ = true\n    }\n    res := make([]int, 0, len(m))\n    for key, _ := range m\
    \ {\n        res = append(res, key)\n    }\n    return res\n}\n", "    var result\
    \ []int\n    if len(numbers) < 2 {\n        return numbers\n    }\n    for i,\
    \ n := range numbers {\n        if i == 0 {\n            result = append(result,\
    \ n)\n        } else {\n            found := false\n            for _, r := range\
    \ result {\n                if r == n {\n                    found = true\n  \
    \                  break\n                }\n            }\n            if !found\
    \ {\n                result = append(result, n)\n            }\n        }\n  \
    \  }\n    return result\n}\n", "    result := []int{}\n    for i := 0; i < len(numbers);\
    \ i++ {\n        if i == 0 || numbers[i-1] != numbers[i] {\n            result\
    \ = append(result, numbers[i])\n        }\n    }\n    return result\n}\n", " \
    \   result := []int{}\n    seen := make(map[int]int)\n    for _, num := range\
    \ numbers {\n        if seen[num] == 0 {\n            result = append(result,\
    \ num)\n            seen[num]++\n        }\n    }\n    return result\n}\n", " \
    \   result := []int{}\n    for _, number := range numbers {\n        for _, result_number\
    \ := range result {\n            if number == result_number {\n              \
    \  goto continue_outer\n            }\n        }\n        result = append(result,\
    \ number)\n        continue_outer:\n    }\n    return result\n}\n", "    cache\
    \ := make(map[int]int)\n    for _, number := range numbers {\n        cache[number]\
    \ += 1\n    }\n    unique := make([]int, 0)\n    for _, number := range numbers\
    \ {\n        if cache[number] == 1 {\n            unique = append(unique, number)\n\
    \        }\n    }\n    return unique\n}\n", "    seen := make(map[int]bool)\n\
    \    var result []int\n    for _, v := range numbers {\n        if !seen[v] {\n\
    \            seen[v] = true\n            result = append(result, v)\n        }\n\
    \    }\n    return result\n}\n", "    duplicates := make(map[int]bool)\n    result\
    \ := make([]int, 0)\n    for _, value := range numbers {\n        if !duplicates[value]\
    \ {\n            duplicates[value] = true\n            result = append(result,\
    \ value)\n        }\n    }\n    return result\n}\n", "    m := make(map[int]bool)\n\
    \    unique := []int{}\n    for _, n := range numbers {\n        if m[n] {\n \
    \           continue\n        }\n        m[n] = true\n        unique = append(unique,\
    \ n)\n    }\n    return unique\n}\n", "    result := []int{}\n    found := make(map[int]bool)\n\
    \    for i := 0; i < len(numbers); i++ {\n        if found[numbers[i]] {\n   \
    \         continue\n        }\n        found[numbers[i]] = true\n        result\
    \ = append(result, numbers[i])\n    }\n    return result\n}\n", "    if len(numbers)\
    \ == 0 {\n        return numbers\n    }\n    numbers_set := make(map[int]bool)\n\
    \    unique_numbers := make([]int, 0)\n    for _, number := range numbers {\n\
    \        if !numbers_set[number] {\n            numbers_set[number] = true\n \
    \           unique_numbers = append(unique_numbers, number)\n        }\n    }\n\
    \    return unique_numbers\n}\n", "    // find unique items\n    uniqueItems :=\
    \ make(map[int]bool)\n    for _, item := range numbers {\n        uniqueItems[item]\
    \ = true\n    }\n\n    // build new list with only unique items\n    result :=\
    \ make([]int, 0, len(uniqueItems))\n    for item := range uniqueItems {\n    \
    \    result = append(result, item)\n    }\n\n    return result\n}\n", "    m :=\
    \ make(map[int]bool)\n    new_slice := make([]int, 0)\n    for _, val := range\
    \ numbers {\n        if _, exists := m[val]; !exists {\n            m[val] = true\n\
    \            new_slice = append(new_slice, val)\n        }\n    }\n    return\
    \ new_slice\n}\n", "    duplicate_checker := make(map[int]int)\n    result :=\
    \ make([]int, 0)\n    for _, v := range numbers {\n        if _, exist := duplicate_checker[v];\
    \ !exist {\n            duplicate_checker[v] = v\n            result = append(result,\
    \ v)\n        }\n    }\n    return result\n}\n", "    m := make(map[int]bool)\n\
    \    for _, x := range numbers {\n        m[x] = true\n    }\n    res := make([]int,\
    \ 0, len(m))\n    for k, _ := range m {\n        res = append(res, k)\n    }\n\
    \    return res\n}\n", "    r := []int{}\n    seen := make(map[int]bool)\n   \
    \ for _, n := range numbers {\n        if !seen[n] {\n            r = append(r,\
    \ n)\n            seen[n] = true\n        }\n    }\n    return r\n}\n", "    elements\
    \ := make(map[int]bool)\n    result := []int{}\n\n    for _, n := range numbers\
    \ {\n        if !elements[n] {\n            elements[n] = true\n            result\
    \ = append(result, n)\n        }\n    }\n\n    return result\n}\n", "    number_set\
    \ := make(map[int]bool)\n    for _, n := range numbers {\n        number_set[n]\
    \ = true\n    }\n    new_numbers := make([]int, 0, len(number_set))\n    for k,\
    \ _ := range number_set {\n        new_numbers = append(new_numbers, k)\n    }\n\
    \    return new_numbers\n}\n", "    uniques := make([]int, 0)\n    unique_set\
    \ := make(map[int]int)\n    for _, number := range numbers {\n        unique_set[number]\
    \ += 1\n    }\n    for number, count := range unique_set {\n        if count ==\
    \ 1 {\n            uniques = append(uniques, number)\n        }\n    }\n    return\
    \ uniques\n}\n\ntype test_pair ", "    i := 0\n    for j := 0; j < len(numbers);\
    \ j++ {\n        if i > 0 && numbers[i-1] == numbers[j] {\n            continue\n\
    \        }\n        numbers[i] = numbers[j]\n        i++\n    }\n    return numbers[:i]\n\
    }\n", "    var result []int\n    for _, number := range numbers {\n        if\
    \ !contains(result, number) {\n            result = append(result, number)\n \
    \       }\n    }\n    return result\n}\n", "    var result []int\n    duplicate\
    \ := make(map[int]bool)\n    for _, num := range numbers {\n        if _, ok :=\
    \ duplicate[num]; !ok {\n            result = append(result, num)\n          \
    \  duplicate[num] = true\n        }\n    }\n    return result\n}\n", "    var\
    \ result []int\n    // Create a map for elements found in the input.\n    // Initialize\
    \ the map for each element with its count.\n    // Then go through the input array\
    \ and check if the element\n    // is present in the map. If it's not, add to\
    \ the result.\n    // If it is, decrease its count, and if its count becomes 0,\n\
    \    // delete it from the map.\n    // This way we can keep track of the elements\
    \ that have occurred\n    // only once.\n    elements := make(map[int]int)\n \
    \   for _, n := range numbers {\n        elements[n] = elements[n] + 1\n    }\n\
    \    for _, n := range numbers {\n        if elements[n] > 0 {\n            result\
    \ = append(result, n)\n            elements[n] = elements[n] - 1\n           \
    \ if elements[n] == 0 {\n                delete(elements, n)\n            }\n\
    \        }\n    }\n    return result\n}\n", "    unique := []int{}\n    for _,\
    \ num := range numbers {\n        // we cannot use map for storing b/c we need\
    \ to keep order the same as the input\n        // map stores the key-value pairs\
    \ in no particular order,\n        // and the order can vary when you iterate\
    \ over the map.\n        found := false\n        for _, val := range unique {\n\
    \            if val == num {\n                found = true\n                break\n\
    \            }\n        }\n        if !found {\n            unique = append(unique,\
    \ num)\n        }\n    }\n    return unique\n}\n", "    u := make([]int, 0, len(numbers))\n\
    \    m := make(map[int]bool)\n\n    for _, val := range numbers {\n        if\
    \ _, ok := m[val]; !ok {\n            m[val] = true\n            u = append(u,\
    \ val)\n        }\n    }\n\n    return u\n}\n", "    l := len(numbers)\n    result\
    \ := make([]int, 0, l)\n    if l == 0 {\n        return result\n    }\n    //\
    \ Go through the slice and copy unique integers to result slice\n    last_num\
    \ := numbers[0]\n    result = append(result, last_num)\n    for i := 1; i < l;\
    \ i++ {\n        if numbers[i] != last_num {\n            result = append(result,\
    \ numbers[i])\n            last_num = numbers[i]\n        }\n    }\n    return\
    \ result\n}\n", "    // return remove_duplicates_set(numbers)\n    return remove_duplicates_map(numbers)\n\
    }\n", "    if len(numbers) == 0 {\n        return numbers\n    }\n    if len(numbers)\
    \ == 1 {\n        return numbers\n    }\n    // map an integer to an index in\
    \ the numbers slice\n    // if it's -1, the integer is unique, otherwise use the\
    \ value in the map\n    // as the index of a duplicate (and only keep the one\
    \ with the smallest index)\n    found := make(map[int]int)\n    for i, value :=\
    \ range numbers {\n        if index, ok := found[value]; ok {\n            found[value]\
    \ = index\n        } else {\n            found[value] = -1\n        }\n      \
    \  found[value] = i\n    }\n    // original slice is unchanged\n    result :=\
    \ make([]int, 0, len(numbers))\n    for i, value := range numbers {\n        if\
    \ found[value] == -1 {\n            result = append(result, value)\n        }\
    \ else if found[value] == i {\n            result = append(result, value)\n  \
    \      }\n    }\n    return result\n}\n", "    m := make(map[int]bool)\n    result\
    \ := make([]int, 0)\n    for _, v := range numbers {\n        if !m[v] {\n   \
    \         m[v] = true\n            result = append(result, v)\n        }\n   \
    \ }\n    return result\n}\n", "    result := []int{}\n    cache := map[int]bool{}\n\
    \    for _, number := range numbers {\n        if _, found := cache[number]; !found\
    \ {\n            cache[number] = true\n            result = append(result, number)\n\
    \        }\n    }\n    return result\n}\n", "    ret := []int{}\n    m := make(map[int]int)\n\
    \    for _, n := range numbers {\n        m[n]++\n    }\n    for _, n := range\
    \ numbers {\n        if m[n] == 1 {\n            ret = append(ret, n)\n      \
    \  }\n    }\n    return ret\n}\n", "    counter := make(map[int]int)\n    for\
    \ _, number := range numbers {\n        counter[number] += 1\n    }\n    result\
    \ := make([]int, 0)\n    for _, number := range numbers {\n        if counter[number]\
    \ == 1 {\n            result = append(result, number)\n        }\n    }\n    return\
    \ result\n}\n", "    table := make(map[int]bool)\n    result := make([]int, 0)\n\
    \    for _, n := range numbers {\n        if ok := table[n]; !ok {\n         \
    \   table[n] = true\n            result = append(result, n)\n        }\n    }\n\
    \    return result\n}\n", "    seen := make(map[int]bool)\n    result := make([]int,\
    \ 0)\n    for i, _ := range numbers {\n        if !seen[numbers[i]] {\n      \
    \      seen[numbers[i]] = true\n            result = append(result, numbers[i])\n\
    \        }\n    }\n    return result\n}\n", "    var uniques []int\n    for _,\
    \ number := range numbers {\n        isUnique := true\n        for _, unique :=\
    \ range uniques {\n            if number == unique {\n                isUnique\
    \ = false\n                break\n            }\n        }\n        if isUnique\
    \ {\n            uniques = append(uniques, number)\n        }\n    }\n    return\
    \ uniques\n}\n", "    var result []int\n    var m = make(map[int]int)\n    for\
    \ _, num := range numbers {\n        if m[num] == 0 {\n            result = append(result,\
    \ num)\n        }\n        m[num] += 1\n    }\n    return result\n}\n", "    if\
    \ numbers == nil {\n        return nil\n    }\n    var r []int\n    for i := 0;\
    \ i < len(numbers); i++ {\n        for j := i + 1; j < len(numbers); j++ {\n \
    \           if numbers[i] == numbers[j] {\n                numbers[i] = 0\n  \
    \              numbers[j] = 0\n            }\n        }\n    }\n    for _, n :=\
    \ range numbers {\n        if n != 0 {\n            r = append(r, n)\n       \
    \ }\n    }\n    return r\n}\n", "    seen := make(map[int]bool)\n    result :=\
    \ make([]int, 0)\n    for _, value := range numbers {\n        if !seen[value]\
    \ {\n            seen[value] = true\n            result = append(result, value)\n\
    \        }\n    }\n    return result\n}\n", "    unique := []int{}\n    counts\
    \ := map[int]int{}\n    for _, number := range numbers {\n        counts[number]\
    \ += 1\n    }\n    for _, number := range numbers {\n        if counts[number]\
    \ == 1 {\n            unique = append(unique, number)\n        }\n    }\n    return\
    \ unique\n}\n", "    known := make(map[int]bool)\n    result := make([]int, 0)\n\
    \    for _, number := range numbers {\n        if !known[number] {\n         \
    \   known[number] = true\n            result = append(result, number)\n      \
    \  }\n    }\n    return result\n}\n", "    result := []int{}\n    for _, n :=\
    \ range numbers {\n        if !contains(result, n) {\n            result = append(result,\
    \ n)\n        }\n    }\n    return result\n}\n", "    output := []int{}\n    seen\
    \ := map[int]bool{}\n    for _, number := range numbers {\n        if seen[number]\
    \ == false {\n            output = append(output, number)\n            seen[number]\
    \ = true\n        }\n    }\n    return output\n}\n", "    m := make(map[int]bool)\n\
    \    for _, num := range numbers {\n        m[num] = true\n    }\n    res := make([]int,\
    \ 0, len(m))\n    for num, _ := range m {\n        res = append(res, num)\n  \
    \  }\n    return res\n}\n", "    result := []int{}\n    occurences := map[int]int{}\n\
    \    for _, number := range numbers {\n        if _, found := occurences[number];\
    \ !found {\n            occurences[number] = 0\n        }\n        occurences[number]\
    \ += 1\n    }\n    for _, number := range numbers {\n        if occurences[number]\
    \ == 1 {\n            result = append(result, number)\n        }\n    }\n    return\
    \ result\n}\n", "    result := []int{}\n    counts := map[int]int{}\n    for _,\
    \ number := range numbers {\n        if _, ok := counts[number]; ok {\n      \
    \      counts[number] += 1\n        } else {\n            counts[number] = 1\n\
    \        }\n    }\n    for number, count := range counts {\n        if count ==\
    \ 1 {\n            result = append(result, number)\n        }\n    }\n    return\
    \ result\n}\n", "    uniques := make([]int, 0)\n    for _, number := range numbers\
    \ {\n        is_unique := true\n        for _, unique := range uniques {\n   \
    \         if number == unique {\n                is_unique = false\n         \
    \       break\n            }\n        }\n        if is_unique {\n            uniques\
    \ = append(uniques, number)\n        }\n    }\n    return uniques\n}\n", "   \
    \ result := []int{}\n    hash := make(map[int]bool)\n    for _, number := range\
    \ numbers {\n        if !hash[number] {\n            hash[number] = true\n   \
    \         result = append(result, number)\n        }\n    }\n    return result\n\
    }\n", "    deduplicated := []int{}\n    for _, n := range numbers {\n        if\
    \ !has(deduplicated, n) {\n            deduplicated = append(deduplicated, n)\n\
    \        }\n    }\n    return deduplicated\n}\n", "    if len(numbers) < 2 {\n\
    \        return numbers\n    }\n    var result []int\n    umap := make(map[int]int)\n\
    \    for _, num := range numbers {\n        if _, ok := umap[num]; !ok {\n   \
    \         umap[num] = 1\n            result = append(result, num)\n        }\n\
    \    }\n    return result\n}\n", "    seen := make(map[int]bool)\n    result :=\
    \ make([]int, 0)\n    for _, n := range numbers {\n        if !seen[n] {\n   \
    \         seen[n] = true\n            result = append(result, n)\n        }\n\
    \    }\n    return result\n}\n", "    seen := make(map[int]bool)\n    result :=\
    \ make([]int, 0)\n    for _, value := range numbers {\n        if !seen[value]\
    \ {\n            seen[value] = true\n            result = append(result, value)\n\
    \        }\n    }\n    return result\n}\n", "    var uniques []int\n    var lookup\
    \ = make(map[int]bool)\n    for _, i := range numbers {\n        if _, ok := lookup[i];\
    \ !ok {\n            lookup[i] = true\n            uniques = append(uniques, i)\n\
    \        }\n    }\n    return uniques\n}\n", "    result := []int{}\n    seen\
    \ := map[int]bool{}\n    for _, n := range numbers {\n        if seen[n] {\n \
    \           continue\n        }\n        seen[n] = true\n        result = append(result,\
    \ n)\n    }\n    return result\n}\n", "    dict := make(map[int]int)\n    unique_numbers\
    \ := make([]int, 0)\n    for _, number := range numbers {\n        if _, ok :=\
    \ dict[number]; !ok {\n            dict[number] = 1\n            unique_numbers\
    \ = append(unique_numbers, number)\n        }\n    }\n    return unique_numbers\n\
    }\n", "    res := make([]int, 0)\n    unique := make(map[int]bool)\n    for _,\
    \ n := range numbers {\n        if _, ok := unique[n]; !ok {\n            res\
    \ = append(res, n)\n            unique[n] = true\n        }\n    }\n    return\
    \ res\n}\n", "    if len(numbers) == 0 {\n        return numbers\n    }\n    var\
    \ unique []int\n    uniques := make(map[int]int)\n    for _, i := range numbers\
    \ {\n        uniques[i]++\n    }\n    for i, c := range uniques {\n        if\
    \ c == 1 {\n            unique = append(unique, i)\n        }\n    }\n    return\
    \ unique\n}\n", "    var results []int\n    var exists bool\n    for _, number\
    \ := range numbers {\n        exists = false\n        for _, result := range results\
    \ {\n            if number == result {\n                exists = true\n      \
    \          break\n            }\n        }\n        if !exists {\n           \
    \ results = append(results, number)\n        }\n    }\n    return results\n}\n",
  "    result := []int{}\n    for i, n := range numbers {\n        if i == 0 || numbers[i-1]\
    \ != n {\n            result = append(result, n)\n        }\n    }\n    return\
    \ result\n}\n", "    var result []int\n    m := make(map[int]bool)\n    for _,\
    \ number := range numbers {\n        if _, ok := m[number]; !ok {\n          \
    \  m[number] = true\n            result = append(result, number)\n        }\n\
    \    }\n    return result\n}\n", "    result := []int{}\n    for i := 0; i < len(numbers);\
    \ i++ {\n        if !contains(result, numbers[i]) {\n            result = append(result,\
    \ numbers[i])\n        }\n    }\n    return result\n}\n", "    result := []int{}\n\
    \    checked := map[int]bool{}\n    for _, num := range numbers {\n        if\
    \ !checked[num] {\n            result = append(result, num)\n            checked[num]\
    \ = true\n        }\n    }\n    return result\n}\n", "    m := make(map[int]bool)\n\
    \    var res []int\n    for _, v := range numbers {\n        if _, ok := m[v];\
    \ !ok {\n            m[v] = true\n            res = append(res, v)\n        }\n\
    \    }\n    return res\n}\n", "    unique_numbers := []int{}\n    for _, num :=\
    \ range numbers {\n        if !number_found(unique_numbers, num) {\n         \
    \   unique_numbers = append(unique_numbers, num)\n        }\n    }\n    return\
    \ unique_numbers\n}\n", "    dupe_map := make(map[int]bool)\n    unique_arr :=\
    \ make([]int, 0)\n    for _, x := range numbers {\n        if _, ok := dupe_map[x];\
    \ !ok {\n            dupe_map[x] = true\n            unique_arr = append(unique_arr,\
    \ x)\n        }\n    }\n    return unique_arr\n}\n", "    if numbers == nil {\n\
    \        return nil\n    }\n    if len(numbers) == 0 {\n        return numbers\n\
    \    }\n    if len(numbers) == 1 {\n        return numbers\n    }\n    for i,\
    \ v := range numbers {\n        for j := i + 1; j < len(numbers); j++ {\n    \
    \        if v == numbers[j] {\n                numbers = append(numbers[:j], numbers[j+1:]...)\n\
    \                j--\n            }\n        }\n    }\n    return numbers\n}\n",
  "    result := []int{}\n    for _, number := range numbers {\n        if !find_number(result,\
    \ number) {\n            result = append(result, number)\n        }\n    }\n \
    \   return result\n}\n", "    var uniques []int\n    var count map[int]int = make(map[int]int)\n\
    \    for _, number := range numbers {\n        count[number]++\n    }\n    for\
    \ _, number := range numbers {\n        if count[number] == 1 {\n            uniques\
    \ = append(uniques, number)\n        }\n    }\n    return uniques\n}\n", "   \
    \ var unique []int\n\n    for _, n := range numbers {\n        for i, n2 := range\
    \ unique {\n            if n == n2 {\n                unique = append(unique[:i],\
    \ unique[i+1:]...)\n                break\n            }\n        }\n        unique\
    \ = append(unique, n)\n    }\n\n    return unique\n}\n", "    // TODO\n    m :=\
    \ make(map[int]int)\n    for _, n := range numbers {\n        m[n] += 1\n    }\n\
    \    var res []int\n    for k, v := range m {\n        if v == 1 {\n         \
    \   res = append(res, k)\n        }\n    }\n    return res\n}\n", "    if numbers\
    \ == nil {\n        return nil\n    }\n    return append(remove_duplicates_recursive(numbers,\
    \ []int{}, 0, 0),\n                  remove_duplicates_recursive(numbers, []int{},\
    \ 1, 0)...)\n}\n", "    if len(numbers) == 0 {\n        return numbers\n    }\n\
    \    var i int\n    var out_numbers []int\n    var last_number int = numbers[0]\n\
    \    out_numbers = append(out_numbers, last_number)\n    for i = 1; i < len(numbers);\
    \ i++ {\n        if numbers[i] != last_number {\n            out_numbers = append(out_numbers,\
    \ numbers[i])\n            last_number = numbers[i]\n        }\n    }\n    return\
    \ out_numbers\n}\n", "    // remove duplicates\n    if len(numbers) <= 1 {\n \
    \       return numbers\n    }\n    // create set\n    set := make(map[int]bool)\n\
    \    result := make([]int, 0)\n    for _, v := range numbers {\n        if !set[v]\
    \ {\n            set[v] = true\n            result = append(result, v)\n     \
    \   }\n    }\n    return result\n}\n", "    var result []int\n    seen := make(map[int]bool)\n\
    \    for _, n := range numbers {\n        if seen[n] == false {\n            result\
    \ = append(result, n)\n            seen[n] = true\n        }\n    }\n    return\
    \ result\n}\n", "    seen := make(map[int]bool)\n    for i, x := range numbers\
    \ {\n        if !seen[x] {\n            seen[x] = true\n            numbers[i]\
    \ = x\n        } else {\n            numbers[i] = 0\n        }\n    }\n    j :=\
    \ 0\n    for i := 0; i < len(numbers); i++ {\n        if numbers[i] != 0 {\n \
    \           numbers[j] = numbers[i]\n            j++\n        }\n    }\n    return\
    \ numbers[:j]\n}\n", "    var stack []int\n    for _, v := range numbers {\n \
    \       if len(stack) == 0 {\n            stack = append(stack, v)\n        }\
    \ else {\n            exists := false\n            for i, vv := range stack {\n\
    \                if v == vv {\n                    exists = true\n           \
    \         stack = append(stack[:i], stack[i+1:]...)\n                    break\n\
    \                }\n            }\n            if !exists {\n                stack\
    \ = append(stack, v)\n            }\n        }\n    }\n    return stack\n}\n",
  "    m := make(map[int]bool)\n    result := make([]int, 0)\n    for _, i := range\
    \ numbers {\n        if _, found := m[i]; !found {\n            m[i] = true\n\
    \            result = append(result, i)\n        }\n    }\n    return result\n\
    }\n", "    mymap := make(map[int]bool)\n    result := []int{}\n    for _, elem\
    \ := range numbers {\n        if mymap[elem] == false {\n            mymap[elem]\
    \ = true\n            result = append(result, elem)\n        }\n    }\n    return\
    \ result\n}\n", "    var result []int\n    seen := make(map[int]bool)\n    for\
    \ _, number := range numbers {\n        if _, ok := seen[number]; !ok {\n    \
    \        result = append(result, number)\n            seen[number] = true\n  \
    \      }\n    }\n    return result\n}\n", "    var uniques []int\n\n    for _,\
    \ num := range numbers {\n        if !in_list(num, uniques) {\n            uniques\
    \ = append(uniques, num)\n        }\n    }\n\n    return uniques\n}\n", "    result\
    \ := []int{}\n    occurences := map[int]int{}\n    for _, v := range numbers {\n\
    \        if occurences[v] == 0 {\n            result = append(result, v)\n   \
    \     }\n        occurences[v]++\n    }\n    return result\n}\n", "    unique\
    \ := make(map[int]bool)\n    result := make([]int, 0)\n    for _, number := range\
    \ numbers {\n        if !unique[number] {\n            unique[number] = true\n\
    \            result = append(result, number)\n        }\n    }\n    return result\n\
    }\n", "    fmt.Println(\"remove_duplicates(\", numbers, \")\")\n    k := 0\n \
    \   for i := 0; i < len(numbers); i++ {\n        for j := 0; j < k; j++ {\n  \
    \          if numbers[i] == numbers[j] {\n                goto Here\n        \
    \    }\n        }\n        numbers[k] = numbers[i]\n        k++\nHere:\n    }\n\
    \    numbers = numbers[:k]\n    fmt.Println(\"result:\", numbers)\n    return\
    \ numbers\n}\n", "    var result []int\n    for i, n := range numbers {\n    \
    \    if !has_other_occurence(numbers, i, n) {\n            result = append(result,\
    \ n)\n        }\n    }\n    return result\n}\n", "    result := []int{}\n    for\
    \ _, v := range numbers {\n        found := false\n        for _, v2 := range\
    \ result {\n            if v == v2 {\n                found = true\n         \
    \       break\n            }\n        }\n        if !found {\n            result\
    \ = append(result, v)\n        }\n    }\n    return result\n}\n", "    numbersMap\
    \ := make(map[int]bool)\n    var result []int\n    for _, num := range numbers\
    \ {\n        if !numbersMap[num] {\n            numbersMap[num] = true\n     \
    \       result = append(result, num)\n        }\n    }\n    return result\n}\n",
  "    length := len(numbers)\n    if length == 0 {\n        return numbers\n    }\n\
    \    unique := make([]int, 0, length)\n    unique_m := make(map[int]bool)\n  \
    \  for _, n := range numbers {\n        if !unique_m[n] {\n            unique\
    \ = append(unique, n)\n            unique_m[n] = true\n        }\n    }\n    return\
    \ unique\n}\n", "    var result []int\n    numbers_set := make(map[int]int)\n\
    \    for _, e := range numbers {\n        numbers_set[e]++\n    }\n    for _,\
    \ e := range numbers {\n        if numbers_set[e] == 1 {\n            result =\
    \ append(result, e)\n        }\n    }\n    return result\n}\n", "    // Create\
    \ a map of all unique elements.\n    uniques := map[int]bool{}\n    for _, number\
    \ := range numbers {\n        uniques[number] = true\n    }\n\n    // Place all\
    \ unique elements into a slice.\n    result := []int{}\n    for number := range\
    \ uniques {\n        result = append(result, number)\n    }\n    return result\n\
    }\n", "    result := []int{}\n    var sliceCount = len(numbers)\n    var prevNumber\
    \ int\n    for i := 0; i < sliceCount; i++ {\n        if i == 0 {\n          \
    \  prevNumber = numbers[i]\n            result = append(result, prevNumber)\n\
    \        } else {\n            if numbers[i] != prevNumber {\n               \
    \ result = append(result, numbers[i])\n                prevNumber = numbers[i]\n\
    \            }\n        }\n    }\n    return result\n}\n", "    var m = make(map[int]bool)\n\
    \    for _, n := range numbers {\n        m[n] = true\n    }\n    var result []int\n\
    \    for k, _ := range m {\n        result = append(result, k)\n    }\n    return\
    \ result\n}\n", "    seen := make(map[int]bool)\n    var result []int\n    for\
    \ _, n := range numbers {\n        if !seen[n] {\n            seen[n] = true\n\
    \            result = append(result, n)\n        }\n    }\n    return result\n\
    }\n", "    var nums []int\n    for _, number := range numbers {\n        // Check\
    \ for duplicates\n        exists := false\n        for _, num := range nums {\n\
    \            if num == number {\n                exists = true\n             \
    \   break\n            }\n        }\n        if !exists {\n            nums =\
    \ append(nums, number)\n        }\n    }\n    return nums\n}\n", "    var set\
    \ map[int]bool = make(map[int]bool)\n    var result []int = make([]int, 0)\n \
    \   for _, n := range numbers {\n        if set[n] {\n            continue\n \
    \       }\n        set[n] = true\n        result = append(result, n)\n    }\n\
    \    return result\n}\n", "    new_list := []int{}\n    for _, n := range numbers\
    \ {\n        contains := false\n        for _, existing := range new_list {\n\
    \            if n == existing {\n                contains = true\n           \
    \     break\n            }\n        }\n        if !contains {\n            new_list\
    \ = append(new_list, n)\n        }\n    }\n    return new_list\n}\n", "    set\
    \ := make(map[int]bool)\n    unique := make([]int, 0)\n    for _, i := range numbers\
    \ {\n        if _, found := set[i]; !found {\n            set[i] = true\n    \
    \        unique = append(unique, i)\n        }\n    }\n    return unique\n}\n",
  "    result := []int{}\n    for _, n := range numbers {\n        if !contains(result,\
    \ n) {\n            result = append(result, n)\n        }\n    }\n    return result\n\
    }\n", "    var result []int\n\n    if len(numbers) == 0 {\n        return result\n\
    \    }\n\n    temp := make(map[int]bool)\n    for _, number := range numbers {\n\
    \        if temp[number] {\n            continue\n        }\n        temp[number]\
    \ = true\n        result = append(result, number)\n    }\n\n    return result\n\
    }\n", "    result := []int{}\n    unique := make(map[int]bool)\n    for _, number\
    \ := range numbers {\n        if _, ok := unique[number]; !ok {\n            unique[number]\
    \ = true\n            result = append(result, number)\n        }\n    }\n    return\
    \ result\n}\n", "    seen := make(map[int]bool)\n    result := make([]int, 0)\n\
    \    for _, num := range numbers {\n        if !seen[num] {\n            seen[num]\
    \ = true\n            result = append(result, num)\n        }\n    }\n    return\
    \ result\n}\n", "    var result []int\n    for _, num := range numbers {\n   \
    \     if !contains(result, num) {\n            result = append(result, num)\n\
    \        }\n    }\n    return result\n}\n", "    var result []int\n    var m =\
    \ make(map[int]bool)\n    for _, n := range numbers {\n        if _, ok := m[n];\
    \ !ok {\n            m[n] = true\n            result = append(result, n)\n   \
    \     }\n    }\n    return result\n}\n", "    seen := make(map[int]bool)\n   \
    \ result := make([]int, 0)\n    for _, number := range numbers {\n        if !seen[number]\
    \ {\n            seen[number] = true\n            result = append(result, number)\n\
    \        }\n    }\n    return result\n}\n", "    m := make(map[int]int)\n    for\
    \ _, v := range numbers {\n        m[v]++\n    }\n    var result []int\n    for\
    \ _, v := range numbers {\n        if m[v] == 1 {\n            result = append(result,\
    \ v)\n        }\n    }\n    return result\n}\n", "    elements := map[int]bool{}\n\
    \    result := []int{}\n\n    for _, n := range numbers {\n        if _, ok :=\
    \ elements[n]; !ok {\n            elements[n] = true\n            result = append(result,\
    \ n)\n        }\n    }\n\n    return result\n}\n", "    m := make(map[int]int)\n\
    \    for _, n := range numbers {\n        m[n]++\n    }\n    result := make([]int,\
    \ 0)\n    for _, n := range numbers {\n        if m[n] == 1 {\n            result\
    \ = append(result, n)\n        }\n    }\n    return result\n}\n", "    dict :=\
    \ make(map[int]int)\n    for _, v := range numbers {\n        dict[v]++\n    }\n\
    \    var answer []int\n    for k, v := range dict {\n        if v == 1 {\n   \
    \         answer = append(answer, k)\n        }\n    }\n    return answer\n}\n",
  "    result := []int{}\n    already_seen := map[int]bool{}\n    for _, n := range\
    \ numbers {\n        if _, ok := already_seen[n]; !ok {\n            already_seen[n]\
    \ = true\n            result = append(result, n)\n        }\n    }\n    return\
    \ result\n}\n", "    m := make(map[int]bool)\n    var uniques []int\n    for _,\
    \ n := range numbers {\n        if _, ok := m[n]; !ok {\n            m[n] = true\n\
    \            uniques = append(uniques, n)\n        }\n    }\n    return uniques\n\
    }\n", "    unique := make(map[int]bool)\n    result := make([]int, 0)\n    for\
    \ _, element := range numbers {\n        if !unique[element] {\n            unique[element]\
    \ = true\n            result = append(result, element)\n        }\n    }\n   \
    \ return result\n}\n", "    deduped := []int{}\n    nIndex := map[int]int{}\n\
    \    for _, n := range numbers {\n        nIndex[n] += 1\n    }\n    for _, n\
    \ := range numbers {\n        if nIndex[n] == 1 {\n            deduped = append(deduped,\
    \ n)\n        }\n    }\n    return deduped\n}\n", "    values := make(map[int]int)\n\
    \    for _, value := range numbers {\n        values[value]++\n    }\n    var\
    \ result []int\n    for _, value := range numbers {\n        if values[value]\
    \ == 1 {\n            result = append(result, value)\n        }\n    }\n    return\
    \ result\n}\n", "    // Use a map to keep track of which number we have already\
    \ seen.\n    seen := make(map[int]bool)\n    result := make([]int, 0)\n    for\
    \ _, number := range numbers {\n        if _, exists := seen[number]; !exists\
    \ {\n            result = append(result, number)\n            seen[number] = true\n\
    \        }\n    }\n    return result\n}\n", "    if len(numbers) < 2 {\n     \
    \   return numbers\n    }\n    result := make([]int, 0, len(numbers))\n    m :=\
    \ make(map[int]bool)\n    for _, n := range numbers {\n        if !m[n] {\n  \
    \          result = append(result, n)\n            m[n] = true\n        }\n  \
    \  }\n    return result\n}\n", "    var result []int\n    count := make(map[int]int)\n\
    \    for _, v := range numbers {\n        count[v] += 1\n    }\n    for _, v :=\
    \ range numbers {\n        if count[v] == 1 {\n            result = append(result,\
    \ v)\n        }\n    }\n    return result\n}\n", "    mem := make(map[int]bool)\n\
    \    result := make([]int, 0)\n    for _, value := range numbers {\n        if\
    \ _, ok := mem[value]; !ok {\n            mem[value] = true\n            result\
    \ = append(result, value)\n        }\n    }\n    return result\n}\n", "    seen\
    \ := make(map[int]bool)\n    final := make([]int, 0)\n    for _, number := range\
    \ numbers {\n        if seen[number] {\n            continue\n        }\n    \
    \    seen[number] = true\n        final = append(final, number)\n    }\n    return\
    \ final\n}\n", "    var s []int\n    m := make(map[int]bool)\n\n    for _, e :=\
    \ range numbers {\n        if _, ok := m[e]; !ok {\n            m[e] = true\n\
    \            s = append(s, e)\n        }\n    }\n    return s\n}\n", "    var\
    \ r []int\n    for i := 0; i < len(numbers); i++ {\n        if count(numbers,\
    \ numbers[i]) == 1 {\n            r = append(r, numbers[i])\n        }\n    }\n\
    \    return r\n}\n", "    if len(numbers) == 0 {\n        return numbers\n   \
    \ }\n    set := make(map[int]int)\n    for _, number := range numbers {\n    \
    \    set[number] += 1\n    }\n    var result []int\n    for _, number := range\
    \ numbers {\n        if set[number] == 1 {\n            result = append(result,\
    \ number)\n        }\n    }\n    return result\n}\n", "    output := []int{}\n\
    \    for _, n := range numbers {\n        if !contains(output, n) {\n        \
    \    output = append(output, n)\n        }\n    }\n    return output\n}\n", " \
    \   output := []int{}\n    for _, number := range numbers {\n        if !contains(output,\
    \ number) {\n            output = append(output, number)\n        }\n    }\n \
    \   return output\n}\n", "    result := []int{}\n    seen := make(map[int]bool)\n\
    \    for _, n := range numbers {\n        if !seen[n] {\n            result =\
    \ append(result, n)\n            seen[n] = true\n        }\n    }\n    return\
    \ result\n}\n", "    seen := make(map[int]bool)\n    result := make([]int, 0)\n\
    \    for _, number := range numbers {\n        if !seen[number] {\n          \
    \  seen[number] = true\n            result = append(result, number)\n        }\n\
    \    }\n    return result\n}\n", "    var no_dups []int\n    var seen = make(map[int]bool)\n\
    \    for _, x := range numbers {\n        if seen[x] {\n            continue\n\
    \        }\n        seen[x] = true\n        no_dups = append(no_dups, x)\n   \
    \ }\n    return no_dups\n}\n", "    var prev_num int\n    var prev_num_cnt int\n\
    \    result := make([]int, 0)\n    for _, num := range numbers {\n        if num\
    \ == prev_num {\n            prev_num_cnt++\n        } else {\n            if\
    \ prev_num_cnt == 1 {\n                result = append(result, prev_num)\n   \
    \         }\n            prev_num = num\n            prev_num_cnt = 1\n      \
    \  }\n    }\n    if prev_num_cnt == 1 {\n        result = append(result, prev_num)\n\
    \    }\n    return result\n}\n", "    result := []int{}\n    for _, num := range\
    \ numbers {\n        found := false\n        for _, item := range result {\n \
    \           if item == num {\n                found = true\n                break\n\
    \            }\n        }\n        if !found {\n            result = append(result,\
    \ num)\n        }\n    }\n    return result\n}\n", "    var uniqueNumbers []int\n\
    \n    var count map[int]int\n    count = make(map[int]int)\n\n    for _, v :=\
    \ range numbers {\n        count[v]++\n    }\n\n    for _, v := range numbers\
    \ {\n        if count[v] == 1 {\n            uniqueNumbers = append(uniqueNumbers,\
    \ v)\n        }\n    }\n\n    return uniqueNumbers\n}\n", "    result := []int{}\n\
    \    set := make(map[int]bool)\n    for _, v := range numbers {\n        if !set[v]\
    \ {\n            result = append(result, v)\n            set[v] = true\n     \
    \   }\n    }\n    return result\n}\n", "    m := make(map[int]bool)\n    result\
    \ := make([]int, 0)\n    for _, v := range numbers {\n        if m[v] {\n    \
    \        continue\n        }\n        m[v] = true\n        result = append(result,\
    \ v)\n    }\n    return result\n}\n", "    m := make(map[int]int)\n    for _,\
    \ n := range numbers {\n        m[n]++\n    }\n    var result []int\n    for n,\
    \ c := range m {\n        if c == 1 {\n            result = append(result, n)\n\
    \        }\n    }\n    return result\n}\n", "    result := []int{}\n    var set\
    \ map[int]bool = make(map[int]bool)\n    for _, el := range numbers {\n      \
    \  if !set[el] {\n            result = append(result, el)\n            set[el]\
    \ = true\n        }\n    }\n    return result\n}\n", "    var filteredNumbers\
    \ []int\n    uniques := make(map[int]bool)\n    for _, number := range numbers\
    \ {\n        if _, ok := uniques[number]; !ok {\n            uniques[number] =\
    \ true\n            filteredNumbers = append(filteredNumbers, number)\n      \
    \  }\n    }\n    return filteredNumbers\n}\n", "    var output = []int{}\n   \
    \ var exists = map[int]bool{}\n    for _, number := range numbers {\n        if\
    \ _, ok := exists[number]; !ok {\n            output = append(output, number)\n\
    \            exists[number] = true\n        }\n    }\n    return output\n}\n",
  "    uniques := make([]int, 0)\n    for _, number := range numbers {\n        if\
    \ !contains(uniques, number) {\n            uniques = append(uniques, number)\n\
    \        }\n    }\n    return uniques\n}\n", "    var filtered []int\n\n    for\
    \ _, v := range numbers {\n        if indexOf(filtered, v) == -1 {\n         \
    \   filtered = append(filtered, v)\n        }\n    }\n\n    return filtered\n\
    }\n", "    elements := make(map[int]bool)\n    result := []int{}\n\n    for _,\
    \ n := range numbers {\n        if !elements[n] {\n            elements[n] = true\n\
    \            result = append(result, n)\n        }\n    }\n\n    return result\n\
    }\n", "    // Make a map to store the number of occurrences of each element\n\
    \    occurences := make(map[int]int)\n    // Find duplicates\n    for _, n :=\
    \ range numbers {\n        occurences[n] += 1\n    }\n    // Go over the input\
    \ again and remove all duplicates\n    // using a nice Go trick\n    var result\
    \ []int\n    for _, n := range numbers {\n        if occurences[n] == 1 {\n  \
    \          result = append(result, n)\n        }\n    }\n    return result\n}\n",
  "    result := []int{}\n    seen := make(map[int]bool)\n    for _, number := range\
    \ numbers {\n        if !seen[number] {\n            result = append(result, number)\n\
    \            seen[number] = true\n        }\n    }\n    return result\n}\n\ntype\
    \ testpair ", "    if numbers == nil {\n        return nil\n    }\n    var result\
    \ []int\n    var foundMap = make(map[int]bool)\n    for _, v := range numbers\
    \ {\n        if _, ok := foundMap[v]; !ok {\n            result = append(result,\
    \ v)\n            foundMap[v] = true\n        }\n    }\n    return result\n}\n",
  '    seen := make(map[int]', "    var result []int\n    for _, value := range numbers\
    \ {\n        if len(result) == 0 {\n            result = append(result, value)\n\
    \        } else {\n            unique := true\n            for _, v := range result\
    \ {\n                if v == value {\n                    unique = false\n   \
    \                 break\n                }\n            }\n            if unique\
    \ {\n                result = append(result, value)\n            }\n        }\n\
    \    }\n    return result\n}\n", "    counter := make(map[int]int)\n    for _,\
    \ v := range numbers {\n        counter[v] += 1\n    }\n    var result []int\n\
    \    for _, v := range numbers {\n        if counter[v] == 1 {\n            result\
    \ = append(result, v)\n        }\n    }\n    return result\n}\n", "    if len(numbers)\
    \ == 0 {\n        return numbers\n    }\n    result := make([]int, 0, len(numbers))\n\
    \    temp := make(map[int]bool)\n    for _, val := range numbers {\n        if\
    \ _, ok := temp[val]; !ok {\n            temp[val] = true\n            result\
    \ = append(result, val)\n        }\n    }\n    return result\n}\n", "    seen\
    \ := make(map[int]bool)\n    result := make([]int, 0)\n    for _, number := range\
    \ numbers {\n        if seen[number] == false {\n            seen[number] = true\n\
    \            result = append(result, number)\n        }\n    }\n    return result\n\
    }\n", "    var uniques []int\n    var dedup = make(map[int]bool)\n    for _, n\
    \ := range numbers {\n        if !dedup[n] {\n            uniques = append(uniques,\
    \ n)\n            dedup[n] = true\n        }\n    }\n    return uniques\n}\n",
  "    // your code here\n    return []int{}\n}\n", "    var seen map[int]bool = make(map[int]bool)\n\
    \    var unique []int\n    for _, number := range numbers {\n        if !seen[number]\
    \ {\n            seen[number] = true\n            unique = append(unique, number)\n\
    \        }\n    }\n    return unique\n}\n", "    unique := []int{}\n    uniq_set\
    \ := make(map[int]bool)\n    for _, value := range numbers {\n        _, is_present\
    \ := uniq_set[value]\n        if !is_present {\n            uniq_set[value] =\
    \ true\n            unique = append(unique, value)\n        }\n    }\n    return\
    \ unique\n}\n", "    unique := make(map[int]bool)\n    result := make([]int, 0)\n\
    \    for _, item := range numbers {\n        if _, found := unique[item]; !found\
    \ {\n            unique[item] = true\n            result = append(result, item)\n\
    \        }\n    }\n    return result\n}\n", "    var newList []int\n    seen :=\
    \ make(map[int]int)\n    for _, number := range numbers {\n        seen[number]++\n\
    \    }\n    for _, number := range numbers {\n        if seen[number] == 1 {\n\
    \            newList = append(newList, number)\n        }\n    }\n    return newList\n\
    }\n", "    noDupes := make([]int, 0)\n    for _, number := range numbers {\n \
    \       if !contains(noDupes, number) {\n            noDupes = append(noDupes,\
    \ number)\n        }\n    }\n    return noDupes\n}\n", "    output := []int{}\n\
    \    for _, number := range numbers {\n        if !contains(output, number) {\n\
    \            output = append(output, number)\n        }\n    }\n    return output\n\
    }\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
