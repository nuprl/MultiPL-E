name: HumanEval_9_rolling_max
language: go_test.go
prompt: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
  // From a given list of integers, generate a list of rolling maximum element found\
  \ until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2, 3, 2,\
  \ 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int) []int\
  \ {\n"
tests: "func TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test\
  \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests :=\
  \ []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
  \ candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
  \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2,\
  \ 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range\
  \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\
  \tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
  \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\
  \t}\n}\n"
completions: ["    rolling_max := make([]int, len(numbers))\n    for i, _ := range\
    \ numbers {\n        if i == 0 {\n            rolling_max[i] = numbers[i]\n  \
    \      } else {\n            if numbers[i] > rolling_max[i-1] {\n            \
    \    rolling_max[i] = numbers[i]\n            } else {\n                rolling_max[i]\
    \ = rolling_max[i-1]\n            }\n        }\n    }\n    return rolling_max\n\
    }\n", "    // TODO: implement me\n    return []int{1, 2, 3, 3, 3, 4, 4}\n}\n",
  "    var max int\n    res := make([]int, len(numbers))\n    for i, e := range numbers\
    \ {\n        if i == 0 {\n            max = e\n        } else {\n            if\
    \ e > max {\n                max = e\n            }\n        }\n        res[i]\
    \ = max\n    }\n    return res\n}\n", "    result := make([]int, len(numbers))\n\
    \    for i, number := range numbers {\n        if i == 0 {\n            result[i]\
    \ = number\n        } else {\n            if number > result[i-1] {\n        \
    \        result[i] = number\n            } else {\n                result[i] =\
    \ result[i-1]\n            }\n        }\n    }\n    return result\n}\n", "   \
    \ var (\n        maxs = make([]int, len(numbers))\n        max = numbers[0]\n\
    \    )\n    for i, n := range numbers {\n        if n > max {\n            max\
    \ = n\n        }\n        maxs[i] = max\n    }\n    return maxs\n}\n", "    rolling_max_list\
    \ := make([]int, len(numbers))\n    var max = numbers[0]\n    for idx, num :=\
    \ range numbers {\n        if num > max {\n            max = num\n        }\n\
    \        rolling_max_list[idx] = max\n    }\n    return rolling_max_list\n}\n",
  "    max := numbers[0]\n    result := make([]int, len(numbers))\n    result[0] =\
    \ max\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] > max {\n\
    \            max = numbers[i]\n        }\n        result[i] = max\n    }\n   \
    \ return result\n}\n", "    var result []int\n    if len(numbers) == 0 {\n   \
    \     return result\n    }\n    var lastMax int = numbers[0]\n    result = append(result,\
    \ lastMax)\n    for _, n := range numbers[1:] {\n        if n > lastMax {\n  \
    \          lastMax = n\n        }\n        result = append(result, lastMax)\n\
    \    }\n    return result\n}\n", "    m := []int{}\n    for i, number := range\
    \ numbers {\n        if i == 0 {\n            m = append(m, number)\n        }\
    \ else {\n            if number > m[i-1] {\n                m = append(m, number)\n\
    \            } else {\n                m = append(m, m[i-1])\n            }\n\
    \        }\n    }\n    return m\n}\n", "    var max int\n    var result []int\n\
    \    for _, number := range numbers {\n        if number > max {\n           \
    \ max = number\n        }\n        result = append(result, max)\n    }\n    return\
    \ result\n}\n", "    var result []int\n\n    if len(numbers) > 0 {\n        result\
    \ = append(result, numbers[0])\n    }\n\n    for i, number := range numbers {\n\
    \        if i > 0 {\n            previous := result[i - 1]\n            if number\
    \ > previous {\n                result = append(result, number)\n            }\
    \ else {\n                result = append(result, previous)\n            }\n \
    \       }\n    }\n\n    return result\n}\n", "    result := make([]int, len(numbers))\n\
    \    max := numbers[0]\n    result[0] = max\n    for i := 1; i < len(numbers);\
    \ i++ {\n        if numbers[i] > max {\n            max = numbers[i]\n       \
    \ }\n        result[i] = max\n    }\n    return result\n}\n", "    var n = len(numbers)\n\
    \    if n == 0 {\n        return numbers\n    }\n    var result = make([]int,\
    \ n)\n    result[0] = numbers[0]\n    for i := 1; i < n; i++ {\n        if numbers[i]\
    \ > result[i-1] {\n            result[i] = numbers[i]\n        } else {\n    \
    \        result[i] = result[i-1]\n        }\n    }\n    return result\n}\n", " \
    \   result := make([]int, len(numbers))\n    result[0] = numbers[0]\n    for i\
    \ := 1; i < len(numbers); i++ {\n        if numbers[i] > result[i-1] {\n     \
    \       result[i] = numbers[i]\n        } else {\n            result[i] = result[i-1]\n\
    \        }\n    }\n    return result\n}\n", "    if len(numbers) == 0 {\n    \
    \    return []int{}\n    }\n    rolling_max_numbers := make([]int, len(numbers))\n\
    \    rolling_max_numbers[0] = numbers[0]\n    max := numbers[0]\n    for i, n\
    \ := range numbers[1:] {\n        if n > max {\n            max = n\n        }\n\
    \        rolling_max_numbers[i+1] = max\n    }\n    return rolling_max_numbers\n\
    }\n", "    result := make([]int, len(numbers))\n    maxValue := numbers[0]\n \
    \   result[0] = maxValue\n    for i := 1; i < len(numbers); i++ {\n        result[i]\
    \ = result[i-1]\n        if maxValue < numbers[i] {\n            maxValue = numbers[i]\n\
    \            result[i] = maxValue\n        }\n    }\n    return result\n}\n",
  "    rolling_max := make([]int, len(numbers))\n    for i, x := range numbers {\n\
    \        rolling_max[i] = x\n        for j := 0; j < i; j++ {\n            if\
    \ rolling_max[j] > rolling_max[i] {\n                rolling_max[i] = rolling_max[j]\n\
    \            }\n        }\n    }\n    return rolling_max\n}\n", "    var rolling_max\
    \ []int\n    max := 0\n    for _, n := range numbers {\n        if n > max {\n\
    \            max = n\n        }\n        rolling_max = append(rolling_max, max)\n\
    \    }\n    return rolling_max\n}\n", "    result := make([]int, len(numbers))\n\
    \    result[0] = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n       \
    \ if numbers[i] > result[i-1] {\n            result[i] = numbers[i]\n        }\
    \ else {\n            result[i] = result[i-1]\n        }\n    }\n    return result\n\
    }\n", "    if len(numbers) == 0 {\n        return []int{}\n    }\n\n    max :=\
    \ numbers[0]\n    result := []int{max}\n\n    for _, number := range numbers[1:]\
    \ {\n        if number > max {\n            max = number\n        }\n        result\
    \ = append(result, max)\n    }\n\n    return result\n}\n", "    max := make([]int,\
    \ len(numbers))\n    for i, v := range numbers {\n        if i == 0 {\n      \
    \      max[i] = v\n        } else {\n            if max[i-1] > v {\n         \
    \       max[i] = max[i-1]\n            } else {\n                max[i] = v\n\
    \            }\n        }\n    }\n    return max\n}\n", "    maxSoFar := numbers[0]\n\
    \    rollingMax := make([]int, len(numbers))\n    rollingMax[0] = maxSoFar\n \
    \   for index, value := range numbers[1:] {\n        if value > maxSoFar {\n \
    \           maxSoFar = value\n        }\n        rollingMax[index + 1] = maxSoFar\n\
    \    }\n    return rollingMax\n}\n", "    var result []int\n\n    for _, num :=\
    \ range numbers {\n        result = append(result, max(num, result))\n    }\n\n\
    \    return result\n}\n", "    r := make([]int, len(numbers))\n    // copy first\
    \ element\n    r[0] = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n  \
    \      if numbers[i] > r[i-1] {\n            r[i] = numbers[i]\n        } else\
    \ {\n            r[i] = r[i-1]\n        }\n    }\n    return r\n}\n", "    window\
    \ := []int{}\n    rolling_max := []int{}\n    for _, num := range numbers {\n\
    \        for i := len(window) - 1; i >= 0; i-- {\n            if window[i] >=\
    \ num {\n                window = window[:i]\n            }\n        }\n     \
    \   window = append(window, num)\n        rolling_max = append(rolling_max, window[0])\n\
    \    }\n    return rolling_max\n}\n", "    var result []int\n    max := 0\n  \
    \  for _, v := range numbers {\n        if v > max {\n            max = v\n  \
    \      }\n        result = append(result, max)\n    }\n    return result\n}\n",
  "    length := len(numbers)\n    result := make([]int, length)\n    max := numbers[0]\n\
    \    result[0] = max\n    for i := 1; i < length; i++ {\n        if numbers[i]\
    \ > max {\n            max = numbers[i]\n        }\n        result[i] = max\n\
    \    }\n    return result\n}\n", "    var result []int\n\n    if len(numbers)\
    \ == 0 {\n        return result\n    }\n\n    result = append(result, numbers[0])\n\
    \n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] > result[i -\
    \ 1] {\n            result = append(result, numbers[i])\n        } else {\n  \
    \          result = append(result, result[i - 1])\n        }\n    }\n\n    return\
    \ result\n}\n", "    var maximum int\n    result := make([]int, len(numbers))\n\
    \    for i, number := range numbers {\n        if number > maximum {\n       \
    \     maximum = number\n        }\n        result[i] = maximum\n    }\n    return\
    \ result\n}\n", "    max := numbers[0]\n    output := []int{max}\n    for _, n\
    \ := range numbers[1:] {\n        if n > max {\n            max = n\n        }\n\
    \        output = append(output, max)\n    }\n    return output\n}\n", "    var\
    \ (\n        output []int\n        maxSoFar int\n    )\n\n    if len(numbers)\
    \ == 0 {\n        return output\n    }\n\n    maxSoFar = numbers[0]\n    output\
    \ = append(output, maxSoFar)\n\n    for _, n := range numbers[1:] {\n        if\
    \ n > maxSoFar {\n            maxSoFar = n\n        }\n        output = append(output,\
    \ maxSoFar)\n    }\n\n    return output\n}\n", "    max := make([]int, len(numbers))\n\
    \    max[0] = numbers[0]\n    for index, number := range numbers {\n        if\
    \ number > max[index] {\n            max[index] = number\n        } else {\n \
    \           max[index] = max[index - 1]\n        }\n    }\n    return max\n}\n",
  "    if len(numbers) == 0 {\n        return []int{}\n    }\n    roll_max := []int{numbers[0]}\n\
    \    for i := 1; i < len(numbers); i++ {\n        if numbers[i] > roll_max[i-1]\
    \ {\n            roll_max = append(roll_max, numbers[i])\n        } else {\n \
    \           roll_max = append(roll_max, roll_max[i-1])\n        }\n    }\n   \
    \ return roll_max\n}\n", "    length := len(numbers)\n    max_numbers := make([]int,\
    \ length)\n    if length == 0 {\n        return max_numbers\n    }\n    max_numbers[0]\
    \ = numbers[0]\n    for i := 1; i < length; i++ {\n        if numbers[i] > max_numbers[i-1]\
    \ {\n            max_numbers[i] = numbers[i]\n        } else {\n            max_numbers[i]\
    \ = max_numbers[i-1]\n        }\n    }\n    return max_numbers\n}\n", "    res\
    \ := make([]int, len(numbers))\n    var max int\n    for i, num := range numbers\
    \ {\n        if i == 0 {\n            max = num\n        } else {\n          \
    \  if num > max {\n                max = num\n            }\n        }\n     \
    \   res[i] = max\n    }\n    return res\n}\n", "    maxes := make([]int, len(numbers))\n\
    \    var max, pos int\n    max = numbers[0]\n    for pos, value := range numbers\
    \ {\n        if value > max {\n            max = value\n        }\n        maxes[pos]\
    \ = max\n    }\n    return maxes\n}\n", "    maximums := make([]int, len(numbers))\n\
    \    maximums[0] = numbers[0]\n    for idx, number := range numbers[1:] {\n  \
    \      if number > maximums[idx] {\n            maximums[idx + 1] = number\n \
    \       } else {\n            maximums[idx + 1] = maximums[idx]\n        }\n \
    \   }\n    return maximums\n}\n", "    var output []int\n    max := numbers[0]\n\
    \    for _, n := range numbers {\n        if n > max {\n            max = n\n\
    \        }\n        output = append(output, max)\n    }\n    return output\n}\n",
  "    var result []int\n    var max int\n\n    if len(numbers) == 0 {\n        return\
    \ result\n    }\n\n    max = numbers[0]\n    result = append(result, max)\n\n\
    \    for _, number := range numbers[1:] {\n        if number > max {\n       \
    \     max = number\n        }\n        result = append(result, max)\n    }\n\n\
    \    return result\n}\n", "    var r []int\n    if len(numbers) == 0 {\n     \
    \   return r\n    }\n    r = append(r, numbers[0])\n    for i := 1; i < len(numbers);\
    \ i++ {\n        r = append(r, max(r[i-1], numbers[i]))\n    }\n    return r\n\
    }\n", "    if len(numbers) == 0 {\n        return []int{}\n    }\n\n    max :=\
    \ numbers[0]\n    result := []int{max}\n\n    for _, num := range numbers[1:]\
    \ {\n        if num > max {\n            max = num\n        }\n        result\
    \ = append(result, max)\n    }\n\n    return result\n}\n", "    rolling_max :=\
    \ make([]int, len(numbers))\n    current_max := 0\n    for i, n := range numbers\
    \ {\n        current_max = int(math.Max(float64(current_max), float64(n)))\n \
    \       rolling_max[i] = current_max\n    }\n    return rolling_max\n}\n", " \
    \   results := make([]int, len(numbers))\n    max := numbers[0]\n    for i, e\
    \ := range numbers {\n        if e > max {\n            max = e\n        }\n \
    \       results[i] = max\n    }\n    return results\n}\n", "    result := make([]int,\
    \ len(numbers))\n    maximum := 0\n    for idx, val := range numbers {\n     \
    \   if val > maximum {\n            maximum = val\n        }\n        result[idx]\
    \ = maximum\n    }\n    return result\n}\n", "    max_numbers := make([]int, len(numbers))\n\
    \    max_number := numbers[0]\n    for i, number := range numbers {\n        if\
    \ number > max_number {\n            max_number = number\n        }\n        max_numbers[i]\
    \ = max_number\n    }\n    return max_numbers\n}\n", "    if numbers == nil ||\
    \ len(numbers) == 0 {\n        return numbers\n    }\n\n    res := make([]int,\
    \ len(numbers))\n    res[0] = numbers[0]\n    for i := 1; i < len(numbers); i++\
    \ {\n        if numbers[i] > res[i-1] {\n            res[i] = numbers[i]\n   \
    \     } else {\n            res[i] = res[i-1]\n        }\n    }\n\n    return\
    \ res\n}\n", "    max := -1\n    result := make([]int, len(numbers))\n    for\
    \ i, n := range numbers {\n        if n > max {\n            max = n\n       \
    \ }\n        result[i] = max\n    }\n    return result\n}\n", "    // Pad the\
    \ array with a zero, it's a trick to avoid many edge cases.\n    numbers = append([]int{0},\
    \ numbers...)\n    // Array that will hold the result.\n    rolling_max := make([]int,\
    \ len(numbers))\n    // Iterate over the entire array, starting from the second\
    \ element\n    // (which is actually the first element of the original sequence).\n\
    \    for i := 1; i < len(numbers); i++ {\n        // Set the current value to\
    \ the max between the current value and the\n        // value of the previous\
    \ element.\n        rolling_max[i] = max(numbers[i], rolling_max[i-1])\n    }\n\
    \    // Return only the original array (skipping the initial 0).\n    return rolling_max[1:]\n\
    }\n", "    output := make([]int, len(numbers))\n    var max int\n    for i, v\
    \ := range numbers {\n        if i == 0 {\n            max = v\n        } else\
    \ {\n            if v > max {\n                max = v\n            }\n      \
    \  }\n        output[i] = max\n    }\n    return output\n}\n", "    if len(numbers)\
    \ == 0 {\n        return []int{}\n    }\n    rollingMax := make([]int, len(numbers))\n\
    \    rollingMax[0] = numbers[0]\n    for i, n := range numbers[1:] {\n       \
    \ if n > rollingMax[i] {\n            rollingMax[i+1] = n\n        } else {\n\
    \            rollingMax[i+1] = rollingMax[i]\n        }\n    }\n    return rollingMax\n\
    }\n", "    max_element := numbers[0]\n    rolling_max := make([]int, len(numbers))\n\
    \    for index, number := range numbers {\n        if number > max_element {\n\
    \            max_element = number\n        }\n        rolling_max[index] = max_element\n\
    \    }\n    return rolling_max\n}\n", "    max := numbers[0]\n    rolling_max_list\
    \ := []int{max}\n    for _, n := range numbers[1:] {\n        if n > max {\n \
    \           max = n\n        }\n        rolling_max_list = append(rolling_max_list,\
    \ max)\n    }\n    return rolling_max_list\n}\n", "    max_so_far := numbers[0]\n\
    \    result := make([]int, len(numbers))\n    result[0] = max_so_far\n    for\
    \ index, number := range numbers[1:] {\n        if number > max_so_far {\n   \
    \         max_so_far = number\n        }\n        result[index + 1] = max_so_far\n\
    \    }\n    return result\n}\n", "    result := make([]int, len(numbers))\n  \
    \  result[0] = numbers[0]\n    for index, num := range numbers[1:] {\n       \
    \ if num > result[index] {\n            result[index + 1] = num\n        } else\
    \ {\n            result[index + 1] = result[index]\n        }\n    }\n    return\
    \ result\n}\n", "    result := make([]int, len(numbers))\n    max := numbers[0]\n\
    \    result[0] = max\n    for i, num := range numbers[1:] {\n        if num >\
    \ max {\n            max = num\n        }\n        result[i+1] = max\n    }\n\
    \    return result\n}\n", "    var result []int\n    for _, number := range numbers\
    \ {\n        if len(result) == 0 {\n            result = append(result, number)\n\
    \        } else {\n            if number > result[len(result) - 1] {\n       \
    \         result = append(result, number)\n            } else {\n            \
    \    result = append(result, result[len(result) - 1])\n            }\n       \
    \ }\n    }\n    return result\n}\n", "    if len(numbers) == 0 {\n        return\
    \ numbers\n    }\n    max := numbers[0]\n    result := []int{max}\n    for _,\
    \ n := range numbers[1:] {\n        if n > max {\n            max = n\n      \
    \  }\n        result = append(result, max)\n    }\n    return result\n}\n", " \
    \   out := make([]int, len(numbers))\n    if len(numbers) > 0 {\n        out[0]\
    \ = numbers[0]\n    }\n    for i, _ := range numbers {\n        if numbers[i]\
    \ > out[i] {\n            out[i] = numbers[i]\n        }\n    }\n    return out\n\
    }\n", "    result := make([]int, len(numbers))\n    result[0] = numbers[0]\n \
    \   for i, n := range numbers[1:] {\n        if n > result[i] {\n            result[i+1]\
    \ = n\n        } else {\n            result[i+1] = result[i]\n        }\n    }\n\
    \    return result\n}\n", "    max := make([]int, len(numbers))\n    max[0] =\
    \ numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] >\
    \ max[i-1] {\n            max[i] = numbers[i]\n        } else {\n            max[i]\
    \ = max[i-1]\n        }\n    }\n    return max\n}\n", "    result := make([]int,\
    \ len(numbers))\n    max := numbers[0]\n    result[0] = max\n    for i := 1; i\
    \ < len(numbers); i++ {\n        if numbers[i] > max {\n            max = numbers[i]\n\
    \        }\n        result[i] = max\n    }\n    return result\n}\n", "    // NOTE:\
    \ Problem asks not to alter the passed in slice, so we make a copy\n    // of\
    \ the passed in slice to work with.\n    // NOTE: Not using this because Go seems\
    \ to be doing an implicit copy\n    // of the slice.\n    //var numbers_copy []int\
    \ = make([]int, len(numbers))\n    //copy(numbers_copy, numbers)\n\n    var result\
    \ []int = make([]int, len(numbers))\n    var max_number int = numbers[0]\n   \
    \ for i, number := range numbers {\n        if number > max_number {\n       \
    \     max_number = number\n        }\n        result[i] = max_number\n    }\n\
    \    return result\n}\n", "    if len(numbers) < 1 {\n        return []int{}\n\
    \    }\n    result := make([]int, len(numbers))\n    result[0] = numbers[0]\n\
    \    for i := 1; i < len(numbers); i++ {\n        if numbers[i] > result[i-1]\
    \ {\n            result[i] = numbers[i]\n        } else {\n            result[i]\
    \ = result[i-1]\n        }\n    }\n    return result\n}\n", "    ans := make([]int,\
    \ len(numbers))\n    if len(numbers) < 1 {\n        return ans\n    }\n    ans[0]\
    \ = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        n := numbers[i]\n\
    \        m := ans[i-1]\n        if n > m {\n            ans[i] = n\n        }\
    \ else {\n            ans[i] = m\n        }\n    }\n    return ans\n}\n", "  \
    \  rolling_max := make([]int, len(numbers))\n    rolling_max[0] = numbers[0]\n\
    \    for index, number := range numbers {\n        if index == 0 {\n         \
    \   continue\n        }\n        rolling_max[index] = rolling_max[index - 1]\n\
    \        if number > rolling_max[index] {\n            rolling_max[index] = number\n\
    \        }\n    }\n    return rolling_max\n}\n", "    var maximum = 0\n    var\
    \ max_seq = make([]int, len(numbers))\n    for index, num := range numbers {\n\
    \        if num > maximum {\n            maximum = num\n        }\n        max_seq[index]\
    \ = maximum\n    }\n    return max_seq\n}\n", "    if len(numbers) == 0 {\n  \
    \      return []int{}\n    }\n\n    rollMax := make([]int, len(numbers))\n   \
    \ rollMax[0] = numbers[0]\n\n    for i := 1; i < len(numbers); i++ {\n       \
    \ rollMax[i] = max(rollMax[i-1], numbers[i])\n    }\n\n    return rollMax\n}\n",
  "    var max_numbers []int\n\n    for i, n := range numbers {\n        m := n\n\
    \        for j := 0; j < i; j++ {\n            if numbers[j] > m {\n         \
    \       m = numbers[j]\n            }\n        }\n        max_numbers = append(max_numbers,\
    \ m)\n    }\n\n    return max_numbers\n}\n", "    var result []int\n    max :=\
    \ numbers[0]\n    for _, number := range numbers {\n        if number > max {\n\
    \            max = number\n        }\n        result = append(result, max)\n \
    \   }\n    return result\n}\n", "    // TODO: Implement\n    return []int{}\n\
    }\n", "    result := make([]int, len(numbers))\n    result[0] = numbers[0]\n \
    \   for i := 1; i < len(numbers); i++ {\n        curr := numbers[i]\n        if\
    \ result[i-1] > curr {\n            result[i] = result[i-1]\n        } else {\n\
    \            result[i] = curr\n        }\n    }\n    return result\n}\n", "  \
    \  if len(numbers) == 0 {\n        return numbers\n    }\n    result := make([]int,\
    \ len(numbers))\n    result[0] = numbers[0]\n    for i := 1; i < len(numbers);\
    \ i++ {\n        if numbers[i] > result[i-1] {\n            result[i] = numbers[i]\n\
    \        } else {\n            result[i] = result[i-1]\n        }\n    }\n   \
    \ return result\n}\n", "    max := 0\n    result := make([]int, len(numbers))\n\
    \    for i, element := range numbers {\n        if element > max {\n         \
    \   max = element\n        }\n        result[i] = max\n    }\n    return result\n\
    }\n", "    var result []int\n\n    max := 0\n    for _, n := range numbers {\n\
    \        if n > max {\n            max = n\n        }\n        result = append(result,\
    \ max)\n    }\n\n    return result\n}\n", "    max := 0\n    result := make([]int,\
    \ len(numbers))\n    for i, v := range numbers {\n        if v > max {\n     \
    \       max = v\n        }\n        result[i] = max\n    }\n    return result\n\
    }\n", "    result := make([]int, len(numbers))\n    result[0] = numbers[0]\n \
    \   for i := 1; i < len(numbers); i++ {\n        if numbers[i] > result[i-1] {\n\
    \            result[i] = numbers[i]\n        } else {\n            result[i] =\
    \ result[i-1]\n        }\n    }\n    return result\n}\n", "    if len(numbers)\
    \ == 0 {\n        return []int{}\n    }\n    result := make([]int, len(numbers))\n\
    \    result[0] = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n       \
    \ currentMax := result[i-1]\n        if numbers[i] > currentMax {\n          \
    \  currentMax = numbers[i]\n        }\n        result[i] = currentMax\n    }\n\
    \    return result\n}\n", "    result := make([]int, len(numbers))\n    result[0]\
    \ = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i]\
    \ > result[i-1] {\n            result[i] = numbers[i]\n        } else {\n    \
    \        result[i] = result[i-1]\n        }\n    }\n    return result\n}\n", " \
    \   maximums := make([]int, len(numbers))\n    maximums[0] = numbers[0]\n    for\
    \ i, v := range numbers[1:] {\n        if i+1 >= len(maximums) {\n           \
    \ break\n        }\n        // fmt.Printf(\"Rolling max: prev: %d, current: %d,\
    \ i: %d\\n\", maximums[i], v, i)\n        if v > maximums[i] {\n            maximums[i+1]\
    \ = v\n        } else {\n            maximums[i+1] = maximums[i]\n        }\n\
    \    }\n    return maximums\n}\n", "    output := make([]int, len(numbers))\n\
    \    // the maximum currently found is the first element in the list\n    current_max\
    \ := numbers[0]\n    for i, v := range numbers {\n        if v > current_max {\n\
    \            current_max = v\n        }\n        output[i] = current_max\n   \
    \ }\n    return output\n}\n", "    result := make([]int, len(numbers))\n    max\
    \ := numbers[0]\n    result[0] = max\n    for i := 1; i < len(numbers); i++ {\n\
    \        num := numbers[i]\n        if num > max {\n            max = num\n  \
    \      }\n        result[i] = max\n    }\n    return result\n}\n", "    result\
    \ := make([]int, len(numbers))\n    max_el := numbers[0]\n    result[0] = max_el\n\
    \    for i := 1; i < len(numbers); i++ {\n        result[i] = max_el\n       \
    \ if numbers[i] > max_el {\n            max_el = numbers[i]\n        }\n    }\n\
    \    return result\n}\n", "    var rolling_numbers []int\n    maximum := 0\n \
    \   for _, number := range numbers {\n        if number > maximum {\n        \
    \    maximum = number\n        }\n        rolling_numbers = append(rolling_numbers,\
    \ maximum)\n    }\n    return rolling_numbers\n}\n", "    max_elements := make([]int,\
    \ len(numbers))\n    max_elements[0] = numbers[0]\n    for i := 1; i < len(numbers);\
    \ i++ {\n        max_elements[i] = max(max_elements[i-1], numbers[i])\n    }\n\
    \    return max_elements\n}\n", "    var res []int\n    for i := 0; i < len(numbers);\
    \ i++ {\n        max := numbers[i]\n        for j := i; j < len(numbers); j++\
    \ {\n            if numbers[j] > max {\n                max = numbers[j]\n   \
    \         }\n        }\n        res = append(res, max)\n    }\n    return res\n\
    }\n", "    max := make([]int, len(numbers))\n    for i, num := range numbers {\n\
    \        if i == 0 {\n            max[i] = num\n        } else {\n           \
    \ if num > max[i-1] {\n                max[i] = num\n            } else {\n  \
    \              max[i] = max[i-1]\n            }\n        }\n    }\n    return\
    \ max\n}\n", "    if len(numbers) == 0 {\n        return []int{}\n    }\n    rolling_maximum\
    \ := make([]int, len(numbers))\n    rolling_maximum[0] = numbers[0]\n    for i\
    \ := 1; i < len(numbers); i++ {\n        if numbers[i] > rolling_maximum[i-1]\
    \ {\n            rolling_maximum[i] = numbers[i]\n        } else {\n         \
    \   rolling_maximum[i] = rolling_maximum[i-1]\n        }\n    }\n    return rolling_maximum\n\
    }\n", "    if len(numbers) == 0 {\n        return numbers\n    }\n    result :=\
    \ make([]int, len(numbers))\n    result[0] = numbers[0]\n    for i, n := range\
    \ numbers[1:] {\n        if result[i] > n {\n            result[i+1] = result[i]\n\
    \        } else {\n            result[i+1] = n\n        }\n    }\n    return result\n\
    }\n", "    if len(numbers) == 0 {\n        return []int{}\n    }\n    // The last\
    \ integer in the list is always the maximum in the range\n    output := []int{numbers[len(numbers)\
    \ - 1]}\n    for i := len(numbers) - 2; i >= 0; i-- {\n        value := numbers[i]\n\
    \        if value > output[len(output) - 1] {\n            output = append(output,\
    \ value)\n        } else {\n            output = append(output, output[len(output)\
    \ - 1])\n        }\n    }\n    // The list we generate is in reverse order, need\
    \ to reverse it back\n    for i, j := 0, len(output) - 1; i < j; i, j = i + 1,\
    \ j - 1 {\n        output[i], output[j] = output[j], output[i]\n    }\n    return\
    \ output\n}\n", "    if len(numbers) == 0 {\n        return numbers\n    }\n \
    \   result := make([]int, len(numbers))\n    // first element of sequence is always\
    \ the same\n    result[0] = numbers[0]\n    for i := 1; i < len(numbers); i++\
    \ {\n        if numbers[i] > result[i-1] {\n            result[i] = numbers[i]\n\
    \        } else {\n            result[i] = result[i-1]\n        }\n    }\n   \
    \ return result\n}\n", "    var max []int\n    for i, num := range numbers {\n\
    \        if i == 0 {\n            max = append(max, num)\n        } else {\n \
    \           var new_max int\n            if num > max[i-1] {\n               \
    \ new_max = num\n            } else {\n                new_max = max[i-1]\n  \
    \          }\n            max = append(max, new_max)\n        }\n    }\n    return\
    \ max\n}\n", "    max := make([]int, len(numbers))\n    runningMax := numbers[0]\n\
    \    for i, x := range numbers {\n        if x > runningMax {\n            runningMax\
    \ = x\n        }\n        max[i] = runningMax\n    }\n    return max\n}\n", " \
    \   rolling := make([]int, len(numbers))\n    currMax := 0\n    for i, n := range\
    \ numbers {\n        if n > currMax {\n            currMax = n\n        }\n  \
    \      rolling[i] = currMax\n    }\n    return rolling\n}\n", "    if len(numbers)\
    \ == 0 {\n        return []int{}\n    }\n    result := make([]int, len(numbers))\n\
    \    result[0] = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n       \
    \ if numbers[i] > result[i-1] {\n            result[i] = numbers[i]\n        }\
    \ else {\n            result[i] = result[i-1]\n        }\n    }\n    return result\n\
    }\n", "    // TODO: implement\n    var max int\n    if len(numbers) > 0 {\n  \
    \      max = numbers[0]\n    }\n    output := make([]int, len(numbers))\n    for\
    \ i, n := range numbers {\n        output[i] = max\n        if n > max {\n   \
    \         max = n\n        }\n    }\n    return output\n}\n", "    r := make([]int,\
    \ len(numbers))\n    max := numbers[0]\n    for i, n := range numbers {\n    \
    \    if n > max {\n            max = n\n        }\n        r[i] = max\n    }\n\
    \    return r\n}\n", "    res := make([]int, len(numbers))\n    res[0] = numbers[0]\n\
    \    for i := 1; i < len(numbers); i++ {\n        if numbers[i] > res[i-1] {\n\
    \            res[i] = numbers[i]\n        } else {\n            res[i] = res[i-1]\n\
    \        }\n    }\n    return res\n}\n", "    var result []int\n    current_max\
    \ := numbers[0]\n    result = append(result, current_max)\n    for _, num := range\
    \ numbers[1:] {\n        if num > current_max {\n            current_max = num\n\
    \        }\n        result = append(result, current_max)\n    }\n    return result\n\
    }\n", "    result := make([]int, len(numbers))\n    result[0] = numbers[0]\n \
    \   max := numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if max\
    \ < numbers[i] {\n            max = numbers[i]\n        }\n        result[i] =\
    \ max\n    }\n    return result\n}\n", "    n := len(numbers)\n    max_numbers\
    \ := make([]int, n)\n    var max int\n    for i, v := range numbers {\n      \
    \  if i == 0 {\n            max = v\n        } else {\n            if v > max\
    \ {\n                max = v\n            }\n        }\n        max_numbers[i]\
    \ = max\n    }\n    return max_numbers\n}\n", "    result := make([]int, len(numbers))\n\
    \    result[0] = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n       \
    \ if numbers[i] > result[i-1] {\n            result[i] = numbers[i]\n        }\
    \ else {\n            result[i] = result[i-1]\n        }\n    }\n    return result\n\
    }\n", "    var result []int\n    if len(numbers) == 0 {\n        return result\n\
    \    }\n    result = append(result, numbers[0])\n    for i := 1; i < len(numbers);\
    \ i++ {\n        current := numbers[i]\n        max := result[i-1]\n        if\
    \ current > max {\n            max = current\n        }\n        result = append(result,\
    \ max)\n    }\n    return result\n}\n", "    max := 0\n    var result []int\n\
    \    for _, n := range numbers {\n        if n > max {\n            max = n\n\
    \        }\n        result = append(result, max)\n    }\n    return result\n}\n",
  "    var max int\n    var result []int\n    for i, number := range numbers {\n \
    \       if i == 0 {\n            max = number\n        } else {\n            if\
    \ number > max {\n                max = number\n            }\n        }\n   \
    \     result = append(result, max)\n    }\n    return result\n}\n", "    var rolling_max_list\
    \ []int\n    rolling_max := -1\n\n    for _, number := range numbers {\n     \
    \   if number > rolling_max {\n            rolling_max = number\n        }\n \
    \       rolling_max_list = append(rolling_max_list, rolling_max)\n    }\n\n  \
    \  return rolling_max_list\n}\n", "    var max int\n    results := make([]int,\
    \ len(numbers))\n    for i, v := range numbers {\n        if v > max {\n     \
    \       max = v\n        }\n        results[i] = max\n    }\n    return results\n\
    }\n", "    result := make([]int, len(numbers))\n    if len(numbers) == 0 {\n \
    \       return result\n    }\n    result[0] = numbers[0]\n    max := numbers[0]\n\
    \    for i := 1; i < len(numbers); i++ {\n        if numbers[i] > max {\n    \
    \        max = numbers[i]\n        }\n        result[i] = max\n    }\n    return\
    \ result\n}\n", "    result := make([]int, len(numbers))\n    max := numbers[0]\n\
    \    result[0] = max\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i]\
    \ > max {\n            max = numbers[i]\n        }\n        result[i] = max\n\
    \    }\n    return result\n}\n", "    var maximum = 0\n    var result = make([]int,\
    \ len(numbers))\n    for i, num := range numbers {\n        if num > maximum {\n\
    \            maximum = num\n        }\n        result[i] = maximum\n    }\n  \
    \  return result\n}\n", "    r_max := make([]int, len(numbers))\n    r_max[0]\
    \ = numbers[0]\n    for idx, num := range numbers[1:] {\n        max := r_max[idx]\n\
    \        if num > max {\n            max = num\n        }\n        r_max[idx+1]\
    \ = max\n    }\n    return r_max\n}\n", "    if len(numbers) == 0 {\n        return\
    \ numbers\n    }\n    rolling_max := make([]int, len(numbers))\n    rolling_max[0]\
    \ = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i]\
    \ > rolling_max[i-1] {\n            rolling_max[i] = numbers[i]\n        } else\
    \ {\n            rolling_max[i] = rolling_max[i-1]\n        }\n    }\n    return\
    \ rolling_max\n}\n", "    if len(numbers) == 0 {\n        return numbers\n   \
    \ }\n    r := make([]int, len(numbers))\n    m := numbers[0]\n    for i, n :=\
    \ range numbers {\n        if n > m {\n            m = n\n        }\n        r[i]\
    \ = m\n    }\n    return r\n}\n", "    if len(numbers) == 0 {\n        return\
    \ numbers\n    }\n    var result = make([]int, len(numbers))\n    result[0] =\
    \ numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] >\
    \ result[i-1] {\n            result[i] = numbers[i]\n        } else {\n      \
    \      result[i] = result[i-1]\n        }\n    }\n    return result\n}\n", " \
    \   max := 0\n    result := make([]int, len(numbers))\n    for index, value :=\
    \ range numbers {\n        if index == 0 {\n            max = value\n        }\
    \ else {\n            if value > max {\n                max = value\n        \
    \    }\n        }\n        result[index] = max\n    }\n    return result\n}\n",
  "    rolling_max := make([]int, len(numbers))\n    var max = numbers[0]\n    for\
    \ i, x := range numbers {\n        if x > max {\n            max = x\n       \
    \ }\n        rolling_max[i] = max\n    }\n    return rolling_max\n}\n", "    n_size\
    \ := len(numbers)\n    if n_size == 0 {\n        return []int{}\n    }\n\n   \
    \ if n_size == 1 {\n        return numbers\n    }\n\n    result := make([]int,\
    \ n_size)\n    last_max := numbers[0]\n    for idx, item := range numbers {\n\
    \        if item > last_max {\n            last_max = item\n        }\n      \
    \  result[idx] = last_max\n    }\n    return result\n}\n", "    var current_max\
    \ int\n    var result []int\n    current_max = numbers[0]\n    result = make([]int,\
    \ len(numbers))\n    result[0] = current_max\n    for i := 1; i < len(numbers);\
    \ i++ {\n        if current_max < numbers[i] {\n            current_max = numbers[i]\n\
    \        }\n        result[i] = current_max\n    }\n    return result\n}\n", " \
    \   if len(numbers) == 0 {\n        return numbers\n    }\n    result := make([]int,\
    \ len(numbers))\n    result[0] = numbers[0]\n    current_max := numbers[0]\n \
    \   for idx, v := range numbers[1:] {\n        if v > current_max {\n        \
    \    current_max = v\n        }\n        result[idx + 1] = current_max\n    }\n\
    \    return result\n}\n", "    rolling_max := make([]int, len(numbers))\n    if\
    \ len(numbers) == 0 {\n        return rolling_max\n    }\n    rolling_max[0] =\
    \ numbers[0]\n    for index, number := range numbers[1:] {\n        if number\
    \ > rolling_max[index] {\n            rolling_max[index + 1] = number\n      \
    \  } else {\n            rolling_max[index + 1] = rolling_max[index]\n       \
    \ }\n    }\n    return rolling_max\n}\n", "    if len(numbers) == 0 {\n      \
    \  return numbers\n    }\n    result := make([]int, len(numbers))\n    result[0]\
    \ = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        result[i] = result[i-1]\n\
    \        if numbers[i] > result[i] {\n            result[i] = numbers[i]\n   \
    \     }\n    }\n    return result\n}\n", "    max := 0\n    result := make([]int,\
    \ len(numbers))\n    for i, num := range numbers {\n        if num > max {\n \
    \           max = num\n        }\n        result[i] = max\n    }\n    return result\n\
    }\n", "    result := make([]int, len(numbers))\n    for i, v := range numbers\
    \ {\n        if i == 0 {\n            result[i] = v\n        } else {\n      \
    \      if v > result[i-1] {\n                result[i] = v\n            } else\
    \ {\n                result[i] = result[i-1]\n            }\n        }\n    }\n\
    \    return result\n}\n", "    rolling_max := make([]int, len(numbers))\n    var\
    \ current_max int\n    for i, val := range numbers {\n        if i == 0 {\n  \
    \          current_max = val\n        } else {\n            if val > current_max\
    \ {\n                current_max = val\n            }\n        }\n        rolling_max[i]\
    \ = current_max\n    }\n    return rolling_max\n}\n", "    if len(numbers) ==\
    \ 0 {\n        return numbers\n    }\n    result := make([]int, len(numbers))\n\
    \    copy(result, numbers)\n    max_number := numbers[0]\n    for i := 0; i <\
    \ len(numbers); i++ {\n        number := numbers[i]\n        if number > max_number\
    \ {\n            max_number = number\n        }\n        result[i] = max_number\n\
    \    }\n    return result\n}\n", "    output := make([]int, len(numbers))\n  \
    \  max := 0\n    for i, current := range numbers {\n        if current > max {\n\
    \            max = current\n        }\n        output[i] = max\n    }\n    return\
    \ output\n}\n", "    result := make([]int, len(numbers))\n    m := numbers[0]\n\
    \    for i, n := range numbers {\n        if n > m {\n            m = n\n    \
    \    }\n        result[i] = m\n    }\n    return result\n}\n", "    length :=\
    \ len(numbers)\n    if length == 0 {\n        return numbers\n    }\n    max_so_far\
    \ := numbers[0]\n    for i := 1; i < length; i++ {\n        if numbers[i] > max_so_far\
    \ {\n            max_so_far = numbers[i]\n        }\n        numbers[i] = max_so_far\n\
    \    }\n    return numbers\n}\n", "    if len(numbers) == 0 {\n        return\
    \ numbers\n    }\n    result := make([]int, len(numbers))\n    result[0] = numbers[0]\n\
    \    for i := 1; i < len(numbers); i++ {\n        if numbers[i] > result[i-1]\
    \ {\n            result[i] = numbers[i]\n        } else {\n            result[i]\
    \ = result[i-1]\n        }\n    }\n    return result\n}\n", "    var result []int\n\
    \n    maxSoFar := 0\n    for _, v := range numbers {\n        if v > maxSoFar\
    \ {\n            maxSoFar = v\n        }\n        result = append(result, maxSoFar)\n\
    \    }\n\n    return result\n}\n", "    max := numbers[0]\n    output := []int{max}\n\
    \    for _, v := range numbers[1:] {\n        if v > max {\n            max =\
    \ v\n        }\n        output = append(output, max)\n    }\n    return output\n\
    }\n", "    // If a list has no elements, we return an empty list\n    if len(numbers)\
    \ == 0 {\n        return numbers\n    }\n\n    // If a list has one element, it\
    \ is the maximum\n    if len(numbers) == 1 {\n        return []int{numbers[0]}\n\
    \    }\n\n    // We create a list with a capacity of the length of given list,\
    \ this\n    // way we are avoiding capacity changes that would cause reallocation.\n\
    \    result := make([]int, 0, len(numbers))\n\n    // We start with the first\
    \ element being the maximum\n    maximum := numbers[0]\n    result = append(result,\
    \ maximum)\n\n    // For each element in the list, compare it to the current maximum.\n\
    \    // If greater, then it is the new maximum.\n    for _, i := range numbers[1:]\
    \ {\n        if i > maximum {\n            maximum = i\n        }\n        result\
    \ = append(result, maximum)\n    }\n\n    return result\n}\n", "    result :=\
    \ make([]int, len(numbers))\n    for i, n := range numbers {\n        if i ==\
    \ 0 {\n            result[i] = n\n        } else {\n            if n > result[i-1]\
    \ {\n                result[i] = n\n            } else {\n                result[i]\
    \ = result[i-1]\n            }\n        }\n    }\n    return result\n}\n", " \
    \   if len(numbers) == 0 {\n        return []int{}\n    }\n\n    rolling_maximums\
    \ := make([]int, len(numbers))\n    rolling_maximums[0] = numbers[0]\n\n    for\
    \ i := 1; i < len(numbers); i++ {\n        if numbers[i] > rolling_maximums[i-1]\
    \ {\n            rolling_maximums[i] = numbers[i]\n        } else {\n        \
    \    rolling_maximums[i] = rolling_maximums[i-1]\n        }\n    }\n\n    return\
    \ rolling_maximums\n}\n", "    // r: rolling maximum found until given moment\
    \ in the sequence\n    var r []int\n    var max int\n\n    for i, n := range numbers\
    \ {\n        if i == 0 {\n            max = n\n        } else {\n            if\
    \ n > max {\n                max = n\n            }\n        }\n        r = append(r,\
    \ max)\n    }\n\n    return r\n}\n", "    var output []int\n    var max int\n\
    \    for _, n := range numbers {\n        if n > max {\n            max = n\n\
    \        }\n        output = append(output, max)\n    }\n    return output\n}\n",
  "    window := numbers[:1]\n    result := window\n    for _, v := range numbers[1:]\
    \ {\n        window = append(window, v)\n        if window[len(window)-1] >= window[len(window)-2]\
    \ {\n            result = append(result, window[len(window)-1])\n        } else\
    \ {\n            result = append(result, window[len(window)-2])\n        }\n \
    \   }\n    return result\n}\n", "    maximums := make([]int, len(numbers))\n \
    \   maximums[0] = numbers[0]\n    for i, _ := range numbers {\n        if i ==\
    \ 0 {\n            continue\n        }\n        if numbers[i] > maximums[i-1]\
    \ {\n            maximums[i] = numbers[i]\n        } else {\n            maximums[i]\
    \ = maximums[i-1]\n        }\n    }\n    return maximums\n}\n", "    if len(numbers)\
    \ == 0 {\n        return numbers\n    }\n    result := make([]int, len(numbers))\n\
    \    for i, n := range numbers {\n        if i == 0 {\n            result[i] =\
    \ n\n        } else {\n            if n > result[i-1] {\n                result[i]\
    \ = n\n            } else {\n                result[i] = result[i-1]\n       \
    \     }\n        }\n    }\n    return result\n}\n", "    var result []int\n  \
    \  max := numbers[0]\n    for _, n := range numbers {\n        if n > max {\n\
    \            max = n\n        }\n        result = append(result, max)\n    }\n\
    \    return result\n}\n", "    // TODO: Implement\n    return []int{}\n}\n", " \
    \   if len(numbers) == 0 {\n        return []int{}\n    }\n    result := make([]int,\
    \ len(numbers))\n    result[0] = numbers[0]\n    for i := 1; i < len(numbers);\
    \ i++ {\n        if numbers[i] > result[i-1] {\n            result[i] = numbers[i]\n\
    \        } else {\n            result[i] = result[i-1]\n        }\n    }\n   \
    \ return result\n}\n", "    length := len(numbers)\n    max := make([]int, length)\n\
    \    for i := 0; i < length; i++ {\n        max[i] = numbers[i]\n        for j\
    \ := 0; j < i; j++ {\n            if numbers[j] > max[i] {\n                max[i]\
    \ = numbers[j]\n            }\n        }\n    }\n    return max\n}\n", "    current_max\
    \ := numbers[0]\n    rolling_max := make([]int, len(numbers))\n    rolling_max[0]\
    \ = current_max\n    for i := 1; i < len(numbers); i++ {\n        current_max\
    \ = max(current_max, numbers[i])\n        rolling_max[i] = current_max\n    }\n\
    \    return rolling_max\n}\n", "    result := make([]int, len(numbers))\n    var\
    \ max int\n\n    for i, current := range numbers {\n        if i == 0 {\n    \
    \        max = current\n        } else {\n            if current > max {\n   \
    \             max = current\n            }\n        }\n        result[i] = max\n\
    \    }\n\n    return result\n}\n", "    // solution 1:\n    //\n    // we want\
    \ to find rolling maximum for numbers\n    // [1, 2, 3, 2, 3, 4, 2]\n    //\n\
    \    // we can use the following algorithm:\n    // starting from the left\n \
    \   //  1  2  3  2  3  4  2\n    //  1  2  3  3  3  4  4\n    //\n    // 1.) take\
    \ the first element as the max\n    // 2.) then take the second element, and compare\
    \ it to the first, if\n    //     it is bigger, it is the new max\n    // 3.)\
    \ repeat until the end\n    //\n    // let's use two pointers, one the current\
    \ position and the other a pointer\n    // to the current max\n    //\n    //\
    \ we can use two indices, current_position and curren_max_position\n    //\n \
    \   // starting from 0 for the position, and 0 for the max_position\n\n    //\
    \ initialize the max slice with the first element\n    if len(numbers) == 0 {\n\
    \        return numbers\n    }\n\n    max := make([]int, len(numbers))\n    max[0]\
    \ = numbers[0]\n\n    // initialize the max positions\n    current_position :=\
    \ 1\n    current_max_position := 0\n\n    for current_position < len(numbers)\
    \ {\n        if numbers[current_position] > numbers[current_max_position] {\n\
    \            max[current_position] = numbers[current_position]\n            current_max_position\
    \ = current_position\n        } else {\n            max[current_position] = numbers[current_max_position]\n\
    \        }\n        current_position++\n    }\n\n    return max\n}\n", "    var\
    \ result []int\n    var current_max int\n\n    for _, number := range numbers\
    \ {\n        if len(result) == 0 {\n            current_max = number\n       \
    \ } else {\n            if number > current_max {\n                current_max\
    \ = number\n            }\n        }\n        result = append(result, current_max)\n\
    \    }\n\n    return result\n}\n", "    var result []int\n    currentMax := 0\n\
    \    for _, v := range numbers {\n        if v > currentMax {\n            currentMax\
    \ = v\n        }\n        result = append(result, currentMax)\n    }\n    return\
    \ result\n}\n", "    results := make([]int, len(numbers))\n    var max int\n\n\
    \    for idx, n := range numbers {\n        if idx == 0 {\n            max = n\n\
    \        }\n\n        if n > max {\n            max = n\n        }\n\n       \
    \ results[idx] = max\n    }\n\n    return results\n}\n", "    rolling_max := make([]int,\
    \ len(numbers))\n    rolling_max[0] = numbers[0]\n    for i := 1; i < len(numbers);\
    \ i++ {\n        if numbers[i] > rolling_max[i-1] {\n            rolling_max[i]\
    \ = numbers[i]\n        } else {\n            rolling_max[i] = rolling_max[i-1]\n\
    \        }\n    }\n    return rolling_max\n}\n", "    result := make([]int, len(numbers))\n\
    \    result[0] = numbers[0]\n    for i, number := range numbers[1:] {\n      \
    \  if number > result[i] {\n            result[i+1] = number\n        } else {\n\
    \            result[i+1] = result[i]\n        }\n    }\n    return result\n}\n",
  "    result := make([]int, len(numbers))\n    current_max := numbers[0]\n    result[0]\
    \ = current_max\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i]\
    \ > current_max {\n            current_max = numbers[i]\n        }\n        result[i]\
    \ = current_max\n    }\n    return result\n}\n", "    if len(numbers) == 0 {\n\
    \        return []int{}\n    }\n    max := numbers[0]\n    result := []int{max}\n\
    \    for _, n := range numbers[1:] {\n        if n > max {\n            max =\
    \ n\n        }\n        result = append(result, max)\n    }\n    return result\n\
    }\n", "    result := make([]int, len(numbers))\n    max := numbers[0]\n    result[0]\
    \ = max\n    for i := 1; i < len(numbers); i++ {\n        current := numbers[i]\n\
    \        if current > max {\n            max = current\n        }\n        result[i]\
    \ = max\n    }\n    return result\n}\n", "    var output []int\n    var max =\
    \ 0\n    for _, number := range numbers {\n        if number > max {\n       \
    \     max = number\n        }\n        output = append(output, max)\n    }\n \
    \   return output\n}\n", "    max := numbers[0]\n    output := []int{}\n    for\
    \ _, n := range numbers {\n        if n > max {\n            max = n\n       \
    \ }\n        output = append(output, max)\n    }\n    return output\n}\n", " \
    \   var res []int\n    var max int\n    for i, v := range numbers {\n        if\
    \ i == 0 {\n            max = v\n        } else {\n            if v > max {\n\
    \                max = v\n            }\n        }\n        res = append(res,\
    \ max)\n    }\n    return res\n}\n", "    max_numbers := make([]int, len(numbers))\n\
    \    max_numbers[0] = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n  \
    \      if numbers[i] > max_numbers[i-1] {\n            max_numbers[i] = numbers[i]\n\
    \        } else {\n            max_numbers[i] = max_numbers[i-1]\n        }\n\
    \    }\n    return max_numbers\n}\n", "    result := make([]int, len(numbers))\n\
    \    max := 0\n    for i, x := range numbers {\n        if x > max {\n       \
    \     max = x\n        }\n        result[i] = max\n    }\n    return result\n\
    }\n", "    if len(numbers) == 0 {\n        return []int{}\n    }\n    rolling_max\
    \ := make([]int, len(numbers))\n    rolling_max[0] = numbers[0]\n    for i :=\
    \ 1; i < len(numbers); i++ {\n        if numbers[i] > rolling_max[i-1] {\n   \
    \         rolling_max[i] = numbers[i]\n        } else {\n            rolling_max[i]\
    \ = rolling_max[i-1]\n        }\n    }\n    return rolling_max\n}\n", "    var\
    \ max, i int\n    var result []int\n    for _, e := range numbers {\n        if\
    \ e > max {\n            max = e\n        }\n        result = append(result, max)\n\
    \    }\n    return result\n}\n", "    result := make([]int, len(numbers))\n  \
    \  var max int\n    for i, n := range numbers {\n        if n > max {\n      \
    \      max = n\n        }\n        result[i] = max\n    }\n    return result\n\
    }\n", "    maximums := make([]int, len(numbers))\n    for i, number := range numbers\
    \ {\n        var prevMax int\n        if i > 0 {\n            prevMax = maximums[i-1]\n\
    \        }\n        maximums[i] = max(number, prevMax)\n    }\n    return maximums\n\
    }\n", "    maxs := make([]int, len(numbers))\n    max := numbers[0]\n    for i,\
    \ n := range numbers {\n        if n > max {\n            max = n\n        }\n\
    \        maxs[i] = max\n    }\n    return maxs\n}\n", "    var rolling_maxes []int\n\
    \    var max_so_far int\n    for _, n := range numbers {\n        if n > max_so_far\
    \ {\n            max_so_far = n\n        }\n        rolling_maxes = append(rolling_maxes,\
    \ max_so_far)\n    }\n    return rolling_maxes\n}\n", "    // TODO\n    return\
    \ []int{}\n}\n", "    if len(numbers) == 0 {\n        return []int{}\n    }\n\
    \    max := numbers[0]\n    result := []int{max}\n    for _, number := range numbers[1:]\
    \ {\n        if number > max {\n            max = number\n        }\n        result\
    \ = append(result, max)\n    }\n    return result\n}\n", "    for index, num :=\
    \ range numbers {\n        if index == 0 {\n            continue\n        }\n\n\
    \        if numbers[index-1] < num {\n            numbers[index] = num\n     \
    \   } else {\n            numbers[index] = numbers[index-1]\n        }\n    }\n\
    \n    return numbers\n}\n", "    result := make([]int, len(numbers))\n    result[0]\
    \ = numbers[0]\n    for i, v := range numbers[1:] {\n        result[i+1] = max(result[i],\
    \ v)\n    }\n    return result\n}\n", "    result := make([]int, len(numbers))\n\
    \    max := numbers[0]\n    result[0] = max\n    for i := 1; i < len(numbers);\
    \ i++ {\n        if numbers[i] > max {\n            max = numbers[i]\n       \
    \ }\n        result[i] = max\n    }\n    return result\n}\n", "    result := make([]int,\
    \ len(numbers))\n    if len(numbers) == 0 {\n        return result\n    }\n  \
    \  result[0] = numbers[0]\n    var last_value int = numbers[0]\n    for index,\
    \ value := range numbers[1:] {\n        if value > last_value {\n            result[index+1]\
    \ = value\n            last_value = value\n        } else {\n            result[index+1]\
    \ = last_value\n        }\n    }\n    return result\n}\n", "    result := make([]int,\
    \ len(numbers))\n    max := 0\n    for i, number := range numbers {\n        if\
    \ number > max {\n            max = number\n        }\n        result[i] = max\n\
    \    }\n    return result\n}\n", "    var result []int\n    max := 0\n    for\
    \ _, n := range numbers {\n        if n > max {\n            max = n\n       \
    \ }\n        result = append(result, max)\n    }\n    return result\n}\n", " \
    \   var solution []int\n    if len(numbers) == 0 {\n        return solution\n\
    \    }\n    solution = append(solution, numbers[0])\n    for _, number := range\
    \ numbers[1:] {\n        previous := solution[len(solution) - 1]\n        if number\
    \ > previous {\n            solution = append(solution, number)\n        } else\
    \ {\n            solution = append(solution, previous)\n        }\n    }\n   \
    \ return solution\n}\n", "    if len(numbers) == 0 {\n        return numbers\n\
    \    }\n    result := make([]int, len(numbers))\n    result[0] = numbers[0]\n\
    \    for i := 1; i < len(numbers); i++ {\n        if numbers[i] > result[i-1]\
    \ {\n            result[i] = numbers[i]\n        } else {\n            result[i]\
    \ = result[i-1]\n        }\n    }\n    return result\n}\n", "    var max_till_now\
    \ int\n    var max_at_index []int\n\n    for _, val := range numbers {\n     \
    \   if val > max_till_now {\n            max_till_now = val\n        }\n     \
    \   max_at_index = append(max_at_index, max_till_now)\n    }\n\n    return max_at_index\n\
    }\n", "    if len(numbers) == 0 {\n        return numbers\n    }\n    out := make([]int,\
    \ len(numbers))\n    out[0] = numbers[0]\n    for i := 1; i < len(numbers); i++\
    \ {\n        if numbers[i] > out[i-1] {\n            out[i] = numbers[i]\n   \
    \     } else {\n            out[i] = out[i-1]\n        }\n    }\n    return out\n\
    }\n", "    result := make([]int, len(numbers))\n    current_max := numbers[0]\n\
    \    result[0] = current_max\n    for i := 1; i < len(numbers); i++ {\n      \
    \  if current_max < numbers[i] {\n            current_max = numbers[i]\n     \
    \   }\n        result[i] = current_max\n    }\n    return result\n}\n", "    var\
    \ rolling = make([]int, len(numbers))\n    var max_elem = 0\n    for i, n := range\
    \ numbers {\n        if n > max_elem {\n            max_elem = n\n        }\n\
    \        rolling[i] = max_elem\n    }\n    return rolling\n}\n", "    if len(numbers)\
    \ == 0 {\n        return []int{}\n    }\n    output := make([]int, len(numbers))\n\
    \    output[0] = numbers[0]\n    for i, n := range numbers[1:] {\n        if n\
    \ > output[i] {\n            output[i+1] = n\n        } else {\n            output[i+1]\
    \ = output[i]\n        }\n    }\n    return output\n}\n", "    rolling_max :=\
    \ make([]int, len(numbers))\n    rolling_max[0] = numbers[0]\n    for i := 1;\
    \ i < len(numbers); i++ {\n        if numbers[i] > rolling_max[i-1] {\n      \
    \      rolling_max[i] = numbers[i]\n        } else {\n            rolling_max[i]\
    \ = rolling_max[i-1]\n        }\n    }\n    return rolling_max\n}\n", "    max\
    \ := 0\n    max_list := make([]int, len(numbers))\n    for i, n := range numbers\
    \ {\n        if n > max {\n            max = n\n        }\n        max_list[i]\
    \ = max\n    }\n    return max_list\n}\n", "    res := make([]int, len(numbers))\n\
    \    m := 0\n    for i, v := range numbers {\n        if v > m {\n           \
    \ m = v\n        }\n        res[i] = m\n    }\n    return res\n}\n", "    var\
    \ result []int\n    for i, v := range numbers {\n        if i == 0 {\n       \
    \     result = append(result, v)\n        } else {\n            if v > result[i-1]\
    \ {\n                result = append(result, v)\n            } else {\n      \
    \          result = append(result, result[i-1])\n            }\n        }\n  \
    \  }\n    return result\n}\n", "    max := numbers[0]\n    res := []int{}\n  \
    \  for _, n := range numbers {\n        if n > max {\n            max = n\n  \
    \      }\n        res = append(res, max)\n    }\n    return res\n}\n", "    res\
    \ := make([]int, len(numbers))\n    res[0] = numbers[0]\n    for i := 1; i < len(numbers);\
    \ i++ {\n        if numbers[i] > res[i-1] {\n            res[i] = numbers[i]\n\
    \        } else {\n            res[i] = res[i-1]\n        }\n    }\n    return\
    \ res\n}\n", "    var rollingMax []int\n    var j int\n\n    for i := 0; i < len(numbers);\
    \ i++ {\n        rollingMax = append(rollingMax, numbers[i])\n        for j =\
    \ i - 1; j >= 0; j-- {\n            if numbers[j] > rollingMax[i] {\n        \
    \        rollingMax[i] = numbers[j]\n            }\n        }\n    }\n\n    return\
    \ rollingMax\n}\n", "    res := make([]int, len(numbers))\n    for i, num := range\
    \ numbers {\n        if i == 0 {\n            res[i] = num\n        } else {\n\
    \            if num > res[i-1] {\n                res[i] = num\n            }\
    \ else {\n                res[i] = res[i-1]\n            }\n        }\n    }\n\
    \    return res\n}\n", "    var result []int\n    var max int\n\n    for i, n\
    \ := range numbers {\n        if i == 0 {\n            max = n\n        } else\
    \ {\n            if n > max {\n                max = n\n            }\n      \
    \  }\n        result = append(result, max)\n    }\n\n    return result\n}\n",
  "    result := make([]int, len(numbers))\n    result[0] = numbers[0]\n    for i\
    \ := 1; i < len(numbers); i++ {\n        result[i] = max(result[i-1], numbers[i])\n\
    \    }\n    return result\n}\n", "    res := make([]int, len(numbers))\n    if\
    \ len(numbers) == 0 {\n        return res\n    }\n    res[0] = numbers[0]\n  \
    \  for i := 1; i < len(numbers); i++ {\n        res[i] = max(res[i-1], numbers[i])\n\
    \    }\n    return res\n}\n", "    if len(numbers) == 0 {\n        return numbers\n\
    \    }\n    max := numbers[0]\n    for _, n := range numbers {\n        if n >\
    \ max {\n            max = n\n        }\n    }\n    return append([]int{max},\
    \ rolling_max(numbers[1:])...)\n}\n", "    max_at := make([]int, len(numbers))\n\
    \    current_max := 0\n    for i, current := range numbers {\n        if current\
    \ > current_max {\n            current_max = current\n        }\n        max_at[i]\
    \ = current_max\n    }\n    return max_at\n}\n", "    result := make([]int, len(numbers))\n\
    \    maxSoFar := numbers[0]\n    result[0] = maxSoFar\n    for i := 1; i < len(numbers);\
    \ i++ {\n        if numbers[i] > maxSoFar {\n            maxSoFar = numbers[i]\n\
    \        }\n        result[i] = maxSoFar\n    }\n    return result\n}\n", "  \
    \  result := make([]int, len(numbers))\n    result[0] = numbers[0]\n    for i\
    \ := 1; i < len(numbers); i++ {\n        if numbers[i] > result[i-1] {\n     \
    \       result[i] = numbers[i]\n        } else {\n            result[i] = result[i-1]\n\
    \        }\n    }\n    return result\n}\n", "    var result []int\n\n    for i,\
    \ _ := range numbers {\n        max := numbers[i]\n        for j := i + 1; j <\
    \ len(numbers); j++ {\n            if numbers[j] > max {\n                max\
    \ = numbers[j]\n            }\n        }\n        result = append(result, max)\n\
    \    }\n\n    return result\n}\n", "    result := make([]int, len(numbers))\n\
    \    maximum := 0\n    for index, number := range numbers {\n        if number\
    \ > maximum {\n            maximum = number\n        }\n        result[index]\
    \ = maximum\n    }\n    return result\n}\n", "    maximums := make([]int, len(numbers))\n\
    \    maximums[0] = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n     \
    \   if numbers[i] > maximums[i-1] {\n            maximums[i] = numbers[i]\n  \
    \      } else {\n            maximums[i] = maximums[i-1]\n        }\n    }\n \
    \   return maximums\n}\n", "    max_numbers := make([]int, len(numbers))\n   \
    \ m := numbers[0]\n    for i, n := range numbers {\n        m = max(m, n)\n  \
    \      max_numbers[i] = m\n    }\n    return max_numbers\n}\n", "    rolling_max\
    \ := make([]int, len(numbers))\n    rolling_max[0] = numbers[0]\n    for i :=\
    \ 1; i < len(numbers); i++ {\n        if numbers[i] > rolling_max[i-1] {\n   \
    \         rolling_max[i] = numbers[i]\n        } else {\n            rolling_max[i]\
    \ = rolling_max[i-1]\n        }\n    }\n    return rolling_max\n}\n", "    if\
    \ len(numbers) == 0 {\n        return numbers\n    }\n    res := make([]int, len(numbers))\n\
    \    res[0] = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if\
    \ numbers[i] > res[i-1] {\n            res[i] = numbers[i]\n        } else {\n\
    \            res[i] = res[i-1]\n        }\n    }\n    return res\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
