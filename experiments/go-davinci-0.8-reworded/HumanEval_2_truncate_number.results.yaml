language: go_test.go
name: HumanEval_2_truncate_number
results:
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 1
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    // TODO: Implement function.\n    return 0.0\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTruncate_Number (0.00s)\n    --- FAIL: TestTruncate_Number/test_num__0\
    \ (0.00s)\n        tmpnacopi1__test.go:34: expected '%!s(float64=0.5)', got '%!s(float64=0)'\n\
    \    --- FAIL: TestTruncate_Number/test_num__1 (0.00s)\n        tmpnacopi1__test.go:34:\
    \ expected '%!s(float64=0.25)', got '%!s(float64=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660075089
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integer, decimal := math.Modf(number)\n    return decimal\n}\n\nfunc\
    \ TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     { actual:\
    \ candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0), expected:\
    \ 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpuwt7xm3y_test.go:15:25: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075088
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    remainder := number - float64(int(number))\n    return remainder\n}\n\
    \nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075089
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    // implementation goes here\n    decimal := number - float64(int(number))\n\
    \    fmt.Println(decimal)\n    return decimal\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075089
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    iPart := int(number)\n    return number - float64(iPart)\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075089
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    // truncate\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075089
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    var integerPart int = int(number)\n    return number - float64(integerPart)\n\
    }\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075089
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integer := int(number)\n    return number - float64(integer)\n}\n\nfunc\
    \ TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     { actual:\
    \ candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0), expected:\
    \ 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075089
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    a := number\n    n := int(a)\n    f := a - float64(n)\n    return f\n\
    }\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075089
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    truncated_number := float64(int(number))\n    return number - truncated_number\n\
    }\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075089
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    if number < 0 {\n        return number\n    }\n    d := number - float64(int(number))\n\
    \    if d == 0 {\n        return 0\n    }\n    return d\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.005s\n"
  timestamp: 1660075089
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    intPart := float64(int(number))\n    return number - intPart\n}\n\nfunc\
    \ TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     { actual:\
    \ candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0), expected:\
    \ 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075089
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integer_part := int(number)\n    return number - float64(integer_part)\n\
    }\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.007s\n"
  timestamp: 1660075089
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    // float64: Go defines floating-point numbers using the IEEE-754 standard\n\
    \    // using a 64-bit representation, which means that they are accurate to 15\n\
    \    // decimal places.\n    fractional := number - float64(int(number))\n   \
    \ return fractional\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate\
    \ := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5), expected:\
    \ 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075089
- exit_code: 1
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    // Your code here\n    return 0.0\n}\n\nfunc TestTruncate_Number(t *testing.T)\
    \ {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTruncate_Number (0.00s)\n    --- FAIL: TestTruncate_Number/test_num__0\
    \ (0.00s)\n        tmp_ibfg114_test.go:34: expected '%!s(float64=0.5)', got '%!s(float64=0)'\n\
    \    --- FAIL: TestTruncate_Number/test_num__1 (0.00s)\n        tmp_ibfg114_test.go:34:\
    \ expected '%!s(float64=0.25)', got '%!s(float64=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.010s\nFAIL\n"
  timestamp: 1660075089
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    var integer int = int(number)\n    return number - float64(integer)\n\
    }\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075089
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    int_part := int(number)\n    return number - float64(int_part)\n}\n\n\
    func TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     { actual:\
    \ candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0), expected:\
    \ 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075089
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    if number < 0 {\n        return number\n    }\n    return number - float64(int(number))\n\
    }\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075089
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    // Extract integer part of the number.\n    integer := int(number)\n\
    \    return number - float64(integer)\n}\n\nfunc TestTruncate_Number(t *testing.T)\
    \ {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075089
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    if number < 0 {\n        return 0\n    }\n    integer, decimals := math.Modf(number)\n\
    \    return decimals\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate\
    \ := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5), expected:\
    \ 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkrziq3mv_test.go:18:26: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075088
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    fmt.Println(number)\n    fmt.Println(int(number))\n    fmt.Println(number\
    \ - float64(int(number)))\n    return number - float64(int(number))\n}\n\nfunc\
    \ TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     { actual:\
    \ candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0), expected:\
    \ 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075089
- exit_code: 1
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    // TODO: implement the function\n    return 0.0\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTruncate_Number (0.00s)\n    --- FAIL: TestTruncate_Number/test_num__0\
    \ (0.00s)\n        tmpntlohj3g_test.go:34: expected '%!s(float64=0.5)', got '%!s(float64=0)'\n\
    \    --- FAIL: TestTruncate_Number/test_num__1 (0.00s)\n        tmpntlohj3g_test.go:34:\
    \ expected '%!s(float64=0.25)', got '%!s(float64=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660075089
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    var decimals float64\n    decimals = number - float64(int(number))\n\
    \    return decimals\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate\
    \ := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5), expected:\
    \ 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075089
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 1
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    // TODO\n    return 0.0\n}\n\nfunc TestTruncate_Number(t *testing.T)\
    \ {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTruncate_Number (0.00s)\n    --- FAIL: TestTruncate_Number/test_num__0\
    \ (0.00s)\n        tmppbpvb3mh_test.go:34: expected '%!s(float64=0.5)', got '%!s(float64=0)'\n\
    \    --- FAIL: TestTruncate_Number/test_num__1 (0.00s)\n        tmppbpvb3mh_test.go:34:\
    \ expected '%!s(float64=0.25)', got '%!s(float64=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660075092
- exit_code: 1
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    //TODO: add your code here\n\n    return 0\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTruncate_Number (0.00s)\n    --- FAIL: TestTruncate_Number/test_num__0\
    \ (0.00s)\n        tmpjv7g0vs4_test.go:35: expected '%!s(float64=0.5)', got '%!s(float64=0)'\n\
    \    --- FAIL: TestTruncate_Number/test_num__1 (0.00s)\n        tmpjv7g0vs4_test.go:35:\
    \ expected '%!s(float64=0.25)', got '%!s(float64=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660075092
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integral := int(number)\n    return number - float64(integral)\n}\n\n\
    func TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     { actual:\
    \ candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0), expected:\
    \ 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075093
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    if number < 0 {\n        panic(\"Only positive numbers supported\")\n\
    \    }\n    i, f := math.Modf(number)\n    return f\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkss1uaf7_test.go:18:13: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075093
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    if number < 0 {\n        panic(\"negative number\")\n    }\n    intPart\
    \ := int(number)\n    return number - float64(intPart)\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.005s\n"
  timestamp: 1660075093
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    /*\n    d := number - float64(int(number))\n    if d < 0 {\n        d\
    \ += 1\n    }\n    */\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075093
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    // Insert code here\n    var (\n        number_int int = int(number)\n\
    \        number_float float64 = number - float64(number_int)\n    )\n    return\
    \ number_float\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate :=\
    \ truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5), expected:\
    \ 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.005s\n"
  timestamp: 1660075093
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    var truncatedNumber float64\n    truncatedNumber = number - float64(int(number))\n\
    \    return truncatedNumber\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n \
    \ candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075093
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    truncate_num := number - float64(int(number))\n    return truncate_num\n\
    }\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075093
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    if number < 0 {\n        return 0\n    }\n    // First, we get integer\
    \ part of number.\n    intpart := int(number)\n    // Then, we subtract it from\
    \ number.\n    return number - float64(intpart)\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075093
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    // First get the integer part\n    int_part := int(number)\n    // Now\
    \ the decimal part is just the difference between the number and\n    // its integer\
    \ part.\n    return number - float64(int_part)\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075093
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n\tvar integer float64\n\tinteger = float64(int(number))\n\treturn number\
    \ - integer\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075093
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    var whole int = int(number)\n    return number - float64(whole)\n}\n\n\
    func TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     { actual:\
    \ candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0), expected:\
    \ 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075093
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    int_part := int(number)\n    return number - float64(int_part)\n}\n\n\
    func TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     { actual:\
    \ candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0), expected:\
    \ 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075089
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integer_part := int(number)\n    return number - float64(integer_part)\n\
    }\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.007s\n"
  timestamp: 1660075089
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 1
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    var x int = int(number)\n    return float64(x)\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTruncate_Number (0.00s)\n    --- FAIL: TestTruncate_Number/test_num__0\
    \ (0.00s)\n        tmpyzzaktwc_test.go:34: expected '%!s(float64=0.5)', got '%!s(float64=3)'\n\
    \    --- FAIL: TestTruncate_Number/test_num__1 (0.00s)\n        tmpyzzaktwc_test.go:34:\
    \ expected '%!s(float64=0.25)', got '%!s(float64=1)'\n    --- FAIL: TestTruncate_Number/test_num__2\
    \ (0.00s)\n        tmpyzzaktwc_test.go:34: expected '%!s(float64=0)', got '%!s(float64=123)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075093
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n\tvar f, intPart float64\n\tf = number\n\tintPart = float64(int(f))\n\treturn\
    \ f - intPart\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075093
- exit_code: 1
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return 0.0\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate\
    \ := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5), expected:\
    \ 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTruncate_Number (0.00s)\n    --- FAIL: TestTruncate_Number/test_num__0\
    \ (0.00s)\n        tmppxj2w_i6_test.go:33: expected '%!s(float64=0.5)', got '%!s(float64=0)'\n\
    \    --- FAIL: TestTruncate_Number/test_num__1 (0.00s)\n        tmppxj2w_i6_test.go:33:\
    \ expected '%!s(float64=0.25)', got '%!s(float64=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660075093
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    int_part := int(number)\n    return number - float64(int_part)\n}\n\n\
    func TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     { actual:\
    \ candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0), expected:\
    \ 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075089
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    var integer, fractional = math.Modf(number)\n    return fractional\n\
    }\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfd718w4e_test.go:15:31: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075093
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    dec := number - float64(int(number))\n    return dec\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075093
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    var intPart float64\n    var decPart float64\n    decPart = modf(number,\
    \ &intPart)\n    return decPart\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n\
    \  candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpo_z7_tk8_test.go:17:15: undefined: modf

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075093
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    fmt.Println(number)\n    fmt.Println(int(number))\n    fmt.Println(number\
    \ - float64(int(number)))\n    return number - float64(int(number))\n}\n\nfunc\
    \ TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     { actual:\
    \ candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0), expected:\
    \ 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075089
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    // a number = 3.5 = 3 + 0.5\n    return number - float64(int(number))\n\
    }\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075093
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    // Example of using math library's modulo function.\n    integer_part\
    \ := math.Mod(number, 1)\n    return integer_part\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpb3ohcf8o_test.go:16:21: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075093
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integer := int(number)\n    return number - float64(integer)\n}\n\nfunc\
    \ TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     { actual:\
    \ candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0), expected:\
    \ 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075089
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 1
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    //TODO\n    return 0.0\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n\
    \  candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTruncate_Number (0.00s)\n    --- FAIL: TestTruncate_Number/test_num__0\
    \ (0.00s)\n        tmp6d7de7p0_test.go:34: expected '%!s(float64=0.5)', got '%!s(float64=0)'\n\
    \    --- FAIL: TestTruncate_Number/test_num__1 (0.00s)\n        tmp6d7de7p0_test.go:34:\
    \ expected '%!s(float64=0.25)', got '%!s(float64=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660075093
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    truncated := int(number)\n    fmt.Println(truncated)\n    decimal :=\
    \ number - float64(truncated)\n    return decimal\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075093
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    intPart := int(number)\n    return number - float64(intPart)\n}\n\nfunc\
    \ TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     { actual:\
    \ candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0), expected:\
    \ 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075095
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n\treturn number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t *testing.T)\
    \ {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075095
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 1
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return 0.0\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate\
    \ := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5), expected:\
    \ 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTruncate_Number (0.00s)\n    --- FAIL: TestTruncate_Number/test_num__0\
    \ (0.00s)\n        tmppxj2w_i6_test.go:33: expected '%!s(float64=0.5)', got '%!s(float64=0)'\n\
    \    --- FAIL: TestTruncate_Number/test_num__1 (0.00s)\n        tmppxj2w_i6_test.go:33:\
    \ expected '%!s(float64=0.25)', got '%!s(float64=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660075093
- exit_code: 1
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    // TODO: implement\n    return 0.0\n}\n\nfunc TestTruncate_Number(t *testing.T)\
    \ {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTruncate_Number (0.00s)\n    --- FAIL: TestTruncate_Number/test_num__0\
    \ (0.00s)\n        tmptyuc278k_test.go:34: expected '%!s(float64=0.5)', got '%!s(float64=0)'\n\
    \    --- FAIL: TestTruncate_Number/test_num__1 (0.00s)\n        tmptyuc278k_test.go:34:\
    \ expected '%!s(float64=0.25)', got '%!s(float64=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    whole_part := int(number)\n    return number - float64(whole_part)\n\
    }\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075095
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integer := int(number)\n    return number - float64(integer)\n}\n\nfunc\
    \ TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     { actual:\
    \ candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0), expected:\
    \ 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075089
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integer_part := int(number)\n    return number - float64(integer_part)\n\
    }\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.007s\n"
  timestamp: 1660075089
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    truncated := int(number)\n    return number - float64(truncated)\n}\n\
    \nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075095
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    _, remainder := math.Modf(number)\n    return remainder\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqf83_e40_test.go:15:21: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075095
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    var integer_part float64\n    fractional_part := modf(number, &integer_part)\n\
    \    return fractional_part\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n \
    \ candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp12omrkc6_test.go:16:24: undefined: modf

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075095
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    var integer int = int(number)\n    return number - float64(integer)\n\
    }\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075089
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    trunc := int(number)\n    return number - float64(trunc)\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075096
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integer, fraction := math.Modf(number)\n    return fraction\n}\n\nfunc\
    \ TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     { actual:\
    \ candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0), expected:\
    \ 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmps8_has7a_test.go:15:26: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075096
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 1
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    // TODO: Implement me\n    return 0.0\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTruncate_Number (0.00s)\n    --- FAIL: TestTruncate_Number/test_num__0\
    \ (0.00s)\n        tmp8jxpfdtd_test.go:34: expected '%!s(float64=0.5)', got '%!s(float64=0)'\n\
    \    --- FAIL: TestTruncate_Number/test_num__1 (0.00s)\n        tmp8jxpfdtd_test.go:34:\
    \ expected '%!s(float64=0.25)', got '%!s(float64=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660075096
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    trunc := int(number)\n    diff := number - float64(trunc)\n    return\
    \ diff\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075096
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    num := int(number)\n    return number - float64(num)\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075096
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integer := int(number)\n    fmt.Println(integer)\n    fmt.Println(number\
    \ - float64(integer))\n    return number - float64(integer)\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075096
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    var integer_part = int(number)\n    return number - float64(integer_part)\n\
    }\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075096
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    remainder := number - float64(int(number))\n    return remainder\n}\n\
    \nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075089
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integer_part := int(number)\n    return number - float64(integer_part)\n\
    }\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.007s\n"
  timestamp: 1660075089
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    var truncated = number - float64(int(number))\n    return truncated\n\
    }\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075096
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    i := int(number)\n    return number - float64(i)\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075096
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n\treturn number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t *testing.T)\
    \ {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075095
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    // use fmt.Printf(\"%g\\n\", number) to print floating point numbers\
    \ in\n    // compact form, this will print \"0.5\" instead of \"0.50000000000000011\"\
    \n    fmt.Printf(\"%.15g\\n\", number)\n    integer_part := int(number)\n    fmt.Printf(\"\
    %d\\n\", integer_part)\n    return number - float64(integer_part)\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075096
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integer, decimals := split_number(number)\n    return decimals\n}\n\n\
    func TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     { actual:\
    \ candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0), expected:\
    \ 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnth72y60_test.go:15:26: undefined: split_number

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075096
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    var integer, decimals float64\n    _, decimals = math.Modf(number)\n\
    \    return decimals\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate\
    \ := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5), expected:\
    \ 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5hnduuo6_test.go:15:9: integer declared but not used

    /tmp/tmp5hnduuo6_test.go:16:19: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075096
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 1
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    // TODO: implement!\n    return 0.0\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTruncate_Number (0.00s)\n    --- FAIL: TestTruncate_Number/test_num__0\
    \ (0.00s)\n        tmpd_sny7d__test.go:34: expected '%!s(float64=0.5)', got '%!s(float64=0)'\n\
    \    --- FAIL: TestTruncate_Number/test_num__1 (0.00s)\n        tmpd_sny7d__test.go:34:\
    \ expected '%!s(float64=0.25)', got '%!s(float64=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660075096
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 1
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return 0.0\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate\
    \ := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5), expected:\
    \ 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTruncate_Number (0.00s)\n    --- FAIL: TestTruncate_Number/test_num__0\
    \ (0.00s)\n        tmppxj2w_i6_test.go:33: expected '%!s(float64=0.5)', got '%!s(float64=0)'\n\
    \    --- FAIL: TestTruncate_Number/test_num__1 (0.00s)\n        tmppxj2w_i6_test.go:33:\
    \ expected '%!s(float64=0.25)', got '%!s(float64=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660075093
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    if number < 0 {\n        panic(\"Negative number!\")\n    }\n    // How\
    \ do we get the decimal?\n    return number - float64(int(number))\n}\n\nfunc\
    \ TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     { actual:\
    \ candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0), expected:\
    \ 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075096
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integer := int(number)\n    decimals := number - float64(integer)\n \
    \   return decimals\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate\
    \ := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5), expected:\
    \ 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075096
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    if number >= 0.0 {\n        return number - float64(int(number))\n  \
    \  }\n    return -(number - float64(int(number)))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075096
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integer_part := float64(int(number))\n    decimal_part := number - integer_part\n\
    \    return decimal_part\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate\
    \ := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5), expected:\
    \ 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075096
- exit_code: 1
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    // replace this for solution\n    return 0.0\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTruncate_Number (0.00s)\n    --- FAIL: TestTruncate_Number/test_num__0\
    \ (0.00s)\n        tmp41zk7k9o_test.go:34: expected '%!s(float64=0.5)', got '%!s(float64=0)'\n\
    \    --- FAIL: TestTruncate_Number/test_num__1 (0.00s)\n        tmp41zk7k9o_test.go:34:\
    \ expected '%!s(float64=0.25)', got '%!s(float64=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075097
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    var number_int int64 = int64(number)\n    var number_flt float64 = float64(number_int)\n\
    \    return number - number_flt\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n\
    \  candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075097
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    var integer_part float64 = float64(int(number))\n    return number -\
    \ integer_part\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate :=\
    \ truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5), expected:\
    \ 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075097
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integer := int(number)\n    return number - float64(integer)\n}\n\nfunc\
    \ TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     { actual:\
    \ candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0), expected:\
    \ 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075089
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integer := int(number)\n    // Leftover part to be returned.\n    return\
    \ number - float64(integer)\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n \
    \ candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075097
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    if number < 0 {\n        panic(\"Number must be positive\")\n    }\n\
    \    var truncated int = int(number)\n    var res float64 = number - float64(truncated)\n\
    \    return res\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate :=\
    \ truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5), expected:\
    \ 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075097
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    var result float64\n    fmt.Println(int(number))\n    fmt.Println(number\
    \ - float64(int(number)))\n    result = number - float64(int(number))\n    return\
    \ result\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075097
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    truncated := float64(int(number))\n    return number - truncated\n}\n\
    \nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075097
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integer_part := int(number)\n    return number - float64(integer_part)\n\
    }\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.007s\n"
  timestamp: 1660075089
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    var integer_part int = int(number)\n    var decimal_part float64 = number\
    \ - float64(integer_part)\n    return decimal_part\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075005
- exit_code: 1
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    // Your code here\n\n    return 0.0\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTruncate_Number (0.00s)\n    --- FAIL: TestTruncate_Number/test_num__0\
    \ (0.00s)\n        tmpsjw65psq_test.go:35: expected '%!s(float64=0.5)', got '%!s(float64=0)'\n\
    \    --- FAIL: TestTruncate_Number/test_num__1 (0.00s)\n        tmpsjw65psq_test.go:35:\
    \ expected '%!s(float64=0.25)', got '%!s(float64=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660075097
- exit_code: null
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    for {\n        if int(number) == 0 {\n            return number\n   \
    \     }\n        number *= 10\n    }\n}\n\nfunc TestTruncate_Number(t *testing.T)\
    \ {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660075111
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    var truncated float64\n    truncated = number - float64(int(number))\n\
    \    return truncated\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate\
    \ := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5), expected:\
    \ 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075098
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    // To get the integer part of the number, convert it to int.\n    return\
    \ number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n\
    \  candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075098
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    var intPart float64\n    mod := math.Modf(number)\n    fmt.Println(intPart,\
    \ mod)\n    return mod\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate\
    \ := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5), expected:\
    \ 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppj58qz2z_test.go:16:12: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075098
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    // Cast the number to integer, this will keep only the integer part\n\
    \    // of the number.\n    // i.e.\n    // >>> 3.5\n    // >>> int(3.5)\n   \
    \ // 3\n    //\n    // Then substract the integer part from the number and return\n\
    \    // the result.\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075098
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    var decimals float64\n    decimals = number - float64(int(number))\n\
    \    return decimals\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate\
    \ := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5), expected:\
    \ 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075089
- exit_code: 1
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    var truncated_int int64 = int64(number)\n    return float64(truncated_int)\n\
    }\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTruncate_Number (0.00s)\n    --- FAIL: TestTruncate_Number/test_num__0\
    \ (0.00s)\n        tmpx5ao5nm__test.go:34: expected '%!s(float64=0.5)', got '%!s(float64=3)'\n\
    \    --- FAIL: TestTruncate_Number/test_num__1 (0.00s)\n        tmpx5ao5nm__test.go:34:\
    \ expected '%!s(float64=0.25)', got '%!s(float64=1)'\n    --- FAIL: TestTruncate_Number/test_num__2\
    \ (0.00s)\n        tmpx5ao5nm__test.go:34: expected '%!s(float64=0)', got '%!s(float64=123)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075098
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integer, decimal := float64(int(number)), number - float64(int(number))\n\
    \    return decimal\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate\
    \ := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5), expected:\
    \ 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnw05m0_t_test.go:15:5: integer declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075098
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 1
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    // your code here\n    return 0.0\n}\n\nfunc TestTruncate_Number(t *testing.T)\
    \ {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTruncate_Number (0.00s)\n    --- FAIL: TestTruncate_Number/test_num__0\
    \ (0.00s)\n        tmpsmc5npzc_test.go:34: expected '%!s(float64=0.5)', got '%!s(float64=0)'\n\
    \    --- FAIL: TestTruncate_Number/test_num__1 (0.00s)\n        tmpsmc5npzc_test.go:34:\
    \ expected '%!s(float64=0.25)', got '%!s(float64=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660075098
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    // We use type casting from float64 to int64.\n    // This does truncate\
    \ the decimal part (it does not round it).\n    // We then subtract this number\
    \ from the original one and obtain the\n    // decimal part.\n    return number\
    \ - float64(int64(number))\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate\
    \ := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5), expected:\
    \ 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075098
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    if number < 0 {\n        panic(\"number is not positive\")\n    }\n \
    \   return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t *testing.T)\
    \ {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5),\
    \ expected: 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     {\
    \ actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075098
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    truncate := float64(int(number))\n    decimal := number - truncate\n\
    \    return decimal\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate\
    \ := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5), expected:\
    \ 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075098
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 2
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    var fractional_part, integer_part float64\n    fractional_part = number\
    \ - float64(int(number))\n    return fractional_part\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp12rmbvxz_test.go:15:26: integer_part declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075098
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integer := int(number)\n    return number - float64(integer)\n}\n\nfunc\
    \ TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     { actual:\
    \ candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0), expected:\
    \ 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075089
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    integral_part := int(number)\n    return number - float64(integral_part)\n\
    }\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate := truncate_number\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3.5), expected: 0.5 },\n     {\
    \ actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075098
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    fmt.Println(number)\n    integer := int(number)\n    return number -\
    \ float64(integer)\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate\
    \ := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5), expected:\
    \ 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075098
- exit_code: 1
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return 0.0\n}\n\nfunc TestTruncate_Number(t *testing.T) {\n  candidate\
    \ := truncate_number\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3.5), expected:\
    \ 0.5 },\n     { actual: candidate(1.25), expected: 0.25 },\n     { actual: candidate(123.0),\
    \ expected: 0.0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTruncate_Number (0.00s)\n    --- FAIL: TestTruncate_Number/test_num__0\
    \ (0.00s)\n        tmppxj2w_i6_test.go:33: expected '%!s(float64=0.5)', got '%!s(float64=0)'\n\
    \    --- FAIL: TestTruncate_Number/test_num__1 (0.00s)\n        tmppxj2w_i6_test.go:33:\
    \ expected '%!s(float64=0.25)', got '%!s(float64=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660075093
- exit_code: 0
  program: "package truncate_number_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive floating point number, it can be decomposed into\n\
    // and integer part (largest integer smaller than given number) and decimals\n\
    // (leftover part always smaller than 1).\n// Return the decimal part of the number.\n\
    // >>> truncate_number(3.5)\n// 0.5\nfunc truncate_number(number float64) float64\
    \ {\n    return number - float64(int(number))\n}\n\nfunc TestTruncate_Number(t\
    \ *testing.T) {\n  candidate := truncate_number\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3.5), expected: 0.5 },\n     { actual: candidate(1.25), expected:\
    \ 0.25 },\n     { actual: candidate(123.0), expected: 0.0 },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074979
