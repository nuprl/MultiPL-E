name: HumanEval_59_largest_prime_factor
language: go_test.go
prompt: "package largest_prime_factor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
  \n)\n\n// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
  // >>> largest_prime_factor(13195)\n// 29\n// >>> largest_prime_factor(2048)\n//\
  \ 2\nfunc largest_prime_factor(n int) int {\n"
tests: "func TestLargest_Prime_Factor(t *testing.T) {\n  candidate := largest_prime_factor\n\
  \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
  \   tests := []test{\n     { actual: candidate(15), expected: 5 },\n     { actual:\
  \ candidate(27), expected: 3 },\n     { actual: candidate(63), expected: 7 },\n\
  \     { actual: candidate(330), expected: 11 },\n     { actual: candidate(13195),\
  \ expected: 29 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
  test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
  \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
  , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    if n == 2 {\n        return 2\n    }\n    // Must be odd.\n   \
    \ var i int = 3\n    var largest int = -1\n    for i * i <= n {\n        if n\
    \ % i == 0 {\n            largest = i\n            n /= i\n        } else {\n\
    \            i += 2\n        }\n    }\n    if n > largest {\n        largest =\
    \ n\n    }\n    return largest\n}\n", "    d := 2\n\n    for n > 1 {\n       \
    \ if n % d == 0 {\n            n /= d\n        } else {\n            d++\n   \
    \     }\n    }\n\n    return d\n}\n", "    lpf := 1\n    for i := 2; i <= n; i++\
    \ {\n        if (n % i == 0) {\n            lpf = i\n            n /= i\n    \
    \        i--\n        }\n    }\n    return lpf\n}\n", "    return -1\n}\n", " \
    \   i := 2\n    for ; i <= n; i++ {\n        if n % i == 0 {\n            break\n\
    \        }\n    }\n    // Check that the largest prime factor is not equal to\
    \ n itself.\n    if i == n {\n        return i\n    } else {\n        return largest_prime_factor(n\
    \ / i)\n    }\n}\n", "    // Solution:\n    //  divide number by primes, and the\
    \ last prime is the largest prime factor\n    //  :param n: int\n    //  :return:\
    \ int\n    //  :rtype: int\n    //  >>> largest_prime_factor(15)\n    //  5\n\
    \    //  >>> largest_prime_factor(2048)\n    //  2\n    //  >>> largest_prime_factor(13195)\n\
    \    //  29\n    // TODO: use prime generator\n    prime := 2\n    for n > 1 {\n\
    \        if n % prime == 0 {\n            n /= prime\n        } else {\n     \
    \       prime += 1\n        }\n    }\n    return prime\n}\n", "    largest_prime\
    \ := 0\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            largest_prime\
    \ = i\n            n /= i\n            i = 1\n        }\n    }\n    return largest_prime\n\
    }\n", "    if n == 1 {\n        return 1\n    }\n    if n % 2 == 0 {\n       \
    \ return largest_prime_factor(n / 2)\n    }\n    lpf := n\n    f := 3\n    for\
    \ f*f <= n {\n        if n % f == 0 {\n            lpf = f\n            n /= f\n\
    \        } else {\n            f += 2\n        }\n    }\n    return lpf\n}\n",
  "    for p := 3; n > p; p += 2 {\n        if n % p == 0 {\n            return largest_prime_factor(n\
    \ / p)\n        }\n    }\n    return n\n}\n", "    if n == 2 {\n        return\
    \ 2\n    }\n\n    lpf := 0\n    last_factor := 0\n    factor := 3\n    while n\
    \ > 1 {\n        if n % factor == 0 {\n            n /= factor\n            last_factor\
    \ = factor\n            lpf = last_factor\n        } else {\n            factor\
    \ += 2\n        }\n    }\n    return lpf\n}\n", "    for i := 2; i < n; i++ {\n\
    \        if n % i == 0 {\n            return largest_prime_factor(n / i)\n   \
    \     }\n    }\n    return n\n}\n", "    // Go through all ints from 3 up to sqrt(n).\n\
    \    i := 3\n    max := n/i\n    for ; i <= max; i++ {\n        if n % i == 0\
    \ {\n            return largest_prime_factor(n/i)\n        }\n    }\n    return\
    \ n\n}\n", "    // This is a brute force approach. It will try each number\n \
    \   // smaller than n and if it is a factor, it will try to\n    // divide out\
    \ any other factors.\n    // TODO: improve this algorithm\n    for i := n - 1;\
    \ i > 1; i-- {\n        if n % i == 0 {\n            if is_prime(i) {\n      \
    \          return i\n            }\n        }\n    }\n    // if we reach here,\
    \ then n is prime, so return it\n    return n\n}\n", "    var prime int\n    prime\
    \ = n\n    i := 2\n    // a prime number must be greater than 1\n    for n > 1\
    \ {\n        if n % i == 0 {\n            prime = i\n            n = n / i\n \
    \       } else {\n            i += 1\n        }\n    }\n    return prime\n}\n",
  "    // assume n is even, so start with 2\n    x := 2\n    for {\n        if n %\
    \ x == 0 {\n            // if x is a factor, then divide n by x\n            n\
    \ = n / x\n        } else {\n            // otherwise, if x is not a factor, increment\
    \ x\n            x += 1\n        }\n        // if n is a prime, then return n\n\
    \        if is_prime(n) {\n            return n\n        }\n    }\n}\n", "   \
    \ for i := 2; i < n; i++ {\n        if n % i == 0 {\n            if n / i == 1\
    \ {\n                return i\n            } else {\n                return largest_prime_factor(n\
    \ / i)\n            }\n        }\n    }\n    return n\n}\n", "    // Start by\
    \ trying to divide by 2\n    factor := 2\n    lastFactor := 1\n    for n > 1 {\n\
    \        if n % factor == 0 {\n            lastFactor = factor\n            n\
    \ = n / factor\n            for n % factor == 0 {\n                n = n / factor\n\
    \            }\n        }\n        factor = factor + 1\n    }\n    return lastFactor\n\
    }\n", "    factors := []int{}\n    for i := 2; i < n; i++ {\n        if n % i\
    \ == 0 {\n            is_prime := true\n            for j := 0; j < len(factors);\
    \ j++ {\n                if i % factors[j] == 0 {\n                    is_prime\
    \ = false\n                    break\n                }\n            }\n     \
    \       if is_prime {\n                factors = append(factors, i)\n        \
    \    }\n        }\n    }\n    return factors[len(factors) - 1]\n}\n", "    //\
    \ Find all the factors.\n    factors := make([]int, 0)\n    p := 2\n    for p\
    \ <= n {\n        if n % p == 0 {\n            factors = append(factors, p)\n\
    \            n /= p\n        } else {\n            p += 1\n        }\n    }\n\
    \    // Find the largest prime factor.\n    largest := 1\n    for _, factor :=\
    \ range factors {\n        if factor > largest {\n            largest = factor\n\
    \        }\n    }\n    return largest\n}\n", "    return 0\n}\n", "    // Go through\
    \ each number from 2 up to n.\n    // If n is divisible by that number, recurse\
    \ on n/number.\n    // Else, go to the next number.\n    // Return the largest\
    \ prime factor found.\n    for i := 2; i < n; i++ {\n        if n % i == 0 {\n\
    \            return largest_prime_factor(n / i)\n        }\n    }\n    return\
    \ n\n}\n", "    max := 0\n    if (n % 2 == 0) {\n        max = 2\n        n /=\
    \ 2\n    }\n    p := 3\n    for p < n {\n        if (n % p == 0) {\n         \
    \   if (p > max) {\n                max = p\n            }\n            n /= p\n\
    \        } else {\n            p += 2\n        }\n    }\n    if (n > max) {\n\
    \        max = n\n    }\n    return max\n}\n", "    fmt.Printf(\"n=%d\\n\", n)\n\
    \    if n == 1 {\n        return 1\n    }\n    for d := 2; d < n; d++ {\n    \
    \    if n % d == 0 {\n            return largest_prime_factor(n / d)\n       \
    \ }\n    }\n    return n\n}\n", "    // Find the smallest divisor of n and divide\
    \ n by that divisor.\n    // Check if n is now a prime.\n    // If n is now a\
    \ prime, it is the largest prime factor of the original n.\n    // If n is not\
    \ a prime, recurse.\n    //\n    // Runtime:  O(sqrt(n))\n    // Space:    O(1)\n\
    \    for i := 2; i <= n/2; i++ {\n        if n % i == 0 {\n            return\
    \ largest_prime_factor(n / i)\n        }\n    }\n    return n\n}\n", "    if n\
    \ <= 2 {\n        return n\n    }\n    var i int\n    for i = 2; i < n; i++ {\n\
    \        if n % i == 0 {\n            return largest_prime_factor(n / i)\n   \
    \     }\n    }\n    return i\n}\n", "    var factors = make([]int, 0)\n    var\
    \ factors_index = 0\n    var factors_max = len(factors)\n    var i = 2\n    var\
    \ k = n\n\n    if n == 1 {\n        return 1\n    }\n\n    // Look for factors\
    \ of 2 first\n    for {\n        if k % i == 0 {\n            // save factor and\
    \ quotient\n            factors = append(factors, i)\n            k = k / i\n\
    \        } else {\n            break\n        }\n    }\n\n    for {\n        if\
    \ k == 1 {\n            break\n        }\n\n        // Only check odd numbers\n\
    \        i += 2\n\n        for {\n            if k % i == 0 {\n              \
    \  // save factor and quotient\n                factors = append(factors, i)\n\
    \                k = k / i\n            } else {\n                break\n    \
    \        }\n        }\n    }\n\n    // return largest prime factor\n    factors_max\
    \ = len(factors)\n    for factors_index = factors_max - 1; factors_index >= 0;\
    \ factors_index-- {\n        if factors[factors_index] > 1 {\n            return\
    \ factors[factors_index]\n        }\n    }\n\n    return 1\n}\n", "    return\
    \ 0\n}\n", "    var factors = make([]int, 0)\n    var i = 2\n    var j = n\n \
    \   for i < j {\n        // If i is a factor of n, split n into two parts:\n \
    \       //  j is the largest prime factor of n\n        //  n/j is the largest\
    \ prime factor of j\n        // Largest prime factor of n == n / (largest prime\
    \ factor of j)\n        if j % i == 0 {\n            factors = append(factors,\
    \ i)\n            j = j / i\n        } else {\n            i += 1\n        }\n\
    \    }\n    return j\n}\n", "    var max int\n    for i := 2; i <= n; i++ {\n\
    \        if n % i == 0 {\n            max = i\n            n /= i\n          \
    \  i--\n        }\n    }\n    return max\n}\n", "    m := 2\n    // Note: this\
    \ function is a bit slow, but it's not the critical path.\n    for m*m <= n {\n\
    \        if n % m == 0 {\n            n /= m\n        } else {\n            m\
    \ += 1\n        }\n    }\n    return n\n}\n", "    // The number is certainly\
    \ divisible by 2, so we can start with 3.\n    // We can skip 4 because it's even.\n\
    \    for p := 5; p < n; p += 2 {\n        if (n % p == 0) {\n            // p\
    \ is a factor of n. If it's prime, we're done.\n            if (is_prime(p)) {\n\
    \                return p\n            }\n\n            // p is not prime. Divide\
    \ out all of its factors and try again.\n            for q := 2; q < p; q++ {\n\
    \                if (p % q == 0) {\n                    n /= q\n             \
    \       break\n                }\n            }\n        }\n    }\n\n    return\
    \ n\n}\n", "    for n % 2 == 0 {\n        n /= 2\n    }\n    var i int\n    for\
    \ i = 3; i * i <= n; i += 2 {\n        for n % i == 0 {\n            n /= i\n\
    \        }\n    }\n    if n > 2 {\n        return n\n    }\n    return i - 2\n\
    }\n", "    largest_prime := 1\n    for ; n % 2 == 0; n /= 2 {\n        largest_prime\
    \ = 2\n    }\n    for factor := 3; factor < n; factor += 2 {\n        for ; n\
    \ % factor == 0; n /= factor {\n            largest_prime = factor\n        }\n\
    \    }\n    if n > 2 {\n        largest_prime = n\n    }\n    return largest_prime\n\
    }\n", "    var largest_prime int = 0\n    for i := 2; i <= n; i++ {\n        if\
    \ n % i == 0 {\n            largest_prime = i\n            n /= i\n          \
    \  i = 1\n        }\n    }\n    return largest_prime\n}\n", "    // TODO\n   \
    \ return -1\n}\n", "    // Check divisibility by 2 first.\n    if n % 2 == 0 {\n\
    \        return largest_prime_factor(n / 2)\n    }\n    // Check odd numbers.\n\
    \    for i := 3; i <= n; i += 2 {\n        if n % i == 0 {\n            return\
    \ largest_prime_factor(n / i)\n        }\n    }\n    return n\n}\n", "    // The\
    \ largest factor of n must be below sqrt(n)\n    for i := 2; i * i <= n; i++ {\n\
    \        if n % i == 0 {\n            return largest_prime_factor(n / i)\n   \
    \     }\n    }\n    return n\n}\n", "    // Assume n > 1 and not a prime, so it\
    \ has a prime factor no greater than sqrt(n).\n    for i := 2; i * i <= n; i++\
    \ {\n        if n % i == 0 {\n            return largest_prime_factor(n / i)\n\
    \        }\n    }\n    return n\n}\n", "    max := 0\n    l := n\n\n    for n\
    \ % 2 == 0 {\n        n /= 2\n        max = 2\n    }\n\n    // no need to test\
    \ evens, they are already handled by the above case\n    for i := 3; i <= l; i\
    \ += 2 {\n        if n % i == 0 {\n            n /= i\n            max = i\n \
    \       }\n    }\n\n    return max\n}\n", "    p := 2\n    for p <= n {\n    \
    \    if n % p == 0 {\n            n /= p\n        } else {\n            p++\n\
    \        }\n    }\n    return p\n}\n", "    // start with 2 and iterate up to\
    \ n\n    factor := 2\n    for factor * factor <= n {\n        // if factor divides\
    \ n, divide out as many times as possible\n        for n % factor == 0 {\n   \
    \         n /= factor\n        }\n        // increment factor by 1\n        factor\
    \ += 1\n    }\n    // return the remaining factor\n    return n\n}\n", "    //\
    \ Find smallest factor.\n    f := 2\n    for n % f != 0 {\n        f += 1\n  \
    \  }\n    if n / f == 1 {\n        return f\n    } else {\n        return largest_prime_factor(n\
    \ / f)\n    }\n}\n", "    return -1\n}\n", "    factor := 2\n    for n % factor\
    \ == 0 {\n        n /= factor\n    }\n    factor += 1\n    if factor * factor\
    \ > n {\n        if n > 1 {\n            return n\n        }\n        return factor\
    \ - 1\n    }\n    if n % factor == 0 {\n        n /= factor\n    }\n    factor\
    \ += 2\n    if factor * factor > n {\n        if n > 1 {\n            return n\n\
    \        }\n        return factor - 2\n    }\n    if n % factor == 0 {\n     \
    \   n /= factor\n    }\n    factor += 4\n    if factor * factor > n {\n      \
    \  if n > 1 {\n            return n\n        }\n        return factor - 4\n  \
    \  }\n    if n % factor == 0 {\n        n /= factor\n    }\n    factor += 2\n\
    \    if factor * factor > n {\n        if n > 1 {\n            return n\n    \
    \    }\n        return factor - 2\n    }\n    if n % factor == 0 {\n        n\
    \ /= factor\n    }\n    factor += 4\n    if factor * factor > n {\n        if\
    \ n > 1 {\n            return n\n        }\n        return factor - 4\n    }\n\
    \    if n % factor == 0 {\n        n /= factor\n    }\n    factor += 6\n    if\
    \ factor * factor > n {\n        if n > 1 {\n            return n\n        }\n\
    \        return factor - 6\n    }\n    if n % factor == 0 {\n        n /= factor\n\
    \    }\n    factor += 2\n    if factor * factor > n {\n        if n > 1 {\n  \
    \          return n\n        }\n        return factor - 2\n    }\n    if n % factor\
    \ == 0 {\n        n /= factor\n    }\n    factor += 6\n    if factor * factor\
    \ > n {\n        if n > 1 {\n            return n\n        }\n        return factor\
    \ - 6\n    }\n    if n % factor == 0 {\n        n /= factor\n    }\n    factor\
    \ += 4\n    if factor * factor > n {\n        if n > 1 {\n            return n\n\
    \        }\n        return factor - 4\n    }\n    if n % factor == 0 {\n     \
    \   n", "    prime_factor := 2\n    max_possible_prime_factor := n / 2\n\n   \
    \ for i := prime_factor; i <= max_possible_prime_factor; i++ {\n        if n %\
    \ i == 0 {\n            prime_factor = i\n            break\n        }\n    }\n\
    \n    return prime_factor\n}\n", "    for i := 2; i < n; i++ {\n        if n %\
    \ i == 0 {\n            n /= i\n            return largest_prime_factor(n)\n \
    \       }\n    }\n    return n\n}\n", "    m := 2\n    for n > 1 {\n        if\
    \ n % m == 0 {\n            n /= m\n        } else {\n            m++\n      \
    \  }\n    }\n    return m\n}\n", "    if (n <= 1) {\n        return 0\n    }\n\
    \    var prime_factors []int\n    i := 2\n    for ; i < n; i++ {\n        if n\
    \ % i == 0 {\n            n = n / i\n            prime_factors = append(prime_factors,\
    \ i)\n            i = 1\n        }\n    }\n    if (i == n) {\n        prime_factors\
    \ = append(prime_factors, i)\n    }\n    return prime_factors[len(prime_factors)\
    \ - 1]\n}\n", "    // Instead of looping over the integers, can loop over\n  \
    \  // the primes to cut down on number of steps (trial division).\n    // Can\
    \ use Sieve of Eratosthenes to find primes.\n    return 0\n}\n", "    i := 2\n\
    \    for ; n % i != 0; i++ {\n    }\n    if n == i {\n        return n\n    }\n\
    \    return largest_prime_factor(n / i)\n}\n", "    f := 2\n    for ; f < n; f++\
    \ {\n        if n % f == 0 {\n            n /= f\n            f--\n        }\n\
    \    }\n    return f\n}\n", "    // i := 2\n    // for ; i < n; i++ {\n    //\
    \     if n % i == 0 {\n    //         return n / i\n    //     }\n    // }\n \
    \   // return n\n    return n / 2\n}\n", "    i := 2\n    for ; n % i != 0; i++\
    \ {\n    }\n    return i\n}\n", "    m := 2\n    for {\n        if m*m > n {\n\
    \            return n\n        }\n        if n % m == 0 {\n            return\
    \ largest_prime_factor(n/m)\n        }\n        m++\n    }\n}\n", "    var largest_factor\
    \ int = 2\n    var factor int = largest_factor\n    var prod int = n\n    for\
    \ prod > 1 {\n        if prod % factor == 0 {\n            prod /= factor\n  \
    \          largest_factor = factor\n        } else {\n            factor += 1\n\
    \        }\n    }\n    return largest_factor\n}\n", "    for i := 2; i < n; i++\
    \ {\n        if n % i == 0 {\n            m := n / i\n            if is_prime(m)\
    \ {\n                return m\n            }\n        }\n    }\n    return 0\n\
    }\n", "    var (\n        i int\n        factor int\n    )\n    for i = 2; i <=\
    \ n / i; i++ {\n        for n % i == 0 {\n            factor = i\n           \
    \ n /= i\n        }\n    }\n    if n > 1 {\n        factor = n\n    }\n    return\
    \ factor\n}\n", "    for d := 2; d < n; d++ {\n        if n % d == 0 {\n     \
    \       n /= d\n            d = 1\n        }\n    }\n    return n\n}\n", "   \
    \ return 1\n}\n", "    factor := 2\n    for ; n % factor != 0; factor++ {\n  \
    \  }\n    // TODO: why not factor == n ?\n    if n / factor == 1 {\n        return\
    \ factor\n    }\n    return largest_prime_factor(n / factor)\n}\n", "    // \n\
    \    factor := 2\n    for ; n > 1; factor++ {\n        for n % factor == 0 {\n\
    \            n /= factor\n        }\n    }\n    return factor - 1\n}\n", "   \
    \ // Find the largest prime factor.\n    for i := 1; i <= n; i++ {\n        for\
    \ j := i; j <= n; j++ {\n            // If n is divisible by i, j and i * j ==\
    \ n, then i is a prime factor.\n            if n % i == 0 && n % j == 0 && i *\
    \ j == n {\n                return i\n            }\n        }\n    }\n    return\
    \ n\n}\n", "    var prime int = 2\n    var ret int = 0\n    for prime <= n {\n\
    \        if n % prime == 0 {\n            ret = prime\n            n /= prime\n\
    \        } else {\n            prime += 1\n        }\n    }\n    return ret\n\
    }\n", "    i := 2\n    //fmt.Printf(\"n=%d, i=%d\\n\", n, i)\n    for n % i ==\
    \ 0 {\n        n /= i\n        //fmt.Printf(\"n=%d, i=%d\\n\", n, i)\n    }\n\
    \    i += 1\n    for n > 1 {\n        for n % i == 0 {\n            n /= i\n \
    \           //fmt.Printf(\"n=%d, i=%d\\n\", n, i)\n        }\n        i += 2\n\
    \    }\n    return i - 2\n}\n", "    return 0\n}\n", "    var i int\n    for i\
    \ = 2; i < n; i++ {\n        if n % i == 0 {\n            break\n        }\n \
    \   }\n    return i\n}\n", "    // https://en.wikipedia.org/wiki/Prime_number\n\
    \    // https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n    sieve := make([]bool,\
    \ n)\n    sieve[0] = true\n    sieve[1] = true\n    for i := 2; i*i < n; i++ {\n\
    \        if !sieve[i] {\n            for j := i*i; j < n; j += i {\n         \
    \       sieve[j] = true\n            }\n        }\n    }\n    for i := n-1; i\
    \ > 1; i-- {\n        if !sieve[i] {\n            return i\n        }\n    }\n\
    \    return 1\n}\n", "    d := 2\n    for n > 1 {\n        for n % d == 0 {\n\
    \            n /= d\n        }\n        d += 1\n    }\n    return d - 1\n}\n",
  "    // Prime factors\n    prime_factors := []int{}\n\n    // Set largest_factor\
    \ to highest possible factor of n.\n    largest_factor := n / 2\n\n    // Starting\
    \ from the largest possible factor, iterate backwards\n    // to find the largest\
    \ prime factor of n.\n    for i := largest_factor; i > 1; i-- {\n        // If\
    \ i is a factor of n and i is prime, it's the largest\n        // prime factor\
    \ of n.\n        if (n % i == 0) && is_prime(i) {\n            prime_factors =\
    \ append(prime_factors, i)\n        }\n    }\n\n    return prime_factors[len(prime_factors)\
    \ - 1]\n}\n", "    largest := 1\n    for i := 2; i <= n; i++ {\n        if n %\
    \ i == 0 {\n            largest = i\n            n /= i\n            i--\n   \
    \     }\n    }\n    return largest\n}\n", "    if n == 2 {\n        return 2\n\
    \    }\n\n    var factor int = 3\n    for n % 2 == 0 {\n        n /= 2\n    }\n\
    \n    for n > 1 {\n        for n % factor == 0 {\n            n /= factor\n  \
    \      }\n        factor += 2\n    }\n\n    return factor - 2\n}\n", "    max\
    \ := n\n    var i int\n    for i = 2; i < max; i++ {\n        for n % i == 0 {\n\
    \            max = n / i\n            n = max\n        }\n    }\n    return max\n\
    }\n", "    d := 2\n    for ; n > 1; d++ {\n        for n % d == 0 {\n        \
    \    n /= d\n        }\n    }\n    return d - 1\n}\n", "    var (\n        i,\
    \ j int\n        m    int\n    )\n    for i = 2; i <= n; i++ {\n        for j\
    \ = 2; j < i; j++ {\n            if i%j == 0 {\n                break\n      \
    \      }\n        }\n        if j == i {\n            if n%i == 0 {\n        \
    \        m = i\n            }\n        }\n    }\n    return m\n}\n", "    largest\
    \ := 0\n    // divide n by 2 until n is odd\n    for n % 2 == 0 {\n        largest\
    \ = 2\n        n /= 2\n    }\n    // now n is odd and we can start from 3\n  \
    \  i := 3\n    // divide n by numbers from 3 and up, until n is a prime number\n\
    \    for i <= n {\n        if n % i == 0 {\n            largest = i\n        \
    \    n /= i\n        } else {\n            i += 2\n        }\n    }\n    return\
    \ largest\n}\n", "    factors := []int{}\n    for i := 2; i <= n; i++ {\n    \
    \    if n % i == 0 {\n            factors = append(factors, i)\n            n\
    \ /= i\n            i--\n        }\n    }\n    return factors[len(factors) - 1]\n\
    }\n", "    largest_factor := 0\n    for d := 2; d < n; d++ {\n        if n % d\
    \ == 0 {\n            largest_factor = d\n            n /= d\n        }\n    }\n\
    \    return largest_factor\n}\n", "    largest := 0\n    for i := 2; i <= n; i++\
    \ {\n        if n % i == 0 {\n            n /= i\n            largest = i\n  \
    \      }\n    }\n    return largest\n}\n", "    var prime int\n    for i := 2;\
    \ i <= n; i++ {\n        for n % i == 0 {\n            prime = i\n           \
    \ n /= i\n        }\n    }\n    return prime\n}\n", "    factor := 2\n    for\
    \ n > 1 {\n        if n % factor == 0 {\n            n /= factor\n        } else\
    \ {\n            factor++\n        }\n    }\n    return factor\n}\n", "    i :=\
    \ 2\n    for n > 1 {\n        for n % i == 0 {\n            n /= i\n        }\n\
    \        i += 1\n    }\n    return i - 1\n}\n", "    for i := 2; i <= n/2; i++\
    \ {\n        if n % i == 0 {\n            j := largest_prime_factor(n / i)\n \
    \           if j > i {\n                return j\n            } else {\n     \
    \           return i\n            }\n        }\n    }\n    return n\n}\n", " \
    \   if n == 2 {\n        return 2\n    }\n    factors := make([]int, 0)\n    for\
    \ i := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors,\
    \ i)\n            n = n / i\n            i = 1\n        }\n    }\n    return factors[len(factors)\
    \ - 1]\n}\n", "    for i := 2; i < n/2 + 1; i++ {\n        if n % i == 0 {\n \
    \           return largest_prime_factor(n/i)\n        }\n    }\n    return n\n\
    }\n", "    // [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59,\
    \ 61, 67, 71, 73, 79, 83, 89, 97]\n    // every composite number has a prime factor\
    \ less than or equal to its square root\n    var largest int = 0\n    var i int\
    \ = 2\n    var limit int = n/2\n    var limit_i int = limit\n    for i <= limit_i\
    \ {\n        if n % i == 0 {\n            largest = i\n            limit_i = limit\
    \ / i\n        }\n        i += 1\n    }\n    return largest\n}\n", "    maxFactor\
    \ := 0\n    for i := 2; i < n; i++ {\n        if n % i == 0 {\n            n /=\
    \ i\n            if i > maxFactor {\n                maxFactor = i\n         \
    \   }\n        }\n    }\n    return maxFactor\n}\n", "    largest_prime := 1\n\
    \    for i := 2; i < n; i++ {\n        if n % i == 0 {\n            is_prime :=\
    \ true\n            for j := 2; j < i; j++ {\n                if i % j == 0 {\n\
    \                    is_prime = false\n                    break\n           \
    \     }\n            }\n            if is_prime {\n                largest_prime\
    \ = i\n            }\n        }\n    }\n    return largest_prime\n}\n", "    var\
    \ f int\n    if n % 2 == 0 {\n        f = 2\n        n /= 2\n    } else {\n  \
    \      f = 1\n    }\n    for ; n != 1; {\n        i := 3\n        for ; i <= n;\
    \ i += 2 {\n            if n % i == 0 {\n                f = i\n             \
    \   n /= i\n                break\n            }\n        }\n        if i > n\
    \ {\n            break\n        }\n    }\n    return f\n}\n", "    var f int\n\
    \    for i := 2; i <= n; i++ {\n        for n % i == 0 {\n            f = i\n\
    \            n /= i\n        }\n    }\n    return f\n}\n", "    // trick: take\
    \ advantage of the fact that primes are odd.\n    for i := 2; i <= n; i += 2 {\n\
    \        if n % i == 0 {\n            return largest_prime_factor(n / i)\n   \
    \     }\n    }\n    return n\n}\n", "    // Start at n-1, count down to 2.\n \
    \   for i := n-1; i > 1; i-- {\n        // If n is divisible by i, check if i\
    \ is prime.\n        if n % i == 0 {\n            // If i is prime, we have our\
    \ answer.\n            if is_prime(i) {\n                return i\n          \
    \  }\n        }\n    }\n    // We should never reach this point.\n    panic(fmt.Sprintf(\"\
    largest_prime_factor(%d) error: no prime factors found\", n))\n}\n", "    //return\
    \ n\n    return 0\n}\n", "    var i, f int = 2, 0\n    for i * i <= n {\n    \
    \    if n % i == 0 {\n            f = i\n            n /= i\n        } else {\n\
    \            i++\n        }\n    }\n    if n > 1 {\n        f = n\n    }\n   \
    \ return f\n}\n", "    var factor int = 2\n    if n % factor == 0 {\n        return\
    \ factor\n    }\n\n    for i := 3; i <= n; i += 2 {\n        if n % i == 0 {\n\
    \            if is_prime(i) {\n                factor = i\n            }\n   \
    \     }\n    }\n    return factor\n}\n", "    var factors []int\n    for i :=\
    \ 2; i <= n; i++ {\n        for n % i == 0 {\n            factors = append(factors,\
    \ i)\n            n /= i\n        }\n    }\n    return factors[len(factors) -\
    \ 1]\n}\n", "    // **** brute force\n    // **** note the loop starts at the\
    \ value of n\n    // start with 1\n    result := 1\n    for i := n; i > 1; i--\
    \ {\n        // fmt.Printf(\">>>>>>> i: %v  n: %v\\n\", i, n)\n        // check\
    \ if i is a factor of n\n        if (n % i) == 0 {\n            // **** check\
    \ if i is a prime\n            // start with 1\n            p := 1\n         \
    \   for j := i; j > 1; j-- {\n                // fmt.Printf(\"  >>>>> j: %v  i:\
    \ %v\\n\", j, i)\n                // check if j is a factor of i\n           \
    \     if (i % j) == 0 {\n                    // **** no need to check if j is\
    \ prime\n                    // as i is not prime\n                    // ****\
    \ check if j is 1\n                    if j == 1 {\n                        //\
    \ **** check if i is prime\n                        if p == 1 {\n            \
    \                // **** save the largest prime factor\n                     \
    \       if i > result {\n                                result = i\n        \
    \                    }\n                        }\n                    } else\
    \ {\n                        // **** i is not prime\n                        //\
    \ fmt.Printf(\"  ****** i: %v not prime\\n\", i)\n                        p =\
    \ 0\n                    }\n                }\n            }\n        }\n    }\n\
    \    return result\n}\n", "    largest := 1\n    for i := 2; i <= n; i++ {\n \
    \       if n % i == 0 {\n            largest = i\n            n /= i\n       \
    \     i = 1\n        }\n    }\n    return largest\n}\n", "    for i := 2; i <\
    \ n; i++ {\n        for n % i == 0 {\n            n /= i\n        }\n    }\n \
    \   return n\n}\n", "    // find factors\n    factors := []int{}\n    for i :=\
    \ 2; i < n; i++ {\n        if n % i == 0 {\n            factors = append(factors,\
    \ i)\n        }\n    }\n\n    fmt.Println(factors)\n\n    // filter out prime\
    \ numbers from factors\n    primes := []int{}\n    for _, factor := range factors\
    \ {\n        if is_prime(factor) {\n            primes = append(primes, factor)\n\
    \        }\n    }\n\n    fmt.Println(primes)\n\n    // find max number\n    var\
    \ max int\n    for _, prime := range primes {\n        if prime > max {\n    \
    \        max = prime\n        }\n    }\n\n    return max\n}\n", "    for i :=\
    \ 2; i < n; i++ {\n        for n % i == 0 {\n            n /= i\n        }\n \
    \   }\n    return n\n}\n", "    largest_prime := 0\n    // A prime number is defined\
    \ as a number that is not divisible by any\n    // number except for 1 and itself.\
    \ We should stop searching for divisors\n    // at the square root of n.\n   \
    \ for i := 2; i <= int(n / 2); i++ {\n        if n % i == 0 {\n            //\
    \ We've found a divisor!\n            // Let's check if it's prime, too.\n   \
    \         is_prime := true\n            for j := 2; j <= int(i / 2); j++ {\n \
    \               if i % j == 0 {\n                    is_prime = false\n      \
    \              break\n                }\n            }\n            if is_prime\
    \ {\n                largest_prime = i\n            }\n        }\n    }\n    return\
    \ largest_prime\n}\n", "    var largest int\n    for i := 2; i < n; i++ {\n  \
    \      if n % i == 0 {\n            largest = i\n            for n = n / i; n\
    \ % i == 0; n = n / i {\n            }\n        }\n    }\n    return largest\n\
    }\n", "    i := 2\n    for ; i * i < n; i++ {\n        for n % i == 0 {\n    \
    \        n /= i\n        }\n    }\n    return n\n}\n", "    factor := 2\n    for\
    \ n % factor == 0 {\n        n /= factor\n    }\n    // TODO: faster\n    for\
    \ i := 3; i <= n; i += 2 {\n        for n % i == 0 {\n            n /= i\n   \
    \         factor = i\n        }\n    }\n    return factor\n}\n", "    var i int\n\
    \    for i = 2; i <= n; i++ {\n        for n % i == 0 {\n            n /= i\n\
    \        }\n    }\n    return i - 1\n}\n", "    // Store all the prime factors\
    \ of n\n    prime_factors := []int{}\n\n    // Helper function to test if a number\
    \ is prime\n    is_prime := func(n int) bool {\n        if n == 2 {\n        \
    \    return true\n        }\n        if n == 1 || n % 2 == 0 {\n            return\
    \ false\n        }\n        for i := 3; i <= int(float64(n)**0.5); i += 2 {\n\
    \            if n % i == 0 {\n                return false\n            }\n  \
    \      }\n        return true\n    }\n\n    // Store all the primes that are factors\
    \ of n\n    for i := 2; i <= n; i++ {\n        if n % i == 0 && is_prime(i) {\n\
    \            prime_factors = append(prime_factors, i)\n        }\n    }\n\n  \
    \  // Return the largest prime factor\n    return prime_factors[len(prime_factors)\
    \ - 1]\n}\n", "    // Prime factorization\n    // http://en.wikipedia.org/wiki/Prime_factor\n\
    \    var factored_numbers []int\n    var factors []int\n    var largest_factor\
    \ int\n    for i := 1; i <= n; i++ {\n        if n % i == 0 {\n            factored_numbers\
    \ = append(factored_numbers, i)\n        }\n    }\n    fmt.Println(factored_numbers)\n\
    \    for _, f := range factored_numbers {\n        if is_prime(f) {\n        \
    \    factors = append(factors, f)\n        }\n    }\n    fmt.Println(factors)\n\
    \    for _, f := range factors {\n        if f > largest_factor {\n          \
    \  largest_factor = f\n        }\n    }\n    return largest_factor\n}\n", "  \
    \  i := 2\n    for ; i < n; i++ {\n        if n % i == 0 {\n            n /= i\n\
    \            i--\n        }\n    }\n    return i\n}\n", "    var largest int\n\
    \    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            n /= i\n\
    \            largest = i\n        }\n    }\n    return largest\n}\n", "    for\
    \ i := n / 2; i > 0; i-- {\n        if n % i == 0 {\n            return largest_prime_factor(i)\n\
    \        }\n    }\n    return n\n}\n", "    for n%2 == 0 {\n        n = n/2\n\
    \    }\n    largest := 0\n    for i := 3; i <= n; i = i+2 {\n        if n%i ==\
    \ 0 {\n            largest = i\n            n = n/i\n        }\n    }\n    return\
    \ largest\n}\n", "    biggestPrime := 0\n    for i := 2; i <= n; i++ {\n     \
    \   for n % i == 0 {\n            biggestPrime = i\n            n /= i\n     \
    \   }\n    }\n    return biggestPrime\n}\n", "    var i, last int\n    for i =\
    \ 2; i <= n; i++ {\n        if n % i == 0 {\n            last = i\n          \
    \  n /= i\n            for n % i == 0 {\n                n /= i\n            }\n\
    \        }\n    }\n    return last\n}\n", "    largest := 2\n    i := 2\n    for\
    \ i < n {\n        if n % i == 0 {\n            n = n / i\n            largest\
    \ = i\n        } else {\n            i += 1\n        }\n    }\n    return largest\n\
    }\n", "    i := 2\n    for ; i < n; i++ {\n        if n % i == 0 {\n         \
    \   break\n        }\n    }\n    if i < n {\n        return largest_prime_factor(n\
    \ / i)\n    }\n    return n\n}\n", "    for i := 2; i < n; i++ {\n        if n\
    \ % i == 0 {\n            return largest_prime_factor(n / i)\n        }\n    }\n\
    \    return n\n}\n", "    // Factors of a number:\n    // https://en.wikipedia.org/wiki/Factorization\n\
    \    //\n    // Algorithm:\n    //\n    // Divide the number by the smallest prime\
    \ number possible.\n    // If the number is a prime, then it is the largest prime\
    \ factor of the original number.\n    // Otherwise, repeat the process with the\
    \ quotient of the division.\n    //\n    // i.e.\n    //\n    // In case of 2048\n\
    \    //\n    // 2048 = 2 * 1024\n    // 1024 = 2 * 512\n    // 512 = 2 * 256\n\
    \    // 256 = 2 * 128\n    // 128 = 2 * 64\n    // 64 = 2 * 32\n    // 32 = 2\
    \ * 16\n    // 16 = 2 * 8\n    // 8 = 2 * 4\n    // 4 = 2 * 2\n    // 2 = 2 *\
    \ 1\n    //\n    // Therefore, the largest prime factor of 2048 is 2.\n    for\
    \ i := 2; i < n; i++ {\n        if n % i == 0 {\n            // i is a factor\
    \ of n\n            return largest_prime_factor(n / i)\n        }\n    }\n   \
    \ return n\n}\n", "    largest := -1\n    for p := 2; p < n; p++ {\n        if\
    \ n % p == 0 {\n            // n is not prime. Is p prime?\n            if is_prime(p)\
    \ {\n                if p > largest {\n                    largest = p\n     \
    \           }\n            }\n        }\n    }\n    return largest\n}\n", "  \
    \  for i := 2; i <= n; i++ {\n        if n % i == 0 {\n            return n /\
    \ i\n        }\n    }\n    return n\n}\n", "    for i := 2; i <= n; i++ {\n  \
    \      if n % i == 0 {\n            // n is not a prime and it is divisible by\
    \ i,\n            // divide n by i to get the result and\n            // store\
    \ it in the next iteration of the loop\n            n = n / i\n            i =\
    \ 1\n        }\n    }\n    return n\n}\n", "    i := 2\n    // Dividend of the\
    \ prime factorization\n    for d := n; d > 1; {\n        if d % i == 0 {\n   \
    \         d /= i\n        } else {\n            i++\n        }\n    }\n    return\
    \ i\n}\n", "    var factors []int\n    var result int\n\n    for i := 1; i <=\
    \ n; i++ {\n        if n % i == 0 {\n            factors = append(factors, i)\n\
    \        }\n    }\n\n    // fmt.Println(factors)\n\n    for i := len(factors)\
    \ - 1; i >= 0; i-- {\n        prime := true\n        for j := 2; j < factors[i];\
    \ j++ {\n            if factors[i] % j == 0 {\n                prime = false\n\
    \                break\n            }\n        }\n        if prime {\n       \
    \     result = factors[i]\n            break\n        }\n    }\n\n    return result\n\
    }\n", "    p := 1\n    // Assume n is not a prime factor, so that we can\n   \
    \ // start with p = 1.\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n\
    \            // n is divisible by i, and i is the largest divisor\n          \
    \  // in [1, n].\n            n /= i\n            // p is either 1, or a prime\
    \ factor of n.\n            p = i\n        }\n    }\n    return p\n}\n", "   \
    \ p, q := 2, n\n    for p*p <= q {\n        if q % p == 0 {\n            q /=\
    \ p\n        } else {\n            p++\n        }\n    }\n    return q\n}\n",
  "    factors := []int{}\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n\
    \            factors = append(factors, i)\n            n /= i\n            i =\
    \ 1\n        }\n    }\n    return factors[len(factors) - 1]\n}\n", "    // Let's\
    \ start with the square root\n    if n % 2 == 0 {\n        return 2\n    }\n \
    \   if n % 3 == 0 {\n        return 3\n    }\n    if n % 5 == 0 {\n        return\
    \ 5\n    }\n    if n % 7 == 0 {\n        return 7\n    }\n    if n % 11 == 0 {\n\
    \        return 11\n    }\n    if n % 13 == 0 {\n        return 13\n    }\n  \
    \  if n % 17 == 0 {\n        return 17\n    }\n    if n % 19 == 0 {\n        return\
    \ 19\n    }\n    if n % 23 == 0 {\n        return 23\n    }\n    // Do I really\
    \ need to go any further?\n    if n % 29 == 0 {\n        return 29\n    }\n  \
    \  if n % 31 == 0 {\n        return 31\n    }\n    if n % 37 == 0 {\n        return\
    \ 37\n    }\n    if n % 41 == 0 {\n        return 41\n    }\n    if n % 43 ==\
    \ 0 {\n        return 43\n    }\n    if n % 47 == 0 {\n        return 47\n   \
    \ }\n    if n % 53 == 0 {\n        return 53\n    }\n    if n % 59 == 0 {\n  \
    \      return 59\n    }\n    if n % 61 == 0 {\n        return 61\n    }\n    if\
    \ n % 67 == 0 {\n        return 67\n    }\n    if n % 71 == 0 {\n        return\
    \ 71\n    }\n    if n % 73 == 0 {\n        return 73\n    }\n    if n % 79 ==\
    \ 0 {\n        return 79\n    }\n    if n % 83 == 0 {\n        return 83\n   \
    \ }\n    if n % 89 == 0 {\n        return 89\n    }\n    if n % 97 == 0 {\n  \
    \      return 97\n    }\n    if n % 101 == 0 {\n        return 101\n    }\n  \
    \  if n % 103 == 0 {\n        return 103\n    }\n    if n % 107 == 0 {\n     \
    \   return 107\n    }\n    if n % 109 == 0 {\n        return 109\n    }\n    if\
    \ n % 113 == 0 {\n        return 113\n    }\n    if n % 127 == 0 {\n", "    if\
    \ n % 2 == 0 {\n        return 2\n    }\n\n    for i := 3; i * i <= n; i += 2\
    \ {\n        if n % i == 0 {\n            return largest_prime_factor(n / i)\n\
    \        }\n    }\n\n    return n\n}\n", "    if n == 2 {\n        return 2\n\
    \    }\n    var j int\n    for j = 2; j <= n; j++ {\n        if n % j == 0 {\n\
    \            break\n        }\n    }\n    return largest_prime_factor(n / j)\n\
    }\n", "    var i, j int\n    i = 2\n    for i < n {\n        if n % i == 0 {\n\
    \            j = n / i\n            if j == 1 {\n                return i\n  \
    \          }\n            if j == i {\n                return j\n            }\n\
    \            if is_prime(j) {\n                return j\n            }\n     \
    \       i = i + 1\n        } else {\n            i = i + 1\n        }\n    }\n\
    \    return n\n}\n", "    p := n\n    f := 2\n    for p > 1 {\n        if p %\
    \ f == 0 {\n            p /= f\n        } else {\n            f += 1\n       \
    \ }\n    }\n    return f\n}\n", "    factors := make([]int, 0)\n    p := 2\n \
    \   for n % p == 0 {\n        factors = append(factors, p)\n        n /= p\n \
    \   }\n    p = 3\n    for n != 1 {\n        if is_prime(p) {\n            if n\
    \ % p == 0 {\n                factors = append(factors, p)\n                n\
    \ /= p\n            } else {\n                p += 2\n            }\n        }\
    \ else {\n            p += 2\n        }\n    }\n    return factors[len(factors)\
    \ - 1]\n}\n", "    factor := 2\n    for n % factor == 0 {\n        n /= factor\n\
    \    }\n    factor = 3\n    for factor*factor <= n {\n        for n % factor ==\
    \ 0 {\n            n /= factor\n        }\n        factor += 2\n    }\n    if\
    \ n > 1 {\n        return n\n    }\n    return factor\n}\n", "    largest_factor\
    \ := 0\n    for i := 2; i < n; i++ {\n        if n % i == 0 {\n            if\
    \ i > largest_factor {\n                largest_factor = i\n            }\n  \
    \          n = n / i\n            i = 2\n        }\n    }\n    return largest_factor\n\
    }\n", "    // starting from 2, try divisors\n    i := 2\n    for {\n        if\
    \ n % i == 0 {\n            // found one. n has at least one prime factor which\
    \ is i.\n            // now we need to find the largest one.\n            return\
    \ largest_prime_factor(n / i)\n        }\n        i += 1\n    }\n    return n\
    \ // if n is a prime, n itself is the largest prime factor\n}\n", "    // For\
    \ the largest prime factor, start from sqrt(n) and work your way down.\n    for\
    \ i := n / 2; i > 1; i-- {\n        if is_prime(i) && n % i == 0 {\n         \
    \   return i\n        }\n    }\n    return n\n}\n", "    var largest int = 2\n\
    \    var d int = 2\n    var r int = n\n\n    // sieve to find primes < n\n   \
    \ for d * d <= n {\n        // n is divisible by d\n        if r % d == 0 {\n\
    \            r = r / d\n            largest = d\n        } else {\n          \
    \  d += 1\n        }\n    }\n\n    if r > largest {\n        return r\n    } else\
    \ {\n        return largest\n    }\n}\n", "    var i int = n / 2\n    var output\
    \ int = 0\n    for ; i > 0; i-- {\n        if n % i == 0 {\n            output\
    \ = i\n            break\n        }\n    }\n    return output\n}\n", "    if n\
    \ % 2 == 0 {\n        return 2\n    }\n    i := 3\n    for ; n % i != 0; i +=\
    \ 2 {\n    }\n    return i\n}\n", "    if n < 2 {\n        return 0\n    }\n \
    \   currentPrime := 2\n    for currentPrime * currentPrime <= n {\n        for\
    \ n % currentPrime == 0 {\n            n /= currentPrime\n        }\n        currentPrime\
    \ += 1\n    }\n    return n\n}\n", "    // Ensure n > 1.\n    if n <= 1 {\n  \
    \      return n\n    }\n\n    // Loop through all possible primes in n.\n    for\
    \ i := 2; i <= n; i++ {\n        // If i is a factor of n and a prime then i is\
    \ a prime factor of n.\n        if n % i == 0 && is_prime(i) {\n            return\
    \ i\n        }\n    }\n\n    // If we reach here then n is prime.\n    return\
    \ n\n}\n", "    var prime int\n    for i := 2; i <= n; i++ {\n        if n % i\
    \ == 0 {\n            prime = i\n            n /= i\n            i = 1\n     \
    \   }\n    }\n    return prime\n}\n", "    for i := 2; i < n; i++ {\n        if\
    \ n % i == 0 {\n            return largest_prime_factor(n / i)\n        }\n  \
    \  }\n    return n\n}\n", "    for i := 2; i < n; i++ {\n        if n % i == 0\
    \ {\n            n /= i\n            i = 1\n        }\n    }\n    return n\n}\n",
  "    var factors []int\n    var largest int\n    for i := 2; i <= n; i++ {\n   \
    \     if n % i == 0 {\n            n /= i\n            factors = append(factors,\
    \ i)\n            largest = i\n        }\n    }\n    fmt.Println(factors)\n  \
    \  return largest\n}\n", "    r := 0\n    for i := 2; i < n; i++ {\n        if\
    \ n % i == 0 {\n            largest_prime_factor(n / i)\n            if r < i\
    \ {\n                r = i\n            }\n        }\n    }\n    return r\n}\n",
  "    var max int\n    if n % 2 == 0 {\n        max = 2\n        n /= 2\n    } else\
    \ {\n        max = 1\n    }\n    for i := 3; i <= n; i += 2 {\n        if n %\
    \ i == 0 {\n            n /= i\n            max = i\n        }\n    }\n    return\
    \ max\n}\n", "    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n       \
    \     n /= i\n            i--\n        }\n    }\n    return n\n}\n", "    prime_factors\
    \ := []int{}\n    max_factor := n\n    for n % 2 == 0 {\n        prime_factors\
    \ = append(prime_factors, 2)\n        n /= 2\n    }\n    for i := 3; i <= max_factor;\
    \ i += 2 {\n        for n % i == 0 {\n            prime_factors = append(prime_factors,\
    \ i)\n            max_factor = n / i\n            n /= i\n        }\n    }\n \
    \   return prime_factors[len(prime_factors) - 1]\n}\n", "    for f := 2; f <=\
    \ n; f++ {\n        if n % f == 0 {\n            if IsPrime(n / f) {\n       \
    \         return n / f\n            }\n            n /= f\n            f = 1\n\
    \        }\n    }\n    return n\n}\n", "    if n == 1 {\n        return 1\n  \
    \  }\n\n    factor := 2\n    for ; n % factor != 0; factor++ {\n    }\n\n    new_n\
    \ := n / factor\n    if new_n == 1 {\n        return factor\n    } else {\n  \
    \      return largest_prime_factor(new_n)\n    }\n}\n", "    for i := 2; i <=\
    \ n/2; i++ {\n        if n % i == 0 {\n            return largest_prime_factor(n/i)\n\
    \        }\n    }\n    return n\n}\n", "    factors := make([]int, 0)\n    for\
    \ i := 2; i < n; i++ {\n        if n % i == 0 {\n            factors = append(factors,\
    \ i)\n        }\n    }\n    for i := len(factors) - 1; i >= 0; i-- {\n       \
    \ is_prime := true\n        for j := 0; j < i; j++ {\n            if factors[i]\
    \ % factors[j] == 0 {\n                is_prime = false\n                break\n\
    \            }\n        }\n        if is_prime {\n            return factors[i]\n\
    \        }\n    }\n    return n\n}\n", "    var i int = 2\n    for ; i * i < n;\
    \ i++ {\n        for ; n % i == 0; n /= i {\n        }\n    }\n    return n\n\
    }\n", "    var factor int = 2\n    for factor < n {\n        if n % factor ==\
    \ 0 {\n            n /= factor\n        } else {\n            factor++\n     \
    \   }\n    }\n    return factor\n}\n", "    i := n\n    for n % 2 == 0 {\n   \
    \     n /= 2\n    }\n    for j := 3; j <= n; j += 2 {\n        for n % j == 0\
    \ {\n            n /= j\n        }\n    }\n    if n == 1 {\n        return i /\
    \ 2\n    }\n    return n\n}\n", "    for i := n/2; i > 0; i-- {\n        if n\
    \ % i == 0 {\n            return i\n        }\n    }\n    return n\n}\n", "  \
    \  if n < 1 {\n        return 0\n    }\n    var i int\n    for i = 2; i <= n;\
    \ i++ {\n        if n % i == 0 {\n            break\n        }\n    }\n    return\
    \ i\n}\n", "    for d := 2; d < n; d++ {\n        if (n % d == 0) {\n        \
    \    return largest_prime_factor(n / d)\n        }\n    }\n    return n\n}\n",
  "    var i, max int\n    i = 2\n    max = 0\n    for i < n {\n        if n % i ==\
    \ 0 {\n            if max < i {\n                max = i\n            }\n    \
    \        n = n / i\n        } else {\n            i += 1\n        }\n    }\n \
    \   if max < n {\n        max = n\n    }\n    return max\n}\n", "    var i int\n\
    \    prime := 0\n    for i = 2; i <= n; i++ {\n        for ; n % i == 0; n /=\
    \ i {\n            prime = i\n        }\n    }\n    return prime\n}\n", "    prime_factors\
    \ := []int{}\n    i := 2\n    for ; n != 1; i++ {\n        if n % i == 0 {\n \
    \           prime_factors = append(prime_factors, i)\n            n /= i\n   \
    \         i = 1\n        }\n    }\n    return prime_factors[len(prime_factors)\
    \ - 1]\n}\n", "    largest := 1\n    for d := 2; d < n/2; d++ {\n        if (n\
    \ % d == 0) {\n            largest = d\n            n = n / d\n        }\n   \
    \ }\n    return largest\n}\n", "    factors := make([]int, 0)\n    for i := 2;\
    \ i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors,\
    \ i)\n            if len(factors) == 2 {\n                break\n            }\n\
    \        }\n    }\n    return factors[1]\n}\n", "    return 0\n}\n", "    // YOUR\
    \ CODE HERE\n    return 0\n}\n", "    largest_factor := 1\n    divisor := 2\n\
    \    limit := n\n\n    for limit > 1 {\n        if limit % divisor == 0 {\n  \
    \          largest_factor = divisor\n            limit /= divisor\n        } else\
    \ {\n            divisor += 1\n        }\n    }\n\n    return largest_factor\n\
    }\n", "    if n % 2 == 0 {\n        return largest_prime_factor(n / 2)\n    }\n\
    \    for i := 3; i * i <= n; i += 2 {\n        if n % i == 0 {\n            return\
    \ largest_prime_factor(n / i)\n        }\n    }\n    return n\n}\n", "    factor\
    \ := 2\n    for n > 1 {\n        if n % factor == 0 {\n            n /= factor\n\
    \        } else {\n            factor++\n        }\n    }\n    return factor\n\
    }\n", "    max := 1\n    for i := 2; i < n; i++ {\n        if n % i == 0 {\n \
    \           if is_prime(i) {\n                max = i\n            }\n       \
    \ }\n    }\n    return max\n}\n", "    for i := 2; i <= n; i++ {\n        for\
    \ n % i == 0 {\n            n /= i\n        }\n    }\n    return n\n}\n", "  \
    \  var factors []int\n    factor := 2\n    for n % factor == 0 {\n        factors\
    \ = append(factors, factor)\n        n /= factor\n    }\n    factor += 1\n   \
    \ for n > 1 {\n        if n % factor == 0 {\n            factors = append(factors,\
    \ factor)\n            n /= factor\n        } else {\n            factor += 2\n\
    \        }\n    }\n    max := 0\n    for _, x := range factors {\n        if x\
    \ > max {\n            max = x\n        }\n    }\n    return max\n}\n", "    if\
    \ n % 2 == 0 {\n        return largest_prime_factor(n / 2)\n    }\n    for i :=\
    \ 3; i <= n; i += 2 {\n        if n % i == 0 {\n            return largest_prime_factor(n\
    \ / i)\n        }\n    }\n    return n\n}\n", "    // idea: start with a divisor\
    \ of 2 and keep increasing it until we get\n    // a factor.\n    factor := 2\n\
    \    for i := 2; i < n; i++ {\n        if n % i == 0 {\n            factor = i\n\
    \            n = n / i\n            // n is now i so we reset i to 2\n       \
    \     i = 2\n        }\n    }\n    return factor\n}\n", "    if (n < 2) {\n  \
    \      panic(\"n must be greater than 1\")\n    }\n    if (is_prime(n)) {\n  \
    \      panic(\"n must not be a prime\")\n    }\n    for x := n; x > 1; x-- {\n\
    \        if (n % x == 0 && is_prime(x)) {\n            return x\n        }\n \
    \   }\n    return 1\n}\n", "    lpf := 0\n    for i := 2; i < n; i++ {\n     \
    \   if n % i == 0 {\n            if is_prime(i) {\n                lpf = i\n \
    \           }\n        }\n    }\n    return lpf\n}\n", "    l := len(factorize(n))\
    \ - 1\n    return factorize(n)[l]\n}\n", "    p := 2\n    for n % p == 0 {\n \
    \       n /= p\n    }\n    for i := 3; i * i <= n; i += 2 {\n        for n % i\
    \ == 0 {\n            n /= i\n        }\n    }\n    if n == 1 {\n        return\
    \ p\n    }\n    return n\n}\n", "    var largest int = 1\n    for i := 2; i <=\
    \ n; i++ {\n        if n % i == 0 {\n            largest = i\n            n /=\
    \ i\n            i--\n        }\n    }\n    return largest\n}\n", "    if n %\
    \ 2 == 0 {\n        return largest_prime_factor(n / 2)\n    }\n    for i := 3;\
    \ i < n; i += 2 {\n        if n % i == 0 {\n            return largest_prime_factor(n\
    \ / i)\n        }\n    }\n    return n\n}\n", "    prime_factors := make([]int,\
    \ 0)\n    for i := 2; i < n; i++ {\n        if n % i == 0 {\n            prime_factors\
    \ = append(prime_factors, i)\n        }\n    }\n    return prime_factors[len(prime_factors)\
    \ - 1]\n}\n", "    // Use the assumption that n is not a prime to get a divisor\
    \ d of n.\n    for d := 2; d < n; d++ {\n        if n % d == 0 {\n           \
    \ // d must be a factor of n. Since d < n,\n            // n/d is also a factor\
    \ of n.\n            // Does n/d have any factors besides 1 and itself?\n    \
    \        for n2 := 2; n2 < n/d; n2++ {\n                if (n/d) % n2 == 0 {\n\
    \                    // n/d has another factor.\n                    // Is it\
    \ a prime?\n                    for d2 := 2; d2 < n/d/n2; d2++ {\n           \
    \             if (n/d/n2) % d2 == 0 {\n                            // Nope. Try\
    \ the next number.\n                            continue\n                   \
    \     }\n                    }\n                    // If we didn't find any other\
    \ factors, then\n                    // n/d/n2 is prime.\n                   \
    \ return n/d/n2\n                }\n            }\n            // If we didn't\
    \ find any other factors, then n/d is prime.\n            return n/d\n       \
    \ }\n    }\n    // n is prime.\n    return n\n}\n", "    max := 1\n    for i :=\
    \ 2; i <= n; i++ {\n        for ; n % i == 0; n /= i {\n            max = i\n\
    \        }\n    }\n    return max\n}\n", "    i := 2\n    for n % i != 0 {\n \
    \       i += 1\n    }\n    // return n if n is prime\n    if n == i {\n      \
    \  return n\n    }\n    return largest_prime_factor(n / i)\n}\n", "    var largest_factor\
    \ int\n    for i := 2; i < n; i++ {\n        if n % i == 0 {\n            largest_factor\
    \ = largest_prime_factor(n / i)\n            break\n        }\n    }\n    if largest_factor\
    \ == 0 {\n        return n\n    }\n    return largest_factor\n}\n", "    if n\
    \ % 2 == 0 {\n        return 2\n    }\n    if n % 3 == 0 {\n        return 3\n\
    \    }\n    if n % 5 == 0 {\n        return 5\n    }\n    if n % 7 == 0 {\n  \
    \      return 7\n    }\n    if n % 11 == 0 {\n        return 11\n    }\n    var\
    \ i int\n    for i = 13; i < n; i++ {\n        if n % i == 0 {\n            return\
    \ i\n        }\n    }\n    return i\n}\n", "    if n == 2 {\n        return 2\n\
    \    }\n    factor := 2\n    for n%factor != 0 {\n        factor += 1\n    }\n\
    \    max_prime_factor := factor\n    for n/factor > factor {\n        factor +=\
    \ 1\n        for n%factor != 0 {\n            factor += 1\n        }\n       \
    \ max_prime_factor = factor\n    }\n    return max_prime_factor\n}\n", "    if\
    \ n < 2 {\n        panic(\"Argument must be greater than 1\")\n    }\n\n    //\
    \ TODO: must be a faster way to get a list of primes\n    for p := 2; p < n; p++\
    \ {\n        if is_prime(p) {\n            if n % p == 0 {\n                return\
    \ p\n            }\n        }\n    }\n\n    panic(\"Unreachable\")\n}\n", "  \
    \  // Get all factors of n.\n    factors := factors_of(n)\n\n    // Get prime\
    \ factors.\n    prime_factors := []int{}\n    for _, f := range factors {\n  \
    \      if is_prime(f) {\n            prime_factors = append(prime_factors, f)\n\
    \        }\n    }\n\n    // Return the largest prime factor.\n    return max(prime_factors)\n\
    }\n", "    x := 2\n    for x*x <= n {\n        if n % x == 0 {\n            n\
    \ /= x\n        } else {\n            x += 1\n        }\n    }\n    return n\n\
    }\n", "    var i int\n    if n % 2 == 0 {\n        i = 2\n    } else {\n     \
    \   i = 3\n    }\n    for i * i <= n {\n        if n % i == 0 {\n            n\
    \ /= i\n        } else {\n            i += 2\n        }\n    }\n    return n\n\
    }\n", "    f := 2\n    for n > 1 {\n        if n % f == 0 {\n            n /=\
    \ f\n        } else {\n            f++\n        }\n    }\n    return f\n}\n",
  "    var largest, i int\n    largest = 1\n    i = 1\n    for i <= n {\n        if\
    \ n % i == 0 {\n            n = n / i\n            largest = i\n        }\n  \
    \      i++\n    }\n    return largest\n}\n", "    for i := n - 1; i > 1; i-- {\n\
    \        if n % i == 0 {\n            return largest_prime_factor(i)\n       \
    \ }\n    }\n    return n\n}\n", "    // TODO: Implement this.\n    return 0\n\
    }\n", "    // Eratosthenes sieve\n    var i, j int\n    var is_prime = make([]bool,\
    \ n)\n    for i = 2; i < n; i++ {\n        is_prime[i] = true\n    }\n    for\
    \ i = 2; i < n; i++ {\n        if is_prime[i] {\n            j = i\n         \
    \   for j += i; j < n; j += i {\n                is_prime[j] = false\n       \
    \     }\n        }\n    }\n\n    // Find the largest prime factor of n.\n    for\
    \ i = n - 1; i > 0; i-- {\n        if n % i == 0 && is_prime[i] {\n          \
    \  return i\n        }\n    }\n    return -1\n}\n", "    if n < 2 {\n        return\
    \ -1\n    }\n    factors := make([]int, 0)\n    i := 2\n    for n != 1 {\n   \
    \     if n % i == 0 {\n            factors = append(factors, i)\n            n\
    \ /= i\n        } else {\n            i++\n        }\n    }\n    return factors[len(factors)\
    \ - 1]\n}\n", "    var i int = 2\n    var last_factor int = 1\n    for i * i <=\
    \ n {\n        if n % i == 0 {\n            last_factor = i\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    if n == 1 {\n\
    \        return last_factor\n    } else {\n        return n\n    }\n}\n", "  \
    \  // For each possible factor i.\n    for i := 2; i <= n; i++ {\n        // If\
    \ i divides n evenly.\n        if n % i == 0 {\n            // Divide n by i and\
    \ call the function again.\n            return largest_prime_factor(n / i)\n \
    \       }\n    }\n    // If no factor evenly divides n, n is prime and the largest\
    \ factor.\n    return n\n}\n", "    var result int\n    for i := 2; i <= n; i++\
    \ {\n        for ; n % i == 0; n /= i {\n            result = i\n        }\n \
    \   }\n    return result\n}\n", "    factors := []int{}\n    for i := 2; i <=\
    \ n; i++ {\n        for n % i == 0 {\n            factors = append(factors, i)\n\
    \            n /= i\n        }\n    }\n    return factors[len(factors) - 1]\n\
    }\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
