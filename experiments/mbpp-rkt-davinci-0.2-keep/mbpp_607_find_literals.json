{
  "name": "mbpp_607_find_literals",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Write a function to search a string for a regex pattern. The function should return the matching subtring, a start index and an end index.\n(define (find_literals text pattern)\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_607_find_literals.py",
  "prompt_terminology": "verbatim",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate find_literals))\n    (check-equal? (candidate \"The quick brown fox jumps over the lazy dog.\" \"fox\") (list \"fox\" 16 19))\n    (check-equal? (candidate \"Its been a very crazy procedure right\" \"crazy\") (list \"crazy\" 16 21))\n    (check-equal? (candidate \"Hardest choices required strongest will\" \"will\") (list \"will\" 35 39))\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (let ([match (regexp-match pattern text)])\n    (if (null? match)\n        #f\n        (list (substring text (car match) (cadr match)) (car match) (cadr match)))))\n",
    "  (regexp-match pattern text))\n",
    "  (define (find_literal text pattern start)\n    (if (regexp-match pattern text start)\n        (let ([match (regexp-match pattern text start)])\n          (list (substring text (car match) (cadr match))\n                (car match)\n                (cadr match)))\n        (list #f #f #f)))\n  (find_literal text pattern 0))\n",
    "  (regexp-match pattern text))\n",
    "  (regexp-match pattern text))\n",
    "  (regexp-match pattern text))\n",
    "  (regexp-match pattern text))\n",
    "  (regexp-match pattern text))\n",
    "  (regexp-match pattern text))\n",
    "  (regexp-match pattern text))\n",
    "  (regexp-match pattern text))\n",
    "  (regexp-match pattern text))\n",
    "  (regexp-match pattern text))\n",
    "  (regexp-match pattern text))\n",
    "  (regexp-match pattern text))\n",
    "  (let ([match (regexp-match pattern text)])\n    (if (not match)\n        #f\n        (list (substring text (car match) (cadr match))\n              (car match)\n              (cadr match)))))\n",
    "  (regexp-match pattern text))\n",
    "  (regexp-match pattern text))\n",
    "  (regexp-match pattern text))\n",
    "  (regexp-match pattern text))\n"
  ]
}