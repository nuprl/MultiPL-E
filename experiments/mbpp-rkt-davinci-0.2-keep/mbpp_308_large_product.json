{
  "name": "mbpp_308_large_product",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n(define (large_product nums1 nums2 N)\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_308_large_product.py",
  "prompt_terminology": "verbatim",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate large_product))\n    (check-equal? (candidate (list 1 2 3 4 5 6) (list 3 6 8 9 10 6) 3) (list 60 54 50))\n    (check-equal? (candidate (list 1 2 3 4 5 6) (list 3 6 8 9 10 6) 4) (list 60 54 50 48))\n    (check-equal? (candidate (list 1 2 3 4 5 6) (list 3 6 8 9 10 6) 5) (list 60 54 50 48 45))\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (define (helper nums1 nums2 N acc)\n    (if (zero? N)\n        acc\n        (let ([max1 (apply max nums1)]\n              [max2 (apply max nums2)])\n          (helper (remove max1 nums1) (remove max2 nums2) (- N 1) (cons (* max1 max2) acc)))))\n  (helper nums1 nums2 N '()))\n",
    "  (define (helper nums1 nums2 N acc)\n    (cond [(empty? nums1) acc]\n          [(empty? nums2) acc]\n          [else\n           (let* ([n1 (first nums1)]\n                  [n2 (first nums2)]\n                  [p (* n1 n2)]\n                  [acc (if (empty? acc) (list p)\n                          (if (< p (first acc)) acc\n                              (cons p (rest acc))))])\n             (helper (rest nums1) (rest nums2) N acc))]))\n  (helper nums1 nums2 N '()))\n",
    "  (let ([nums1 (sort nums1 >)]\n        [nums2 (sort nums2 >)])\n    (for/list ([i (in-range N)])\n      (* (list-ref nums1 i) (list-ref nums2 i)))))\n",
    "  (define (helper nums1 nums2 N acc)\n    (if (= N 0)\n        acc\n        (let* ([max1 (apply max nums1)]\n               [max2 (apply max nums2)]\n               [max-product (* max1 max2)])\n          (helper (remove max1 nums1) (remove max2 nums2) (- N 1) (cons max-product acc)))))\n  (helper nums1 nums2 N '()))\n",
    "  (define (helper nums1 nums2 N result)\n    (cond\n      [(zero? N) result]\n      [(empty? nums1) result]\n      [(empty? nums2) result]\n      [else\n       (define max-product (apply max (map * nums1 nums2)))\n       (define max-index (apply max (map (lambda (x) (if (= x max-product) 1 0)) (map * nums1 nums2))))\n       (define max-index-nums1 (apply max (map (lambda (x) (if (= x max-product) 1 0)) nums1)))\n       (define max-index-nums2 (apply max (map (lambda (x) (if (= x max-product) 1 0)) nums2)))\n       (helper (remove (list-ref nums1 max-index-nums1) nums1) (remove (list-ref nums2 max-index-nums2) nums2) (- N 1) (cons max-product result))]))\n  (helper nums1 nums2 N '()))\n",
    "  (map (lambda (n) (* n (apply max nums2))) (apply max nums1)))\n",
    "  (let ([nums1 (sort nums1 >)]\n        [nums2 (sort nums2 >)])\n    (for/list ([i (in-range N)])\n      (* (list-ref nums1 i) (list-ref nums2 i)))))\n",
    "  (let loop ([nums1 nums1] [nums2 nums2] [N N] [acc '()])\n    (cond [(zero? N) (reverse acc)]\n          [else\n           (let* ([max1 (apply max nums1)]\n                  [max2 (apply max nums2)]\n                  [product (* max1 max2)])\n             (loop (remove max1 nums1) (remove max2 nums2) (- N 1) (cons product acc)))])))\n",
    "  (define (helper nums1 nums2 N acc)\n    (if (= N 0)\n        acc\n        (let ([max1 (apply max nums1)]\n              [max2 (apply max nums2)])\n          (helper (remove max1 nums1)\n                  (remove max2 nums2)\n                  (- N 1)\n                  (cons (* max1 max2) acc)))))\n  (reverse (helper nums1 nums2 N '())))\n",
    "  (define (helper nums1 nums2 N acc)\n    (if (= N 0)\n        acc\n        (let* ([max1 (apply max nums1)]\n               [max2 (apply max nums2)]\n               [max-product (* max1 max2)])\n          (helper (remove max1 nums1) (remove max2 nums2) (- N 1) (cons max-product acc)))))\n  (helper nums1 nums2 N '()))\n",
    "  (let ([prods (for/list ([n1 nums1] [n2 nums2]) (* n1 n2))])\n    (sort prods >)))\n",
    "  (define (helper nums1 nums2 N result)\n    (cond\n      [(empty? nums1) result]\n      [(empty? nums2) result]\n      [else\n       (define product (apply * (append (list (first nums1)) (list (first nums2)))))\n       (cond\n         [(< (length result) N)\n          (helper (rest nums1) (rest nums2) N (append result (list product)))]\n         [else\n          (helper (rest nums1) (rest nums2) N (append (list product) (remove (min result) result)))])]))\n  (helper nums1 nums2 N '()))\n",
    "  (define (helper nums1 nums2 N)\n    (if (zero? N)\n        '()\n        (cons (list (apply * (take N (sort > nums1)))\n                    (apply * (take N (sort > nums2))))\n              (helper nums1 nums2 (- N 1)))))\n  (helper nums1 nums2 N))\n",
    "  (define (helper nums1 nums2 N result)\n    (if (= N 0)\n        result\n        (let* ([max1 (apply max nums1)]\n               [max2 (apply max nums2)]\n               [max-product (* max1 max2)])\n          (helper (remove max1 nums1) (remove max2 nums2) (- N 1) (cons max-product result)))))\n  (helper nums1 nums2 N '()))\n",
    "  (define (helper nums1 nums2 N acc)\n    (if (zero? N)\n        acc\n        (let* ([max1 (apply max nums1)]\n               [max2 (apply max nums2)]\n               [max-product (* max1 max2)])\n          (helper (remove max1 nums1) (remove max2 nums2) (- N 1) (cons max-product acc)))))\n  (reverse (helper nums1 nums2 N '())))\n",
    "  (define (helper nums1 nums2 N acc)\n    (if (zero? N)\n        acc\n        (helper (cdr nums1) (cdr nums2) (- N 1) (cons (* (car nums1) (car nums2)) acc))))\n  (reverse (helper nums1 nums2 N '())))\n",
    "  (define (helper nums1 nums2 N result)\n    (if (zero? N)\n        result\n        (let ([max-product (apply max (for/list ([x nums1] [y nums2]) (* x y)))])\n          (helper (remove max-product nums1) (remove max-product nums2) (- N 1) (cons max-product result)))))\n  (helper nums1 nums2 N '()))\n",
    "  (let loop ([nums1 nums1] [nums2 nums2] [N N] [result '()])\n    (cond [(zero? N) result]\n          [else (loop (cdr nums1) (cdr nums2) (- N 1) (cons (* (car nums1) (car nums2)) result))])))\n",
    "  (let ([nums1 (sort nums1 >)]\n        [nums2 (sort nums2 >)])\n    (for/list ([i (in-range N)]\n               #:when (not (zero? (nth nums1 i)))\n               #:when (not (zero? (nth nums2 i))))\n      (* (nth nums1 i) (nth nums2 i)))))\n",
    "  (define (helper nums1 nums2 N acc)\n    (if (zero? N)\n        acc\n        (helper (cdr nums1) (cdr nums2) (- N 1) (cons (* (car nums1) (car nums2)) acc))))\n  (reverse (helper nums1 nums2 N '())))\n"
  ]
}