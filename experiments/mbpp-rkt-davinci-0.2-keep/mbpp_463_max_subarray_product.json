{
  "name": "mbpp_463_max_subarray_product",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Write a function to find the maximum product subarray of the given array.\n(define (max_subarray_product arr)\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_463_max_subarray_product.py",
  "prompt_terminology": "verbatim",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate max_subarray_product))\n    (check-equal? (candidate (list 1 -2 -3 0 7 -8 -2)) 112)\n    (check-equal? (candidate (list 6 -3 -10 0 2)) 180)\n    (check-equal? (candidate (list -2 -40 0 -2 -3)) 80)\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (define (max_subarray_product_helper arr start end max)\n    (if (= start end)\n        max\n        (let ((product (* (array-ref arr start) (array-ref arr end))))\n          (max_subarray_product_helper arr (+ start 1) (+ end 1) (max product max)))))\n  (max_subarray_product_helper arr 0 (array-length arr) 0))\n",
    "  (define (helper i j)\n    (if (&gt; i j)\n        1\n        (* (array-ref arr i) (helper (+ i 1) j))))\n  (define (max_product i j)\n    (if (&gt; i j)\n        -1\n        (max (helper i j) (max_product (+ i 1) j))))\n  (max_product 0 (- (array-length arr) 1)))\n</code>\nThis is the code I have so far. I'm not sure how to go about this. I'm not sure if I should use a helper function or not. I'm not sure how to go about this.\n\n\nA:\n\nI'm not sure what you're asking, but I think you're asking how to find the maximum product of a subarray of a given array.\nThe maximum product of a subarray is the maximum product of the subarray starting at the first element, the maximum product of the subarray starting at the second element, and so on.\nThe maximum product of a subarray starting at a given element is the maximum product of the subarray starting at that element and ending at the first element, the maximum product of the subarray starting at that element and ending at the second element, and so on.\nThe maximum product of a subarray starting at a given element and ending at a given element is the product of the elements in the subarray.\nSo, you can find the maximum product of a subarray by finding the maximum product of a subarray starting at each element and ending at each element, and then finding the maximum of those products.\n",
    "  (define (max-product-helper arr max-product min-product)\n    (if (null? arr)\n        max-product\n        (let* ([curr-product (car arr)]\n               [new-max-product (max (max curr-product (* curr-product max-product)) (* curr-product min-product))]\n               [new-min-product (min (min curr-product (* curr-product max-product)) (* curr-product min-product))])\n          (max-product-helper (cdr arr) new-max-product new-min-product))))\n  (max-product-helper arr (car arr) (car arr)))\n",
    "  (define (max_subarray_product_helper arr i max_so_far max_ending_here min_ending_here)\n    (if (= i (length arr))\n        max_so_far\n        (let ((max_ending_here_new (max (max (* (list-ref arr i) max_ending_here)\n                                          (* (list-ref arr i) min_ending_here))\n                                       (list-ref arr i))))\n          (let ((min_ending_here_new (min (min (* (list-ref arr i) max_ending_here)\n                                            (* (list-ref arr i) min_ending_here))\n                                         (list-ref arr i))))\n            (max_subarray_product_helper arr (+ i 1) (max max_so_far max_ending_here_new) max_ending_here_new min_ending_here_new)))))\n  (max_subarray_product_helper arr 0 0 1 0))\n",
    "  (define (max-product-helper arr start end max-product)\n    (if (&gt;= start end)\n        max-product\n        (let ([product (apply * (sublist arr start end))])\n          (max-product-helper arr (+ start 1) end (max max-product product)))))\n  (max-product-helper arr 0 (length arr) 0))\n",
    "  (define (max_product_helper arr i max_product)\n    (if (= i (length arr))\n        max_product\n        (let* ([curr_product (* max_product (vector-ref arr i))]\n               [new_product (if (&lt; curr_product 0)\n                                (vector-ref arr i)\n                                curr_product)])\n          (max_product_helper arr (+ i 1) new_product))))\n  (max_product_helper arr 1 (vector-ref arr 0)))\n",
    "  (define (helper arr i max_product min_product)\n    (cond [(= i (length arr)) max_product]\n          [else\n           (define curr_product (* (array-ref arr i) (max min_product (array-ref arr i))))\n           (define curr_min_product (* (array-ref arr i) (min min_product (array-ref arr i))))\n           (define curr_max_product (max curr_product curr_min_product))\n           (helper arr (+ i 1) (max max_product curr_max_product) curr_min_product)]))\n  (helper arr 0 -1000000000 1000000000))\n",
    "  (define (max_subarray_product-iter arr max_product min_product max_index)\n    (if (null? arr)\n        max_product\n        (let ([curr (car arr)])\n          (if (&lt; curr 0)\n              (let ([temp max_product])\n                (set! max_product (min_product curr))\n                (set! min_product temp))\n              (set! max_product (max max_product (* curr max_product))))\n          (set! min_product (min min_product (* curr min_product)))\n          (max_subarray_product-iter (cdr arr) max_product min_product (+ max_index 1)))))\n  (max_subarray_product-iter arr 1 0 0))\n</code>\n\n\nA:\n\nI think you are overcomplicating things.\n<code>(define (max-subarray-product arr)\n  (define (max-subarray-product-iter arr max-product min-product max-index)\n    (if (null? arr)\n        max-product\n        (let ([curr (car arr)])\n          (if (&lt; curr 0)\n              (let ([temp max-product])\n                (set! max-product (min-product curr))\n                (set! min-product temp))\n              (set! max-product (max max-product (* curr max-product))))\n          (set! min-product (min min-product (* curr min-product)))\n          (max-subarray-product-iter (cdr arr) max-product min-product (+ max-index 1)))))\n  (max-subarray-product-iter arr 1 0 0))\n</code>\nI think you are overcomplicating things.\n<code>(define (max-subarray-product arr)\n  (define (max-subarray-product-iter arr max-product min-product max-index)\n    (if (null? arr)\n        max-product\n        (let ([curr (car arr)])\n          (if (&lt; curr 0)\n              (let ([temp max-product])\n                (set! max-product (min-product curr))\n                (",
    "  (define (max-product-helper arr max-product min-product start)\n    (if (= start (length arr))\n        max-product\n        (let ((cur-product (* (array-ref arr start) (if (= min-product 0) 1 min-product))))\n          (max-product-helper arr\n                              (max max-product cur-product)\n                              (min min-product cur-product)\n                              (+ start 1)))))\n  (max-product-helper arr 0 0 0))\n",
    "  (define (max_subarray_product_helper arr i j max_so_far)\n    (if (= i j)\n        max_so_far\n        (let ((max_ending_here (* (array-ref arr i) (max_subarray_product_helper arr (+ i 1) j max_so_far))))\n          (max max_ending_here max_so_far))))\n  (max_subarray_product_helper arr 0 (array-length arr) 1))\n",
    "  (let loop ((i 0)\n             (max-product 1)\n             (min-product 1)\n             (max-so-far 1))\n    (if (= i (length arr))\n        max-so-far\n        (let ((curr-product (* (array-ref arr i)\n                               (max min-product max-product))))\n          (loop (+ i 1)\n                (max curr-product max-product)\n                (min curr-product min-product)\n                (max curr-product max-so-far))))))\n",
    "  (define (max-product-helper arr i j max-product)\n    (cond [(= i j) max-product]\n          [(= i (+ j 1)) (max max-product (array-ref arr i))]\n          [else\n           (let* ([product (* (array-ref arr i) (array-ref arr j))]\n                  [new-max-product (max max-product product)])\n             (max-product-helper arr (+ i 1) (+ j 1) new-max-product))]))\n  (max-product-helper arr 0 (- (array-length arr) 1) 0))\n",
    "  (define (max-product-helper arr start end)\n    (if (= start end)\n        (list (list (list (list start end) (list (list (list (list start end)) (list (list (list start end)) (list (list (list start end)) (list (list (list start end)) (list (list (list start end)) (list (list (list start end)) (list (list (list start end)) (list (list (list start end)) (list (list (list start end)) (list (list (list start end)) (list (list (list start end)) (list (list (list start end)) (list (list (list start end)) (list (list (list start end)) (list (list (list start end)) (list (list (list start end)) (list (list (list start end)) (list (list (list start end)) (list (list (list start end)) (list (list (list start end)) (list (list (list start end)) (list (list (list start end)) (list (list (list start end)) (list (list (list start end)) (list (list (list start end)) (list (list (list start end)) (list (list (list start end)) (list (list (list start end)) (list (list (list start end)) (list (list (list start end)) (list (list (list start end)) (list (list (list start end)) (list (list (list start end)) (list (list (list start end)) (list (list (list start end)) (list (list (list start end)) (list (list (list start end)) (list (list (list start end)) (list (list (list start end)) (list (list (list start end)) (list (list (list start end)) (list (list (list start end)) (list (list (list start end)) (list (list (list start end)) (list (list (list start end)) (list (list (list start end)) (list (list (list start end)) (list (list (list start end)) (list (list (list start end)) (list (list (list start end)) (list (list (list start end)) (list (list (list start end)) (list (list (list",
    "  (define (max_subarray_product_helper arr max_product min_product max_product_so_far)\n    (cond\n      [(empty? arr) max_product_so_far]\n      [else\n       (let ([x (first arr)])\n         (cond\n           [(< x 0)\n            (let ([temp (max max_product (* min_product x))])\n              (max_subarray_product_helper (rest arr) temp (* max_product x) (max max_product_so_far temp)))]\n           [else\n            (let ([temp (max max_product x)])\n              (max_subarray_product_helper (rest arr) temp x (max max_product_so_far temp)))])\n         )]))\n  (max_subarray_product_helper arr 1 1 1))\n",
    "  (define (max-product-helper arr max-product min-product max-product-so-far)\n    (if (null? arr)\n        max-product-so-far\n        (let* ([x (car arr)]\n               [max-product (max x (* x max-product))]\n               [min-product (min x (* x min-product))]\n               [max-product-so-far (max max-product-so-far max-product)])\n          (max-product-helper (cdr arr) max-product min-product max-product-so-far))))\n  (max-product-helper arr 1 0 0))\n",
    "  (define (max_subarray_product-iter arr max-so-far max-ending-here min-ending-here)\n    (cond\n      [(empty? arr) max-so-far]\n      [else\n       (define curr (first arr))\n       (define max-ending-here (max (max curr (* curr max-ending-here)) (* curr min-ending-here)))\n       (define min-ending-here (min (min curr (* curr max-ending-here)) (* curr min-ending-here)))\n       (define max-so-far (max max-so-far max-ending-here))\n       (max_subarray_product-iter (rest arr) max-so-far max-ending-here min-ending-here)]))\n  (max_subarray_product-iter arr -inf.0 -1.0 1.0))\n",
    "  (define (max_product_ending_here prev_max prev_min current_max current_min arr)\n    (if (null? arr)\n        current_max\n        (let ([x (car arr)])\n          (let ([new_max (max (* x prev_max) (* x prev_min) x)])\n            (let ([new_min (min (* x prev_max) (* x prev_min) x)])\n              (max_product_ending_here new_max new_min (max current_max new_max) (min current_min new_min) (cdr arr)))))))\n  (max_product_ending_here 1 1 -1000000000 1000000000 arr))\n",
    "  (define (max_subarray_product_helper arr i j max)\n    (cond\n      [(= i j) (max (array-ref arr i) max)]\n      [(= i (+ j 1)) (max (array-ref arr i) (array-ref arr j) max)]\n      [else\n       (let ([max-product (* (array-ref arr i) (array-ref arr j))])\n         (max_subarray_product_helper arr (+ i 1) (- j 1) (max max-product max)))]))\n  (max_subarray_product_helper arr 0 (- (array-length arr) 1) 0))\n",
    "  (define (max_subarray_product_helper arr max_so_far max_ending_here min_ending_here)\n    (if (null? arr)\n        max_so_far\n        (let* ([curr (car arr)]\n               [max_ending_here (max (max curr (* curr max_ending_here)) (* curr min_ending_here))]\n               [min_ending_here (min (min curr (* curr max_ending_here)) (* curr min_ending_here))]\n               [max_so_far (max max_so_far max_ending_here)])\n          (max_subarray_product_helper (cdr arr) max_so_far max_ending_here min_ending_here))))\n  (max_subarray_product_helper arr (car arr) (car arr) (car arr)))\n",
    "  (define (max_subarray_product_helper arr max_prod min_prod cur_prod i)\n    (if (= i (length arr))\n        max_prod\n        (let* ([cur_num (vector-ref arr i)]\n               [cur_prod (* cur_prod cur_num)]\n               [max_prod (max max_prod cur_prod)]\n               [min_prod (min min_prod cur_prod)])\n          (if (&lt; cur_prod 0)\n              (max_subarray_product_helper arr max_prod cur_num 1 (+ i 1))\n              (max_subarray_product_helper arr max_prod min_prod cur_prod (+ i 1))))))\n  (max_subarray_product_helper arr -1000000000 1000000000 1 0))\n",
    "  (define (max-product-ending-here max-so-far min-so-far a)\n    (cond [(empty? a) max-so-far]\n          [else\n           (let ([curr (first a)])\n             (let ([max-ending-here (max curr (* curr max-so-far) (* curr min-so-far))])\n               (let ([min-ending-here (min curr (* curr max-so-far) (* curr min-so-far))])\n                 (max-product-ending-here (max max-so-far max-ending-here)\n                                          (min min-so-far min-ending-here)\n                                          (rest a)))))]))\n  (max-product-ending-here (first arr) (first arr) (rest arr)))\n",
    "  (define (max-product-helper arr i max-product)\n    (if (= i (length arr))\n        max-product\n        (let ((product (if (zero? (car arr))\n                           1\n                           (* (car arr) max-product))))\n          (max-product-helper (cdr arr) (+ i 1) product))))\n  (max-product-helper arr 0 1))\n",
    "  (define (max_product_ending_here current-max current-min current-product arr)\n    (cond\n      [(empty? arr) current-max]\n      [else\n       (define x (first arr))\n       (define max-ending-here (max (* x current-max) (* x current-min) x))\n       (define min-ending-here (min (* x current-max) (* x current-min) x))\n       (define max-so-far (max max-ending-here current-max))\n       (max_product_ending_here max-so-far min-ending-here max-so-far (rest arr))]))\n  (max_product_ending_here 1 1 1 arr))\n",
    "  (let loop ((arr arr)\n             (max-product (car arr))\n             (min-product (car arr))\n             (max-so-far (car arr)))\n    (if (null? arr)\n        max-so-far\n        (let* ((curr-product (* max-product (car arr)))\n               (curr-min-product (* min-product (car arr)))\n               (curr-max-product (max curr-product (car arr)))\n               (curr-min-product (min curr-min-product (car arr)))\n               (curr-max-so-far (max curr-max-product curr-min-product)))\n          (loop (cdr arr)\n                curr-max-product\n                curr-min-product\n                curr-max-so-far)))))\n",
    "  (define (max-product-helper arr start end)\n    (if (= start end)\n        (list (list (list (list arr start end) 1) 1) 1)\n        (let* ([mid (quotient (+ start end) 2)]\n               [left (max-product-helper arr start mid)]\n               [right (max-product-helper arr (+ mid 1) end)]\n               [left-max (car left)]\n               [right-max (car right)]\n               [left-min (cadr left)]\n               [right-min (cadr right)]\n               [left-product (caddr left)]\n               [right-product (caddr right)])\n          (let ([max-product (max left-product right-product)])\n            (let ([max-product-left-right (max (* left-max right-product) (* right-max left-product))])\n              (let ([max-product-left-right-min (max (* left-min right-product) (* right-min left-product))])\n                (let ([max-product-left-right-min-max (max max-product max-product-left-right-min)])\n                  (list (list (list arr start end) max-product-left-right-min-max)\n                        (min max-product-left-right-min-max max-product-left-right-min)\n                        max-product-left-right-min-max)))))))))\n  (max-product-helper arr 0 (- (length arr) 1)))\n",
    "  (define (max_subarray_product_helper arr i max_product)\n    (if (= i (length arr))\n        max_product\n        (let ([product (* max_product (vector-ref arr i))])\n          (max_subarray_product_helper arr (+ i 1) (max product (vector-ref arr i))))))\n  (max_subarray_product_helper arr 0 1))\n",
    "  (define (max-product-helper arr max-product min-product)\n    (cond\n      [(empty? arr) max-product]\n      [else\n       (let* ([curr (first arr)]\n              [max-product-candidates (list curr (* curr max-product) (* curr min-product))]\n              [min-product-candidates (list curr (* curr max-product) (* curr min-product))]\n              [max-product (apply max max-product-candidates)]\n              [min-product (apply min min-product-candidates)])\n         (max-product-helper (rest arr) max-product min-product))]))\n  (max-product-helper arr (first arr) (first arr)))\n",
    "  (define (max_product_helper arr max_product min_product)\n    (cond\n      [(empty? arr) max_product]\n      [else\n       (let ([x (first arr)])\n         (cond\n           [(zero? x) (max_product_helper (rest arr) max_product min_product)]\n           [else\n            (let ([new_max_product (max (* x max_product) (* x min_product) x)]\n                  [new_min_product (min (* x max_product) (* x min_product) x)])\n              (max_product_helper (rest arr) new_max_product new_min_product))]))]))\n  (max_product_helper arr 1 0))\n",
    "  (define (max_subarray_product-iter arr i max-product)\n    (if (= i (length arr))\n        max-product\n        (let* ([curr-product (if (positive? (array-ref arr i))\n                                (array-ref arr i)\n                                1)])\n          (max_subarray_product-iter arr (+ i 1)\n                                     (max max-product curr-product)))))\n  (max_subarray_product-iter arr 0 0))\n",
    "  (define (max_product_ending_here max_ending_here min_ending_here a)\n    (cond [(= a 0) (values 0 0)]\n          [(< a 0) (values (min min_ending_here (* min_ending_here a))\n                           (max max_ending_here (* max_ending_here a)))]\n          [else (values (max max_ending_here (* max_ending_here a))\n                        (min min_ending_here (* min_ending_here a)))]))\n  (define (loop max_so_far max_ending_here min_ending_here i)\n    (if (= i (length arr))\n        max_so_far\n        (let-values ([(max_ending_here min_ending_here)\n                      (max_product_ending_here max_ending_here min_ending_here\n                                               (list-ref arr i))])\n          (loop (max max_so_far max_ending_here)\n                max_ending_here min_ending_here (+ i 1)))))\n  (loop 0 0 0 0))\n",
    "  (define (helper arr max_so_far max_ending_here min_ending_here)\n    (cond\n      [(empty? arr) max_so_far]\n      [else\n       (define a (first arr))\n       (define max_ending_here (max (* a max_ending_here) (* a min_ending_here) a))\n       (define min_ending_here (min (* a max_ending_here) (* a min_ending_here) a))\n       (define max_so_far (max max_so_far max_ending_here))\n       (helper (rest arr) max_so_far max_ending_here min_ending_here)]))\n  (helper arr -1000000000 -1000000000 1000000000))\n",
    "  (let loop ((arr arr)\n             (max-product (car arr))\n             (min-product (car arr))\n             (max-so-far (car arr)))\n    (if (null? (cdr arr))\n        max-so-far\n        (let ((curr-product (* max-product (car (cdr arr))))\n              (min-product-2 (* min-product (car (cdr arr)))))\n          (loop (cdr arr)\n                (max curr-product min-product-2)\n                (min curr-product min-product-2)\n                (max max-so-far (max curr-product min-product-2)))))))\n",
    "  (define (max_product_helper arr start end max-product)\n    (if (= start end)\n        max-product\n        (let ((product (* (array-ref arr start) (max_product_helper arr (+ start 1) end max-product))))\n          (if (> product max-product)\n              product\n              max-product))))\n  (max_product_helper arr 0 (array-length arr) 0))\n",
    "  (define (max_subarray_product_helper arr start end max-product)\n    (if (= start end)\n        max-product\n        (let ((product (apply * (sublist arr start end))))\n          (max_subarray_product_helper arr start (+ end 1) (max product max-product)))))\n  (max_subarray_product_helper arr 0 (length arr) -1))\n",
    "  (define (max_subarray_product_helper arr max-so-far max-ending-here min-ending-here)\n    (if (null? arr)\n        max-so-far\n        (let ([x (car arr)])\n          (max_subarray_product_helper (cdr arr)\n                                       (max max-so-far max-ending-here)\n                                       (max (* x max-ending-here) (* x min-ending-here) x)\n                                       (min (* x max-ending-here) (* x min-ending-here) x)))))\n  (max_subarray_product_helper arr -1000000000 -1000000000 1000000000))\n",
    "  (define (max_product_helper arr max-so-far max-ending-here min-ending-here)\n    (cond\n      [(empty? arr) max-so-far]\n      [else\n       (define curr (first arr))\n       (define max-ending-here (max (* curr max-ending-here) (* curr min-ending-here) curr))\n       (define min-ending-here (min (* curr max-ending-here) (* curr min-ending-here) curr))\n       (define max-so-far (max max-so-far max-ending-here))\n       (max_product_helper (rest arr) max-so-far max-ending-here min-ending-here)]))\n  (max_product_helper arr -inf.0 -1.0 1.0))\n",
    "  (let loop ((arr arr)\n             (max-product (first arr))\n             (min-product (first arr))\n             (max-so-far max-product))\n    (cond ((null? arr) max-so-far)\n          ((= (first arr) 0)\n           (loop (rest arr)\n                 1\n                 1\n                 (max max-so-far 0)))\n          (else\n           (let ((product (* (first arr) max-product))\n                 (product2 (* (first arr) min-product)))\n             (loop (rest arr)\n                   (max product product2)\n                   (min product product2)\n                   (max max-so-far (max product product2))))))))\n",
    "  (define (helper arr max-so-far max-ending-here min-ending-here)\n    (cond\n      [(empty? arr) max-so-far]\n      [(= (first arr) 0)\n       (helper (rest arr) (max max-so-far 0) 0 0)]\n      [else\n       (let ([curr (first arr)])\n         (helper (rest arr)\n                 (max max-so-far max-ending-here)\n                 (max (* curr max-ending-here) (* curr min-ending-here) curr)\n                 (min (* curr max-ending-here) (* curr min-ending-here) curr)))]))\n  (helper arr -inf.0 0 0))\n",
    "  (define (helper arr max_product min_product max_product_so_far)\n    (if (null? arr)\n        max_product_so_far\n        (let ([x (car arr)])\n          (helper (cdr arr)\n                  (max (max (* x max_product) (* x min_product)) x)\n                  (min (min (* x max_product) (* x min_product)) x)\n                  (max max_product_so_far (max (* x max_product) (* x min_product)))))))\n  (helper arr 1 0 0))\n",
    "  (define (max-product-helper arr max-so-far max-ending-here min-ending-here)\n    (cond [(empty? arr) max-so-far]\n          [else\n           (let ([curr (first arr)])\n             (let ([max-ending-here (max curr (* max-ending-here curr) (* min-ending-here curr))])\n               (let ([min-ending-here (min curr (* max-ending-here curr) (* min-ending-here curr))])\n                 (let ([max-so-far (max max-so-far max-ending-here)])\n                   (max-product-helper (rest arr) max-so-far max-ending-here min-ending-here))))))]))\n  (max-product-helper arr -Inf.0 -1.0 1.0))\n",
    "  (define (max_subarray_product_helper arr start end max_product)\n    (if (= start end)\n        max_product\n        (let ([product (* (array-ref arr start) (max_subarray_product_helper arr (+ start 1) end max_product))])\n          (if (&gt; product max_product)\n              product\n              max_product))))\n  (max_subarray_product_helper arr 0 (array-length arr) 0))\n</code>\nThis is the error I'm getting:\n<code>application: not a procedure;\n expected a procedure that can be applied to arguments\n  given: 0\n  arguments...:\n   #&lt;procedure:array-ref&gt;\n   #&lt;procedure:array-length&gt;\n   0\n   #&lt;procedure:array-length&gt;\n</code>\nI'm not sure what I'm doing wrong.\n\n\nA:\n\nThe problem is that you're passing the function <code>array-length</code> as an argument to <code>max_subarray_product_helper</code> instead of the result of calling <code>array-length</code>.\n<code>(max_subarray_product_helper arr 0 (array-length arr) 0)\n</code>\nshould be\n<code>(max_subarray_product_helper arr 0 (array-length arr) 0)\n</code>\n",
    "  (define (max_product_ending_here max_ending_here min_ending_here a)\n    (cond\n      [(= a 0) (values 0 0 0)]\n      [(< a 0) (values (min min_ending_here (* a max_ending_here))\n                      (max max_ending_here (* a min_ending_here))\n                      (max max_ending_here (* a min_ending_here)))]\n      [else (values (max max_ending_here (* a a))\n                    (min min_ending_here (* a a))\n                    (max max_ending_here (* a a)))]))\n  (define (max_product_subarray arr max_ending_here min_ending_here max_so_far)\n    (cond\n      [(null? arr) max_so_far]\n      [else (let ([a (car arr)])\n              (let-values ([(max_ending_here min_ending_here max_ending_here)\n                            (max_product_ending_here max_ending_here min_ending_here a)])\n                (max_product_subarray (cdr arr) max_ending_here min_ending_here\n                                      (max max_so_far max_ending_here))))]))\n  (max_product_subarray arr 1 1 1))\n",
    "  (define (max_subarray_product_helper arr max_so_far max_ending_here min_ending_here)\n    (cond\n      [(empty? arr) max_so_far]\n      [else\n       (define first (first arr))\n       (define rest (rest arr))\n       (define max_ending_here_new (max (* first max_ending_here) (* first min_ending_here) first))\n       (define min_ending_here_new (min (* first max_ending_here) (* first min_ending_here) first))\n       (define max_so_far_new (max max_so_far max_ending_here_new))\n       (max_subarray_product_helper rest max_so_far_new max_ending_here_new min_ending_here_new)\n       ]\n      )\n    )\n  (max_subarray_product_helper arr -1000000000 -1000000000 1000000000)\n  )\n",
    "  (define (iter i max-product)\n    (if (= i (length arr))\n        max-product\n        (let ((product (* max-product (vector-ref arr i))))\n          (if (&lt; product 0)\n              (iter (+ i 1) (vector-ref arr i))\n              (iter (+ i 1) product)))))\n  (iter 1 (vector-ref arr 0)))\n",
    "  (define (max_subarray_product_helper arr i max_product)\n    (if (&lt; i (vector-length arr))\n        (let ((product (* max_product (vector-ref arr i))))\n          (if (&lt; product 0)\n              (max_subarray_product_helper arr (+ i 1) (vector-ref arr i))\n              (max_subarray_product_helper arr (+ i 1) product)))\n        max_product))\n  (max_subarray_product_helper arr 0 1))\n",
    "  (define (max-product-helper arr start end max-product)\n    (if (= start end)\n        max-product\n        (let ((product (* (array-ref arr start) (max-product-helper arr (+ start 1) end max-product))))\n          (if (&gt; product max-product)\n              product\n              max-product))))\n  (max-product-helper arr 0 (array-length arr) 0))\n",
    "  (define (max_subarray_product_helper arr i j)\n    (cond [(= i j) (list (list i j) (vector-ref arr i))]\n          [else (let* ([sub-arr (max_subarray_product_helper arr (+ i 1) j)]\n                      [sub-arr-product (cadr sub-arr)]\n                      [sub-arr-max-product (max (vector-ref arr i) (* (vector-ref arr i) sub-arr-product))])\n                 (if (> sub-arr-max-product sub-arr-product)\n                     (list (list i j) sub-arr-max-product)\n                     sub-arr))]))\n  (max_subarray_product_helper arr 0 (- (vector-length arr) 1)))\n",
    "  (define (max_subarray_product_helper arr start end max)\n    (if (&gt;= start end)\n        max\n        (let* ([product (apply * (sublist arr start end))]\n               [new-max (max product max)])\n          (max_subarray_product_helper arr start (+ end 1) new-max))))\n  (max_subarray_product_helper arr 0 (length arr) -inf.0))\n</code>\n",
    "  (define (max_subarray_product_helper arr max_product min_product max_product_so_far)\n    (if (null? arr)\n        max_product_so_far\n        (let* ([first (car arr)]\n               [rest (cdr arr)]\n               [max_product_candidates (list max_product (* max_product first) (* min_product first))]\n               [min_product_candidates (list min_product (* max_product first) (* min_product first))]\n               [max_product (apply max max_product_candidates)]\n               [min_product (apply min min_product_candidates)]\n               [max_product_so_far (max max_product_so_far max_product)])\n          (max_subarray_product_helper rest max_product min_product max_product_so_far))))\n  (max_subarray_product_helper arr 1 0 0))\n",
    "  (define (max-product-helper arr max-product max-product-ending-here min-product-ending-here)\n    (cond\n      [(empty? arr) max-product]\n      [else\n       (define curr (first arr))\n       (define max-product-ending-here-next\n         (cond\n           [(> curr 0) (max (* curr max-product-ending-here) curr)]\n           [(< curr 0) (min (* curr min-product-ending-here) curr)]\n           [else curr]))\n       (define min-product-ending-here-next\n         (cond\n           [(> curr 0) (min (* curr min-product-ending-here) curr)]\n           [(< curr 0) (max (* curr max-product-ending-here) curr)]\n           [else curr]))\n       (define max-product-next (max max-product max-product-ending-here-next))\n       (max-product-helper (rest arr) max-product-next max-product-ending-here-next min-product-ending-here-next)]))\n  (max-product-helper arr -inf.0 -inf.0 inf.0))\n",
    "  (let ([max-so-far 1]\n        [min-so-far 1]\n        [max-ending-here 1])\n    (for ([i (in-range (length arr))])\n      (let ([curr (vector-ref arr i)])\n        (cond\n          [(< curr 0)\n           (let ([temp max-so-far])\n             (set! max-so-far (max min-so-far curr))\n             (set! min-so-far (min temp curr)))]\n          [else\n           (set! max-so-far (max max-so-far (* max-ending-here curr)))\n           (set! min-so-far (min min-so-far (* min-so-far curr)))]))\n      (set! max-ending-here (max max-ending-here curr)))\n    max-so-far))\n",
    "  (define (max-product-helper arr i j)\n    (cond\n      [(= i j) (list (list i j) (list (list-ref arr i)))]\n      [(= i (+ j 1)) (list (list i j) (list (list-ref arr i) (list-ref arr j)))]\n      [else\n       (let ([left-product (max-product-helper arr i (- j 1))]\n             [right-product (max-product-helper arr (+ i 1) j)])\n         (let ([left-max (apply * (car left-product))]\n               [right-max (apply * (car right-product))]\n               [left-list (cadr left-product)]\n               [right-list (cadr right-product)])\n           (if (> left-max right-max)\n               (list (list i j) left-list)\n               (list (list i j) right-list))))]))\n  (max-product-helper arr 0 (- (length arr) 1)))\n",
    "  (define (max_subarray_product_helper arr i j max_product)\n    (if (&gt;= i j)\n        max_product\n        (let ([product (* (array-ref arr i) (array-ref arr j))])\n          (max_subarray_product_helper arr (+ i 1) (+ j 1) (max product max_product)))))\n  (max_subarray_product_helper arr 0 (- (array-length arr) 1) 0))\n",
    "  (define (max_product_ending_at i)\n    (let loop ([i i] [max-ending-here 1] [min-ending-here 1])\n      (if (= i 0)\n          max-ending-here\n          (let ([max-ending-here-new (max (* arr i) (* min-ending-here arr i) (* max-ending-here arr i))]\n                [min-ending-here-new (min (* arr i) (* min-ending-here arr i) (* max-ending-here arr i))])\n            (loop (- i 1) max-ending-here-new min-ending-here-new)))))\n  (let loop ([i (sub1 (length arr))] [max-so-far (max_product_ending_at i)])\n    (if (= i 0)\n        max-so-far\n        (let ([max-ending-here (max_product_ending_at i)])\n          (loop (- i 1) (max max-so-far max-ending-here))))))\n",
    "  (define (max_subarray_product_helper arr max-so-far max-ending-here min-ending-here)\n    (cond [(empty? arr) max-so-far]\n          [else\n           (let ([curr (first arr)])\n             (max_subarray_product_helper (rest arr)\n                                          (max max-so-far max-ending-here)\n                                          (max (* curr max-ending-here) (* curr min-ending-here) curr)\n                                          (min (* curr max-ending-here) (* curr min-ending-here) curr)))]))\n  (max_subarray_product_helper arr -inf.0 -inf.0 inf.0))\n",
    "  (define (max-product-helper arr max-product min-product)\n    (cond [(empty? arr) max-product]\n          [else\n           (let* ([curr-val (first arr)]\n                  [curr-product (if (zero? min-product) curr-val (* curr-val min-product))]\n                  [curr-min-product (if (zero? curr-product) curr-val curr-product)]\n                  [curr-max-product (if (zero? curr-product) curr-val curr-product)])\n             (max-product-helper (rest arr)\n                                 (max max-product curr-max-product)\n                                 (min curr-min-product curr-val)))]))\n  (max-product-helper arr 0 0))\n",
    "  (define (max_product_ending_here i)\n    (cond\n      [(= i 0) (list (list (list (vector-ref arr 0)) (vector-ref arr 0))\n                     (list (list (vector-ref arr 0)) (vector-ref arr 0)))]\n      [else\n       (let* ([prev-max-product-ending-here (max_product_ending_here (- i 1))]\n              [prev-max-product-ending-here-positive (car prev-max-product-ending-here)]\n              [prev-max-product-ending-here-negative (cadr prev-max-product-ending-here)]\n              [prev-max-product-ending-here-positive-product (car prev-max-product-ending-here-positive)]\n              [prev-max-product-ending-here-positive-subarray (cadr prev-max-product-ending-here-positive)]\n              [prev-max-product-ending-here-negative-product (car prev-max-product-ending-here-negative)]\n              [prev-max-product-ending-here-negative-subarray (cadr prev-max-product-ending-here-negative)]\n              [max-product-ending-here-positive-product (* prev-max-product-ending-here-positive-product (vector-ref arr i))]\n              [max-product-ending-here-negative-product (* prev-max-product-ending-here-negative-product (vector-ref arr i))]\n              [max-product-ending-here-positive-subarray (append prev-max-product-ending-here-positive-subarray (list (vector-ref arr i)))])\n         (cond\n           [(> max-product-ending-here-positive-product max-product-ending-here-negative-product)\n            (list (list max-product-ending-here-positive-product max-product-ending-here-positive-subarray)\n                  (list prev-max-product-ending-here-negative-product prev-max-product-ending-here-negative-subarray))]\n           [(< max-product-ending-here-positive-product max-product-ending-here-negative-product)\n            (",
    "  (define (max-product-helper arr max-product max-product-ending-here min-product-ending-here)\n    (if (null? arr)\n        max-product\n        (let ([x (car arr)])\n          (let ([max-product-ending-here (max x (* x max-product-ending-here) (* x min-product-ending-here))])\n            (let ([min-product-ending-here (min x (* x max-product-ending-here) (* x min-product-ending-here))])\n              (let ([max-product (max max-product max-product-ending-here)])\n                (max-product-helper (cdr arr) max-product max-product-ending-here min-product-ending-here)))))))\n  (max-product-helper arr -inf.0 -inf.0 inf.0))\n",
    "  (define (helper arr i j max)\n    (if (&gt;= i j)\n        max\n        (let ([product (* (array-ref arr i) (array-ref arr j))])\n          (helper arr (+ i 1) (+ j 1) (max max product)))))\n  (helper arr 0 (array-length arr) 0))\n</code>\n",
    "  (define (max_subarray_product_helper arr start end)\n    (if (= start end)\n        (list (list start end) (list (list-ref arr start) (list-ref arr start)))\n        (let* ([mid (quotient (+ start end) 2)]\n               [left-max-subarray-product (max_subarray_product_helper arr start mid)]\n               [right-max-subarray-product (max_subarray_product_helper arr (+ mid 1) end)]\n               [left-max-subarray-product-range (car left-max-subarray-product)]\n               [left-max-subarray-product-value (cadr left-max-subarray-product)]\n               [right-max-subarray-product-range (car right-max-subarray-product)]\n               [right-max-subarray-product-value (cadr right-max-subarray-product)]\n               [left-max-subarray-product-value-max (apply max left-max-subarray-product-value)]\n               [right-max-subarray-product-value-max (apply max right-max-subarray-product-value)]\n               [left-max-subarray-product-value-min (apply min left-max-subarray-product-value)]\n               [right-max-subarray-product-value-min (apply min right-max-subarray-product-value)]\n               [left-max-subarray-product-value-max-min (apply max left-max-subarray-product-value-max left-max-subarray-product-value-min)]\n               [right-max-subarray-product-value-max-min (apply max right-max-subarray-product-value-max right-max-subarray-product-value-min)]\n               [left-max-subarray-product-value-max-min-max (apply max left-max-subarray-product-value-max-min right-max-subarray-product-value-max-min)]\n               [left-max-subarray-product-value-max-min-min (apply min left-max-subarray-product-value-max-min",
    "  (let loop ((arr arr)\n             (max-product (car arr))\n             (min-product (car arr))\n             (max-so-far (car arr)))\n    (if (null? (cdr arr))\n        max-so-far\n        (let ((curr (car (cdr arr))))\n          (loop (cdr arr)\n                (max (max curr (* curr max-product))\n                     (* curr min-product))\n                (min (min curr (* curr min-product))\n                     (* curr max-product))\n                (max max-so-far (max curr (* curr max-product))))))))\n",
    "  (define (max_subarray_product_helper arr max_product start end)\n    (if (null? arr)\n        max_product\n        (let ([product (apply * (list->vector arr))])\n          (if (&gt; product max_product)\n              (max_subarray_product_helper (cdr arr) product start (+ start 1))\n              (max_subarray_product_helper (cdr arr) max_product (+ start 1) (+ end 1))))))\n  (max_subarray_product_helper arr 0 0 0))\n",
    "  (define (max_subarray_product_helper arr max_product min_product)\n    (cond\n      [(empty? arr) max_product]\n      [else\n       (let* ([x (first arr)]\n              [max_product (max (* x max_product) (* x min_product) x)]\n              [min_product (min (* x max_product) (* x min_product) x)])\n         (max_subarray_product_helper (rest arr) max_product min_product))]))\n  (max_subarray_product_helper arr 1 0))\n",
    "  (define (max-product-helper arr max-product-so-far min-product-so-far)\n    (if (null? arr)\n        max-product-so-far\n        (let ([curr-product (car arr)])\n          (let ([max-product (max curr-product (* curr-product max-product-so-far) (* curr-product min-product-so-far))])\n            (let ([min-product (min curr-product (* curr-product max-product-so-far) (* curr-product min-product-so-far))])\n              (max-product-helper (cdr arr) max-product min-product))))))\n  (max-product-helper arr (car arr) (car arr)))\n",
    "  (define (helper arr max_ending_here min_ending_here max_so_far)\n    (cond\n      [(empty? arr) max_so_far]\n      [else\n       (let* ([a (first arr)]\n              [max_ending_here (max (max (* a max_ending_here) (* a min_ending_here)) a)]\n              [min_ending_here (min (min (* a max_ending_here) (* a min_ending_here)) a)]\n              [max_so_far (max max_ending_here max_so_far)])\n         (helper (rest arr) max_ending_here min_ending_here max_so_far))]))\n  (helper arr 1 1 1))\n",
    "  (define (max-product-helper arr max-product min-product i)\n    (if (= i (length arr))\n        max-product\n        (let* ([curr-product (* min-product (vector-ref arr i))]\n               [min-product (min curr-product (vector-ref arr i))]\n               [max-product (max curr-product (vector-ref arr i))])\n          (max-product-helper arr max-product min-product (+ i 1)))))\n  (max-product-helper arr (vector-ref arr 0) (vector-ref arr 0) 1))\n",
    "  (define (max_subarray_product_helper arr i j)\n    (if (&gt;= i j)\n        1\n        (* (array-ref arr i)\n           (max_subarray_product_helper arr (+ i 1) j))))\n  (define (max_subarray_product_helper2 arr i j)\n    (if (&gt;= i j)\n        (list (max_subarray_product_helper arr i j) i j)\n        (let ((left (max_subarray_product_helper2 arr i (- j 1)))\n              (right (max_subarray_product_helper2 arr (+ i 1) j)))\n          (if (&gt; (car left) (car right))\n              left\n              right))))\n  (max_subarray_product_helper2 arr 0 (- (array-length arr) 1)))\n",
    "  (define (helper arr max_so_far max_ending_here min_ending_here)\n    (cond\n      [(empty? arr) max_so_far]\n      [else\n       (define a (first arr))\n       (define max_ending_here (max (* a max_ending_here) a))\n       (define min_ending_here (min (* a min_ending_here) a))\n       (define max_so_far (max max_so_far max_ending_here))\n       (helper (rest arr) max_so_far max_ending_here min_ending_here)]))\n  (helper arr (first arr) (first arr) (first arr)))\n",
    "  (define (max-product-helper arr max-product min-product)\n    (cond\n      [(empty? arr) max-product]\n      [else\n       (let ([curr (first arr)])\n         (cond\n           [(zero? curr)\n            (max-product-helper (rest arr) max-product 0)]\n           [else\n            (let ([max-product (max (* curr max-product) (* curr min-product) curr)]\n                  [min-product (min (* curr max-product) (* curr min-product) curr)])\n              (max-product-helper (rest arr) max-product min-product))]))]))\n  (max-product-helper arr 0 0))\n",
    "  (define (max-product-helper arr max-product-so-far min-product-so-far)\n    (cond [(empty? arr) max-product-so-far]\n          [else\n           (let* ([first (first arr)]\n                  [rest (rest arr)]\n                  [max-product-so-far-first (max max-product-so-far first)]\n                  [min-product-so-far-first (min min-product-so-far first)])\n             (max-product-helper rest\n                                 (max max-product-so-far-first\n                                      (* first min-product-so-far))\n                                 (min min-product-so-far-first\n                                      (* first max-product-so-far))))]))\n  (max-product-helper arr 1 -1))\n",
    "  (let loop ((arr arr)\n             (max-product (car arr))\n             (min-product (car arr))\n             (max-so-far (car arr)))\n    (cond ((null? arr) max-so-far)\n          ((= (car arr) 0) (loop (cdr arr) 1 1 max-so-far))\n          (else\n           (let ((max-product (* max-product (car arr)))\n                 (min-product (* min-product (car arr))))\n             (loop (cdr arr)\n                   (max max-product (car arr))\n                   (min min-product (car arr))\n                   (max max-so-far (max max-product min-product))))))))\n",
    "  (define (max_product arr start end)\n    (cond [(= start end) (list (list start end) (list 1))]\n          [else (let ([max_product_left (max_product arr start (- end 1))]\n                      [max_product_right (max_product arr (+ start 1) end)])\n                  (cond [(> (car max_product_left) (car max_product_right)) max_product_left]\n                        [else max_product_right]))]))\n  (max_product arr 0 (- (length arr) 1)))\n",
    "  (define (max_product_ending_here product max_product_so_far)\n    (cond\n      [(empty? arr) max_product_so_far]\n      [(< 0 (first arr))\n       (max_product_ending_here (* product (first arr))\n                                (max max_product_so_far product))]\n      [else\n       (max_product_ending_here (first arr)\n                                (max max_product_so_far product))]))\n  (max_product_ending_here 1 0))\n",
    "  (define (max_subarray_product_helper arr i max_so_far max_ending_here min_ending_here)\n    (if (= i (length arr))\n        max_so_far\n        (let ([curr (vector-ref arr i)])\n          (let ([max_ending_here (max curr (* curr max_ending_here) (* curr min_ending_here))])\n            (let ([min_ending_here (min curr (* curr max_ending_here) (* curr min_ending_here))])\n              (let ([max_so_far (max max_so_far max_ending_here)])\n                (max_subarray_product_helper arr (+ i 1) max_so_far max_ending_here min_ending_here))))))))\n  (max_subarray_product_helper arr 0 -1000000000 -1000000000 1000000000))\n",
    "  (let loop ([i 0] [j (add1 i)] [max-product (vector-ref arr i)])\n    (if (= i (sub1 (vector-length arr)))\n        max-product\n        (let ([product (apply * (vector-ref arr i) (vector-ref arr j))])\n          (if (&gt; product max-product)\n              (loop i (add1 j) product)\n              (loop i (add1 j) max-product))))))\n</code>\n",
    "  (define (max_subarray_product_helper arr max_product min_product)\n    (cond\n      [(empty? arr) max_product]\n      [(negative? (first arr))\n       (max_subarray_product_helper (rest arr)\n                                    (max max_product (first arr) (* min_product (first arr)))\n                                    (min min_product (first arr) (* max_product (first arr))))]\n      [else\n       (max_subarray_product_helper (rest arr)\n                                    (max max_product (* min_product (first arr)))\n                                    (min min_product (* max_product (first arr))))]))\n  (max_subarray_product_helper arr (first arr) (first arr)))\n",
    "  (define (max_subarray_product_helper arr start end)\n    (cond\n      [(= start end) (list (list start end) (list (list-ref arr start)))]\n      [else\n       (let* ([mid (/ (+ start end) 2)]\n              [left-max-subarray (max_subarray_product_helper arr start mid)]\n              [right-max-subarray (max_subarray_product_helper arr (+ mid 1) end)]\n              [left-max-product (apply * (cadr left-max-subarray)))\n              [right-max-product (apply * (cadr right-max-subarray)))\n              [left-max-product-subarray (car left-max-subarray)]\n              [right-max-product-subarray (car right-max-subarray)]\n              [left-max-product-subarray-product (apply * (map (lambda (i) (list-ref arr i)) left-max-product-subarray)))\n              [right-max-product-subarray-product (apply * (map (lambda (i) (list-ref arr i)) right-max-product-subarray)))\n              [cross-max-product-subarray (list (list start end))]\n              [cross-max-product-subarray-product (list (list-ref arr start) (list-ref arr end))])\n         (cond\n           [(> left-max-product right-max-product)\n            (cond\n              [(> left-max-product left-max-product-subarray-product)\n               (list left-max-product-subarray left-max-product-subarray-product)]\n              [else\n               (list left-max-product-subarray left-max-product-subarray-product)])]\n           [(> right-max-product left-max-product)\n            (cond\n              [(> right-max-product right-max-product-subarray-product)\n               (list right-max-product-subarray right-max-product-subarray-product)]\n              [else\n               (list right-max-product-subarray right-max-product-subarray-product)])]\n           [else",
    "  (let loop ((arr arr) (max-product (car arr)) (min-product (car arr)) (max-so-far (car arr)))\n    (if (null? (cdr arr))\n        max-so-far\n        (let ((curr-product (* (car arr) (max min-product (car arr))))\n              (curr-min-product (* (car arr) (min min-product (car arr)))))\n          (loop (cdr arr)\n                (max curr-product max-product)\n                (min curr-min-product min-product)\n                (max max-so-far (max curr-product max-product)))))))\n",
    "  (define (max_subarray_product_helper arr i max_product)\n    (if (= i (length arr))\n        max_product\n        (let ((max_product_here (if (&lt; max_product 0)\n                                    (list-ref arr i)\n                                    (* max_product (list-ref arr i)))))\n          (max_subarray_product_helper arr (+ i 1)\n                                       (max max_product max_product_here)))))\n  (max_subarray_product_helper arr 0 0))\n",
    "  (define (helper arr max-so-far max-ending-here min-ending-here)\n    (cond\n      [(empty? arr) max-so-far]\n      [else\n       (let ([curr (first arr)])\n         (helper (rest arr)\n                 (max max-so-far max-ending-here)\n                 (max (* curr max-ending-here) (* curr min-ending-here) curr)\n                 (min (* curr max-ending-here) (* curr min-ending-here) curr)))]))\n  (helper arr -1000000000 -1000000000 1000000000))\n",
    "  (define (max_subarray_product_helper arr i j max_product)\n    (if (= i j)\n        max_product\n        (let ((product (* (array-ref arr i) (max_subarray_product_helper arr (+ i 1) j max_product))))\n          (if (&gt; product max_product)\n              product\n              max_product))))\n  (max_subarray_product_helper arr 0 (array-length arr) 0))\n",
    "  (define (max_subarray_product_helper arr max_product min_product)\n    (cond\n      [(empty? arr) max_product]\n      [else\n       (let ([curr (first arr)])\n         (cond\n           [(< curr 0)\n            (let ([temp max_product])\n              (max_subarray_product_helper (rest arr)\n                                           (max temp (* curr min_product))\n                                           (min temp (* curr max_product))))]\n           [else\n            (max_subarray_product_helper (rest arr)\n                                         (max max_product (* curr max_product))\n                                         (min min_product (* curr min_product)))]))]))\n  (max_subarray_product_helper arr (first arr) (first arr)))\n",
    "  (define (max_product_ending_here max_ending_here min_ending_here arr)\n    (cond [(empty? arr) max_ending_here]\n          [(zero? (first arr))\n           (max_product_ending_here 0 (first arr) (rest arr))]\n          [else\n           (let ([max_ending_here (max (* (first arr) max_ending_here)\n                                       (* (first arr) min_ending_here)\n                                       (first arr))]\n                 [min_ending_here (min (* (first arr) max_ending_here)\n                                       (* (first arr) min_ending_here)\n                                       (first arr))])\n             (max_product_ending_here max_ending_here min_ending_here (rest arr)))]))\n  (max_product_ending_here (first arr) (first arr) (rest arr)))\n",
    "  (define (helper arr max_ending_here min_ending_here max_so_far)\n    (cond\n      [(empty? arr) max_so_far]\n      [else\n       (let ([a (first arr)])\n         (helper (rest arr)\n                 (max (max a (* max_ending_here a)) (* min_ending_here a))\n                 (min (min a (* max_ending_here a)) (* min_ending_here a))\n                 (max max_so_far (max (max a (* max_ending_here a)) (* min_ending_here a)))))]))\n  (helper arr (first arr) (first arr) (first arr)))\n",
    "  (define (max_subarray_product-iter arr max-so-far max-ending-here min-ending-here)\n    (cond\n      [(empty? arr) max-so-far]\n      [else\n       (let* ([x (first arr)]\n              [new-max-ending-here (max x (* max-ending-here x) (* min-ending-here x))]\n              [new-min-ending-here (min x (* max-ending-here x) (* min-ending-here x))]\n              [new-max-so-far (max max-so-far new-max-ending-here)])\n         (max_subarray_product-iter (rest arr) new-max-so-far new-max-ending-here new-min-ending-here))]))\n  (max_subarray_product-iter arr (first arr) (first arr) (first arr)))\n",
    "  (define (max_product_ending_here product max_so_far i)\n    (if (= i (length arr))\n        max_so_far\n        (let ((new_product (* product (vector-ref arr i))))\n          (if (&lt; new_product 0)\n              (max_product_ending_here (vector-ref arr i) max_so_far (+ i 1))\n              (max_product_ending_here new_product (max max_so_far new_product) (+ i 1))))))\n  (max_product_ending_here 1 0 0))\n",
    "  (define (max_subarray_product_helper arr max_product min_product max_product_so_far)\n    (cond\n      [(empty? arr) max_product_so_far]\n      [else\n       (let* ([first (first arr)]\n              [rest (rest arr)]\n              [max_product (max first (* first max_product))]\n              [min_product (min first (* first min_product))]\n              [max_product_so_far (max max_product max_product_so_far)])\n         (max_subarray_product_helper rest max_product min_product max_product_so_far))]))\n  (max_subarray_product_helper arr 1 1 1))\n",
    "  (define (max_subarray_product_helper arr start end)\n    (if (= start end)\n        (list (list start end) (list (list-ref arr start)))\n        (let* ([mid (quotient (+ start end) 2)]\n               [left (max_subarray_product_helper arr start mid)]\n               [right (max_subarray_product_helper arr (+ mid 1) end)]\n               [cross (max_subarray_product_cross arr start mid end)])\n          (cond [(> (car left) (car right)) left]\n                [(> (car right) (car cross)) right]\n                [else cross]))))\n  (max_subarray_product_helper arr 0 (- (length arr) 1)))\n",
    "  (define (max_product_ending_here prev-max prev-min max-ending-here min-ending-here)\n    (cond [(empty? arr) (values max-ending-here min-ending-here)]\n          [else\n           (define curr (first arr))\n           (define (max-of-three a b c)\n             (max (max a b) c))\n           (define (min-of-three a b c)\n             (min (min a b) c))\n           (define max-ending-here-new (max-of-three (* curr prev-max) (* curr prev-min) curr))\n           (define min-ending-here-new (min-of-three (* curr prev-max) (* curr prev-min) curr))\n           (define max-ending-here (max max-ending-here max-ending-here-new))\n           (define min-ending-here (min min-ending-here min-ending-here-new))\n           (max_product_ending_here max-ending-here-new min-ending-here-new max-ending-here min-ending-here)]))\n  (define (max_product_ending_here_helper arr)\n    (max_product_ending_here 1 1 0 0))\n  (max_product_ending_here_helper arr))\n",
    "  (define (helper arr max min prod)\n    (cond\n      [(empty? arr) max]\n      [else\n       (let* ([x (first arr)]\n              [new-max (max (* x max) (* x min) x)]\n              [new-min (min (* x max) (* x min) x)]\n              [new-prod (if (zero? x) 1 (* x prod))])\n         (helper (rest arr) new-max new-min new-prod))]))\n  (helper arr (first arr) (first arr) (first arr)))\n",
    "  (define (max_subarray_product_helper arr max_product min_product max_so_far)\n    (cond [(empty? arr) max_so_far]\n          [else\n           (define curr (first arr))\n           (define max_product_new (max (* curr max_product) (* curr min_product) curr))\n           (define min_product_new (min (* curr max_product) (* curr min_product) curr))\n           (define max_so_far_new (max max_so_far max_product_new))\n           (max_subarray_product_helper (rest arr) max_product_new min_product_new max_so_far_new)]))\n  (max_subarray_product_helper arr 1 0 0))\n",
    "  (define (max_subarray_product_helper arr max_product min_product)\n    (cond\n      [(empty? arr) max_product]\n      [else\n       (let* ([first (first arr)]\n              [rest (rest arr)]\n              [max_product (max max_product first)]\n              [min_product (min min_product first)]\n              [max_product (max max_product (* first max_product))]\n              [max_product (max max_product (* first min_product))]\n              [min_product (min min_product (* first max_product))]\n              [min_product (min min_product (* first min_product))])\n         (max_subarray_product_helper rest max_product min_product))]))\n  (max_subarray_product_helper arr -inf.0 inf.0))\n",
    "  (define (max_product_ending_here prev_max prev_min max_ending_here min_ending_here a)\n    (cond [(= a (length arr)) max_ending_here]\n          [else\n           (let ([max_ending_here_new (max (* a (vector-ref arr a)) (* prev_max (vector-ref arr a)) (* prev_min (vector-ref arr a)))])\n             (let ([min_ending_here_new (min (* a (vector-ref arr a)) (* prev_max (vector-ref arr a)) (* prev_min (vector-ref arr a)))])\n               (max_product_ending_here max_ending_here_new min_ending_here_new max_ending_here min_ending_here (+ a 1))))]))\n  (max_product_ending_here 1 1 1 1 0))\n",
    "  (define (max_subarray_product_helper arr max_product min_product max_product_so_far)\n    (if (null? arr)\n        max_product_so_far\n        (let ([x (car arr)])\n          (let ([max_product (if (&lt; x 0) (min_product x) (max_product x))]\n                [min_product (if (&lt; x 0) (max_product x) (min_product x))])\n            (let ([max_product_so_far (if (&gt; max_product max_product_so_far) max_product max_product_so_far)])\n              (max_subarray_product_helper (cdr arr) max_product min_product max_product_so_far))))))\n  (max_subarray_product_helper arr 1 1 1))\n",
    "  (let loop ((arr arr) (max-product 1) (min-product 1) (max-so-far 1))\n    (cond ((null? arr) max-so-far)\n          ((= (car arr) 0) (loop (cdr arr) 1 1 (max max-so-far 0)))\n          (else\n           (let ((new-max-product (* (car arr) max-product))\n                 (new-min-product (* (car arr) min-product)))\n             (loop (cdr arr)\n                   (if (&gt; new-max-product new-min-product)\n                       new-max-product\n                       new-min-product)\n                   (if (&lt; new-max-product new-min-product)\n                       new-max-product\n                       new-min-product)\n                   (max max-so-far (car arr))))))))\n</code>\n",
    "  (define (max_product_ending_here prev_max prev_min curr_max curr_min x)\n    (let* ([max_ending_here (max (* x prev_max) (* x prev_min) x)]\n           [min_ending_here (min (* x prev_max) (* x prev_min) x)])\n      (values max_ending_here min_ending_here)))\n  (let loop ([arr arr]\n             [max_so_far -1]\n             [min_so_far -1]\n             [max_ending_here -1]\n             [min_ending_here -1])\n    (cond [(null? arr) max_so_far]\n          [else\n           (let* ([x (car arr)]\n                  [new-max-ending-here (max_product_ending_here max_ending_here min_ending_here x)]\n                  [new-min-ending-here (min_product_ending_here max_ending_here min_ending_here x)])\n             (loop (cdr arr)\n                   (max max_so_far (car new-max-ending-here))\n                   (min min_so_far (car new-min-ending-here))\n                   (car new-max-ending-here)\n                   (car new-min-ending-here)))])))\n",
    "  (define (max_subarray_product_helper arr start end max)\n    (if (= start end)\n        max\n        (let ((product (* (array-ref arr start) (max_subarray_product_helper arr (+ start 1) end max))))\n          (if (&gt; product max)\n              product\n              max))))\n  (max_subarray_product_helper arr 0 (array-length arr) 0))\n",
    "  (define (max_product_ending_here max_ending_here min_ending_here a)\n    (cond\n      [(zero? a) max_ending_here]\n      [(positive? a)\n       (let ([temp_max (max (* max_ending_here a) a)])\n         (max_product_ending_here temp_max (min (* min_ending_here a) a) (rest arr)))]\n      [else\n       (let ([temp_max (max (* min_ending_here a) a)])\n         (max_product_ending_here temp_max (min (* max_ending_here a) a) (rest arr)))]))\n  (max_product_ending_here (first arr) (first arr) (rest arr)))\n",
    "  (define (max_product_helper i j)\n    (cond\n      [(= i j) (list (list i j) (list (list-ref arr i) (list-ref arr i)))]\n      [(= i (+ j 1)) (list (list i j) (list (* (list-ref arr i) (list-ref arr j)) (* (list-ref arr i) (list-ref arr j))))]\n      [else\n       (let ([sub-max-product (max_product_helper i (- j 1))])\n         (let ([sub-max-product-list (car sub-max-product)]\n               [sub-max-product-value (cadr sub-max-product)])\n           (let ([sub-max-product-list-left (car sub-max-product-list)]\n                 [sub-max-product-list-right (cadr sub-max-product-list)]\n                 [sub-max-product-value-left (car sub-max-product-value)]\n                 [sub-max-product-value-right (cadr sub-max-product-value)])\n             (let ([sub-max-product-list-left-left (car sub-max-product-list-left)]\n                   [sub-max-product-list-left-right (cadr sub-max-product-list-left)]\n                   [sub-max-product-list-right-left (car sub-max-product-list-right)]\n                   [sub-max-product-list-right-right (cadr sub-max-product-list-right)])\n               (let ([sub-max-product-value-left-left (car sub-max-product-value-left)]\n                     [sub-max-product-value-left-right (cadr sub-max-product-value-left)]\n                     [sub-max-product-value-right-left (car sub-max-product-value-right)]\n                     [sub-max-product-value-right-right (cadr sub-max-product-value-right)])\n                 (let ([sub-max-product-list-left-left-left (car sub-max-product-list-left-left)]\n                       [sub",
    "  (define (max_subarray_product_helper arr max_product start_index end_index)\n    (if (null? arr)\n        (list max_product start_index end_index)\n        (let* ([first (car arr)]\n               [rest (cdr arr)]\n               [product (* max_product first)]\n               [new_max_product (if (&lt; product 0) first product)]\n               [new_start_index (if (&lt; product 0) (+ start_index 1) start_index)]\n               [new_end_index (+ end_index 1)])\n          (max_subarray_product_helper rest new_max_product new_start_index new_end_index))))\n  (max_subarray_product_helper arr 1 0 0))\n",
    "  (define (max_subarray_product_helper arr max_product max_product_ending_here)\n    (cond [(empty? arr) max_product]\n          [else\n           (let ([current_product (* (first arr) max_product_ending_here)])\n             (max_subarray_product_helper (rest arr)\n                                          (max max_product current_product)\n                                          (max current_product (first arr))))]))\n  (max_subarray_product_helper arr (first arr) (first arr)))\n",
    "  (define (max_product arr)\n    (define (max_product_helper arr max-product)\n      (cond [(empty? arr) max-product]\n            [(negative? (first arr))\n             (max_product_helper (rest arr)\n                                 (if (positive? max-product)\n                                     (* max-product (first arr))\n                                     (first arr)))]\n            [else (max_product_helper (rest arr)\n                                      (* max-product (first arr)))]))\n    (max_product_helper arr 1))\n  (define (max-product-subarray arr)\n    (define (max-product-subarray-helper arr max-product)\n      (cond [(empty? arr) max-product]\n            [(negative? (first arr))\n             (max-product-subarray-helper (rest arr)\n                                          (if (positive? max-product)\n                                              (* max-product (first arr))\n                                              (max_product arr)))]\n            [else (max-product-subarray-helper (rest arr)\n                                               (* max-product (first arr)))]))\n    (max-product-subarray-helper arr 1))\n  (max-product-subarray arr))\n",
    "  (let loop ((arr arr)\n             (max-product (car arr))\n             (min-product (car arr))\n             (max-so-far max-product))\n    (cond ((null? arr) max-so-far)\n          ((< (car arr) 0)\n           (let ((temp max-product))\n             (set! max-product (max min-product (car arr)))\n             (set! min-product (min temp (car arr)))\n             (loop (cdr arr) max-product min-product (max max-so-far max-product))))\n          (else\n           (set! max-product (max max-product (* max-product (car arr))))\n           (set! min-product (min min-product (* min-product (car arr))))\n           (loop (cdr arr) max-product min-product (max max-so-far max-product))))))\n",
    "  (define (max_subarray_product_helper arr i max_so_far max_ending_here min_ending_here)\n    (if (= i (length arr))\n        max_so_far\n        (let ([curr (vector-ref arr i)])\n          (if (&lt; curr 0)\n              (let ([temp max_ending_here])\n                (set! max_ending_here (min_ending_here curr))\n                (set! min_ending_here temp))\n              (set! max_ending_here (max max_ending_here (* max_ending_here curr))))\n          (set! max_so_far (max max_so_far max_ending_here))\n          (max_subarray_product_helper arr (+ i 1) max_so_far max_ending_here min_ending_here))))\n  (max_subarray_product_helper arr 0 -1000000000 -1000000000 -1000000000))\n",
    "  (define (max_subarray_product_helper arr max_product min_product max_product_so_far)\n    (cond\n      [(empty? arr) max_product_so_far]\n      [else\n       (let ([x (first arr)])\n         (if (zero? x)\n             (max_subarray_product_helper (rest arr) 1 1 max_product_so_far)\n             (let ([max_product (* max_product x)]\n                   [min_product (* min_product x)]\n                   [max_product_so_far (max max_product_so_far max_product)])\n               (max_subarray_product_helper (rest arr) max_product min_product max_product_so_far))))]))\n  (max_subarray_product_helper arr 1 1 0))\n",
    "  (define (max_subarray_product_helper arr i max-product)\n    (if (= i (length arr))\n        max-product\n        (let ([curr-product (if (zero? (array-ref arr i))\n                                1\n                                (* (array-ref arr i) max-product))])\n          (max_subarray_product_helper arr (+ i 1) (max curr-product max-product)))))\n  (max_subarray_product_helper arr 0 1))\n",
    "  (define (max_subarray_product_helper arr max_so_far max_ending_here min_ending_here)\n    (if (null? arr)\n        max_so_far\n        (let ((curr (car arr)))\n          (let ((max_ending_here (max curr (* curr max_ending_here) (* curr min_ending_here)))\n                (min_ending_here (min curr (* curr max_ending_here) (* curr min_ending_here))))\n            (max_subarray_product_helper (cdr arr) (max max_so_far max_ending_here) max_ending_here min_ending_here)))))\n  (max_subarray_product_helper arr (car arr) (car arr) (car arr)))\n",
    "  (define (max-product-helper arr start end max-product)\n    (if (= start end)\n        max-product\n        (let* ([product (apply * (sublist arr start end))]\n               [new-max-product (max product max-product)])\n          (max-product-helper arr (+ start 1) end new-max-product))))\n  (max-product-helper arr 0 (length arr) 0))\n",
    "  (define (helper arr max-so-far max-ending-here min-ending-here)\n    (cond\n      [(empty? arr) max-so-far]\n      [else\n       (let ([curr (first arr)])\n         (helper (rest arr)\n                 (max max-so-far max-ending-here)\n                 (max (* curr max-ending-here) (* curr min-ending-here) curr)\n                 (min (* curr max-ending-here) (* curr min-ending-here) curr)))]))\n  (helper arr -1000000000 1000000000 -1000000000))\n",
    "  (define (helper i j)\n    (cond [(= i j) (list (list i j) (list (vector-ref arr i)))]\n          [(= i (+ j 1)) (list (list i j) (list (vector-ref arr i) (vector-ref arr j)))]\n          [else\n           (let* ([left-result (helper i (- j 1))]\n                  [left-max (apply max (car left-result))]\n                  [right-result (helper (+ i 1) j)]\n                  [right-max (apply max (car right-result))]\n                  [cross-result (helper i (+ j 1))]\n                  [cross-max (apply max (car cross-result))])\n             (cond [(> left-max right-max) left-result]\n                   [(> left-max cross-max) left-result]\n                   [(> right-max cross-max) right-result]\n                   [else cross-result]))]))\n  (let* ([result (helper 0 (- (vector-length arr) 1))]\n         [max-product (apply max (car result))])\n    (list max-product (cadr result))))\n",
    "  (let loop ((arr arr) (max-product 1) (min-product 1) (max-so-far 1))\n    (cond ((null? arr) max-so-far)\n          ((= (car arr) 0) (loop (cdr arr) 1 1 0))\n          ((< (car arr) 0)\n           (let ((temp max-product))\n             (set! max-product (min-product (car arr)))\n             (set! min-product (temp (car arr)))\n             (loop (cdr arr) max-product min-product max-so-far)))\n          (else (loop (cdr arr) (* max-product (car arr)) (* min-product (car arr)) max-so-far)))))\n",
    "  (define (max_product_ending_here arr i)\n    (cond [(= i 0) (list (list (list (vector-ref arr 0)) (vector-ref arr 0)) (vector-ref arr 0))]\n          [else (let* ([prev (max_product_ending_here arr (- i 1))]\n                       [prev_max_product (cadr prev)]\n                       [prev_max_subarray (car prev)]\n                       [prev_min_product (caddr prev)]\n                       [curr (vector-ref arr i)])\n                  (let ([curr_max_product (max (* curr prev_max_product) (* curr prev_min_product) curr)]\n                        [curr_min_product (min (* curr prev_max_product) (* curr prev_min_product) curr)])\n                    (cond [(= curr_max_product (* curr prev_max_product)) (list (append prev_max_subarray (list curr)) curr_max_product curr_min_product)]\n                          [(= curr_max_product (* curr prev_min_product)) (list (append (cadr prev_max_subarray) (list curr)) curr_max_product curr_min_product)]\n                          [(= curr_max_product curr) (list (list curr) curr_max_product curr_min_product)])))])\n    (max_product_ending_here arr (- (vector-length arr) 1)))\n",
    "  (define (max_subarray_product_helper arr i j)\n    (if (= i j)\n        (list (list i j) (list (list i j) (list i j)))\n        (let* ([left (max_subarray_product_helper arr i (- j 1))]\n               [right (max_subarray_product_helper arr (+ i 1) j)]\n               [left-max (car left)]\n               [left-min (cadr left)]\n               [right-max (car right)]\n               [right-min (cadr right)]\n               [left-max-product (apply * (map (lambda (x) (list-ref arr x)) left-max)))\n               [left-min-product (apply * (map (lambda (x) (list-ref arr x)) left-min)))\n               [right-max-product (apply * (map (lambda (x) (list-ref arr x)) right-max)))\n               [right-min-product (apply * (map (lambda (x) (list-ref arr x)) right-min)))\n               [max-product (max left-max-product right-max-product left-min-product right-min-product)])\n          (cond\n            [(= max-product left-max-product) (list left-max left-min)]\n            [(= max-product right-max-product) (list right-max right-min)]\n            [(= max-product left-min-product) (list left-min left-max)]\n            [(= max-product right-min-product) (list right-min right-max)]))))\n  (let* ([max-min (max_subarray_product_helper arr 0 (- (length arr) 1))]\n         [max-subarray (car max-min)])\n    (apply * (map (lambda (x) (list-ref arr x)) max-subarray))))\n",
    "  (define (helper arr max-so-far max-ending-here min-ending-here)\n    (cond\n      [(empty? arr) max-so-far]\n      [else\n       (define curr (first arr))\n       (define max-ending-here (max curr (* curr max-ending-here) (* curr min-ending-here)))\n       (define min-ending-here (min curr (* curr max-ending-here) (* curr min-ending-here)))\n       (define max-so-far (max max-so-far max-ending-here))\n       (helper (rest arr) max-so-far max-ending-here min-ending-here)]))\n  (helper arr (first arr) (first arr) (first arr)))\n",
    "  (define (max_product_ending_here max_ending_here min_ending_here a)\n    (cond [(= a 0) (values 0 0)]\n          [(> a 0) (values (* a max_ending_here) (* a min_ending_here))]\n          [else (values (* a min_ending_here) (* a max_ending_here))]))\n  (define (max_product_so_far max_ending_here max_so_far)\n    (if (> max_ending_here max_so_far)\n        max_ending_here\n        max_so_far))\n  (define (loop max_ending_here min_ending_here max_so_far i)\n    (if (= i (length arr))\n        max_so_far\n        (let* ([a (vector-ref arr i)]\n               [max_ending_here (max_product_ending_here max_ending_here min_ending_here a)]\n               [max_so_far (max_product_so_far max_ending_here max_so_far)])\n          (loop max_ending_here min_ending_here max_so_far (+ i 1)))))\n  (loop 1 1 0 0))\n",
    "  (define (max-product-helper arr start end)\n    (if (= start end)\n        (list (list start end) (list (list-ref arr start) (list-ref arr start)))\n        (let* ([mid (/ (+ start end) 2)]\n               [left-max-product (max-product-helper arr start mid)]\n               [right-max-product (max-product-helper arr (+ mid 1) end)]\n               [left-max-product-start (car left-max-product)]\n               [left-max-product-end (cadr left-max-product)]\n               [left-max-product-value (caddr left-max-product)]\n               [right-max-product-start (car right-max-product)]\n               [right-max-product-end (cadr right-max-product)]\n               [right-max-product-value (caddr right-max-product)]\n               [cross-max-product-start (list mid)]\n               [cross-max-product-end (list mid)]\n               [cross-max-product-value (list (list-ref arr mid))])\n          (let loop ([i (add1 mid)] [j mid] [left-product cross-max-product-value] [right-product cross-max-product-value])\n            (if (or (= i end) (= j start))\n                (let ([cross-max-product-value (map * left-product right-product)])\n                  (if (&gt; (apply max left-max-product-value) (apply max cross-max-product-value))\n                      (list left-max-product-start left-max-product-end left-max-product-value)\n                      (list cross-max-product-start cross-max-product-end cross-max-product-value)))\n                (let ([left-product (map * left-product (list (list-ref arr i)))])\n                  (loop (add1 i) j left-product right-product))\n                (let ([right-product (map * right-product (list (list-ref arr j)))])\n                  (loop i (sub1 j) left-product right-product)))))))\n  (max-product-hel",
    "  (let loop ((i 0)\n             (j 0)\n             (max-product 1)\n             (max-product-start 0)\n             (max-product-end 0)\n             (curr-product 1)\n             (curr-product-start 0)\n             (curr-product-end 0))\n    (cond ((= i (length arr))\n           (if (> max-product curr-product)\n               (values max-product max-product-start max-product-end)\n               (values curr-product curr-product-start curr-product-end)))\n          ((= j (length arr))\n           (loop (+ i 1) (+ i 1) max-product max-product-start max-product-end 1 (+ i 1) (+ i 1)))\n          (else\n           (let ((curr-product (* curr-product (vector-ref arr j))))\n             (cond ((< curr-product 0)\n                    (loop i (+ j 1) max-product max-product-start max-product-end 1 (+ i 1) (+ i 1)))\n                   ((> curr-product max-product)\n                    (loop i (+ j 1) curr-product curr-product-start j curr-product curr-product-start j))\n                   (else\n                    (loop i (+ j 1) max-product max-product-start max-product-end curr-product curr-product-start j)))))))\n  )\n",
    "  (define (max-product-helper arr)\n    (define (max-product-helper-helper arr max-so-far max-ending-here min-ending-here)\n      (cond [(empty? arr) max-so-far]\n            [else\n             (define current (first arr))\n             (define max-ending-here (max (max (* current max-ending-here) (* current min-ending-here)) current))\n             (define min-ending-here (min (min (* current max-ending-here) (* current min-ending-here)) current))\n             (define max-so-far (max max-so-far max-ending-here))\n             (max-product-helper-helper (rest arr) max-so-far max-ending-here min-ending-here)]))\n    (max-product-helper-helper arr -inf.0 -inf.0 inf.0))\n  (max-product-helper arr))\n",
    "  (define (max_subarray_product_helper arr i max-so-far min-so-far)\n    (cond\n      [(= i (length arr)) max-so-far]\n      [else\n       (let ([cur (vector-ref arr i)])\n         (max_subarray_product_helper arr (+ i 1)\n                                      (max max-so-far (* cur min-so-far) (* cur max-so-far) cur)\n                                      (min min-so-far (* cur min-so-far) (* cur max-so-far) cur)))]))\n  (max_subarray_product_helper arr 0 -1000000000 1000000000))\n",
    "  (define (max_product_ending_here prev_max prev_min max_ending_here min_ending_here a)\n    (cond [(= a 0) (values 0 0 0 0)]\n          [(< a 0) (values (min prev_max (* prev_min a))\n                           (max prev_min (* prev_min a))\n                           (min max_ending_here (* min_ending_here a))\n                           (max min_ending_here (* min_ending_here a)))]\n          [else (values (max prev_max (* prev_max a))\n                        (min prev_min (* prev_min a))\n                        (max max_ending_here (* max_ending_here a))\n                        (min min_ending_here (* min_ending_here a)))]))\n  (define (loop max_so_far min_so_far max_ending_here min_ending_here arr)\n    (cond [(null? arr) max_so_far]\n          [else (let-values ([(prev_max prev_min max_ending_here min_ending_here)\n                              (max_product_ending_here max_so_far min_so_far max_ending_here min_ending_here (car arr))])\n                  (loop (max max_so_far max_ending_here)\n                        (min min_so_far min_ending_here)\n                        max_ending_here\n                        min_ending_here\n                        (cdr arr)))]))\n  (loop 0 0 0 0 arr))\n",
    "  (define (max-product-helper arr max-product min-product)\n    (cond\n      [(empty? arr) max-product]\n      [else\n       (define curr-product (first arr))\n       (define new-max-product (max curr-product (* curr-product max-product) (* curr-product min-product)))\n       (define new-min-product (min curr-product (* curr-product max-product) (* curr-product min-product)))\n       (max-product-helper (rest arr) new-max-product new-min-product)]))\n  (max-product-helper arr 1 0))\n",
    "  (define (max_subarray_product_helper arr max_product max_product_ending_here min_product_ending_here)\n    (cond [(empty? arr) max_product]\n          [else\n           (define curr (first arr))\n           (define max_product_ending_here_new (max (* curr max_product_ending_here) (* curr min_product_ending_here) curr))\n           (define min_product_ending_here_new (min (* curr max_product_ending_here) (* curr min_product_ending_here) curr))\n           (define max_product_new (max max_product max_product_ending_here_new))\n           (max_subarray_product_helper (rest arr) max_product_new max_product_ending_here_new min_product_ending_here_new)]))\n  (max_subarray_product_helper arr -Infinity -Infinity Infinity))\n",
    "  (let loop ((arr arr)\n             (max-product (first arr))\n             (min-product (first arr))\n             (max-so-far max-product))\n    (cond ((null? arr) max-so-far)\n          ((= (first arr) 0)\n           (loop (rest arr)\n                 1\n                 1\n                 (max max-so-far 0)))\n          (else\n           (let ((curr-max (* max-product (first arr)))\n                 (curr-min (* min-product (first arr))))\n             (loop (rest arr)\n                   (max curr-max (first arr))\n                   (min curr-min (first arr))\n                   (max max-so-far curr-max)))))))\n",
    "  (let loop ((i 0) (max-product 1) (min-product 1) (max-so-far 1))\n    (cond ((= i (length arr)) max-so-far)\n          ((= (vector-ref arr i) 0)\n           (loop (+ i 1) 1 1 1))\n          (else\n           (let ((max-product (* (vector-ref arr i) max-product))\n                 (min-product (* (vector-ref arr i) min-product)))\n             (if (&lt; max-product min-product)\n                 (let ((temp max-product))\n                   (set! max-product min-product)\n                   (set! min-product temp)))\n             (if (&gt; max-product max-so-far)\n                 (set! max-so-far max-product))\n             (if (&lt; min-product 1)\n                 (set! min-product 1))\n             (loop (+ i 1) max-product min-product max-so-far))))))\n",
    "  (define (max_product arr)\n    (define (max_product_helper arr max_so_far max_ending_here)\n      (cond\n        [(empty? arr) max_so_far]\n        [else\n         (let ([x (first arr)])\n           (cond\n             [(> x 0)\n              (max_product_helper (rest arr)\n                                  (max max_so_far (* max_ending_here x))\n                                  (* max_ending_here x))]\n             [(< x 0)\n              (max_product_helper (rest arr)\n                                  (max max_so_far (* max_ending_here x))\n                                  (if (zero? max_ending_here)\n                                      x\n                                      (* max_ending_here x)))]\n             [else\n              (max_product_helper (rest arr)\n                                  (max max_so_far max_ending_here)\n                                  x)]))]))\n    (max_product_helper arr 0 0))\n  (max_product arr))\n",
    "  (define (max_subarray_product_helper arr start end max)\n    (if (= start end)\n        max\n        (let ((product (* (array-ref arr start) (max_subarray_product_helper arr (+ start 1) end max))))\n          (if (&gt; product max)\n              product\n              max))))\n  (max_subarray_product_helper arr 0 (array-length arr) 0))\n</code>\nThis is the error I get:\n<code>application: not a procedure;\n expected a procedure that can be applied to arguments\n  given: #&lt;void&gt;\n  arguments...:\n   #&lt;void&gt;\n</code>\nI'm not sure what I'm doing wrong. I'm pretty sure I'm not using recursion correctly.\n\n\nA:\n\nYou're not using recursion correctly. You're calling <code>max_subarray_product_helper</code> with the same arguments every time. You need to call it with different arguments each time.\n",
    "  (let loop ((arr arr)\n             (max-product (car arr))\n             (min-product (car arr))\n             (max-so-far max-product))\n    (if (null? (cdr arr))\n        max-so-far\n        (let ((curr-product (* (car arr) max-product))\n              (curr-min-product (* (car arr) min-product)))\n          (loop (cdr arr)\n                (max curr-product curr-min-product (car arr))\n                (min curr-product curr-min-product (car arr))\n                (max max-so-far (max curr-product curr-min-product (car arr))))))))\n",
    "  (define (max_subarray_product_helper arr start end)\n    (if (= start end)\n        (list (list start end) (list (list-ref arr start)))\n        (let* ([mid (quotient (+ start end) 2)]\n               [left-result (max_subarray_product_helper arr start mid)]\n               [right-result (max_subarray_product_helper arr (+ mid 1) end)]\n               [cross-result (max_subarray_product_cross arr start mid end)])\n          (cond [(> (car (cdr left-result)) (car (cdr right-result))) left-result]\n                [(> (car (cdr right-result)) (car (cdr cross-result))) right-result]\n                [else cross-result]))))\n  (max_subarray_product_helper arr 0 (- (length arr) 1)))\n",
    "  (let loop ((arr arr)\n             (max-product (car arr))\n             (min-product (car arr))\n             (max-so-far max-product))\n    (cond ((null? arr) max-so-far)\n          ((= (car arr) 0)\n           (loop (cdr arr)\n                 1\n                 1\n                 (max max-so-far 0)))\n          (else\n           (let ((max-product (* max-product (car arr)))\n                 (min-product (* min-product (car arr))))\n             (loop (cdr arr)\n                   (max max-product (car arr))\n                   (min min-product (car arr))\n                   (max max-so-far max-product)))))))\n",
    "  (define (max_subarray_product-iter arr max-so-far max-ending-here min-ending-here)\n    (cond\n      [(empty? arr) max-so-far]\n      [else\n       (let* ([x (first arr)]\n              [new-max-ending-here (max x (* max-ending-here x) (* min-ending-here x))]\n              [new-min-ending-here (min x (* max-ending-here x) (* min-ending-here x))]\n              [new-max-so-far (max max-so-far new-max-ending-here)])\n         (max_subarray_product-iter (rest arr) new-max-so-far new-max-ending-here new-min-ending-here))]))\n  (max_subarray_product-iter arr -inf.0 -1.0 1.0))\n",
    "  (define (max_subarray_product-iter arr max-product max-product-ending-here)\n    (if (null? arr)\n        max-product\n        (let ([curr-product (* max-product-ending-here (car arr))])\n          (max_subarray_product-iter (cdr arr)\n                                     (max max-product curr-product)\n                                     (max (car arr) curr-product)))))\n  (max_subarray_product-iter arr (car arr) (car arr)))\n",
    "  (define (max_subarray_product_helper arr max_product min_product max_product_so_far)\n    (cond\n      [(null? arr) max_product_so_far]\n      [else\n       (let* ([x (car arr)]\n              [new_max_product (max x (* x max_product) (* x min_product))]\n              [new_min_product (min x (* x max_product) (* x min_product))]\n              [new_max_product_so_far (max new_max_product max_product_so_far)])\n         (max_subarray_product_helper (cdr arr) new_max_product new_min_product new_max_product_so_far))]))\n  (max_subarray_product_helper arr 1 1 1))\n",
    "  (let loop ((arr arr)\n             (max-product (car arr))\n             (min-product (car arr))\n             (max-so-far (car arr)))\n    (if (null? (cdr arr))\n        max-so-far\n        (let ((curr-max-product (max (car arr) (max (* (car arr) max-product) (* (car arr) min-product))))\n              (curr-min-product (min (car arr) (min (* (car arr) max-product) (* (car arr) min-product)))))\n          (loop (cdr arr)\n                curr-max-product\n                curr-min-product\n                (max max-so-far curr-max-product))))))\n",
    "  (define (max_product arr)\n    (define (helper arr max-product min-product)\n      (cond [(empty? arr) max-product]\n            [else\n             (let ([curr (first arr)])\n               (helper (rest arr)\n                       (max max-product\n                            (max (* curr max-product)\n                                 (* curr min-product)))\n                       (min min-product\n                            (min (* curr max-product)\n                                 (* curr min-product)))))]))\n    (helper arr (first arr) (first arr)))\n  (max_product arr))\n",
    "  (let loop ([i 0] [j 0] [max-product (car arr)] [min-product (car arr)] [cur-product (car arr)])\n    (if (&gt;= i (length arr))\n        max-product\n        (let ([cur-product (if (&gt;= j (length arr))\n                              (car arr)\n                              (* cur-product (list-ref arr j)))])\n          (let ([max-product (max max-product cur-product)])\n            (let ([min-product (min min-product cur-product)])\n              (if (&lt; cur-product 0)\n                  (loop (+ i 1) (+ i 1) max-product min-product (car arr))\n                  (loop i (+ j 1) max-product min-product cur-product))))))))\n",
    "  (define (max_subarray_product_helper arr max_product max_product_ending_here min_product_ending_here)\n    (cond\n      [(empty? arr) max_product]\n      [else\n       (let ([first (first arr)])\n         (if (&lt; first 0)\n             (let ([temp max_product_ending_here])\n               (set! max_product_ending_here (min_product_ending_here first))\n               (set! min_product_ending_here temp))\n             (set! max_product_ending_here (* max_product_ending_here first))\n             (set! min_product_ending_here (min min_product_ending_here (* min_product_ending_here first))))\n         (set! max_product (max max_product max_product_ending_here))\n         (max_subarray_product_helper (rest arr) max_product max_product_ending_here min_product_ending_here))]))\n  (max_subarray_product_helper arr -inf.0 -inf.0 inf.0))\n",
    "  (define (max_subarray_product_helper arr max_product min_product)\n    (cond\n      [(empty? arr) max_product]\n      [else\n       (let* ([first (first arr)]\n              [rest (rest arr)]\n              [max_product (max max_product first)]\n              [min_product (min min_product first)]\n              [max_product (max max_product (* first max_product))]\n              [min_product (min min_product (* first min_product))]\n              [max_product (max max_product (* first min_product))]\n              [min_product (min min_product (* first max_product))])\n         (max_subarray_product_helper rest max_product min_product))]))\n  (max_subarray_product_helper arr -Infinity Infinity))\n",
    "  (define (max_product_ending_here prod arr)\n    (cond [(empty? arr) prod]\n          [(zero? (first arr)) (max_product_ending_here (/ prod (first arr)) (rest arr))]\n          [else (max_product_ending_here (* prod (first arr)) (rest arr))]))\n  (define (max_product_starting_here prod arr)\n    (cond [(empty? arr) prod]\n          [(zero? (first arr)) (max_product_starting_here (/ prod (first arr)) (rest arr))]\n          [else (max_product_starting_here (* prod (first arr)) (rest arr))]))\n  (define (max_product_subarray arr)\n    (cond [(empty? arr) 0]\n          [(empty? (rest arr)) (first arr)]\n          [else (max (max_product_ending_here 1 arr)\n                     (max_product_starting_here 1 (reverse arr)))]))\n  (max_product_subarray arr))\n",
    "  (define (max_subarray_product_helper arr start end max-product)\n    (if (= start end)\n        max-product\n        (let* ([product (apply * (sublist arr start end))]\n               [new-max-product (if (&gt; product max-product) product max-product)])\n          (max_subarray_product_helper arr (+ start 1) end new-max-product))))\n  (max_subarray_product_helper arr 0 (length arr) 0))\n",
    "  (define (max_product_helper arr i j)\n    (if (= i j)\n        (list (list (list i j) (list (list i j) (list (list i j) (list (list i j) (list (list i j) (list (list i j) (list (list i j) (list (list i j) (list (list i j) (list (list i j) (list (list i j) (list (list i j) (list (list i j) (list (list i j) (list (list i j) (list (list i j) (list (list i j) (list (list i j) (list (list i j) (list (list i j) (list (list i j) (list (list i j) (list (list i j) (list (list i j) (list (list i j) (list (list i j) (list (list i j) (list (list i j) (list (list i j) (list (list i j) (list (list i j) (list (list i j) (list (list i j) (list (list i j) (list (list i j) (list (list i j) (list (list i j) (list (list i j) (list (list i j) (list (list i j) (list (list i j) (list (list i j) (list (list i j) (list (list i j) (list (list i j) (list (list i j) (list (list i j) (list (list i j) (list (list i j) (list (list i j) (list (list i j) (list (list i j) (list (list i j) (list (list i j) (list (list i j) (list (list i j) (list (list i j) (list (list i j) (list (list i j) (list (list i j) (list (list i j) (list (list i j) (list (list i j) (list (list i j) (list (list i j) (list (list i j) (list (list i j) (list (list i j) (list (list i j) (list",
    "  (define (max_product_ending_here max_ending_here min_ending_here a)\n    (cond [(zero? a) max_ending_here]\n          [else\n           (let ([max_ending_here_new (max (* a max_ending_here) (* a min_ending_here) a)]\n                 [min_ending_here_new (min (* a max_ending_here) (* a min_ending_here) a)])\n             (max_product_ending_here max_ending_here_new min_ending_here_new (rest arr)))]))\n  (max_product_ending_here (first arr) (first arr) (rest arr)))\n",
    "  (define (helper arr max_ending_here min_ending_here max_so_far)\n    (if (null? arr)\n        max_so_far\n        (let ([curr (car arr)])\n          (let ([max_ending_here (max curr (* max_ending_here curr) (* min_ending_here curr))])\n            (let ([min_ending_here (min curr (* max_ending_here curr) (* min_ending_here curr))])\n              (let ([max_so_far (max max_so_far max_ending_here)])\n                (helper (cdr arr) max_ending_here min_ending_here max_so_far)))))))\n  (helper arr 1 1 1))\n",
    "  (define (max_product_helper arr max_product min_product i)\n    (cond\n      [(= i (length arr)) max_product]\n      [else\n       (let* ([curr_num (array-ref arr i)]\n              [max_product_1 (* curr_num max_product)]\n              [max_product_2 (* curr_num min_product)]\n              [min_product_1 (* curr_num min_product)]\n              [min_product_2 (* curr_num max_product)]\n              [max_product_3 curr_num]\n              [min_product_3 curr_num]\n              [max_product_4 1]\n              [min_product_4 1])\n         (let* ([max_product_5 (max max_product_1 max_product_2 max_product_3 max_product_4)]\n                [min_product_5 (min min_product_1 min_product_2 min_product_3 min_product_4)])\n           (max_product_helper arr max_product_5 min_product_5 (+ i 1))))]))\n  (max_product_helper arr 1 0 0))\n",
    "  (define (max_subarray_product_helper arr max_product min_product)\n    (cond [(empty? arr) max_product]\n          [else\n           (let* ([first (first arr)]\n                  [rest (rest arr)]\n                  [max_product_first (max (* first max_product) (* first min_product) first)]\n                  [min_product_first (min (* first max_product) (* first min_product) first)])\n             (max_subarray_product_helper rest max_product_first min_product_first))]))\n  (max_subarray_product_helper arr 1 0))\n",
    "  (define (max_product_helper arr start end max-product)\n    (if (= start end)\n        max-product\n        (let ((product (* (array-ref arr start) (max_product_helper arr (+ start 1) end max-product))))\n          (if (&gt; product max-product)\n              product\n              max-product))))\n  (max_product_helper arr 0 (array-length arr) 0))\n",
    "  (define (helper arr max-product curr-product)\n    (cond\n      [(empty? arr) max-product]\n      [(negative? (first arr))\n       (helper (rest arr)\n               (max max-product curr-product)\n               (first arr))]\n      [else\n       (helper (rest arr)\n               (max max-product curr-product)\n               (* curr-product (first arr)))]))\n  (helper arr (first arr) (first arr)))\n",
    "  (define (max_subarray_product_helper arr max-so-far max-ending-here min-ending-here)\n    (cond\n      [(empty? arr) max-so-far]\n      [else\n       (define curr (first arr))\n       (define max-ending-here (max (* curr max-ending-here) (* curr min-ending-here) curr))\n       (define min-ending-here (min (* curr max-ending-here) (* curr min-ending-here) curr))\n       (define max-so-far (max max-so-far max-ending-here))\n       (max_subarray_product_helper (rest arr) max-so-far max-ending-here min-ending-here)]))\n  (max_subarray_product_helper arr -inf.0 -1.0 1.0))\n",
    "  (define (max-product-helper arr max-product min-product i)\n    (cond\n      [(= i (length arr)) max-product]\n      [else\n       (let ([curr-product (if (zero? min-product) (list-ref arr i) (* min-product (list-ref arr i)))]\n             [new-max-product (max max-product curr-product)]\n             [new-min-product (min min-product curr-product)])\n         (max-product-helper arr new-max-product new-min-product (+ i 1)))\n       ]))\n  (max-product-helper arr -inf.0 inf.0 0))\n",
    "  (define (max-product-helper arr i max-so-far max-ending-here min-ending-here)\n    (if (= i (length arr))\n        max-so-far\n        (let ([curr (vector-ref arr i)])\n          (let ([max-ending-here (max curr (* curr max-ending-here) (* curr min-ending-here))])\n            (let ([min-ending-here (min curr (* curr max-ending-here) (* curr min-ending-here))])\n              (let ([max-so-far (max max-so-far max-ending-here)])\n                (max-product-helper arr (+ i 1) max-so-far max-ending-here min-ending-here)))))))\n  (max-product-helper arr 0 0 1 1))\n",
    "  (define (helper arr max_so_far max_ending_here min_ending_here)\n    (if (null? arr)\n        max_so_far\n        (let ([x (car arr)]\n              [new_max_ending_here (max (max x (* x max_ending_here)) (* x min_ending_here))]\n              [new_min_ending_here (min (min x (* x max_ending_here)) (* x min_ending_here))])\n          (helper (cdr arr)\n                  (max max_so_far new_max_ending_here)\n                  new_max_ending_here\n                  new_min_ending_here))))\n  (helper arr -inf.0 1.0 1.0))\n",
    "  (define (max_subarray_product_helper arr max_product max_product_ending_here min_product_ending_here)\n    (if (null? arr)\n        max_product\n        (let ([curr (car arr)])\n          (let ([max_product_ending_here (max curr (* max_product_ending_here curr) (* min_product_ending_here curr))])\n            (let ([min_product_ending_here (min curr (* max_product_ending_here curr) (* min_product_ending_here curr))])\n              (let ([max_product (max max_product max_product_ending_here)])\n                (max_subarray_product_helper (cdr arr) max_product max_product_ending_here min_product_ending_here))))))))\n  (max_subarray_product_helper arr -inf.0 -inf.0 inf.0))\n",
    "  (define (max_product_ending_here i)\n    (cond ((= i 0) (list (list (list (list arr 0) 0) 0) (list (list (list arr 0) 0) 0)))\n          ((< (list-ref arr i) 0)\n           (let* ((neg-max (list-ref (max_product_ending_here (- i 1)) 0))\n                  (pos-max (list-ref (max_product_ending_here (- i 1)) 1))\n                  (neg-max-product (list-ref neg-max 0))\n                  (neg-max-product-start (list-ref neg-max 1))\n                  (neg-max-product-end (list-ref neg-max 2))\n                  (pos-max-product (list-ref pos-max 0))\n                  (pos-max-product-start (list-ref pos-max 1))\n                  (pos-max-product-end (list-ref pos-max 2))\n                  (cur-product (* (list-ref arr i) (list-ref neg-max-product 0)))\n                  (cur-product-start (list-ref neg-max-product 1))\n                  (cur-product-end i))\n             (list (list (list cur-product cur-product-start cur-product-end)\n                         (list-ref pos-max-product 0)\n                         (list-ref pos-max-product 1)\n                         (list-ref pos-max-product 2))\n                   (list (list-ref neg-max-product 0)\n                         (list-ref neg-max-product 1)\n                         (list-ref neg-max-product 2)))))\n          ((> (list-ref arr i) 0)\n           (let* ((neg-max (list-ref (max_product_ending_here (- i 1)) 0))\n                  (pos-max (list-ref (max_product_ending_here (- i 1)) 1))\n                  (neg-max-product (list-ref neg-max 0))\n                  (neg-max-product-start (list-ref neg-max 1))\n                  (neg-max-product-end (list-ref neg-max 2))\n                  (pos-max-product (list-",
    "  (define (max-product-ending-here prev-max prev-min curr-max curr-min x)\n    (define max-ending-here (* x prev-max))\n    (define min-ending-here (* x prev-min))\n    (define max-so-far (max max-ending-here min-ending-here x))\n    (define min-so-far (min max-ending-here min-ending-here x))\n    (values max-so-far min-so-far))\n  (define (loop arr max-so-far min-so-far)\n    (if (null? arr)\n        max-so-far\n        (let* ([x (car arr)]\n               [max-so-far (max max-so-far x)]\n               [min-so-far (min min-so-far x)]\n               [max-so-far (max max-so-far (* x max-so-far))]\n               [min-so-far (min min-so-far (* x min-so-far))]\n               [max-so-far (max max-so-far (* x min-so-far))]\n               [min-so-far (min min-so-far (* x max-so-far))])\n          (loop (cdr arr) max-so-far min-so-far))))\n  (loop arr 1 -1))\n",
    "  (define (max_product_ending_here product max_product min_product i)\n    (cond\n      [(> i (length arr)) max_product]\n      [(= i (length arr)) (max max_product product)]\n      [else\n       (let ([cur (array-ref arr i)])\n         (cond\n           [(< cur 0)\n            (let ([temp (max min_product product)])\n              (max_product_ending_here (max cur (/ product temp))\n                                       (max max_product product)\n                                       (min min_product product)\n                                       (+ i 1)))]\n           [else\n            (max_product_ending_here (* product cur)\n                                     (max max_product product)\n                                     (min min_product product)\n                                     (+ i 1))]))]))\n  (max_product_ending_here 1 -1000000000 1000000000 0))\n",
    "  (define (max-product-helper arr max-product max-product-ending-here min-product-ending-here)\n    (if (null? arr)\n        max-product\n        (let ([x (car arr)])\n          (let ([max-product-ending-here-new (max x (* x max-product-ending-here) (* x min-product-ending-here))])\n            (let ([min-product-ending-here-new (min x (* x max-product-ending-here) (* x min-product-ending-here))])\n              (let ([max-product-new (max max-product max-product-ending-here-new)])\n                (max-product-helper (cdr arr) max-product-new max-product-ending-here-new min-product-ending-here-new))))))))\n  (max-product-helper arr -inf.0 -inf.0 inf.0))\n",
    "  (define (max-product-helper arr start end)\n    (if (= start end)\n        (list (list (list (list start end) arr) 1))\n        (let* ([mid (/ (+ start end) 2)]\n               [left-max-product (max-product-helper arr start mid)]\n               [right-max-product (max-product-helper arr (+ mid 1) end)])\n          (let ([left-max-product-val (second left-max-product)]\n                [right-max-product-val (second right-max-product)])\n            (let ([left-max-product-val-neg (if (negative? left-max-product-val)\n                                                (abs left-max-product-val)\n                                                left-max-product-val))\n                  [right-max-product-val-neg (if (negative? right-max-product-val)\n                                                 (abs right-max-product-val)\n                                                 right-max-product-val)])\n              (let ([left-max-product-val-neg-list (list left-max-product-val-neg left-max-product)]\n                    [right-max-product-val-neg-list (list right-max-product-val-neg right-max-product)])\n                (let ([max-product-val-neg-list (if (&gt; left-max-product-val-neg right-max-product-val-neg)\n                                                    left-max-product-val-neg-list\n                                                    right-max-product-val-neg-list)])\n                  (let ([max-product-val-neg (first max-product-val-neg-list)]\n                        [max-product-val-neg-list-list (second max-product-val-neg-list)])\n                    (let ([max-product-val-neg-list-list-list (list max-product-val-neg-list-list)])\n                      (let ([max-product-val-neg-list-list-list-list (list max-product-val-neg-list-list-list)])\n                        (let ([max-product-val-neg-list-list",
    "  (define (helper arr max-so-far max-ending-here min-ending-here)\n    (cond [(empty? arr) max-so-far]\n          [else\n           (let* ([x (first arr)]\n                  [new-max-ending-here (max (max (* x max-ending-here) (* x min-ending-here)) x)]\n                  [new-min-ending-here (min (min (* x max-ending-here) (* x min-ending-here)) x)]\n                  [new-max-so-far (max new-max-ending-here max-so-far)])\n             (helper (rest arr) new-max-so-far new-max-ending-here new-min-ending-here))]))\n  (helper arr (first arr) (first arr) (first arr)))\n",
    "  (define (max_subarray_product_helper arr max_prod min_prod curr_prod)\n    (if (null? arr)\n        max_prod\n        (let ([curr_prod (if (= 0 (car arr))\n                             1\n                             (* curr_prod (car arr)))])\n          (max_subarray_product_helper (cdr arr)\n                                       (max max_prod curr_prod)\n                                       (min min_prod curr_prod)\n                                       curr_prod))))\n  (max_subarray_product_helper arr 0 1 1))\n",
    "  (define (max_product_ending_here arr i)\n    (cond [(= i 0) (list (list (list (vector-ref arr 0)) (vector-ref arr 0)) (vector-ref arr 0))]\n          [else\n           (let* ([prev (max_product_ending_here arr (- i 1))]\n                  [prev_max_product (cadr prev)]\n                  [prev_max_product_subarray (car prev)]\n                  [prev_min_product (caddr prev)]\n                  [prev_min_product_subarray (cadr prev)]\n                  [curr_product (* prev_max_product (vector-ref arr i))]\n                  [curr_product_subarray (append prev_max_product_subarray (list (vector-ref arr i)))])\n             (cond [(> curr_product prev_max_product)\n                    (list curr_product_subarray curr_product prev_min_product prev_min_product_subarray)]\n                   [(< curr_product prev_max_product)\n                    (list prev_max_product_subarray prev_max_product curr_product curr_product_subarray)]\n                   [else\n                    (list prev_max_product_subarray prev_max_product prev_min_product prev_min_product_subarray)]))]))\n  (max_product_ending_here arr (- (vector-length arr) 1)))\n",
    "  (define (max_product_helper arr i max-product)\n    (if (= i (length arr))\n        max-product\n        (let* ([curr-product (* max-product (vector-ref arr i))]\n               [new-max-product (if (&lt; curr-product (vector-ref arr i))\n                                    (vector-ref arr i)\n                                    curr-product)])\n          (max_product_helper arr (+ i 1) new-max-product))))\n  (max_product_helper arr 0 1))\n",
    "  (define (helper arr max_so_far max_ending_here min_ending_here)\n    (cond\n      [(empty? arr) max_so_far]\n      [else\n       (let ([x (first arr)])\n         (helper (rest arr)\n                 (max max_so_far\n                      (max max_ending_here\n                           (max min_ending_here\n                                x)))\n                 (max (max max_ending_here\n                           (min min_ending_here\n                                x))\n                      x)\n                 (min (min max_ending_here\n                           (min min_ending_here\n                                x))\n                      x)))]))\n  (helper arr -inf.0 -inf.0 inf.0))\n",
    "  (define (max_subarray_product_helper arr i max_product)\n    (if (= i (length arr))\n        max_product\n        (let ([product (* max_product (vector-ref arr i))])\n          (max_subarray_product_helper arr (+ i 1) (max product (vector-ref arr i))))))\n  (max_subarray_product_helper arr 1 (vector-ref arr 0)))\n",
    "  (let loop ((arr arr) (max-product 1) (min-product 1) (max-so-far 1))\n    (cond\n      [(empty? arr) max-so-far]\n      [else\n       (let ((curr (first arr)))\n         (loop (rest arr)\n               (max (* curr max-product) (* curr min-product) curr)\n               (min (* curr max-product) (* curr min-product) curr)\n               (max max-so-far (max (* curr max-product) (* curr min-product) curr))))])))\n",
    "  (define (max_subarray_product_helper arr curr-max curr-min curr-prod)\n    (if (null? arr)\n        curr-prod\n        (let* ([curr-val (car arr)]\n               [new-max (max curr-val (* curr-val curr-max) (* curr-val curr-min))]\n               [new-min (min curr-val (* curr-val curr-max) (* curr-val curr-min))]\n               [new-prod (max curr-prod new-max)])\n          (max_subarray_product_helper (cdr arr) new-max new-min new-prod))))\n  (max_subarray_product_helper arr 1 1 1))\n",
    "  (define (max_subarray_product_helper arr start end max_product)\n    (if (= start end)\n        max_product\n        (let ((product (* (array-ref arr start) (max_subarray_product_helper arr (+ start 1) end max_product))))\n          (if (&gt; product max_product)\n              product\n              max_product))))\n  (max_subarray_product_helper arr 0 (array-length arr) 0))\n</code>\nThe problem is that I'm getting a stack overflow error. I'm not sure how to fix this. I've tried using <code>for/fold</code> but I can't seem to get it to work.\n\n\nA:\n\nYour code is not tail recursive.\n<code>(define (max_subarray_product arr)\n  (define (max_subarray_product_helper arr start end max_product)\n    (if (= start end)\n        max_product\n        (let ((product (* (array-ref arr start) (max_subarray_product_helper arr (+ start 1) end max_product))))\n          (if (&gt; product max_product)\n              product\n              max_product))))\n  (max_subarray_product_helper arr 0 (array-length arr) 0))\n</code>\nThe recursive call is not the last thing that happens in the function.  The last thing that happens is the <code>if</code> expression.  The recursive call is inside the <code>let</code> expression, which is inside the <code>if</code> expression.  So the recursive call is not tail recursive.\nYou can fix this by using an accumulator parameter.  The accumulator parameter will hold the maximum product so far.  The recursive call will be the last thing that happens in the function.\n<code>(define (max_subarray_product arr)\n  (define (max_subarray_product_helper arr start end max_product)\n    (if (= start end)\n        max_product\n        (let ((product (* (array-ref arr start) max_product)))\n          (max_subarray_product_helper arr (+ start 1) end (if (&gt; product max_product) product max_product",
    "  (define (max_product_ending_here prev_max prev_min current)\n    (define max_ending_here (max (* prev_max current) (* prev_min current) current))\n    (define min_ending_here (min (* prev_max current) (* prev_min current) current))\n    (values max_ending_here min_ending_here))\n  (define (max_product_so_far max_ending_here max_so_far)\n    (if (&gt; max_ending_here max_so_far)\n        max_ending_here\n        max_so_far))\n  (for/fold ([max_so_far 0] [prev_max 1] [prev_min 1]) ([current (in-list arr)])\n    (define (max_ending_here min_ending_here)\n      (max_product_so_far max_ending_here max_so_far))\n    (define (min_ending_here max_ending_here)\n      (values prev_max prev_min))\n    (max_product_ending_here prev_max prev_min current)))\n</code>\nThe problem is that I'm getting the error:\n<code>max_subarray_product.rkt:14:0: for/fold: expected a value of type &lt;for/fold-value&gt;, but got: #&lt;procedure:max_ending_here&gt;\n  in: max_ending_here\n</code>\nI'm not sure what I'm doing wrong. I'm trying to use <code>for/fold</code> to iterate over the list and return the max product. I'm also trying to use <code>max_product_ending_here</code> to return the max product ending at the current element, and <code>max_product_so_far</code> to return the max product so far.\nI'm not sure how to fix this error. I'm also not sure if this is the best way to solve this problem.\n\n\nA:\n\nYou have a few problems here.\nFirst, you're using <code>for/fold</code> incorrectly. You're using it like <code>for</code>, but you're not returning any values. You need",
    "  (let loop ([arr arr] [max-product (car arr)] [min-product (car arr)] [max-so-far (car arr)])\n    (if (null? (cdr arr))\n        max-so-far\n        (let ([curr-max-product (max (max (car arr) (* (car arr) max-product)) (* (car arr) min-product))]\n              [curr-min-product (min (min (car arr) (* (car arr) max-product)) (* (car arr) min-product))])\n          (loop (cdr arr) curr-max-product curr-min-product (max max-so-far curr-max-product))))))\n",
    "  (define (max_product_ending_here prev_max prev_min max_so_far)\n    (cond [(empty? arr) max_so_far]\n          [else\n           (let* ([curr (first arr)]\n                  [max_ending_here (max (* curr prev_max) (* curr prev_min) curr)]\n                  [min_ending_here (min (* curr prev_max) (* curr prev_min) curr)])\n             (max_product_ending_here max_ending_here min_ending_here (max max_so_far max_ending_here)))]))\n  (max_product_ending_here 1 1 0))\n",
    "  (define (max_product_ending_here a i)\n    (cond [(= i 0) a]\n          [(< a 0) (max_product_ending_here (* a (vector-ref arr i)) (+ i 1))]\n          [else (max_product_ending_here (* a (vector-ref arr i)) (+ i 1))]))\n  (define (max_product_starting_here a i)\n    (cond [(= i (vector-length arr)) a]\n          [(< a 0) (max_product_starting_here (* a (vector-ref arr (- i 1))) (- i 1))]\n          [else (max_product_starting_here (* a (vector-ref arr (- i 1))) (- i 1))]))\n  (define (max_product_subarray a i)\n    (cond [(= i (vector-length arr)) a]\n          [else (max (max_product_subarray (max_product_ending_here (vector-ref arr i) (+ i 1)) (+ i 1))\n                    (max_product_subarray (max_product_starting_here (vector-ref arr (- i 1)) (- i 1)) (- i 1)))]))\n  (max_product_subarray (vector-ref arr 0) 1))\n",
    "  (define (max-product-helper arr i j max-product)\n    (if (&gt;= i j)\n        max-product\n        (let ((product (* (array-ref arr i) (array-ref arr j))))\n          (max-product-helper arr (+ i 1) (+ j 1) (max max-product product)))))\n  (max-product-helper arr 0 (array-length arr) 0))\n",
    "  (define (max_subarray_product-helper arr max-so-far max-ending-here min-ending-here)\n    (cond [(empty? arr) max-so-far]\n          [else\n           (let ([curr (first arr)])\n             (let ([max-ending-here (max (* curr max-ending-here) (* curr min-ending-here) curr)]\n                   [min-ending-here (min (* curr max-ending-here) (* curr min-ending-here) curr)])\n               (max_subarray_product-helper (rest arr) (max max-so-far max-ending-here) max-ending-here min-ending-here)))]))\n  (max_subarray_product-helper arr -inf.0 -inf.0 inf.0))\n",
    "  (let loop ((arr arr) (max-product (car arr)) (min-product (car arr)) (max-so-far (car arr)))\n    (if (null? (cdr arr))\n        max-so-far\n        (let ((curr-product (* (car arr) max-product))\n              (curr-min-product (* (car arr) min-product)))\n          (loop (cdr arr)\n                (max curr-product curr-min-product (car arr))\n                (min curr-product curr-min-product (car arr))\n                (max max-so-far curr-product curr-min-product (car arr)))))))\n",
    "  (define (max-product-helper arr max-product min-product curr-product i)\n    (if (= i (length arr))\n        max-product\n        (let ([curr-product (* curr-product (vector-ref arr i))])\n          (cond [(< curr-product 0)\n                 (max-product-helper arr max-product curr-product (- curr-product min-product) (+ i 1))]\n                [(> curr-product 0)\n                 (max-product-helper arr (max max-product curr-product) min-product curr-product (+ i 1))]\n                [else\n                 (max-product-helper arr max-product min-product 1 (+ i 1))]))))\n  (max-product-helper arr 0 0 1 0))\n",
    "  (define (max_product_helper arr start end)\n    (if (= start end)\n        (list (list (list (vector-ref arr start)))\n              (list (list (vector-ref arr start))))\n        (let* ([mid (/ (+ start end) 2)]\n               [left-max-product (max_product_helper arr start mid)]\n               [right-max-product (max_product_helper arr (+ mid 1) end)]\n               [left-max-product-list (car left-max-product)]\n               [left-min-product-list (cadr left-max-product)]\n               [right-max-product-list (car right-max-product)]\n               [right-min-product-list (cadr right-max-product)]\n               [left-max-product-value (apply * (map car left-max-product-list)))\n               [left-min-product-value (apply * (map car left-min-product-list)))\n               [right-max-product-value (apply * (map car right-max-product-list)))\n               [right-min-product-value (apply * (map car right-min-product-list)))\n               [max-product-value (max left-max-product-value\n                                       right-max-product-value\n                                       (* (vector-ref arr mid)\n                                          left-max-product-value\n                                          right-min-product-value)\n                                       (* (vector-ref arr mid)\n                                          left-min-product-value\n                                          right-max-product-value))]\n               [min-product-value (min left-max-product-value\n                                       right-max-product-value\n                                       (* (vector-ref arr mid)\n                                          left-max-product-value\n                                          right-min-product-value)\n                                       (* (vector-ref arr mid)\n                                          left-min-product-value\n                                          right-max-product-value))])\n          (list (list max-product-value)\n                (list min-product-value))))))\n  (max_product_helper arr 0 (- (vector-length arr) 1)))\n",
    "  (define (max-product-helper arr max-product max-product-ending-here min-product-ending-here)\n    (cond\n      [(empty? arr) max-product]\n      [else\n       (define curr-product (first arr))\n       (define max-product-ending-here (max curr-product (* curr-product max-product-ending-here)))\n       (define min-product-ending-here (min curr-product (* curr-product min-product-ending-here)))\n       (define max-product (max max-product max-product-ending-here))\n       (max-product-helper (rest arr) max-product max-product-ending-here min-product-ending-here)]))\n  (max-product-helper arr 0 0 0))\n",
    "  (define (max_subarray_product_helper arr i max_product)\n    (if (null? arr)\n        max_product\n        (let ([curr_product (* (car arr) i)])\n          (if (&lt; curr_product max_product)\n              (max_subarray_product_helper (cdr arr) (car arr) max_product)\n              (max_subarray_product_helper (cdr arr) (car arr) curr_product)))))\n  (max_subarray_product_helper arr 1 0))\n",
    "  (define (helper arr max_prod min_prod max_elem min_elem)\n    (if (null? arr)\n        max_prod\n        (let ([elem (car arr)])\n          (cond\n            [(> elem 0)\n             (helper (cdr arr)\n                     (max max_prod (* max_elem elem))\n                     (min min_prod (* min_elem elem))\n                     (* max_elem elem)\n                     elem)]\n            [(< elem 0)\n             (helper (cdr arr)\n                     (max max_prod (* min_elem elem))\n                     (min min_prod (* max_elem elem))\n                     elem\n                     (* min_elem elem))]\n            [else\n             (helper (cdr arr)\n                     max_prod\n                     min_prod\n                     elem\n                     elem)]))))\n  (helper arr 0 0 0 0))\n",
    "  (let loop ((arr arr)\n             (max-product (car arr))\n             (min-product (car arr))\n             (max-so-far max-product))\n    (if (null? (cdr arr))\n        max-so-far\n        (let ((curr (car (cdr arr))))\n          (loop (cdr arr)\n                (max (max curr (* curr max-product))\n                     (* curr min-product))\n                (min (min curr (* curr max-product))\n                     (* curr min-product))\n                (max max-so-far (max curr (* curr max-product))))))))\n",
    "  (define (helper arr max_so_far max_ending_here min_ending_here)\n    (cond\n      [(empty? arr) max_so_far]\n      [else\n       (define curr (first arr))\n       (define max_ending_here (max curr (* curr max_ending_here) (* curr min_ending_here)))\n       (define min_ending_here (min curr (* curr max_ending_here) (* curr min_ending_here)))\n       (define max_so_far (max max_so_far max_ending_here))\n       (helper (rest arr) max_so_far max_ending_here min_ending_here)]))\n  (helper arr (first arr) (first arr) (first arr)))\n",
    "  (let loop ((arr arr) (max-product 1) (min-product 1) (max-so-far 1))\n    (cond\n      [(empty? arr) max-so-far]\n      [else\n       (let* ([curr (first arr)]\n              [new-max-product (max (* curr max-product) (* curr min-product) curr)]\n              [new-min-product (min (* curr max-product) (* curr min-product) curr)])\n         (loop (rest arr) new-max-product new-min-product (max max-so-far new-max-product)))])))\n",
    "  (define (max_subarray_product_helper arr max_product max_product_ending_here min_product_ending_here)\n    (cond\n      [(empty? arr) max_product]\n      [(zero? (first arr))\n       (max_subarray_product_helper (rest arr) max_product 0 (first arr))]\n      [else\n       (let ([new_max_product_ending_here (max (first arr) (* (first arr) max_product_ending_here))]\n             [new_min_product_ending_here (min (first arr) (* (first arr) min_product_ending_here))])\n         (max_subarray_product_helper (rest arr) (max max_product new_max_product_ending_here) new_max_product_ending_here new_min_product_ending_here))]))\n  (max_subarray_product_helper arr 0 1 0))\n",
    "  (define (max-product-helper arr max-product min-product curr-product)\n    (cond\n      [(empty? arr) max-product]\n      [else\n       (define curr-num (first arr))\n       (define new-max-product (max max-product curr-product))\n       (define new-min-product (min min-product curr-product))\n       (define new-curr-product (max (* curr-num curr-product) (* curr-num min-product) curr-num))\n       (max-product-helper (rest arr) new-max-product new-min-product new-curr-product)]))\n  (max-product-helper arr -inf.0 inf.0 1))\n",
    "  (define (max_subarray_product_helper arr max-so-far max-ending-here min-ending-here)\n    (cond\n      [(empty? arr) max-so-far]\n      [else\n       (define curr (first arr))\n       (define max-ending-here (max curr (* curr max-ending-here) (* curr min-ending-here)))\n       (define min-ending-here (min curr (* curr max-ending-here) (* curr min-ending-here)))\n       (define max-so-far (max max-so-far max-ending-here))\n       (max_subarray_product_helper (rest arr) max-so-far max-ending-here min-ending-here)]))\n  (max_subarray_product_helper arr -inf.0 -1.0 1.0))\n",
    "  (define (max_product_ending_here max_ending_here min_ending_here a)\n    (cond [(= a 0) (values 0 0)]\n          [(< a 0) (values (min min_ending_here (* min_ending_here a))\n                           (max max_ending_here (* max_ending_here a)))]\n          [else (values (max max_ending_here (* max_ending_here a))\n                        (min min_ending_here (* min_ending_here a)))]))\n  (define (max_product_subarray arr max_ending_here min_ending_here max_so_far)\n    (cond [(null? arr) max_so_far]\n          [else (let ([a (car arr)]\n                       [max_ending_here_next (max-ending-here max_ending_here min_ending_here a)]\n                       [min_ending_here_next (min-ending-here max_ending_here min_ending_here a)])\n                  (max_product_subarray (cdr arr) max_ending_here_next min_ending_here_next\n                                        (max max_so_far max_ending_here_next)))]))\n  (max_product_subarray arr 1 0 0))\n",
    "  (define (max-product-helper arr i j)\n    (if (or (= i j) (= i (+ j 1)))\n        (list (list i j) (list (list-ref arr i) (list-ref arr j)))\n        (let* ([left (max-product-helper arr i (- j 1))]\n               [right (max-product-helper arr (+ i 1) j)]\n               [cross (max-product-helper arr i j)])\n          (cond\n            [(> (car (cdr left)) (car (cdr right))) left]\n            [(> (car (cdr left)) (car (cdr cross))) left]\n            [(> (car (cdr right)) (car (cdr cross))) right]\n            [else cross]))))\n  (max-product-helper arr 0 (- (length arr) 1)))\n",
    "  (define (helper arr i j)\n    (cond\n      [(= i j) (vector (vector i j) (vector (list-ref arr i) (list-ref arr i)))]\n      [else (let* ([left (helper arr i (- j 1))]\n                   [right (helper arr (+ i 1) j)]\n                   [cross (vector (vector i j)\n                                  (vector (list-ref arr i)\n                                          (* (vector-ref (vector-ref left 1) 0)\n                                             (vector-ref (vector-ref right 1) 1))))])\n              (cond\n                [(> (vector-ref (vector-ref left 1) 0)\n                    (vector-ref (vector-ref right 1) 0))\n                 left]\n                [(> (vector-ref (vector-ref right 1) 0)\n                    (vector-ref (vector-ref left 1) 0))\n                 right]\n                [else cross])))]))\n  (helper arr 0 (- (vector-length arr) 1)))\n",
    "  (define (max_subarray_product_helper arr max_product max_product_ending_here min_product_ending_here)\n    (if (null? arr)\n        max_product\n        (let ([x (car arr)]\n              [max_product_ending_here (max x (* x max_product_ending_here))]\n              [min_product_ending_here (min x (* x min_product_ending_here))]\n              [max_product (max max_product max_product_ending_here)])\n          (max_subarray_product_helper (cdr arr) max_product max_product_ending_here min_product_ending_here))))\n  (max_subarray_product_helper arr -1000000000 -1000000000 1000000000))\n",
    "  (define (max_subarray_product_iter arr max_product min_product)\n    (cond [(empty? arr) max_product]\n          [else\n           (let* ([head (first arr)]\n                  [tail (rest arr)]\n                  [max_product (max max_product head)]\n                  [min_product (min min_product head)])\n             (max_subarray_product_iter tail max_product min_product))]))\n  (max_subarray_product_iter arr (first arr) (first arr)))\n",
    "  (define (max_subarray_product-iter arr max-so-far max-ending-here min-ending-here)\n    (cond\n      [(empty? arr) max-so-far]\n      [else\n       (define curr (first arr))\n       (define max-ending-here (max (* curr max-ending-here) (* curr min-ending-here) curr))\n       (define min-ending-here (min (* curr max-ending-here) (* curr min-ending-here) curr))\n       (define max-so-far (max max-so-far max-ending-here))\n       (max_subarray_product-iter (rest arr) max-so-far max-ending-here min-ending-here)]))\n  (max_subarray_product-iter arr (first arr) (first arr) (first arr)))\n",
    "  (define (max-product-helper arr max-product min-product curr-product)\n    (cond\n      [(empty? arr) max-product]\n      [else\n       (define curr-val (first arr))\n       (define new-curr-product (* curr-val curr-product))\n       (define new-max-product (max max-product new-curr-product))\n       (define new-min-product (min min-product new-curr-product))\n       (max-product-helper (rest arr) new-max-product new-min-product new-curr-product)]))\n  (max-product-helper arr (first arr) (first arr) 1))\n",
    "  (define (max_product_ending_here prev_max prev_min current)\n    (let ((max_ending_here (* prev_max current))\n          (min_ending_here (* prev_min current)))\n      (values (max max_ending_here min_ending_here current)\n              (min min_ending_here max_ending_here current))))\n  (define (loop max_so_far max_ending_here min_ending_here arr)\n    (if (null? arr)\n        max_so_far\n        (let-values (((max_ending_here min_ending_here)\n                     (max_product_ending_here max_ending_here min_ending_here (car arr))))\n          (loop (max max_so_far max_ending_here) max_ending_here min_ending_here (cdr arr)))))\n  (loop (car arr) (car arr) (car arr) (cdr arr)))\n",
    "  (define (max_product_from_index i)\n    (define (iter product max-product)\n      (if (= i (length arr))\n          max-product\n          (let ((next-product (* product (vector-ref arr i))))\n            (if (&lt; next-product 0)\n                (iter (vector-ref arr i) (max max-product product))\n                (iter next-product (max max-product next-product))))))\n    (iter 1 0))\n  (apply max (map max_product_from_index (range (length arr)))))\n",
    "  (let loop ([i 0] [max-prod 0] [min-prod 0] [max-so-far 0])\n    (if (= i (length arr))\n        max-so-far\n        (let* ([curr-prod (if (zero? min-prod)\n                              (vector-ref arr i)\n                              (* min-prod (vector-ref arr i)))]\n               [curr-min-prod (min (vector-ref arr i) curr-prod)]\n               [curr-max-prod (max (vector-ref arr i) curr-prod)])\n          (loop (+ i 1) curr-max-prod curr-min-prod (max max-so-far curr-max-prod))))))\n",
    "  (define (max_product_helper arr i max_product)\n    (if (&lt; i (vector-length arr))\n        (let* ([curr_product (if (&lt; max_product 0)\n                                (vector-ref arr i)\n                                (* max_product (vector-ref arr i)))]\n               [next_max_product (max_product_helper arr (+ i 1) curr_product)])\n          (max curr_product next_max_product))\n        max_product))\n  (max_product_helper arr 0 0))\n",
    "  (define (max_subarray_product_helper arr start end)\n    (cond [(= start end) (list (list start end) (list (list-ref arr start)))]\n          [else\n           (let ([mid (quotient (+ start end) 2)])\n             (let-values ([(left-max-subarray left-max-product) (max_subarray_product_helper arr start mid)]\n                          [(right-max-subarray right-max-product) (max_subarray_product_helper arr (+ mid 1) end)])\n               (let ([cross-max-subarray (list start end)]\n                     [cross-max-product (list (list-ref arr start))])\n                 (let loop ([i start] [j mid] [k (- end 1)])\n                   (cond [(>= i j)\n                          (cond [(>= j k)\n                                 (let ([left-product (apply * left-max-product)]\n                                       [right-product (apply * right-max-product)])\n                                   (cond [(> left-product right-product)\n                                          (values left-max-subarray left-max-product)]\n                                         [(> right-product left-product)\n                                          (values right-max-subarray right-max-product)]\n                                         [else\n                                          (values (append left-max-subarray right-max-subarray)\n                                                  (append left-max-product right-max-product))]))]\n                                [else\n                                 (let loop ([i j] [j k])\n                                   (cond [(>= i j)\n                                          (let ([product (apply * cross-max-product)])\n                                            (cond [(> product (apply * left-max-product))\n                                                   (values cross-max-subarray cross-max-product)]\n                                                  [(> (apply * left-max-product) product)\n                                                   (values left-max-subarray left-max-product)]\n                                                  [else\n                                                   (values (append left-max-subarray cross-max-subarray)\n                                                           (append left-max-product cross-max",
    "  (define (max-product-helper arr start end)\n    (cond [(= start end) (list (list start end) (list 1))]\n          [else\n           (let* ([mid (quotient (+ start end) 2)]\n                  [left-max-product (max-product-helper arr start mid)]\n                  [right-max-product (max-product-helper arr (+ mid 1) end)]\n                  [left-max-product-range (car left-max-product)]\n                  [left-max-product-value (cadr left-max-product)]\n                  [right-max-product-range (car right-max-product)]\n                  [right-max-product-value (cadr right-max-product)]\n                  [left-max-product-left-value (array-ref arr (car left-max-product-range))]\n                  [left-max-product-right-value (array-ref arr (cadr left-max-product-range))]\n                  [right-max-product-left-value (array-ref arr (car right-max-product-range))]\n                  [right-max-product-right-value (array-ref arr (cadr right-max-product-range))]\n                  [left-max-product-left-value-left (if (positive? left-max-product-left-value)\n                                                        left-max-product-left-value\n                                                        1)]\n                  [left-max-product-right-value-right (if (positive? left-max-product-right-value)\n                                                          left-max-product-right-value\n                                                          1)]\n                  [right-max-product-left-value-left (if (positive? right-max-product-left-value)\n                                                         right-max-product-left-value\n                                                         1)]\n                  [right-max-product-right-value-right (if (positive? right-max-product-right-value)\n                                                           right-max-product-right-value\n                                                           1)]\n                  [left-max-product-left-value-right (if (positive? left-max-product-left-value)\n",
    "  (define (max_subarray_product_helper arr max_so_far max_ending_here min_ending_here)\n    (cond [(empty? arr) max_so_far]\n          [else\n           (define curr (first arr))\n           (define max_ending_here (max (* curr max_ending_here) (* curr min_ending_here) curr))\n           (define min_ending_here (min (* curr max_ending_here) (* curr min_ending_here) curr))\n           (define max_so_far (max max_so_far max_ending_here))\n           (max_subarray_product_helper (rest arr) max_so_far max_ending_here min_ending_here)]))\n  (max_subarray_product_helper arr (first arr) (first arr) (first arr)))\n",
    "  (define (max_subarray_product_helper arr curr-max curr-min curr-prod)\n    (if (null? arr)\n        curr-prod\n        (let ([curr-num (car arr)])\n          (let ([new-max (max curr-num (* curr-num curr-max) (* curr-num curr-min))])\n            (let ([new-min (min curr-num (* curr-num curr-max) (* curr-num curr-min))])\n              (let ([new-prod (max new-max curr-prod)])\n                (max_subarray_product_helper (cdr arr) new-max new-min new-prod)))))))\n  (max_subarray_product_helper arr 1 -1 1))\n",
    "  (define (max-product-ending-here a b)\n    (if (zero? a)\n        b\n        (max a b)))\n  (define (min-product-ending-here a b)\n    (if (zero? a)\n        b\n        (min a b)))\n  (define (max-product-so-far a b)\n    (if (zero? a)\n        b\n        (max a b)))\n  (define (min-product-so-far a b)\n    (if (zero? a)\n        b\n        (min a b)))\n  (define (max-product-subarray arr)\n    (define (max-product-subarray-helper arr max-ending-here min-ending-here max-so-far min-so-far)\n      (if (null? arr)\n          max-so-far\n          (let ([x (car arr)])\n            (max-product-subarray-helper (cdr arr)\n                                         (max-product-ending-here (* x max-ending-here)\n                                                                  (* x min-ending-here))\n                                         (min-product-ending-here (* x max-ending-here)\n                                                                  (* x min-ending-here))\n                                         (max-product-so-far max-so-far max-ending-here)\n                                         (min-product-so-far min-so-far min-ending-here)))))\n    (max-product-subarray-helper arr 1 1 1 1))\n  (max-product-subarray arr))\n",
    "  (define (max_product_helper arr i max-product)\n    (if (null? arr)\n        max-product\n        (let ([product (* (car arr) i)])\n          (max_product_helper (cdr arr)\n                              (if (&lt; product 0) 1 product)\n                              (max max-product product)))))\n  (max_product_helper arr 1 0))\n"
  ]
}