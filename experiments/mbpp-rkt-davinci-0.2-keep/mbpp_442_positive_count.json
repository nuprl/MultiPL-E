{
  "name": "mbpp_442_positive_count",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Write a function to find the ration of positive numbers in an array of integers.\n(define (positive_count nums)\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_442_positive_count.py",
  "prompt_terminology": "verbatim",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate positive_count))\n    (check-equal? (candidate (list 0 1 2 -1 -5 6 0 -3 -2 3 4 6 8)) 0.54)\n    (check-equal? (candidate (list 2 1 2 -1 -5 6 4 -3 -2 3 4 6 8)) 0.69)\n    (check-equal? (candidate (list 2 4 -6 -9 11 -12 14 -5 17)) 0.56)\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (define (positive? num)\n    (if (&gt; num 0)\n        1\n        0))\n  (define (sum nums)\n    (if (null? nums)\n        0\n        (+ (positive? (car nums)) (sum (cdr nums)))))\n  (/ (sum nums) (length nums)))\n",
    "  (define (positive? num)\n    (and (number? num)\n         (positive? num)))\n  (define (count-positive nums)\n    (cond ((null? nums) 0)\n          ((positive? (car nums)) (+ 1 (count-positive (cdr nums))))\n          (else (count-positive (cdr nums)))))\n  (/ (count-positive nums) (length nums)))\n",
    "  (define (positive? num)\n    (if (&gt; num 0)\n        #t\n        #f))\n  (define (count-positive nums count)\n    (if (null? nums)\n        count\n        (if (positive? (car nums))\n            (count-positive (cdr nums) (+ count 1))\n            (count-positive (cdr nums) count))))\n  (/ (count-positive nums 0) (length nums)))\n",
    "  (define (positive? n)\n    (and (number? n)\n         (positive? n)))\n  (define (count-positive nums)\n    (if (null? nums)\n        0\n        (+ (if (positive? (car nums))\n               1\n               0)\n           (count-positive (cdr nums)))))\n  (/ (count-positive nums)\n     (length nums)))\n",
    "  (define (positive? num)\n    (if (&gt; num 0)\n        #t\n        #f))\n  (define (count-positive nums)\n    (if (null? nums)\n        0\n        (+ (positive? (car nums))\n           (count-positive (cdr nums)))))\n  (/ (count-positive nums)\n     (length nums)))\n</code>\nI'm getting the following error:\n<code>application: not a procedure;\n expected a procedure that can be applied to arguments\n  given: #t\n  arguments...:\n   #f\n</code>\nI'm not sure what I'm doing wrong.\n\n\nA:\n\nThe problem is that <code>positive?</code> returns a boolean, but you're trying to add it to an integer. You need to convert the boolean to an integer first.\n<code>(define (positive_count nums)\n  (define (positive? num)\n    (if (&gt; num 0)\n        #t\n        #f))\n  (define (count-positive nums)\n    (if (null? nums)\n        0\n        (+ (if (positive? (car nums)) 1 0)\n           (count-positive (cdr nums)))))\n  (/ (count-positive nums)\n     (length nums)))\n</code>\n",
    "  (let loop ([nums nums] [count 0])\n    (if (null? nums)\n        (/ count (length nums))\n        (if (> (car nums) 0)\n            (loop (cdr nums) (+ count 1))\n            (loop (cdr nums) count)))))\n",
    "  (letrec ([count (for/sum ([n nums]) (if (> n 0) 1 0))])\n    (/ count (length nums))))\n",
    "  (let loop ([nums nums] [count 0])\n    (if (null? nums)\n        (/ count (length nums))\n        (if (> (car nums) 0)\n            (loop (cdr nums) (+ count 1))\n            (loop (cdr nums) count)))))\n",
    "  (let loop ([nums nums] [count 0])\n    (if (null? nums)\n        (/ count (length nums))\n        (if (> (car nums) 0)\n            (loop (cdr nums) (+ count 1))\n            (loop (cdr nums) count)))))\n",
    "  (define (positive? n)\n    (and (integer? n)\n         (> n 0)))\n  (define (count-positive nums)\n    (if (null? nums)\n        0\n        (+ (if (positive? (car nums)) 1 0)\n           (count-positive (cdr nums)))))\n  (/ (count-positive nums) (length nums)))\n",
    "  (define (helper nums count)\n    (if (null? nums)\n        (/ count (length nums))\n        (if (&gt; (car nums) 0)\n            (helper (cdr nums) (+ count 1))\n            (helper (cdr nums) count))))\n  (helper nums 0))\n",
    "  (define (positive? num)\n    (if (&gt; num 0)\n        #t\n        #f))\n  (define (count-positive nums)\n    (if (null? nums)\n        0\n        (+ (if (positive? (car nums)) 1 0)\n           (count-positive (cdr nums)))))\n  (/ (count-positive nums) (length nums)))\n",
    "  (define (positive? num)\n    (if (&gt; num 0)\n        1\n        0))\n  (define (sum-of-positive nums)\n    (if (null? nums)\n        0\n        (+ (positive? (car nums)) (sum-of-positive (cdr nums)))))\n  (/ (sum-of-positive nums) (length nums)))\n",
    "  (define (pos? n)\n    (if (&gt; n 0)\n        1\n        0))\n  (/ (apply + (map pos? nums)) (length nums)))\n",
    "  (define (positive? num)\n    (if (&gt; num 0)\n        #t\n        #f))\n  (define (count-positive nums)\n    (if (null? nums)\n        0\n        (+ (if (positive? (car nums))\n               1\n               0)\n           (count-positive (cdr nums)))))\n  (/ (count-positive nums) (length nums)))\n",
    "  (define (positive? n)\n    (if (&gt; n 0)\n        #t\n        #f))\n  (define (count-positive nums)\n    (if (null? nums)\n        0\n        (+ (if (positive? (car nums))\n               1\n               0)\n           (count-positive (cdr nums)))))\n  (/ (count-positive nums)\n     (length nums)))\n",
    "  (define (positive? num)\n    (if (&gt; num 0)\n        1\n        0))\n  (define (sum nums)\n    (if (null? nums)\n        0\n        (+ (positive? (car nums)) (sum (cdr nums)))))\n  (/ (sum nums) (length nums)))\n",
    "  (define (count-positive nums count)\n    (if (null? nums)\n        (/ count (length nums))\n        (if (&gt; (car nums) 0)\n            (count-positive (cdr nums) (+ count 1))\n            (count-positive (cdr nums) count))))\n  (count-positive nums 0))\n",
    "  (cond\n    [(empty? nums) 0]\n    [(> (first nums) 0) (+ 1 (positive_count (rest nums)))]\n    [else (positive_count (rest nums))]))\n",
    "  (define (iter nums count)\n    (if (null? nums)\n        (/ count (length nums))\n        (if (&gt; (car nums) 0)\n            (iter (cdr nums) (+ count 1))\n            (iter (cdr nums) count))))\n  (iter nums 0))\n"
  ]
}