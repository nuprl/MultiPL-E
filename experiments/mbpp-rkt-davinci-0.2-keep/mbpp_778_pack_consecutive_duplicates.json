{
  "name": "mbpp_778_pack_consecutive_duplicates",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Write a function to pack consecutive duplicates of a given list elements into sublists.\n(define (pack_consecutive_duplicates list1)\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_778_pack_consecutive_duplicates.py",
  "prompt_terminology": "verbatim",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate pack_consecutive_duplicates))\n    (check-equal? (candidate (list 0 0 1 2 3 4 4 5 6 6 6 7 8 9 4 4)) (list (list 0 0) (list 1) (list 2) (list 3) (list 4 4) (list 5) (list 6 6 6) (list 7) (list 8) (list 9) (list 4 4)))\n    (check-equal? (candidate (list 10 10 15 19 18 18 17 26 26 17 18 10)) (list (list 10 10) (list 15) (list 19) (list 18 18) (list 17) (list 26 26) (list 17) (list 18) (list 10)))\n    (check-equal? (candidate (list \"a\" \"a\" \"b\" \"c\" \"d\" \"d\")) (list (list \"a\" \"a\") (list \"b\") (list \"c\") (list \"d\" \"d\")))\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (let* ([first (first list1)]\n            [rest (rest list1)]\n            [first-rest (cons first rest)]\n            [first-rest-duplicates (filter (lambda (x) (equal? x first)) first-rest)])\n       (cons first-rest-duplicates (pack_consecutive_duplicates (remove first first-rest))))]))\n",
    "  (define (pack_consecutive_duplicates_helper list1 result)\n    (cond ((null? list1) result)\n          ((null? result) (pack_consecutive_duplicates_helper (cdr list1) (list (list (car list1)))))\n          ((equal? (caar result) (car list1)) (pack_consecutive_duplicates_helper (cdr list1) (cons (append (car result) (list (car list1))) (cdr result))))\n          (else (pack_consecutive_duplicates_helper (cdr list1) (cons (list (car list1)) result)))))\n  (reverse (pack_consecutive_duplicates_helper list1 '())))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (cons\n      (list (first list1))\n      (pack_consecutive_duplicates (rest list1)))]))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (let ([first (first list1)]\n           [rest (rest list1)])\n       (if (equal? first (first rest))\n           (cons (cons first (pack_consecutive_duplicates rest))\n                 (pack_consecutive_duplicates rest))\n           (cons (list first)\n                 (pack_consecutive_duplicates rest))))]))\n",
    "  (cond\n    [(null? list1) '()]\n    [(null? (cdr list1)) (list list1)]\n    [else\n     (let ([first (car list1)] [rest (cdr list1)])\n       (if (equal? first (car rest))\n           (cons (cons first (car (pack_consecutive_duplicates rest)))\n                 (pack_consecutive_duplicates (cdr (pack_consecutive_duplicates rest))))\n           (cons (list first) (pack_consecutive_duplicates rest))))]))\n",
    "  (cond\n    [(null? list1) '()]\n    [(null? (cdr list1)) (list list1)]\n    [else (cons (list (car list1))\n                (pack_consecutive_duplicates (cdr list1)))]))\n",
    "  (define (pack_consecutive_duplicates_iter list1 list2)\n    (cond ((null? list1) list2)\n          ((null? list2) (pack_consecutive_duplicates_iter (cdr list1) (list (list (car list1)))))\n          ((equal? (caar list2) (car list1)) (pack_consecutive_duplicates_iter (cdr list1) (cons (append (car list2) (list (car list1))) (cdr list2))))\n          (else (pack_consecutive_duplicates_iter (cdr list1) (cons (list (car list1)) list2)))))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (cond\n    [(empty? list1) empty]\n    [(empty? (cdr list1)) (list (list (car list1)))]\n    [(equal? (car list1) (cadr list1))\n     (cons (cons (car list1) (pack_consecutive_duplicates (cdr list1)))\n           (pack_consecutive_duplicates (cdr list1)))]\n    [else (cons (list (car list1)) (pack_consecutive_duplicates (cdr list1)))]))\n",
    "  (cond\n    [(null? list1) '()]\n    [else\n     (let* ([first (car list1)]\n            [rest (cdr list1)]\n            [first-rest (cons first rest)]\n            [first-rest-duplicates (filter (lambda (x) (equal? x first)) first-rest)]\n            [rest-duplicates (filter (lambda (x) (not (equal? x first))) first-rest)])\n       (cons first-rest-duplicates (pack_consecutive_duplicates rest-duplicates)))]))\n",
    "  (cond\n    [(null? list1) '()]\n    [else (cons (list (car list1)) (pack_consecutive_duplicates (cdr list1)))]))\n",
    "  (if (null? list1)\n      '()\n      (let ((sublist (list (car list1))))\n        (if (null? (cdr list1))\n            (list sublist)\n            (if (equal? (car list1) (cadr list1))\n                (append (pack_consecutive_duplicates (cons (car list1) (cdr list1))) '())\n                (cons sublist (pack_consecutive_duplicates (cdr list1))))))))\n",
    "  (let loop ((list1 list1)\n             (list2 '()))\n    (if (null? list1)\n        list2\n        (let ((sublist (list (car list1))))\n          (loop (cdr list1)\n                (if (equal? (car list1) (cadr list1))\n                    (append list2 (list (append sublist (list (cadr list1)))))\n                    (append list2 (list sublist))))))))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (let*\n         ([first (first list1)]\n          [rest (rest list1)]\n          [first-rest (cons first rest)]\n          [first-rest-duplicates (filter (lambda (x) (equal? first x)) first-rest)])\n       (cons first-rest-duplicates (pack_consecutive_duplicates (remove first first-rest))))]))\n",
    "  (if (null? list1)\n      '()\n      (let ((sublist (list (car list1))))\n        (if (null? (cdr list1))\n            (list sublist)\n            (if (= (car list1) (cadr list1))\n                (append (pack_consecutive_duplicates (cons (car list1) (cdr list1))) '())\n                (cons sublist (pack_consecutive_duplicates (cdr list1))))))))\n",
    "  (define (pack_consecutive_duplicates_helper list1 result)\n    (cond ((null? list1) result)\n          ((null? result) (pack_consecutive_duplicates_helper (cdr list1) (list (list (car list1)))))\n          ((equal? (caar result) (car list1)) (pack_consecutive_duplicates_helper (cdr list1) (cons (cons (car list1) (car result)) (cdr result))))\n          (else (pack_consecutive_duplicates_helper (cdr list1) (cons (list (car list1)) result)))))\n  (reverse (pack_consecutive_duplicates_helper list1 '())))\n",
    "  (cond\n    [(null? list1) '()]\n    [(null? (cdr list1)) (list list1)]\n    [else (cons (list (car list1)) (pack_consecutive_duplicates (cdr list1)))]))\n",
    "  (let loop ((list1 list1)\n             (result '()))\n    (cond ((null? list1) result)\n          ((null? (cdr list1)) (cons (list (car list1)) result))\n          ((equal? (car list1) (cadr list1))\n           (loop (cdr list1) (cons (cons (car list1) (car result)) (cdr result))))\n          (else (loop (cdr list1) (cons (list (car list1)) result))))))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (cond ((null? list1) result)\n          ((null? result) (pack_consecutive_duplicates_iter (cdr list1) (list (list (car list1)))))\n          ((equal? (caar result) (car list1)) (pack_consecutive_duplicates_iter (cdr list1) (cons (cons (car list1) (car result)) (cdr result))))\n          (else (pack_consecutive_duplicates_iter (cdr list1) (cons (list (car list1)) result)))))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (cond [(empty? list1) empty]\n        [else (cons (list (first list1))\n                    (pack_consecutive_duplicates (filter (lambda (x) (not (= x (first list1)))) (rest list1))))]))\n",
    "  (cond\n    [(null? list1) '()]\n    [(null? (cdr list1)) (list list1)]\n    [else\n     (let* ([first (car list1)]\n            [rest (cdr list1)]\n            [first-rest (car rest)]\n            [rest-rest (cdr rest)])\n       (if (equal? first first-rest)\n           (cons (cons first (pack_consecutive_duplicates rest))\n                 (pack_consecutive_duplicates rest-rest))\n           (cons (list first)\n                 (pack_consecutive_duplicates rest))))]))\n",
    "  (define (pack_consecutive_duplicates_iter list1 list2)\n    (cond ((null? list1) list2)\n          ((null? list2) (pack_consecutive_duplicates_iter (cdr list1) (list (list (car list1)))))\n          ((equal? (car list1) (caar list2)) (pack_consecutive_duplicates_iter (cdr list1) (cons (cons (car list1) (car list2)) (cdr list2))))\n          (else (pack_consecutive_duplicates_iter (cdr list1) (cons (list (car list1)) list2)))))\n  (pack_consecutive_duplicates_iter list1 '()))\n",
    "  (define (pack_consecutive_duplicates_helper list1 result)\n    (cond\n      [(empty? list1) result]\n      [(empty? result) (pack_consecutive_duplicates_helper (rest list1) (list (list (first list1))))]\n      [(equal? (first (first result)) (first list1)) (pack_consecutive_duplicates_helper (rest list1) (cons (cons (first list1) (first result)) (rest result)))]\n      [else (pack_consecutive_duplicates_helper (rest list1) (cons (list (first list1)) result))]))\n  (reverse (pack_consecutive_duplicates_helper list1 '())))\n",
    "  (let loop ((list1 list1)\n             (result '()))\n    (cond ((null? list1) (reverse result))\n          (else (let ((first (car list1))\n                       (rest (cdr list1)))\n                  (loop (drop-while (lambda (x) (= x first)) rest)\n                        (cons (cons first (take-while (lambda (x) (= x first)) rest)) result)))))))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else (cons (list (first list1))\n                (pack_consecutive_duplicates (filter (lambda (x) (not (= x (first list1)))) (rest list1))))]))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (cons\n      (cons (first list1) (take-while (lambda (x) (= x (first list1))) (rest list1)))\n      (pack_consecutive_duplicates (drop-while (lambda (x) (= x (first list1))) (rest list1))))]))\n",
    "  (let loop ([list1 list1] [list2 '()])\n    (cond [(null? list1) (reverse list2)]\n          [(null? (cdr list1)) (reverse (cons (list (car list1)) list2))]\n          [(equal? (car list1) (cadr list1))\n           (loop (cdr list1) (cons (cons (car list1) (car list2)) (cdr list2)))]\n          [else (loop (cdr list1) (cons (list (car list1)) list2))])))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else (cons (list (first list1))\n                (pack_consecutive_duplicates (filter (lambda (x) (not (equal? x (first list1)))) (rest list1))))]))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (cons\n      (list (first list1))\n      (pack_consecutive_duplicates (rest list1)))]))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (cond ((null? list1) result)\n          ((null? result) (pack_consecutive_duplicates_iter (cdr list1) (list (list (car list1)))))\n          ((equal? (car (car result)) (car list1)) (pack_consecutive_duplicates_iter (cdr list1) (cons (cons (car list1) (car result)) (cdr result))))\n          (else (pack_consecutive_duplicates_iter (cdr list1) (cons (list (car list1)) result)))))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else (cons (list (first list1))\n                (pack_consecutive_duplicates (filter (lambda (x) (not (= x (first list1)))) (rest list1))))]))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (cond ((null? list1) result)\n          ((null? result) (pack_consecutive_duplicates_iter (cdr list1) (list (list (car list1)))))\n          ((equal? (caar result) (car list1)) (pack_consecutive_duplicates_iter (cdr list1) (cons (cons (car list1) (car result)) (cdr result))))\n          (else (pack_consecutive_duplicates_iter (cdr list1) (cons (list (car list1)) result)))))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (if (null? list1)\n      '()\n      (let ((sublist (list (car list1))))\n        (if (null? (cdr list1))\n            (list sublist)\n            (if (equal? (car list1) (cadr list1))\n                (cons (cons (car list1) (pack_consecutive_duplicates (cdr list1))) '())\n                (cons sublist (pack_consecutive_duplicates (cdr list1))))))))\n",
    "  (define (pack_consecutive_duplicates_helper list1 result)\n    (cond\n      [(null? list1) result]\n      [(null? result) (pack_consecutive_duplicates_helper (cdr list1) (list (list (car list1))))]\n      [(equal? (car list1) (caar result)) (pack_consecutive_duplicates_helper (cdr list1) (cons (cons (car list1) (car result)) (cdr result)))]\n      [else (pack_consecutive_duplicates_helper (cdr list1) (cons (list (car list1)) result))]))\n  (reverse (pack_consecutive_duplicates_helper list1 '())))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (cons\n      (cons (first list1)\n            (filter (lambda (x) (equal? x (first list1))) list1))\n      (pack_consecutive_duplicates (filter (lambda (x) (not (equal? x (first list1)))) list1)))]))\n",
    "  (define (pack_consecutive_duplicates_helper list1 result)\n    (if (null? list1)\n        result\n        (let ((first (car list1))\n              (rest (cdr list1)))\n          (if (null? rest)\n              (cons (list first) result)\n              (if (equal? first (car rest))\n                  (pack_consecutive_duplicates_helper (cdr rest) (cons (cons first (car result)) (cdr result)))\n                  (pack_consecutive_duplicates_helper rest (cons (list first) result)))))))\n  (pack_consecutive_duplicates_helper list1 (list)))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (cons\n      (cons (first list1)\n            (take-while (lambda (x) (= x (first list1))) (rest list1)))\n      (pack_consecutive_duplicates (drop-while (lambda (x) (= x (first list1))) (rest list1))))]))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else (cons (list (first list1))\n                (pack_consecutive_duplicates (filter (lambda (x) (not (equal? x (first list1)))) (rest list1))))]))\n",
    "  (if (null? list1)\n      '()\n      (let ((first (car list1))\n            (rest (cdr list1)))\n        (cons (cons first (take-while (lambda (x) (= x first)) rest))\n              (pack_consecutive_duplicates (drop-while (lambda (x) (= x first)) rest))))))\n",
    "  (cond\n    [(empty? list1) empty]\n    [(empty? (rest list1)) (list (list (first list1)))]\n    [else (cons (list (first list1)) (pack_consecutive_duplicates (rest list1)))]))\n",
    "  (cond\n    [(empty? list1) empty]\n    [(empty? (rest list1)) (list (list (first list1)))]\n    [else\n     (let ([first-element (first list1)]\n           [rest-of-list (rest list1)])\n       (if (equal? first-element (first rest-of-list))\n           (cons (cons first-element (first (pack_consecutive_duplicates rest-of-list)))\n                 (rest (pack_consecutive_duplicates rest-of-list)))\n           (cons (list first-element) (pack_consecutive_duplicates rest-of-list))))]))\n</code>\nI'm not sure if this is the best way to do it, but it works.\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (cond ((null? list1) result)\n          ((null? result) (pack_consecutive_duplicates_iter (cdr list1) (list (list (car list1)))))\n          ((equal? (car (car result)) (car list1)) (pack_consecutive_duplicates_iter (cdr list1) (append (list (append (car result) (list (car list1)))) (cdr result))))\n          (else (pack_consecutive_duplicates_iter (cdr list1) (append (list (list (car list1))) result)))))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (cond ((null? list1) result)\n          ((null? result) (pack_consecutive_duplicates_iter (cdr list1) (list (list (car list1)))))\n          ((equal? (caar result) (car list1)) (pack_consecutive_duplicates_iter (cdr list1) (cons (append (car result) (list (car list1))) (cdr result))))\n          (else (pack_consecutive_duplicates_iter (cdr list1) (cons (list (car list1)) result)))))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (cond\n    [(empty? list1) empty]\n    [(empty? (rest list1)) (list (list (first list1)))]\n    [else (cons (list (first list1))\n                (pack_consecutive_duplicates (rest list1)))]))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else (cons (list (first list1))\n                (pack_consecutive_duplicates (rest list1)))]))\n</code>\nThe output is:\n<code>&gt; (pack_consecutive_duplicates '(a a a a b c c a a d e e e e))\n'((a) (a) (a) (a) (b) (c) (c) (a) (a) (d) (e) (e) (e) (e))\n</code>\nI am not sure how to make the function to pack consecutive duplicates into sublists.\nAny help would be appreciated.\n\n\nA:\n\nYou can use <code>group</code> from <code>racket/list</code> to do this.\n<code>(require racket/list)\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (cons (list (first list1))\n           (pack_consecutive_duplicates (filter (lambda (x) (not (equal? x (first list1)))) (rest list1))))]))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (let ([first (first list1)]\n           [rest (rest list1)])\n       (cond\n         [(empty? rest) (cons (list first) empty)]\n         [(equal? first (first rest))\n          (cons (cons first (first (pack_consecutive_duplicates rest)))\n                (rest (pack_consecutive_duplicates rest)))]\n         [else\n          (cons (list first) (pack_consecutive_duplicates rest))]))]))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (let ([first (first list1)]\n           [rest (rest list1)])\n       (if (equal? first (first rest))\n           (cons (cons first (pack_consecutive_duplicates rest))\n                 (pack_consecutive_duplicates rest))\n           (cons (list first)\n                 (pack_consecutive_duplicates rest))))]))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else (cons (list (first list1))\n                (pack_consecutive_duplicates (filter (lambda (x) (not (= x (first list1)))) (rest list1))))]))\n",
    "  (cond\n    [(empty? list1) empty]\n    [(empty? (rest list1)) (list (list (first list1)))]\n    [else\n     (let ([first-element (first list1)]\n           [rest-of-list (rest list1)])\n       (if (equal? first-element (first rest-of-list))\n           (cons (cons first-element (first (pack_consecutive_duplicates rest-of-list)))\n                 (pack_consecutive_duplicates (rest (pack_consecutive_duplicates rest-of-list))))\n           (cons (list first-element)\n                 (pack_consecutive_duplicates rest-of-list))))]))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (cond ((null? list1) result)\n          ((null? result) (pack_consecutive_duplicates_iter (cdr list1) (list (list (car list1)))))\n          ((equal? (caar result) (car list1)) (pack_consecutive_duplicates_iter (cdr list1) (cons (append (car result) (list (car list1))) (cdr result))))\n          (else (pack_consecutive_duplicates_iter (cdr list1) (cons (list (car list1)) result)))))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (cond\n    [(null? list1) '()]\n    [else\n     (let ([first (car list1)]\n           [rest (cdr list1)])\n       (let loop ([acc (list first)]\n                  [rest rest])\n         (cond\n           [(null? rest) (list acc)]\n           [(equal? first (car rest)) (loop (append acc (list (car rest))) (cdr rest))]\n           [else (cons acc (loop (list (car rest)) (cdr rest)))])))]))\n",
    "  (if (null? list1)\n      '()\n      (let loop ((list1 list1)\n                 (list2 '())\n                 (list3 '()))\n        (if (null? list1)\n            (reverse (cons list2 list3))\n            (if (equal? (car list1) (car list2))\n                (loop (cdr list1) (cons (car list1) list2) list3)\n                (loop (cdr list1) (list (car list1)) (cons list2 list3)))))))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (cond\n      [(null? list1) result]\n      [(null? result) (pack_consecutive_duplicates_iter (cdr list1) (list (list (car list1))))]\n      [(equal? (caar result) (car list1)) (pack_consecutive_duplicates_iter (cdr list1) (cons (cons (car list1) (car result)) (cdr result)))]\n      [else (pack_consecutive_duplicates_iter (cdr list1) (cons (list (car list1)) result))]))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (let* ([first (first list1)]\n            [rest (rest list1)]\n            [sublist (cons first (filter (lambda (x) (equal? x first)) rest))])\n       (cons sublist (pack_consecutive_duplicates (remove (lambda (x) (equal? x first)) rest))))]))\n",
    "  (cond\n    [(empty? list1) empty]\n    [(empty? (rest list1)) (list (list (first list1)))]\n    [else (cons (list (first list1)) (pack_consecutive_duplicates (rest list1)))]))\n",
    "  (cond\n    [(null? list1) '()]\n    [else\n     (let ([first (car list1)]\n           [rest (cdr list1)])\n       (if (null? rest)\n           (list (list first))\n           (let ([next (car rest)]\n                 [rest-rest (cdr rest)])\n             (if (equal? first next)\n                 (cons (cons first (car (pack_consecutive_duplicates rest))) (pack_consecutive_duplicates rest-rest))\n                 (cons (list first) (pack_consecutive_duplicates rest))))))]))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (cons\n      (list (first list1))\n      (pack_consecutive_duplicates (rest list1)))]))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (if (null? list1)\n        result\n        (let ((first (car list1))\n              (rest (cdr list1)))\n          (if (null? rest)\n              (append result (list (list first)))\n              (if (= first (car rest))\n                  (pack_consecutive_duplicates_iter (cdr rest) result)\n                  (pack_consecutive_duplicates_iter (cdr rest) (append result (list (list first)))))))))\n  (pack_consecutive_duplicates_iter list1 '()))\n",
    "  (if (null? list1)\n      '()\n      (let ((first (car list1))\n            (rest (cdr list1)))\n        (cons (cons first (take-while (lambda (x) (equal? x first)) rest))\n              (pack_consecutive_duplicates (drop-while (lambda (x) (equal? x first)) rest))))))\n",
    "  (if (null? list1)\n      '()\n      (let* ((first (car list1))\n             (rest (cdr list1))\n             (rest-packed (pack_consecutive_duplicates rest)))\n        (if (null? rest-packed)\n            (list (list first))\n            (if (eq? first (caar rest-packed))\n                (cons (cons first (car rest-packed)) (cdr rest-packed))\n                (cons (list first) rest-packed))))))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (cond ((null? list1) result)\n          ((null? result) (pack_consecutive_duplicates_iter (cdr list1) (list (list (car list1)))))\n          ((equal? (caar result) (car list1)) (pack_consecutive_duplicates_iter (cdr list1) (cons (append (car result) (list (car list1))) (cdr result))))\n          (else (pack_consecutive_duplicates_iter (cdr list1) (cons (list (car list1)) result)))))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (if (null? list1)\n        result\n        (let ((first (car list1))\n              (rest (cdr list1)))\n          (if (null? rest)\n              (cons (list first) result)\n              (let ((second (car rest)))\n                (if (equal? first second)\n                    (pack_consecutive_duplicates_iter rest (cons (cons first (car result)) (cdr result)))\n                    (pack_consecutive_duplicates_iter rest (cons (list first) result))))))))\n  (pack_consecutive_duplicates_iter list1 '()))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (let* ([first (first list1)]\n            [rest (rest list1)]\n            [first-rest (cons first rest)]\n            [first-rest-pack (pack_consecutive_duplicates first-rest)]\n            [first-rest-pack-first (first first-rest-pack)])\n       (if (equal? first first-rest-pack-first)\n           (cons (cons first first-rest-pack-first) (rest first-rest-pack))\n           (cons (list first) first-rest-pack)))]))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (cons (list (first list1))\n           (pack_consecutive_duplicates (filter (lambda (x) (not (= x (first list1)))) (rest list1))))]))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (cons\n      (cons (first list1)\n            (filter (lambda (x) (equal? x (first list1))) list1))\n      (pack_consecutive_duplicates (filter (lambda (x) (not (equal? x (first list1)))) list1)))]))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (cond ((null? list1) result)\n          ((null? result) (pack_consecutive_duplicates_iter (cdr list1) (list (list (car list1)))))\n          ((equal? (caar result) (car list1)) (pack_consecutive_duplicates_iter (cdr list1) (cons (cons (car list1) (car result)) (cdr result))))\n          (else (pack_consecutive_duplicates_iter (cdr list1) (cons (list (car list1)) result)))))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (cons (list (first list1))\n           (pack_consecutive_duplicates (filter (lambda (x) (not (= x (first list1)))) (rest list1))))]))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (let ([first (first list1)]\n           [rest (rest list1)])\n       (cons (cons first (filter (lambda (x) (equal? x first)) rest))\n             (pack_consecutive_duplicates (filter (lambda (x) (not (equal? x first))) rest))))]))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (cond\n      [(empty? list1) result]\n      [(empty? result) (pack_consecutive_duplicates_iter (rest list1) (list (list (first list1))))]\n      [(equal? (first (first result)) (first list1)) (pack_consecutive_duplicates_iter (rest list1) (cons (cons (first list1) (first result)) (rest result)))]\n      [else (pack_consecutive_duplicates_iter (rest list1) (cons (list (first list1)) result))]))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (cond\n    [(null? list1) '()]\n    [(null? (cdr list1)) (list list1)]\n    [else (cons (list (car list1)) (pack_consecutive_duplicates (cdr list1)))]))\n",
    "  (cond\n    [(empty? list1) empty]\n    [(empty? (rest list1)) (list (list (first list1)))]\n    [else (cons (list (first list1)) (pack_consecutive_duplicates (rest list1)))]))\n",
    "  (cond\n    [(empty? list1) empty]\n    [(empty? (rest list1)) (list (list (first list1)))]\n    [else (cons (list (first list1)) (pack_consecutive_duplicates (rest list1)))]))\n",
    "  (cond\n    [(null? list1) '()]\n    [else (cons (list (car list1)) (pack_consecutive_duplicates (cdr list1)))]))\n",
    "  (if (null? list1)\n      '()\n      (let loop ((list1 list1)\n                 (list2 '())\n                 (list3 '()))\n        (if (null? list1)\n            (reverse (cons list2 list3))\n            (if (equal? (car list1) (car list2))\n                (loop (cdr list1) (cons (car list1) list2) list3)\n                (loop (cdr list1) (list (car list1)) (cons list2 list3)))))))\n",
    "  (let loop ((list1 list1)\n             (list2 '()))\n    (cond ((null? list1) list2)\n          ((null? (cdr list1)) (cons (list (car list1)) list2))\n          ((equal? (car list1) (cadr list1))\n           (loop (cdr list1)\n                 (cons (cons (car list1) (car list2)) (cdr list2))))\n          (else (loop (cdr list1)\n                      (cons (list (car list1)) list2))))))\n",
    "  (cond\n    [(empty? list1) empty]\n    [(empty? (cdr list1)) (list (car list1))]\n    [else\n     (let ([first (car list1)]\n           [second (cadr list1)])\n       (if (equal? first second)\n           (cons (cons first (pack_consecutive_duplicates (cdr list1))) (pack_consecutive_duplicates (cdr list1)))\n           (cons (list first) (pack_consecutive_duplicates (cdr list1)))))]))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (cons (list (first list1))\n           (pack_consecutive_duplicates (filter (lambda (x) (not (= x (first list1)))) (rest list1))))]))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (cond ((null? list1) result)\n          ((null? result) (pack_consecutive_duplicates_iter (cdr list1) (list (list (car list1)))))\n          ((equal? (caar result) (car list1)) (pack_consecutive_duplicates_iter (cdr list1) (cons (append (car result) (list (car list1))) (cdr result))))\n          (else (pack_consecutive_duplicates_iter (cdr list1) (cons (list (car list1)) result)))))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (define (pack_consecutive_duplicates_iter list1 list2)\n    (if (null? list1)\n        list2\n        (if (null? list2)\n            (pack_consecutive_duplicates_iter (cdr list1) (list (list (car list1))))\n            (if (= (car (car list2)) (car list1))\n                (pack_consecutive_duplicates_iter (cdr list1) (cons (cons (car list1) (car list2)) (cdr list2)))\n                (pack_consecutive_duplicates_iter (cdr list1) (cons (list (car list1)) list2))))))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else (cons (list (first list1)) (pack_consecutive_duplicates (rest list1)))]))\n",
    "  (if (null? list1)\n      '()\n      (let ((sublist (list (car list1))))\n        (if (null? (cdr list1))\n            (list sublist)\n            (if (equal? (car list1) (cadr list1))\n                (append (pack_consecutive_duplicates (cdr list1)) (list sublist))\n                (cons sublist (pack_consecutive_duplicates (cdr list1))))))))\n",
    "  (cond\n    [(null? list1) '()]\n    [else (cons (list (car list1)) (pack_consecutive_duplicates (cdr list1)))]))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (cons (list (first list1))\n           (pack_consecutive_duplicates (filter (lambda (x) (not (equal? x (first list1)))) (rest list1))))]))\n",
    "  (let loop ((list1 list1)\n             (list2 '())\n             (list3 '()))\n    (cond ((null? list1) (reverse list3))\n          ((null? list2) (loop (cdr list1) (list (car list1)) list3))\n          ((equal? (car list1) (car list2)) (loop (cdr list1) (cons (car list1) list2) list3))\n          (else (loop (cdr list1) (list (car list1)) (cons list2 list3))))))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (if (null? list1)\n        result\n        (let ((first (car list1))\n              (rest (cdr list1)))\n          (if (null? rest)\n              (cons (list first) result)\n              (let ((second (car rest)))\n                (if (= first second)\n                    (pack_consecutive_duplicates_iter (cdr rest) (cons (cons first (car result)) (cdr result)))\n                    (pack_consecutive_duplicates_iter rest (cons (list first) result))))))))\n  (pack_consecutive_duplicates_iter list1 '()))\n",
    "  (let loop ((list1 list1) (list2 '()) (list3 '()))\n    (cond ((null? list1) (reverse list2))\n          ((null? list2) (loop (cdr list1) (list (list (car list1))) list3))\n          ((equal? (car list1) (car (car list2))) (loop (cdr list1) (cons (cons (car list1) (car list2)) (cdr list2)) list3))\n          (else (loop (cdr list1) (list (list (car list1))) list3)))))\n",
    "  (cond [(empty? list1) empty]\n        [else (cons (list (first list1))\n                    (pack_consecutive_duplicates (filter (lambda (x) (not (= x (first list1)))) (rest list1))))]))\n",
    "  (define (pack_consecutive_duplicates_iter list1 list2)\n    (cond\n      [(empty? list1) list2]\n      [(empty? list2) (pack_consecutive_duplicates_iter (cdr list1) (list (list (car list1))))]\n      [(equal? (car (car list2)) (car list1)) (pack_consecutive_duplicates_iter (cdr list1) (cons (cons (car list1) (car list2)) (cdr list2)))]\n      [else (pack_consecutive_duplicates_iter (cdr list1) (cons (list (car list1)) list2))]))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (cond\n    [(null? list1) '()]\n    [else (cons (list (car list1)) (pack_consecutive_duplicates (cdr list1)))]))\n",
    "  (let loop ((list1 list1)\n             (result '()))\n    (cond ((null? list1) result)\n          ((null? (cdr list1)) (cons (list (car list1)) result))\n          ((equal? (car list1) (cadr list1))\n           (loop (cdr list1) (cons (cons (car list1) (car result)) (cdr result))))\n          (else\n           (loop (cdr list1) (cons (list (car list1)) result))))))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (let* ([first (first list1)]\n            [rest (rest list1)]\n            [first-rest (cons first rest)]\n            [first-rest-duplicates (filter (lambda (x) (equal? first x)) first-rest)])\n       (cons first-rest-duplicates (pack_consecutive_duplicates (filter (lambda (x) (not (equal? first x))) first-rest))))]))\n",
    "  (define (pack_consecutive_duplicates_iter list1 list2)\n    (cond ((null? list1) list2)\n          ((null? list2) (pack_consecutive_duplicates_iter (cdr list1) (list (list (car list1)))))\n          ((equal? (car list1) (caar list2)) (pack_consecutive_duplicates_iter (cdr list1) (cons (cons (car list1) (car list2)) (cdr list2))))\n          (else (pack_consecutive_duplicates_iter (cdr list1) (cons (list (car list1)) list2)))))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (if (null? list1)\n        result\n        (let ((first (car list1))\n              (rest (cdr list1)))\n          (if (null? rest)\n              (cons (list first) result)\n              (let ((second (car rest)))\n                (if (equal? first second)\n                    (pack_consecutive_duplicates_iter rest (cons (cons first (car result)) (cdr result)))\n                    (pack_consecutive_duplicates_iter rest (cons (list first) result))))))))\n  (pack_consecutive_duplicates_iter list1 '()))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (cons (list (first list1))\n           (pack_consecutive_duplicates (remove (first list1) (rest list1))))]))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (cons\n      (list (first list1))\n      (pack_consecutive_duplicates (rest list1)))]))\n",
    "  (cond [(empty? list1) empty]\n        [else (cons (list (first list1))\n                    (pack_consecutive_duplicates (filter (lambda (x) (not (= x (first list1)))) (rest list1))))]))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (cond ((null? list1) result)\n          ((null? result) (pack_consecutive_duplicates_iter (cdr list1) (list (list (car list1)))))\n          ((equal? (caar result) (car list1)) (pack_consecutive_duplicates_iter (cdr list1) (cons (append (car result) (list (car list1))) (cdr result))))\n          (else (pack_consecutive_duplicates_iter (cdr list1) (cons (list (car list1)) result)))))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (if (null? list1)\n      '()\n      (let ((first (car list1))\n            (rest (cdr list1)))\n        (if (null? rest)\n            (list (list first))\n            (let ((next (car rest)))\n              (if (= first next)\n                  (cons (cons first (car (pack_consecutive_duplicates rest)))\n                        (cdr (pack_consecutive_duplicates rest)))\n                  (cons (list first) (pack_consecutive_duplicates rest))))))))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (cons (list (first list1))\n           (pack_consecutive_duplicates (remove (first list1) list1)))]))\n",
    "  (define (pack_consecutive_duplicates_helper list1 result)\n    (cond ((null? list1) result)\n          ((null? result) (pack_consecutive_duplicates_helper (cdr list1) (list (list (car list1)))))\n          ((equal? (caar result) (car list1)) (pack_consecutive_duplicates_helper (cdr list1) (cons (append (car result) (list (car list1))) (cdr result))))\n          (else (pack_consecutive_duplicates_helper (cdr list1) (cons (list (car list1)) result)))))\n  (reverse (pack_consecutive_duplicates_helper list1 '())))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (let* ([first (first list1)]\n            [rest (rest list1)]\n            [first-rest (cons first rest)]\n            [first-rest-duplicates (filter (lambda (x) (equal? x first)) first-rest)]\n            [rest-duplicates (filter (lambda (x) (not (equal? x first))) first-rest)])\n       (cons first-rest-duplicates (pack_consecutive_duplicates rest-duplicates)))]))\n",
    "  (let loop ((list1 list1)\n             (list2 '()))\n    (cond ((null? list1) (reverse list2))\n          ((null? (cdr list1)) (reverse (cons (list (car list1)) list2)))\n          ((equal? (car list1) (cadr list1))\n           (loop (cdr list1) (cons (cons (car list1) (car list2)) (cdr list2))))\n          (else (loop (cdr list1) (cons (list (car list1)) list2))))))\n",
    "  (let loop ((list1 list1)\n             (result '()))\n    (cond\n      [(null? list1) result]\n      [(null? (cdr list1)) (cons (list (car list1)) result)]\n      [(equal? (car list1) (cadr list1))\n       (loop (cdr list1) (cons (list (car list1) (cadr list1)) result))]\n      [else (loop (cdr list1) (cons (list (car list1)) result))])))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (let* ([first (first list1)]\n            [rest (rest list1)]\n            [first-rest (cons first rest)]\n            [first-rest-duplicates (filter (lambda (x) (equal? x first)) first-rest)])\n       (cons first-rest-duplicates (pack_consecutive_duplicates (remove first first-rest))))]))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (cons (list (first list1))\n           (pack_consecutive_duplicates (filter (lambda (x) (not (= x (first list1)))) (rest list1))))]))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (if (null? list1)\n        result\n        (let ((first (car list1))\n              (rest (cdr list1)))\n          (if (null? result)\n              (pack_consecutive_duplicates_iter rest (list (list first)))\n              (let ((last (car (last result))))\n                (if (equal? first (car last))\n                    (pack_consecutive_duplicates_iter rest (append (butlast result) (list (append last (list first)))))\n                    (pack_consecutive_duplicates_iter rest (append result (list (list first)))))))))\n  (pack_consecutive_duplicates_iter list1 '()))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (cons\n      (list (first list1))\n      (pack_consecutive_duplicates (rest list1)))]))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (cond ((null? list1) result)\n          ((null? result) (pack_consecutive_duplicates_iter (cdr list1) (list (list (car list1)))))\n          ((equal? (caar result) (car list1)) (pack_consecutive_duplicates_iter (cdr list1) (cons (append (car result) (list (car list1))) (cdr result))))\n          (else (pack_consecutive_duplicates_iter (cdr list1) (cons (list (car list1)) result)))))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (cons (list (first list1))\n           (pack_consecutive_duplicates (filter (lambda (x) (not (= x (first list1)))) (rest list1))))]))\n",
    "  (if (null? list1)\n      '()\n      (let ((first (car list1))\n            (rest (cdr list1)))\n        (if (null? rest)\n            (list (list first))\n            (let ((first-rest (car rest))\n                  (rest-rest (cdr rest)))\n              (if (equal? first first-rest)\n                  (cons (cons first (car (pack_consecutive_duplicates rest)))\n                        (pack_consecutive_duplicates rest-rest))\n                  (cons (list first) (pack_consecutive_duplicates rest))))))))\n",
    "  (cond\n    [(empty? list1) empty]\n    [(empty? (rest list1)) (list (list (first list1)))]\n    [else\n     (let* ([first-element (first list1)]\n            [rest-of-list (rest list1)]\n            [first-element-of-rest (first rest-of-list)]\n            [rest-of-rest (rest rest-of-list)])\n       (if (equal? first-element first-element-of-rest)\n           (cons (cons first-element (pack_consecutive_duplicates rest-of-list))\n                 (pack_consecutive_duplicates rest-of-rest))\n           (cons (list first-element)\n                 (pack_consecutive_duplicates rest-of-list))))]))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (let* ([first (first list1)]\n            [rest (rest list1)]\n            [first-rest (cons first rest)]\n            [first-rest-duplicates (filter (lambda (x) (equal? x first)) first-rest)])\n       (cons first-rest-duplicates (pack_consecutive_duplicates (filter (lambda (x) (not (equal? x first))) first-rest))))]))\n",
    "  (define (pack_consecutive_duplicates_helper list1 result)\n    (cond ((null? list1) result)\n          ((null? result) (pack_consecutive_duplicates_helper (cdr list1) (list (list (car list1)))))\n          ((equal? (caar result) (car list1)) (pack_consecutive_duplicates_helper (cdr list1) (cons (append (car result) (list (car list1))) (cdr result))))\n          (else (pack_consecutive_duplicates_helper (cdr list1) (cons (list (car list1)) result)))))\n  (reverse (pack_consecutive_duplicates_helper list1 '())))\n",
    "  (define (pack_consecutive_duplicates_iter list1 list2)\n    (cond ((null? list1) list2)\n          ((null? list2) (pack_consecutive_duplicates_iter (cdr list1) (list (list (car list1)))))\n          ((equal? (caar list2) (car list1)) (pack_consecutive_duplicates_iter (cdr list1) (cons (append (car list2) (list (car list1))) (cdr list2))))\n          (else (pack_consecutive_duplicates_iter (cdr list1) (cons (list (car list1)) list2)))))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else (cons (list (first list1))\n                (pack_consecutive_duplicates (filter (lambda (x) (not (= x (first list1)))) (rest list1))))]))\n",
    "  (if (null? list1)\n      '()\n      (let* ((first (car list1))\n             (rest (cdr list1))\n             (first-duplicates (take-while (lambda (x) (= x first)) rest)))\n        (cons (cons first first-duplicates)\n              (pack_consecutive_duplicates (drop-while (lambda (x) (= x first)) rest))))))\n",
    "  (cond\n    [(null? list1) '()]\n    [(null? (cdr list1)) (list list1)]\n    [(equal? (car list1) (cadr list1))\n     (cons (cons (car list1) (cdr list1))\n           (pack_consecutive_duplicates (cdr list1)))]\n    [else\n     (cons (list (car list1))\n           (pack_consecutive_duplicates (cdr list1)))]))\n",
    "  (cond\n    [(empty? list1) empty]\n    [(empty? (rest list1)) (list (list (first list1)))]\n    [else\n     (let* ([first-element (first list1)]\n            [rest-of-list (rest list1)]\n            [first-element-of-rest (first rest-of-list)]\n            [rest-of-rest-of-list (rest rest-of-list)])\n       (if (equal? first-element first-element-of-rest)\n           (cons (cons first-element (pack_consecutive_duplicates rest-of-list)) (pack_consecutive_duplicates rest-of-rest-of-list))\n           (cons (list first-element) (pack_consecutive_duplicates rest-of-list))))]))\n",
    "  (if (null? list1)\n      '()\n      (let ((sublist (list (car list1))))\n        (cons sublist (pack_consecutive_duplicates (cdr list1))))))\n",
    "  (cond\n    [(empty? list1) empty]\n    [(empty? (rest list1)) (list list1)]\n    [else (cons (list (first list1)) (pack_consecutive_duplicates (rest list1)))]))\n",
    "  (let loop ((list1 list1)\n             (result '()))\n    (cond ((null? list1) result)\n          ((null? (cdr list1)) (cons (list (car list1)) result))\n          ((equal? (car list1) (cadr list1))\n           (loop (cdr list1) (cons (cons (car list1) (car result)) (cdr result))))\n          (else (loop (cdr list1) (cons (list (car list1)) result))))))\n",
    "  (define (pack_consecutive_duplicates_helper list1 result)\n    (cond\n      [(null? list1) result]\n      [(null? result) (pack_consecutive_duplicates_helper (cdr list1) (list (list (car list1))))]\n      [(equal? (car list1) (caar result)) (pack_consecutive_duplicates_helper (cdr list1) (cons (cons (car list1) (car result)) (cdr result)))]\n      [else (pack_consecutive_duplicates_helper (cdr list1) (cons (list (car list1)) result))]))\n  (reverse (pack_consecutive_duplicates_helper list1 '())))\n",
    "  (let loop ((list1 list1)\n             (result '()))\n    (cond ((null? list1) result)\n          ((null? (cdr list1)) (cons list1 result))\n          ((= (car list1) (cadr list1)) (loop (cdr list1) (cons (cons (car list1) (cdr list1)) result)))\n          (else (loop (cdr list1) (cons (list (car list1)) result))))))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (let* ([first (first list1)]\n            [rest (rest list1)]\n            [first-rest (cons first rest)]\n            [first-rest-duplicates (filter (lambda (x) (equal? x first)) first-rest)])\n       (cons first-rest-duplicates (pack_consecutive_duplicates (filter (lambda (x) (not (equal? x first))) first-rest))))]))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (cons (list (first list1))\n           (pack_consecutive_duplicates (rest list1)))]))\n</code>\nI'm not sure how to get the consecutive duplicates into sublists.\n\n\nA:\n\nYou need to check if the first element of the list is equal to the first element of the rest of the list. If so, you need to add it to the first element of the list. If not, you need to add it to the rest of the list.\n<code>(define (pack_consecutive_duplicates list1)\n  (cond\n    [(empty? list1) empty]\n    [(empty? (rest list1)) (list list1)]\n    [else\n     (cons (list (first list1))\n           (pack_consecutive_duplicates (rest list1)))]))\n</code>\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (cons (list (first list1))\n           (pack_consecutive_duplicates (filter (lambda (x) (not (= x (first list1)))) (rest list1))))]))\n",
    "  (letrec ([pack_consecutive_duplicates_helper (lambda (list1 result)\n                                                (cond [(empty? list1) result]\n                                                      [(empty? result) (pack_consecutive_duplicates_helper (rest list1) (list (list (first list1))))]\n                                                      [(equal? (first (last result)) (first list1)) (pack_consecutive_duplicates_helper (rest list1) (append result (list (first list1))))]\n                                                      [else (pack_consecutive_duplicates_helper (rest list1) (append result (list (list (first list1)))))]))])\n    (pack_consecutive_duplicates_helper list1 '())))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (cond ((null? list1) result)\n          ((null? result) (pack_consecutive_duplicates_iter (cdr list1) (list (list (car list1)))))\n          ((equal? (caar result) (car list1)) (pack_consecutive_duplicates_iter (cdr list1) (cons (append (car result) (list (car list1))) (cdr result))))\n          (else (pack_consecutive_duplicates_iter (cdr list1) (cons (list (car list1)) result)))))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (let loop ([list1 list1] [result '()])\n    (cond\n      [(empty? list1) (reverse result)]\n      [else\n       (let ([sublist (take-while (lambda (x) (equal? x (car list1))) list1)])\n         (loop (drop (length sublist) list1) (cons sublist result)))])))\n",
    "  (cond\n    [(null? list1) '()]\n    [else\n     (let* ([first (car list1)]\n            [rest (cdr list1)]\n            [first-duplicates (take-while (lambda (x) (= x first)) rest)]\n            [rest-duplicates (drop-while (lambda (x) (= x first)) rest)])\n       (cons (cons first first-duplicates) (pack_consecutive_duplicates rest-duplicates)))]))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else (cons (list (first list1)) (pack_consecutive_duplicates (rest list1)))]))\n",
    "  (cond\n    [(null? list1) '()]\n    [(null? (cdr list1)) (list list1)]\n    [else (cons (list (car list1)) (pack_consecutive_duplicates (cdr list1)))]))\n",
    "  (let loop ((list1 list1) (list2 '()))\n    (cond ((null? list1) (reverse list2))\n          ((null? (cdr list1)) (reverse (cons (list (car list1)) list2)))\n          ((equal? (car list1) (cadr list1))\n           (loop (cdr list1) (cons (cons (car list1) (car list2)) (cdr list2))))\n          (else (loop (cdr list1) (cons (list (car list1)) list2))))))\n",
    "  (define (pack_consecutive_duplicates_helper list1 result)\n    (cond ((null? list1) result)\n          ((null? result) (pack_consecutive_duplicates_helper (cdr list1) (list (list (car list1)))))\n          ((equal? (caar result) (car list1)) (pack_consecutive_duplicates_helper (cdr list1) (cons (append (car result) (list (car list1))) (cdr result))))\n          (else (pack_consecutive_duplicates_helper (cdr list1) (cons (list (car list1)) result)))))\n  (reverse (pack_consecutive_duplicates_helper list1 '())))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else (cons (list (first list1))\n                (pack_consecutive_duplicates (rest list1)))]))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (cons\n      (list (first list1))\n      (pack_consecutive_duplicates (rest list1)))]))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (cond\n      [(empty? list1) result]\n      [(empty? result) (pack_consecutive_duplicates_iter (rest list1) (list (list (first list1))))]\n      [(equal? (first list1) (first (first result))) (pack_consecutive_duplicates_iter (rest list1) (cons (cons (first list1) (first result)) (rest result)))]\n      [else (pack_consecutive_duplicates_iter (rest list1) (cons (list (first list1)) result))]))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (cond ((null? list1) result)\n          ((null? result) (pack_consecutive_duplicates_iter (cdr list1) (list (list (car list1)))))\n          ((equal? (car (car result)) (car list1)) (pack_consecutive_duplicates_iter (cdr list1) (cons (append (car result) (list (car list1))) (cdr result))))\n          (else (pack_consecutive_duplicates_iter (cdr list1) (cons (list (car list1)) result)))))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (define (pack_consecutive_duplicates_helper list1 list2)\n    (cond ((null? list1) list2)\n          ((null? list2) (pack_consecutive_duplicates_helper (cdr list1) (list (list (car list1)))))\n          ((equal? (car (car list2)) (car list1)) (pack_consecutive_duplicates_helper (cdr list1) (cons (cons (car list1) (car list2)) (cdr list2))))\n          (else (pack_consecutive_duplicates_helper (cdr list1) (cons (list (car list1)) list2)))))\n  (reverse (pack_consecutive_duplicates_helper list1 '())))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (cond ((null? list1) result)\n          ((null? result) (pack_consecutive_duplicates_iter (cdr list1) (list (list (car list1)))))\n          ((equal? (caar result) (car list1)) (pack_consecutive_duplicates_iter (cdr list1) (cons (cons (car list1) (car result)) (cdr result))))\n          (else (pack_consecutive_duplicates_iter (cdr list1) (cons (list (car list1)) result)))))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (cond\n    [(empty? list1) empty]\n    [(= (length list1) 1) (list list1)]\n    [else (cons (list (first list1)) (pack_consecutive_duplicates (rest list1)))]))\n",
    "  (if (null? list1)\n      '()\n      (let ((sublist (list (car list1))))\n        (if (null? (cdr list1))\n            (list sublist)\n            (if (equal? (car list1) (cadr list1))\n                (cons (append sublist (list (cadr list1)))\n                      (pack_consecutive_duplicates (cdr (cdr list1))))\n                (cons sublist (pack_consecutive_duplicates (cdr list1))))))))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (cond ((null? list1) result)\n          ((null? result) (pack_consecutive_duplicates_iter (cdr list1) (list (list (car list1)))))\n          ((equal? (caar result) (car list1)) (pack_consecutive_duplicates_iter (cdr list1) (cons (cons (car list1) (car result)) (cdr result))))\n          (else (pack_consecutive_duplicates_iter (cdr list1) (cons (list (car list1)) result)))))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (cond ((null? list1) result)\n          ((null? result) (pack_consecutive_duplicates_iter (cdr list1) (list (list (car list1)))))\n          ((equal? (caar result) (car list1)) (pack_consecutive_duplicates_iter (cdr list1) (cons (cons (car list1) (car result)) (cdr result))))\n          (else (pack_consecutive_duplicates_iter (cdr list1) (cons (list (car list1)) result)))))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (define (pack_consecutive_duplicates_helper list1 result)\n    (cond ((null? list1) result)\n          ((null? result) (pack_consecutive_duplicates_helper (cdr list1) (list (list (car list1)))))\n          ((equal? (car (car result)) (car list1)) (pack_consecutive_duplicates_helper (cdr list1) (cons (cons (car list1) (car result)) (cdr result))))\n          (else (pack_consecutive_duplicates_helper (cdr list1) (cons (list (car list1)) result)))))\n  (reverse (pack_consecutive_duplicates_helper list1 '())))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (if (null? list1)\n        result\n        (let ((first (car list1))\n              (rest (cdr list1)))\n          (if (null? rest)\n              (append result (list (list first)))\n              (if (equal? first (car rest))\n                  (pack_consecutive_duplicates_iter rest (append result (list (list first))))\n                  (pack_consecutive_duplicates_iter rest (append result (list (list first)))))))))\n  (pack_consecutive_duplicates_iter list1 '()))\n",
    "  (if (null? list1)\n      '()\n      (let ((first (car list1))\n            (rest (cdr list1)))\n        (cons (cons first (take-while (lambda (x) (equal? x first)) rest))\n              (pack_consecutive_duplicates (drop-while (lambda (x) (equal? x first)) rest))))))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (let ([first (first list1)]\n           [rest (rest list1)])\n       (if (equal? first (first rest))\n           (cons (cons first (pack_consecutive_duplicates rest))\n                 (pack_consecutive_duplicates rest))\n           (cons (list first)\n                 (pack_consecutive_duplicates rest))))]))\n",
    "  (cond\n    [(empty? list1) empty]\n    [(empty? (cdr list1)) (list list1)]\n    [else (cons (list (car list1)) (pack_consecutive_duplicates (cdr list1)))]))\n",
    "  (define (pack_consecutive_duplicates_helper list1 result)\n    (cond\n      [(empty? list1) (reverse result)]\n      [(empty? result) (pack_consecutive_duplicates_helper (rest list1) (list (list (first list1))))]\n      [(equal? (first (first result)) (first list1)) (pack_consecutive_duplicates_helper (rest list1) (cons (cons (first list1) (first result)) (rest result)))]\n      [else (pack_consecutive_duplicates_helper (rest list1) (cons (list (first list1)) result))]))\n  (pack_consecutive_duplicates_helper list1 '()))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (let* ([first (first list1)]\n            [rest (rest list1)]\n            [same-as-first? (lambda (x) (equal? first x))]\n            [first-group (take-while same-as-first? rest)]\n            [rest-group (drop-while same-as-first? rest)])\n       (cons (cons first first-group)\n             (pack_consecutive_duplicates rest-group)))]))\n",
    "  (cond\n    [(null? list1) '()]\n    [(null? (cdr list1)) (list list1)]\n    [else\n     (let loop ([list1 list1]\n                [list2 '()]\n                [list3 '()])\n       (cond\n         [(null? list1) (reverse (cons list2 list3))]\n         [(null? (cdr list1)) (reverse (cons (cons (car list1) list2) list3))]\n         [(equal? (car list1) (cadr list1)) (loop (cdr list1) (cons (car list1) list2) list3)]\n         [else (loop (cdr list1) '() (cons (cons (car list1) list2) list3))]))]))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (cond ((null? list1) result)\n          ((null? result) (pack_consecutive_duplicates_iter (cdr list1) (list (list (car list1)))))\n          ((equal? (caar result) (car list1)) (pack_consecutive_duplicates_iter (cdr list1) (append (list (append (car result) (list (car list1)))) (cdr result))))\n          (else (pack_consecutive_duplicates_iter (cdr list1) (append (list (list (car list1))) result)))))\n  (pack_consecutive_duplicates_iter list1 '()))\n",
    "  (if (null? list1)\n      '()\n      (let loop ((list1 list1)\n                 (list2 '())\n                 (list3 '()))\n        (if (null? list1)\n            (reverse (cons list2 list3))\n            (if (equal? (car list1) (car list2))\n                (loop (cdr list1) (cons (car list1) list2) list3)\n                (loop (cdr list1) (list (car list1)) (cons list2 list3)))))))\n",
    "  (let loop ([list1 list1]\n             [result '()])\n    (cond [(null? list1) result]\n          [(null? (cdr list1)) (cons (list (car list1)) result)]\n          [(equal? (car list1) (cadr list1))\n           (loop (cdr list1) (cons (list (car list1)) result))]\n          [else (loop (cdr list1) (cons (list (car list1)) result))])))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (let* ([first (first list1)]\n            [rest (rest list1)]\n            [packed_rest (pack_consecutive_duplicates rest)])\n       (if (equal? first (first (first packed_rest)))\n           (cons (cons first (first packed_rest)) (rest packed_rest))\n           (cons (list first) packed_rest)))]))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else (cons (list (first list1))\n                 (pack_consecutive_duplicates (rest list1)))]))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (if (null? list1)\n        result\n        (let ((first (car list1))\n              (rest (cdr list1)))\n          (if (null? rest)\n              (cons (list first) result)\n              (if (equal? first (car rest))\n                  (pack_consecutive_duplicates_iter rest (cons (cons first (car result)) (cdr result)))\n                  (pack_consecutive_duplicates_iter rest (cons (list first) result)))))))\n  (pack_consecutive_duplicates_iter list1 '()))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else (cons (list (first list1))\n                (pack_consecutive_duplicates (filter (lambda (x) (not (= x (first list1)))) (rest list1))))]))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (cond\n      [(empty? list1) result]\n      [else\n       (define (get_duplicates list1)\n         (define (get_duplicates_iter list1 result)\n           (cond\n             [(empty? list1) result]\n             [else\n              (if (= (first list1) (first (rest list1)))\n                  (get_duplicates_iter (rest list1) (append result (list (first list1))))\n                  result)]))\n         (get_duplicates_iter list1 (list (first list1))))\n       (pack_consecutive_duplicates_iter (drop (length (get_duplicates list1)) list1) (append result (list (get_duplicates list1))))])\n  (pack_consecutive_duplicates_iter list1 (list)))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else (cons (list (first list1))\n                (pack_consecutive_duplicates (filter (lambda (x) (not (equal? x (first list1)))) (rest list1))))]))\n",
    "  (define (pack_consecutive_duplicates_helper list1 result)\n    (cond ((null? list1) result)\n          ((null? result) (pack_consecutive_duplicates_helper (cdr list1) (list (list (car list1)))))\n          ((equal? (caar result) (car list1)) (pack_consecutive_duplicates_helper (cdr list1) (cons (append (car result) (list (car list1))) (cdr result))))\n          (else (pack_consecutive_duplicates_helper (cdr list1) (cons (list (car list1)) result)))))\n  (reverse (pack_consecutive_duplicates_helper list1 '())))\n",
    "  (define (pack_consecutive_duplicates_helper list1 result)\n    (if (null? list1)\n        result\n        (let ((first (car list1))\n              (rest (cdr list1)))\n          (if (null? result)\n              (pack_consecutive_duplicates_helper rest (list (list first)))\n              (let ((last (car (last result))))\n                (if (equal? first (car last))\n                    (pack_consecutive_duplicates_helper rest (append (butlast result) (list (append last (list first)))))\n                    (pack_consecutive_duplicates_helper rest (append result (list (list first)))))))))\n  (pack_consecutive_duplicates_helper list1 '()))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (if (null? list1)\n        result\n        (let ((sublist (list (car list1))))\n          (let loop ((list2 (cdr list1))\n                     (sublist sublist))\n            (if (null? list2)\n                (pack_consecutive_duplicates_iter (cdr list1) (append result (list sublist)))\n                (if (equal? (car list2) (car sublist))\n                    (loop (cdr list2) (append sublist (list (car list2))))\n                    (pack_consecutive_duplicates_iter (cdr list1) (append result (list sublist)))))))))\n  (pack_consecutive_duplicates_iter list1 '()))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (cond\n      [(empty? list1) result]\n      [(empty? result) (pack_consecutive_duplicates_iter (rest list1) (list (list (first list1))))]\n      [(equal? (first (first result)) (first list1)) (pack_consecutive_duplicates_iter (rest list1) (cons (cons (first list1) (first result)) (rest result)))]\n      [else (pack_consecutive_duplicates_iter (rest list1) (cons (list (first list1)) result))]))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (let* ([first (first list1)]\n            [rest (rest list1)]\n            [sublist (list first)]\n            [sublist (cons first sublist)])\n       (cond\n         [(empty? rest) (list sublist)]\n         [(equal? first (first rest))\n          (cons (pack_consecutive_duplicates (cons first rest))\n                (pack_consecutive_duplicates (rest rest)))]\n         [else\n          (cons sublist (pack_consecutive_duplicates rest))]))]))\n",
    "  (cond\n    [(null? list1) '()]\n    [(null? (cdr list1)) (list list1)]\n    [else\n     (let* ([first (car list1)]\n            [rest (cdr list1)]\n            [first-rest (car rest)]\n            [rest-rest (cdr rest)])\n       (if (equal? first first-rest)\n           (cons (cons first (pack_consecutive_duplicates rest))\n                 (pack_consecutive_duplicates rest-rest))\n           (cons (list first)\n                 (pack_consecutive_duplicates rest))))]))\n",
    "  (cond [(empty? list1) empty]\n        [else (cons (list (first list1))\n                    (pack_consecutive_duplicates (rest list1)))]))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (cons\n      (list (first list1))\n      (pack_consecutive_duplicates (rest list1)))]))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (let ([first (first list1)]\n           [rest (rest list1)])\n       (if (equal? first (first rest))\n           (cons (cons first (pack_consecutive_duplicates rest))\n                 (pack_consecutive_duplicates rest))\n           (cons (list first)\n                 (pack_consecutive_duplicates rest))))]))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (cond ((null? list1) result)\n          ((null? result) (pack_consecutive_duplicates_iter (cdr list1) (list (list (car list1)))))\n          ((equal? (caar result) (car list1)) (pack_consecutive_duplicates_iter (cdr list1) (cons (append (car result) (list (car list1))) (cdr result))))\n          (else (pack_consecutive_duplicates_iter (cdr list1) (cons (list (car list1)) result)))))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (cond\n    [(null? list1) '()]\n    [else\n     (let* ([first (car list1)]\n            [rest (cdr list1)]\n            [first-duplicates (take-while (lambda (x) (= x first)) rest)]\n            [rest-duplicates (drop-while (lambda (x) (= x first)) rest)])\n       (cons (cons first first-duplicates) (pack_consecutive_duplicates rest-duplicates)))]))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (cond ((null? list1) result)\n          ((null? result) (pack_consecutive_duplicates_iter (cdr list1) (list (list (car list1)))))\n          ((equal? (car (car result)) (car list1)) (pack_consecutive_duplicates_iter (cdr list1) (cons (append (car result) (list (car list1))) (cdr result))))\n          (else (pack_consecutive_duplicates_iter (cdr list1) (cons (list (car list1)) result)))))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (let ([first (first list1)]\n           [rest (rest list1)])\n       (cond\n         [(empty? rest) (list first)]\n         [(equal? first (first rest))\n          (cons first (pack_consecutive_duplicates rest))]\n         [else\n          (cons (list first) (pack_consecutive_duplicates rest))]))]))\n",
    "  (define (pack_consecutive_duplicates_iter list1 list2)\n    (cond ((null? list1) list2)\n          ((null? list2) (pack_consecutive_duplicates_iter (cdr list1) (list (list (car list1)))))\n          ((equal? (caar list2) (car list1)) (pack_consecutive_duplicates_iter (cdr list1) (cons (append (car list2) (list (car list1))) (cdr list2))))\n          (else (pack_consecutive_duplicates_iter (cdr list1) (cons (list (car list1)) list2)))))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (cond\n      [(empty? list1) result]\n      [(empty? result) (pack_consecutive_duplicates_iter (rest list1) (list (list (first list1))))]\n      [(equal? (first (last result)) (first list1)) (pack_consecutive_duplicates_iter (rest list1) (append result (list (first list1))))]\n      [else (pack_consecutive_duplicates_iter (rest list1) (append result (list (list (first list1)))))]))\n  (pack_consecutive_duplicates_iter list1 '()))\n",
    "  (cond\n    [(null? list1) '()]\n    [(null? (cdr list1)) (list list1)]\n    [else\n     (let ([first (car list1)]\n           [second (cadr list1)])\n       (if (equal? first second)\n           (cons (cons first (pack_consecutive_duplicates (cdr list1)))\n                 (pack_consecutive_duplicates (cdr list1)))\n           (cons (list first)\n                 (pack_consecutive_duplicates (cdr list1)))))]))\n",
    "  (define (pack_consecutive_duplicates_iter list1 list2)\n    (cond\n      [(empty? list1) list2]\n      [(empty? list2) (pack_consecutive_duplicates_iter (rest list1) (list (list (first list1))))]\n      [(equal? (first (first list2)) (first list1)) (pack_consecutive_duplicates_iter (rest list1) (cons (cons (first list1) (first list2)) (rest list2)))]\n      [else (pack_consecutive_duplicates_iter (rest list1) (cons (list (first list1)) list2))]))\n  (pack_consecutive_duplicates_iter list1 '()))\n",
    "  (cond [(empty? list1) empty]\n        [else (cons (list (first list1))\n                    (pack_consecutive_duplicates (filter (lambda (x) (not (= x (first list1)))) (rest list1))))]))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (cons\n      (list (first list1))\n      (pack_consecutive_duplicates (rest list1)))]))\n",
    "  (let loop ((list1 list1)\n             (acc '()))\n    (cond ((null? list1) (reverse acc))\n          ((null? (cdr list1)) (reverse (cons (list (car list1)) acc)))\n          ((equal? (car list1) (cadr list1))\n           (loop (cdr list1) (cons (cons (car list1) (car acc)) (cdr acc))))\n          (else (loop (cdr list1) (cons (list (car list1)) acc))))))\n",
    "  (let loop ((list1 list1)\n             (acc '()))\n    (cond ((null? list1) (reverse acc))\n          ((null? (cdr list1)) (reverse (cons (list (car list1)) acc)))\n          (else (if (equal? (car list1) (cadr list1))\n                   (loop (cdr list1) (cons (cons (car list1) (car acc)) (cdr acc)))\n                   (loop (cdr list1) (cons (list (car list1)) acc)))))))\n",
    "  (if (null? list1)\n      '()\n      (let ((first (car list1))\n            (rest (cdr list1)))\n        (if (null? rest)\n            (list list1)\n            (if (equal? first (car rest))\n                (cons (cons first (pack_consecutive_duplicates rest)) '())\n                (cons (list first) (pack_consecutive_duplicates rest)))))))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (let* ([first (first list1)]\n            [rest (rest list1)]\n            [first-rest (cons first rest)]\n            [first-rest-duplicates (filter (lambda (x) (equal? x first)) first-rest)])\n       (cons first-rest-duplicates (pack_consecutive_duplicates (remove first first-rest))))]))\n",
    "  (cond ((null? list1) '())\n        ((null? (cdr list1)) (list list1))\n        (else (cons (list (car list1)) (pack_consecutive_duplicates (cdr list1))))))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (cond ((null? list1) result)\n          ((null? result) (pack_consecutive_duplicates_iter (cdr list1) (list (list (car list1)))))\n          ((equal? (car (car result)) (car list1)) (pack_consecutive_duplicates_iter (cdr list1) (cons (cons (car list1) (car result)) (cdr result))))\n          (else (pack_consecutive_duplicates_iter (cdr list1) (cons (list (car list1)) result)))))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (cond ((null? list1) result)\n          ((null? result) (pack_consecutive_duplicates_iter (cdr list1) (list (list (car list1)))))\n          ((equal? (car (car result)) (car list1)) (pack_consecutive_duplicates_iter (cdr list1) (cons (cons (car list1) (car result)) (cdr result))))\n          (else (pack_consecutive_duplicates_iter (cdr list1) (cons (list (car list1)) result)))))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (cons\n      (list (first list1))\n      (pack_consecutive_duplicates (rest list1)))]))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (cond\n      [(empty? list1) result]\n      [(empty? result) (pack_consecutive_duplicates_iter (rest list1) (list (list (first list1))))]\n      [(equal? (first (first result)) (first list1)) (pack_consecutive_duplicates_iter (rest list1) (cons (append (first result) (list (first list1))) (rest result)))]\n      [else (pack_consecutive_duplicates_iter (rest list1) (cons (list (first list1)) result))]))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (if (null? list1)\n      '()\n      (let ((first (car list1))\n            (rest (cdr list1)))\n        (cons (cons first (filter (lambda (x) (equal? x first)) rest))\n              (pack_consecutive_duplicates (filter (lambda (x) (not (equal? x first))) rest))))))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (let* ([first (first list1)]\n            [rest (rest list1)]\n            [sublist (list first)])\n       (cond\n         [(empty? rest) (list sublist)]\n         [(equal? first (first rest))\n          (cons sublist (pack_consecutive_duplicates rest))]\n         [else\n          (cons sublist (pack_consecutive_duplicates rest))]))]))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (let ([first (first list1)]\n           [rest (rest list1)])\n       (if (equal? first (first rest))\n           (cons (cons first (pack_consecutive_duplicates rest))\n                 (pack_consecutive_duplicates rest))\n           (cons (list first) (pack_consecutive_duplicates rest))))]))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (cond ((null? list1) result)\n          ((null? result) (pack_consecutive_duplicates_iter (cdr list1) (list (list (car list1)))))\n          ((equal? (car (car result)) (car list1)) (pack_consecutive_duplicates_iter (cdr list1) (cons (append (car result) (list (car list1))) (cdr result))))\n          (else (pack_consecutive_duplicates_iter (cdr list1) (cons (list (car list1)) result)))))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (cond ((null? list1) result)\n          ((null? result) (pack_consecutive_duplicates_iter (cdr list1) (list (list (car list1)))))\n          ((equal? (caar result) (car list1)) (pack_consecutive_duplicates_iter (cdr list1) (cons (cons (car list1) (car result)) (cdr result))))\n          (else (pack_consecutive_duplicates_iter (cdr list1) (cons (list (car list1)) result)))))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (cond ((null? list1) '())\n        ((null? (cdr list1)) (list list1))\n        (else\n         (let ((first (car list1))\n               (rest (cdr list1)))\n           (if (equal? first (car rest))\n               (cons (cons first (pack_consecutive_duplicates rest))\n                     (pack_consecutive_duplicates (cdr rest)))\n               (cons (list first)\n                     (pack_consecutive_duplicates rest)))))))\n",
    "  (define (pack_consecutive_duplicates_iter list1 result)\n    (cond ((null? list1) result)\n          ((null? result) (pack_consecutive_duplicates_iter (cdr list1) (list (list (car list1)))))\n          ((equal? (caar result) (car list1)) (pack_consecutive_duplicates_iter (cdr list1) (cons (cons (car list1) (car result)) (cdr result))))\n          (else (pack_consecutive_duplicates_iter (cdr list1) (cons (list (car list1)) result)))))\n  (reverse (pack_consecutive_duplicates_iter list1 '())))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (cons (list (first list1))\n           (pack_consecutive_duplicates (filter (lambda (x) (not (= x (first list1)))) (rest list1))))]))\n",
    "  (cond\n    [(empty? list1) empty]\n    [(empty? (rest list1)) (list (list (first list1)))]\n    [else\n     (let* ([first-element (first list1)]\n            [rest-of-list (rest list1)]\n            [first-element-of-rest (first rest-of-list)]\n            [rest-of-rest-of-list (rest rest-of-list)])\n       (if (equal? first-element first-element-of-rest)\n           (cons (cons first-element (pack_consecutive_duplicates rest-of-list))\n                 (pack_consecutive_duplicates rest-of-rest-of-list))\n           (cons (list first-element)\n                 (pack_consecutive_duplicates rest-of-list))))]))\n",
    "  (define (pack_consecutive_duplicates_helper list1 result)\n    (cond\n      [(empty? list1) result]\n      [(empty? result) (pack_consecutive_duplicates_helper (rest list1) (list (list (first list1))))]\n      [(equal? (first (first result)) (first list1)) (pack_consecutive_duplicates_helper (rest list1) (cons (cons (first list1) (first result)) (rest result)))]\n      [else (pack_consecutive_duplicates_helper (rest list1) (cons (list (first list1)) result))]))\n  (reverse (pack_consecutive_duplicates_helper list1 '())))\n",
    "  (cond\n    [(empty? list1) empty]\n    [else\n     (cons (list (first list1))\n           (pack_consecutive_duplicates (rest list1)))]))\n"
  ]
}