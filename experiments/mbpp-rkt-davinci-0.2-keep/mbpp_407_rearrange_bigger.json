{
  "name": "mbpp_407_rearrange_bigger",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Write a function to create the next bigger number by rearranging the digits of a given number.\n(define (rearrange_bigger n)\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_407_rearrange_bigger.py",
  "prompt_terminology": "verbatim",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate rearrange_bigger))\n    (check-equal? (candidate 12) 21)\n    (check-equal? (candidate 10) #f)\n    (check-equal? (candidate 102) 120)\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (define (rearrange_bigger-helper n)\n    (define (rearrange-helper n)\n      (define (rearrange-helper-helper n)\n        (define (rearrange-helper-helper-helper n)\n          (define (rearrange-helper-helper-helper-helper n)\n            (define (rearrange-helper-helper-helper-helper-helper n)\n              (define (rearrange-helper-helper-helper-helper-helper-helper n)\n                (define (rearrange-helper-helper-helper-helper-helper-helper-helper n)\n                  (define (rearrange-helper-helper-helper-helper-helper-helper-helper-helper n)\n                    (define (rearrange-helper-helper-helper-helper-helper-helper-helper-helper-helper n)\n                      (define (rearrange-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper n)\n                        (define (rearrange-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper n)\n                          (define (rearrange-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper n)\n                            (define (rearrange-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper n)\n                              (define (rearrange-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper n)\n                                (define (rearrange-helper-helper-helper-helper-helper-helper-helper-helper-helper-hel",
    "  (define (rearrange-bigger-helper n i)\n    (if (= i (- (string-length n) 1))\n        (string-append n (string-append (string-ref n 0) (string-ref n 1)))\n        (if (&gt; (string-ref n i) (string-ref n (+ i 1)))\n            (string-append (substring n 0 i) (string-append (string-ref n (+ i 1)) (string-ref n i)) (substring n (+ i 2) (string-length n)))\n            (rearrange-bigger-helper n (+ i 1)))))\n  (rearrange-bigger-helper n 0))\n",
    "  (define (rearrange-bigger-helper n)\n    (define (rearrange-bigger-helper-helper n)\n      (define (rearrange-bigger-helper-helper-helper n)\n        (define (rearrange-bigger-helper-helper-helper-helper n)\n          (define (rearrange-bigger-helper-helper-helper-helper-helper n)\n            (define (rearrange-bigger-helper-helper-helper-helper-helper-helper n)\n              (define (rearrange-bigger-helper-helper-helper-helper-helper-helper-helper n)\n                (define (rearrange-bigger-helper-helper-helper-helper-helper-helper-helper-helper n)\n                  (define (rearrange-bigger-helper-helper-helper-helper-helper-helper-helper-helper-helper n)\n                    (define (rearrange-bigger-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper n)\n                      (define (rearrange-bigger-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper n)\n                        (define (rearrange-bigger-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper n)\n                          (define (rearrange-bigger-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper n)\n                            (define (rearrange-bigger-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper n)\n                              (define (rearrange-bigger-",
    "  (define (rearrange_bigger_helper n i)\n    (if (= i (- (string-length n) 1))\n        n\n        (let* ([n (string->number n)]\n               [n-i (string-ref n i)]\n               [n-i+1 (string-ref n (+ i 1))])\n          (if (> n-i n-i+1)\n              (let* ([n-i (number->string n-i)]\n                     [n-i+1 (number->string n-i+1)]\n                     [n (string-append (substring n 0 i) n-i+1 (substring n (+ i 1) (string-length n)) n-i)])\n                (rearrange_bigger_helper n (+ i 1)))\n              (rearrange_bigger_helper n (+ i 1))))))\n  (rearrange_bigger_helper (number->string n) 0))\n",
    "  (define (rearrange-bigger-helper n)\n    (if (zero? n)\n        (list)\n        (cons (modulo n 10) (rearrange-bigger-helper (quotient n 10)))))\n  (define (rearrange-bigger-helper2 n)\n    (if (zero? n)\n        (list)\n        (cons (modulo n 10) (rearrange-bigger-helper2 (quotient n 10)))))\n  (define (rearrange-bigger-helper3 n)\n    (if (zero? n)\n        (list)\n        (cons (modulo n 10) (rearrange-bigger-helper3 (quotient n 10)))))\n  (define (rearrange-bigger-helper4 n)\n    (if (zero? n)\n        (list)\n        (cons (modulo n 10) (rearrange-bigger-helper4 (quotient n 10)))))\n  (define (rearrange-bigger-helper5 n)\n    (if (zero? n)\n        (list)\n        (cons (modulo n 10) (rearrange-bigger-helper5 (quotient n 10)))))\n  (define (rearrange-bigger-helper6 n)\n    (if (zero? n)\n        (list)\n        (cons (modulo n 10) (rearrange-bigger-helper6 (quotient n 10)))))\n  (define (rearrange-bigger-helper7 n)\n    (if (zero? n)\n        (list)\n        (cons (modulo n 10) (rearrange-bigger-helper7 (quotient n 10)))))\n  (define (rearrange-bigger-helper8 n)\n    (if (zero? n)\n        (list)\n        (cons (modulo n 10) (rearrange-bigger-helper8 (quotient n 10)))))\n  (define (rearrange-bigger-helper9 n)\n    (if (zero? n)\n        (list)\n        (",
    "  (define (rearrange_bigger_helper n)\n    (if (null? (cdr n))\n        #f\n        (if (< (car n) (cadr n))\n            (cons (cadr n) (cons (car n) (cddr n)))\n            (cons (car n) (rearrange_bigger_helper (cdr n))))))\n  (if (rearrange_bigger_helper n)\n      (rearrange_bigger_helper n)\n      #f))\n",
    "  (let ([digits (string->list (number->string n))])\n    (let ([i (find-index (lambda (x) (< x (cadr x))) (rest digits))])\n      (if i\n          (let ([j (find-index (lambda (x) (> x (cadr x))) (drop (add1 i) digits))])\n            (if j\n                (let ([j (sub1 j)])\n                  (let ([tmp (list-ref digits j)])\n                    (set-list-ref! digits j (cadr digits))\n                    (set-list-ref! digits (add1 i) tmp))\n                  (let ([sub-digits (sort (drop (add1 i) digits) <)])\n                    (for ([i (in-range (add1 i) (length digits))])\n                      (set-list-ref! digits i (list-ref sub-digits (sub1 i))))\n                    (string->number (list->string digits))))\n                (let ([sub-digits (sort (drop (add1 i) digits) <)])\n                  (for ([i (in-range (add1 i) (length digits))])\n                    (set-list-ref! digits i (list-ref sub-digits (sub1 i))))\n                  (string->number (list->string digits)))))\n          #f))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (let ([i (find-first-decreasing-digit digits)])\n      (if (not i)\n          n\n          (let ([j (find-first-larger-digit digits i)])\n            (let ([digits (swap-digits digits i j)])\n              (let ([digits (reverse-digits digits i)])\n                (string->number (list->string digits)))))))))\n",
    "  (define (rearrange_bigger_helper n)\n    (let ([d (string->list (number->string n))])\n      (let loop ([i (sub1 (length d))])\n        (if (= i 0)\n            (list #f #f)\n            (let ([j (sub1 i)])\n              (if (and (< (list-ref d i) (list-ref d j))\n                       (not (zero? (modulo i 2))))\n                  (list i j)\n                  (loop j)))))))\n  (let ([i (rearrange_bigger_helper n)])\n    (if (first i)\n        (let ([d (string->list (number->string n))])\n          (let ([t (list-ref d (first i))])\n            (set-car! (list-ref d (first i)) (list-ref d (second i)))\n            (set-car! (list-ref d (second i)) t)\n            (string->number (list->string (sort d <)))))\n        #f)))\n",
    "  (define (rearrange_bigger_helper n i)\n    (if (= i (- (string-length n) 1))\n        n\n        (let* ([n-i (string-ref n i)]\n               [n-i+1 (string-ref n (+ i 1))])\n          (if (&gt; n-i n-i+1)\n              (let* ([n-i+1-i (string-ref n (+ i 1) i)]\n                     [n-i-i+1 (string-ref n i (+ i 1))])\n                (string-set! n i n-i+1-i)\n                (string-set! n (+ i 1) n-i-i+1)\n                (rearrange_bigger_helper n (+ i 2)))\n              (rearrange_bigger_helper n (+ i 1))))))\n  (rearrange_bigger_helper (number-&gt;string n) 0))\n</code>\nThe code above is not working. I am not sure what is wrong with it. I am getting the following error:\n<code>rearrange_bigger.rkt:14:2: string-set!: expects type &lt;string-index&gt; as 1st argument, given: #&lt;syntax:rearrange_bigger.rkt:14:2&gt;; other arguments were: #&lt;syntax:rearrange_bigger.rkt:14:2&gt;\n</code>\nI am not sure what is wrong with the code. I am trying to swap the digits of the number.\n\n\nA:\n\nYou're using <code>string-set!</code> incorrectly. The first argument is the index of the character to replace, and the second argument is the new character.\n<code>(string-set! n i n-i+1-i)\n</code>\nshould be\n<code>(string-set! n i (string-ref n (+ i 1)))\n</code>\nand\n<code>(string-set! n (+ i 1) n-i-i+1)\n</code>\nshould be\n<code>(string-set! n (+ i 1) (string-ref n i))\n",
    "  (define (rearrange_bigger_helper n i)\n    (if (= i (sub1 (string-length n)))\n        #f\n        (let ((next-i (add1 i)))\n          (if (string<? (string-ref n next-i) (string-ref n i))\n              (rearrange_bigger_helper n next-i)\n              (let ((next-bigger (string-append (substring n 0 i)\n                                                (string-append (string-append (string-ref n next-i) (string-ref n i))\n                                                               (substring n (add1 i))))))\n                (if (string<? next-bigger n)\n                    (rearrange_bigger_helper n next-i)\n                    next-bigger))))))\n  (rearrange_bigger_helper (number->string n) 0))\n",
    "  (define (rearrange_bigger_helper n i)\n    (cond [(zero? i) n]\n          [(< (modulo n (expt 10 i)) (modulo n (expt 10 (- i 1))))\n           (rearrange_bigger_helper n (- i 1))]\n          [else (rearrange_bigger_helper (modulo (+ n (expt 10 (- i 1))) (expt 10 i)) (- i 1))]))\n  (rearrange_bigger_helper n (number->string n)))\n",
    "  (define (rearrange_bigger_iter n i)\n    (if (= i 0)\n        n\n        (let* ([n-str (number->string n)]\n               [n-str-len (string-length n-str)]\n               [i-str (number->string i)]\n               [i-str-len (string-length i-str)]\n               [n-str-i (substring n-str (- n-str-len i-str-len) n-str-len)]\n               [n-str-i-num (string->number n-str-i)])\n          (if (and (= i-str-len n-str-len)\n                   (= i n-str-i-num))\n              (rearrange_bigger_iter n (- i 1))\n              (let* ([n-str-i-num-1 (- n-str-i-num 1)]\n                     [n-str-i-num-1-str (number->string n-str-i-num-1)]\n                     [n-str-i-num-1-str-len (string-length n-str-i-num-1-str)]\n                     [n-str-i-num-1-str-padded (string-pad-right n-str-i-num-1-str (- i-str-len n-str-i-num-1-str-len) #\\0)]\n                     [n-str-i-num-1-str-padded-num (string->number n-str-i-num-1-str-padded)]\n                     [n-str-i-num-1-str-padded-num-str (number->string n-str-i-num-1-str-padded-num)]\n                     [n-str-i-num-1-str-padded-num-str-len (string-length n-str-i-num-1-str-padded-num-str)]\n                     [n-str-i-num-1-str-padded-num-str-padded (string-pad-right n-str-i-num-1-str-padded-num-str (- n-str-len n-str-",
    "  (define (rearrange_bigger_helper n i)\n    (if (= i 0)\n        (list n)\n        (let* ([n-i (modulo n (expt 10 i))]\n               [n-i-1 (modulo n (expt 10 (- i 1)))])\n          (if (< n-i-1 n-i)\n              (let* ([n-i-1-1 (quotient n-i-1 10)]\n                     [n-i-1-2 (modulo n-i-1 10)]\n                     [n-i-1-3 (modulo n-i-1-1 10)]\n                     [n-i-1-4 (quotient n-i-1-1 10)]\n                     [n-i-1-5 (modulo n-i-1-4 10)]\n                     [n-i-1-6 (quotient n-i-1-4 10)]\n                     [n-i-1-7 (modulo n-i-1-6 10)]\n                     [n-i-1-8 (quotient n-i-1-6 10)]\n                     [n-i-1-9 (modulo n-i-1-8 10)]\n                     [n-i-1-10 (quotient n-i-1-8 10)])\n                (cond\n                 [(= i 1) (list (+ n-i-1-1 n-i-1-2))]\n                 [(= i 2) (list (+ n-i-1-1 n-i-1-3)\n                                (+ n-i-1-2 n-i-1-3))]\n                 [(= i 3) (list (+ n-i-1-1 n-i-1-4)\n                                (+ n-i-1-2 n-i-1-4)\n                                (+ n-i-1-3 n-i-1-4))]\n                 [(= i 4) (list (+ n-i-1-1 n-i-1-5)\n                                (+ n-i-1-2 n-i-1-5)\n                                (+ n-i-1-3 n-i-1-5",
    "  (define (rearrange-bigger-helper n i)\n    (cond\n      [(= i (- (string-length n) 1)) #f]\n      [(> (string-ref n i) (string-ref n (+ i 1)))\n       (rearrange-bigger-helper (string-append (substring n 0 i)\n                                               (substring n (+ i 1) (- (string-length n) 1))\n                                               (string-append (string-ref n i)\n                                                              (substring n (- (string-length n) 1))))\n                                 i)]\n      [else (rearrange-bigger-helper n (+ i 1))]))\n  (rearrange-bigger-helper n 0))\n",
    "  (define (rearrange_bigger_helper n i)\n    (if (= i (sub1 (string-length n)))\n        (string-append n)\n        (let* ([n-i (string-ref n i)]\n               [n-i+1 (string-ref n (add1 i))]\n               [n-i+2 (string-ref n (add1 (add1 i)))]\n               [n-i+3 (string-ref n (add1 (add1 (add1 i))))])\n          (if (and (char=? n-i+1 #\\0) (char=? n-i+2 #\\0) (char=? n-i+3 #\\0))\n              (rearrange_bigger_helper n (add1 i))\n              (let ([new-n (string-append (substring n 0 i)\n                                          (string n-i+1)\n                                          (string n-i)\n                                          (substring n (add1 (add1 i))))])\n                (if (string<? new-n n)\n                    (rearrange_bigger_helper n (add1 i))\n                    new-n))))))\n  (rearrange_bigger_helper (number->string n) 0))\n",
    "  (define (rearrange_bigger-helper n i)\n    (if (= i 0)\n        (list n)\n        (let* ([d (modulo n (expt 10 i))]\n               [n (quotient n (expt 10 i))])\n          (if (and (not (zero? n))\n                   (< d (modulo n (expt 10 i))))\n              (cons (modulo n (expt 10 i))\n                    (cons d (rearrange_bigger-helper (quotient n (expt 10 i)) (- i 1))))\n              (rearrange_bigger-helper n (- i 1))))))\n  (if (zero? n)\n      n\n      (rearrange_bigger-helper n (exact-floor (log10 n)))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (let ([i (find-index (\u03bb (x) (&lt; x (cadr x))) digits)])\n      (if i\n          (let ([j (find-index (\u03bb (x) (&gt; x (cadr x))) (reverse (drop (add1 i) digits)))]\n                [k (add1 i)])\n            (if j\n                (let ([l (add1 (sub1 (length digits)))])\n                  (list-&gt;number (append (take k digits)\n                                         (list (list-ref digits (add k j)))\n                                         (list (list-ref digits k))\n                                         (sort (drop (add k (add1 j)) digits)))))\n                (list-&gt;number (append (take k digits)\n                                       (sort (drop k digits))))))\n          (list-&gt;number (sort digits))))))\n",
    "  (define (rearrange_bigger_helper n i)\n    (if (= i (sub1 (string-length n)))\n        #f\n        (let ((next-digit (string-ref n (add1 i))))\n          (if (&gt; (string-ref n i) next-digit)\n              (string-append (substring n 0 i)\n                             next-digit\n                             (substring n (add1 i) (string-length n))\n                             (string-ref n i))\n              (rearrange_bigger_helper n (add1 i))))))\n  (rearrange_bigger_helper n 0))\n",
    "  (let loop ([n n] [i 0])\n    (cond [(< n 10) #f]\n          [(< (modulo n 10) (modulo (quotient n 10) 10))\n           (let ([j (quotient n 10)])\n             (loop j (+ i 1)))]\n          [else\n           (let ([j (quotient n 10)])\n             (loop j (+ i 1)))])))\n"
  ]
}