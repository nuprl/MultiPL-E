{
  "name": "mbpp_438_count_bidirectional",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Write a function to count bidirectional tuple pairs.\n(define (count_bidirectional test_list)\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_438_count_bidirectional.py",
  "prompt_terminology": "verbatim",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate count_bidirectional))\n    (check-equal? (candidate (list (list 5 6) (list 1 2) (list 6 5) (list 9 1) (list 6 5) (list 2 1))) 3)\n    (check-equal? (candidate (list (list 5 6) (list 1 3) (list 6 5) (list 9 1) (list 6 5) (list 2 1))) 2)\n    (check-equal? (candidate (list (list 5 6) (list 1 2) (list 6 5) (list 9 2) (list 6 5) (list 2 1))) 4)\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (define (count_bidirectional_helper test_list count)\n    (cond\n      [(null? test_list) count]\n      [(member (cdr (car test_list)) (map car test_list))\n       (count_bidirectional_helper (cdr test_list) (+ count 1))]\n      [else (count_bidirectional_helper (cdr test_list) count)]))\n  (count_bidirectional_helper test_list 0))\n",
    "  (define (count_bidirectional_helper test_list count)\n    (cond\n      [(empty? test_list) count]\n      [else\n       (define (is_bidirectional? test_list)\n         (cond\n           [(empty? test_list) #f]\n           [(equal? (first test_list) (second test_list)) #t]\n           [else (is_bidirectional? (rest test_list))]))\n       (cond\n         [(is_bidirectional? test_list) (count_bidirectional_helper (rest test_list) (+ count 1))]\n         [else (count_bidirectional_helper (rest test_list) count)])]))\n  (count_bidirectional_helper test_list 0))\n",
    "  (define (count_bidirectional_iter test_list count)\n    (cond [(empty? test_list) count]\n          [(member (car test_list) (cdr test_list))\n           (count_bidirectional_iter (cdr test_list) (+ count 1))]\n          [else (count_bidirectional_iter (cdr test_list) count)]))\n  (count_bidirectional_iter test_list 0))\n",
    "  (define (count_bidirectional_helper test_list count)\n    (if (null? test_list)\n        count\n        (if (member (cdr (car test_list)) (map car test_list))\n            (count_bidirectional_helper (cdr test_list) (+ count 1))\n            (count_bidirectional_helper (cdr test_list) count))))\n  (count_bidirectional_helper test_list 0))\n",
    "  (cond\n    [(empty? test_list) 0]\n    [else\n     (let ([first (first test_list)]\n           [rest (rest test_list)])\n       (+ (count_bidirectional rest)\n          (count_bidirectional (filter (lambda (x) (test first x)) rest))))]))\n",
    "  (length (filter (lambda (x) (member x test_list)) test_list)))\n",
    "  (define (count_bidirectional_helper test_list count)\n    (cond\n      [(empty? test_list) count]\n      [(member (first test_list) (rest test_list))\n       (count_bidirectional_helper (rest test_list) (+ count 1))]\n      [else (count_bidirectional_helper (rest test_list) count)]))\n  (count_bidirectional_helper test_list 0))\n",
    "  (letrec ([count (lambda (test_list)\n                    (cond [(empty? test_list) 0]\n                          [(empty? (rest test_list)) 0]\n                          [else (+ (count (rest test_list))\n                                   (count (rest (rest test_list)))\n                                   (if (test (first test_list) (second test_list))\n                                       1\n                                       0))]))])\n    (count test_list)))\n",
    "  (let loop ([test_list test_list] [count 0])\n    (cond\n      [(empty? test_list) count]\n      [(member (first test_list) (rest test_list))\n       (loop (rest test_list) (+ count 1))]\n      [else (loop (rest test_list) count)])))\n",
    "  (define (count_bidirectional_helper test_list count)\n    (if (null? test_list)\n        count\n        (if (member (list (car test_list) (cadr test_list)) (cddr test_list))\n            (count_bidirectional_helper (cddr test_list) (+ count 1))\n            (count_bidirectional_helper (cddr test_list) count))))\n  (count_bidirectional_helper test_list 0))\n",
    "  (define (count_bidirectional_helper test_list counter)\n    (cond ((null? test_list) counter)\n          ((member (reverse (car test_list)) (cdr test_list))\n           (count_bidirectional_helper (cdr test_list) (+ counter 1)))\n          (else (count_bidirectional_helper (cdr test_list) counter))))\n  (count_bidirectional_helper test_list 0))\n",
    "  (define (count_bidirectional_helper test_list count)\n    (cond ((null? test_list) count)\n          ((and (member (car test_list) (cdr test_list))\n                (member (cadr test_list) (cddr test_list)))\n           (count_bidirectional_helper (cddr test_list) (+ count 1)))\n          (else (count_bidirectional_helper (cdr test_list) count))))\n  (count_bidirectional_helper test_list 0))\n",
    "  (let loop ([test_list test_list]\n             [count 0])\n    (cond [(null? test_list) count]\n          [(and (pair? (car test_list))\n                (pair? (cdr test_list))\n                (equal? (car (car test_list)) (cdr (cdr (car test_list))))\n                (equal? (cdr (car test_list)) (car (cdr (car test_list)))))\n           (loop (cdr test_list) (+ count 1))]\n          [else (loop (cdr test_list) count)])))\n",
    "  (define (count_bidirectional_helper test_list count)\n    (cond [(empty? test_list) count]\n          [(member (first test_list) (rest test_list))\n           (count_bidirectional_helper (rest test_list) (+ count 1))]\n          [else (count_bidirectional_helper (rest test_list) count)]))\n  (count_bidirectional_helper test_list 0))\n",
    "  (define (count_bidirectional_helper test_list count)\n    (cond\n      [(empty? test_list) count]\n      [else\n       (define first_pair (first test_list))\n       (define first_pair_reverse (reverse first_pair))\n       (define rest_of_list (rest test_list))\n       (cond\n         [(member first_pair_reverse rest_of_list)\n          (count_bidirectional_helper rest_of_list (+ count 1))]\n         [else\n          (count_bidirectional_helper rest_of_list count)])]))\n  (count_bidirectional_helper test_list 0))\n",
    "  (let loop ([test_list test_list]\n             [count 0])\n    (cond [(empty? test_list) count]\n          [(and (member (first test_list) (rest test_list))\n                (member (rest test_list) (first test_list)))\n           (loop (rest test_list) (+ count 1))]\n          [else (loop (rest test_list) count)])))\n",
    "  (let loop ([test_list test_list] [count 0])\n    (cond [(empty? test_list) count]\n          [else (let ([first (first test_list)])\n                  (loop (rest test_list)\n                        (+ count (count_bidirectional_helper first (rest test_list)))))])))\n",
    "  (length (filter (lambda (x) (member (reverse x) test_list)) test_list)))\n",
    "  (define (count_bidirectional_helper test_list count)\n    (cond\n      [(empty? test_list) count]\n      [(member (first test_list) (rest test_list))\n       (count_bidirectional_helper (rest test_list) (+ count 1))]\n      [else (count_bidirectional_helper (rest test_list) count)]))\n  (count_bidirectional_helper test_list 0))\n",
    "  (let loop ([test_list test_list] [count 0])\n    (cond\n      [(null? test_list) count]\n      [(and (member (car test_list) (cdr test_list))\n            (member (cadr test_list) (cddr test_list)))\n       (loop (cddr test_list) (+ count 1))]\n      [else (loop (cdr test_list) count)])))\n"
  ]
}