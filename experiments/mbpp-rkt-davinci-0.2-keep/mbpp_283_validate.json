{
  "name": "mbpp_283_validate",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Write a python function takes in an integer and check whether the frequency of each digit in the integer is less than or equal to the digit itself.\n(define (validate n)\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_283_validate.py",
  "prompt_terminology": "verbatim",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate validate))\n    (check-equal? (candidate 1234) #t)\n    (check-equal? (candidate 51241) #f)\n    (check-equal? (candidate 321) #t)\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (define (validate-helper n)\n    (if (zero? n)\n        '()\n        (cons (remainder n 10) (validate-helper (quotient n 10)))))\n  (define (count-helper lst)\n    (if (null? lst)\n        '()\n        (cons (length (filter (lambda (x) (= x (car lst))) lst)) (count-helper (cdr lst)))))\n  (define (check-helper lst1 lst2)\n    (if (null? lst1)\n        #t\n        (if (&lt;= (car lst1) (car lst2))\n            (check-helper (cdr lst1) (cdr lst2))\n            #f)))\n  (check-helper (validate-helper n) (count-helper (validate-helper n))))\n</code>\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([digit (in-list digits)]\n              [count (in-list (map (\u03bb (d) (count d digits)) digits))])\n      (<= count digit))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (define (count-digits n)\n    (cond\n      [(zero? n) 0]\n      [else (+ 1 (count-digits (quotient n 10)))]))\n  (define (count-digit-freq n d)\n    (cond\n      [(zero? n) 0]\n      [(= (remainder n 10) d) (+ 1 (count-digit-freq (quotient n 10) d))]\n      [else (count-digit-freq (quotient n 10) d)]))\n  (define (validate-helper n)\n    (cond\n      [(zero? n) #t]\n      [(>= (count-digit-freq n (remainder n 10)) (remainder n 10)) (validate-helper (quotient n 10))]\n      [else #f]))\n  (validate-helper n))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([digit (in-list digits)]\n              [count (in-list (map (\u03bb (d) (count d digits)) digits))])\n      (<= count digit))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([digit (in-list digits)]\n              [count (in-list (map (\u03bb (d) (count d digits)) digits))])\n      (<= count digit))))\n",
    "  (define (validate-helper n)\n    (if (zero? n)\n        (list 0 0 0 0 0 0 0 0 0 0)\n        (let ([d (modulo n 10)])\n          (cons d (validate-helper (quotient n 10))))))\n  (let ([l (validate-helper n)])\n    (for/and ([i (in-range 10)])\n      (<= (list-ref l i) i))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([digit (in-list digits)]\n              [count (in-list (map (\u03bb (d) (count d digits)) digits))])\n      (<= count digit))))\n",
    "  (define (count-digit n d)\n    (if (= n 0)\n        0\n        (+ (if (= (remainder n 10) d) 1 0)\n           (count-digit (quotient n 10) d))))\n  (define (helper n)\n    (if (= n 0)\n        #t\n        (and (<= (count-digit n (remainder n 10)) (remainder n 10))\n             (helper (quotient n 10)))))\n  (helper n))\n",
    "  (let loop ([n n] [digits '()])\n    (if (zero? n)\n        (let loop ([digits digits] [freq '()])\n          (if (null? digits)\n              (let loop ([freq freq] [valid #t])\n                (if (null? freq)\n                    valid\n                    (if (<= (car freq) (cadr freq))\n                        (loop (cddr freq) valid)\n                        (loop (cddr freq) #f))))\n              (loop (cdr digits) (cons (length (filter (lambda (x) (= x (car digits))) digits)) freq))))\n        (loop (quotient n 10) (cons (remainder n 10) digits))))))\n",
    "  (define (validate-helper n)\n    (cond [(zero? n) '()]\n          [else (cons (remainder n 10) (validate-helper (quotient n 10)))]))\n  (define (count-digit lst digit)\n    (cond [(empty? lst) 0]\n          [(= (first lst) digit) (+ 1 (count-digit (rest lst) digit))]\n          [else (count-digit (rest lst) digit)]))\n  (define (validate-all lst)\n    (cond [(empty? lst) #t]\n          [(<= (count-digit lst (first lst)) (first lst)) (validate-all (rest lst))]\n          [else #f]))\n  (validate-all (validate-helper n)))\n",
    "  (define (count-digit n d)\n    (cond [(zero? n) 0]\n          [(= (remainder n 10) d) (+ 1 (count-digit (quotient n 10) d))]\n          [else (count-digit (quotient n 10) d)]))\n  (define (helper n)\n    (cond [(zero? n) #t]\n          [(>= (count-digit n (remainder n 10)) (remainder n 10)) #f]\n          [else (helper (quotient n 10))]))\n  (helper n))\n",
    "  (let loop ([n n] [digits '()])\n    (cond [(zero? n) (for/and ([d (in-list digits)])\n                              (<= (count d digits) d))]\n          [else (loop (quotient n 10) (cons (remainder n 10) digits))])))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)]\n              [f (in-list (map (\u03bb (d) (count d digits)) digits))])\n      (<= f d))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (define (count-digit n d)\n    (cond\n      [(zero? n) 0]\n      [(= (remainder n 10) d) (+ 1 (count-digit (quotient n 10) d))]\n      [else (count-digit (quotient n 10) d)]))\n  (define (validate-helper n)\n    (cond\n      [(zero? n) #t]\n      [(<= (count-digit n (remainder n 10)) (remainder n 10)) (validate-helper (quotient n 10))]\n      [else #f]))\n  (validate-helper n))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)]\n              [f (in-list (map (\u03bb (x) (count x digits)) digits))])\n      (<= f d))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([s (number->string n)])\n    (for/and ([d (in-range 10)]\n              [f (in-range (string-length s))])\n      (let ([c (string-ref s f)])\n        (and (<= d (string->number c))\n             (<= (count c s) d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)]\n              [c (in-list (count-list digits d))])\n      (<= c d))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)]\n              [f (in-list (map (\u03bb (x) (count x digits)) digits))])\n      (<= f d))))\n",
    "  (let ([str (number->string n)])\n    (for/and ([d (in-list (string->list str))])\n      (<= (count (string->list str) d) (string->number (string d))))))\n",
    "  (define (validate-helper n)\n    (if (zero? n)\n        '()\n        (cons (remainder n 10) (validate-helper (quotient n 10)))))\n  (define (count-helper lst)\n    (if (null? lst)\n        '()\n        (cons (count (lambda (x) (equal? x (car lst))) lst) (count-helper (cdr lst)))))\n  (define (validate-helper2 lst1 lst2)\n    (if (null? lst1)\n        #t\n        (if (&lt;= (car lst1) (car lst2))\n            (validate-helper2 (cdr lst1) (cdr lst2))\n            #f)))\n  (validate-helper2 (validate-helper n) (count-helper (validate-helper n))))\n</code>\nI'm not sure if this is the most efficient way to do it, but it works.\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([digit (in-list digits)]\n              [count (in-list (map (\u03bb (d) (count d digits)) digits))])\n      (<= count digit))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (let loop ([digits digits] [freq (make-hash)])\n      (cond [(empty? digits)\n             (for/and ([(k v) (in-hash freq)])\n               (<= v (string->number (symbol->string k))))]\n            [else\n             (let ([d (car digits)])\n               (hash-update! freq d add1 0)\n               (loop (cdr digits) freq))]))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)]\n              [f (in-list (map (\u03bb (x) (count x digits)) digits))])\n      (<= f d))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)]\n              [f (in-list (map (\u03bb (x) (count x digits)) digits))])\n      (<= f d))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (define (validate-helper n)\n    (if (zero? n)\n        '()\n        (cons (remainder n 10) (validate-helper (quotient n 10)))))\n  (define (count-digit n lst)\n    (if (null? lst)\n        0\n        (if (= n (car lst))\n            (+ 1 (count-digit n (cdr lst)))\n            (count-digit n (cdr lst)))))\n  (define (validate-all lst)\n    (if (null? lst)\n        #t\n        (if (<= (count-digit (car lst) lst) (car lst))\n            (validate-all (cdr lst))\n            #f)))\n  (validate-all (validate-helper n)))\n",
    "  (let ((freq (make-hash)))\n    (for/and ([d (in-string (number->string n))])\n      (hash-update! freq d add1 0)\n      (<= (hash-ref freq d 0) (string->number d)))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)]\n              [f (in-list (map (\u03bb (d) (count d digits)) digits))])\n      (<= f d))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)]\n              [f (in-list (map (\u03bb (x) (count (\u03bb (y) (=? x y)) digits)) digits))])\n      (<= f d))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)]\n              [f (in-list (map (\u03bb (x) (count x digits)) digits))])\n      (<= f d))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)]\n              [f (in-list (map (lambda (x) (count x digits)) digits))])\n      (<= f d))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([s (number->string n)])\n    (for/and ([c (in-string s)]\n              [i (in-range (string-length s))])\n      (let ([count (for/sum ([j (in-range (string-length s))])\n                     (if (= c (string-ref s j)) 1 0))])\n        (<= count (string->number (string c)))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)]\n              #:when (not (equal? (count d digits) d)))\n      #f)))\n",
    "  (let loop ([n n] [freq (make-hash)])\n    (cond\n      [(zero? n) (for/and ([(k v) (in-hash freq)])\n                     (<= v k))]\n      [else (let ([d (remainder n 10)])\n              (hash-set! freq d (add1 (hash-ref freq d 0)))\n              (loop (quotient n 10) freq))])))\n",
    "  (define (validate-helper n)\n    (if (zero? n)\n        #t\n        (let* ([d (remainder n 10)]\n               [f (frequency n d)]\n               [r (validate-helper (quotient n 10))])\n          (and (or (= d f) (&lt; d f)) r))))\n  (validate-helper (abs n)))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (let loop ([ds digits])\n      (cond\n        [(empty? ds) #t]\n        [(<= (count (first ds) digits) (string->number (number->string (first ds))))\n         (loop (rest ds))]\n        [else #f]))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (let loop ([digits digits] [freq (make-hash)])\n      (cond [(empty? digits)\n             (for/and ([(k v) (in-hash freq)])\n               (<= v (string->number (symbol->string k))))]\n            [else\n             (let ([d (car digits)])\n               (hash-update! freq d add1 0)\n               (loop (cdr digits) freq))]))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([s (number->string n)]\n        [freq (make-hash)])\n    (for ([c (in-string s)])\n      (hash-update! freq c add1 0))\n    (for ([c (in-string s)])\n      (when (&gt; (hash-ref freq c 0) (string-&gt;number (string c)))\n        (return #f)))\n    #t))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)]\n              [f (in-list (map (\u03bb (x) (count x digits)) digits))])\n      (<= f d))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (define (validate-helper n freq)\n    (if (zero? n)\n        (if (zero? freq)\n            #t\n            #f)\n        (let* ([digit (modulo n 10)]\n               [new-freq (if (zero? freq)\n                             1\n                             (+ freq 1))])\n          (if (&lt;= new-freq digit)\n              (validate-helper (quotient n 10) new-freq)\n              #f))))\n  (validate-helper n 0))\n",
    "  (define (count-digit n d)\n    (if (zero? n)\n        0\n        (+ (if (= (remainder n 10) d) 1 0)\n           (count-digit (quotient n 10) d))))\n  (define (helper n)\n    (if (zero? n)\n        #t\n        (and (<= (count-digit n (remainder n 10)) (remainder n 10))\n             (helper (quotient n 10)))))\n  (helper n))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)]\n              [f (in-list (count-list digits d))])\n      (<= f d))))\n",
    "  (define (count-digit d n)\n    (if (zero? n)\n        0\n        (+ (if (= (remainder n 10) d) 1 0) (count-digit d (quotient n 10)))))\n  (define (check-digit d n)\n    (if (zero? n)\n        #t\n        (and (if (<= (count-digit d n) d) #t #f) (check-digit d (quotient n 10)))))\n  (check-digit 0 n))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (define (count-digit n d)\n    (cond\n      [(zero? n) 0]\n      [(= (remainder n 10) d) (+ 1 (count-digit (quotient n 10) d))]\n      [else (count-digit (quotient n 10) d)]))\n  (define (helper n)\n    (cond\n      [(zero? n) #t]\n      [(<= (count-digit n (remainder n 10)) (remainder n 10)) (helper (quotient n 10))]\n      [else #f]))\n  (helper n))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([s (number->string n)])\n    (for/and ([c (in-string s)])\n      (<= (count c s) (string->number c)))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (define (validate-helper n)\n    (if (zero? n)\n        '()\n        (cons (remainder n 10)\n              (validate-helper (quotient n 10)))))\n  (define (frequency lst)\n    (if (null? lst)\n        '()\n        (cons (list (car lst) (count (car lst) lst))\n              (frequency (remove (car lst) lst)))))\n  (define (check lst)\n    (if (null? lst)\n        #t\n        (if (&lt;= (cadr (car lst)) (car (car lst)))\n            (check (cdr lst))\n            #f)))\n  (check (frequency (validate-helper n))))\n</code>\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (define (count-digit n d)\n    (cond\n      [(zero? n) 0]\n      [(= (remainder n 10) d) (+ 1 (count-digit (quotient n 10) d))]\n      [else (count-digit (quotient n 10) d)]))\n  (define (helper n)\n    (cond\n      [(zero? n) #t]\n      [(<= (count-digit n (remainder n 10)) (remainder n 10)) (helper (quotient n 10))]\n      [else #f]))\n  (helper n))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (every (\u03bb (d)\n             (let ([count (count (\u03bb (x) (= x d)) digits)])\n               (<= count (string->number (char->string d)))))\n           digits)))\n",
    "  (define (validate-helper n freq)\n    (cond\n      [(zero? n) (not (zero? freq))]\n      [(= (remainder n 10) freq) (validate-helper (quotient n 10) freq)]\n      [else (validate-helper (quotient n 10) (+ freq 1))]))\n  (validate-helper n 0))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)]\n              [f (in-list (map (\u03bb (x) (count x digits)) digits))])\n      (<= f d))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (define (validate-helper n)\n    (if (zero? n)\n        '()\n        (cons (modulo n 10) (validate-helper (quotient n 10)))))\n  (define (count-helper lst)\n    (if (null? lst)\n        '()\n        (cons (list (car lst) (count (lambda (x) (= x (car lst))) lst)) (count-helper (cdr lst)))))\n  (define (check-helper lst)\n    (if (null? lst)\n        #t\n        (if (<= (car (cdr (car lst))) (car (car lst)))\n            (check-helper (cdr lst))\n            #f)))\n  (check-helper (count-helper (validate-helper n))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count (lambda (x) (=? x d)) digits) d))))\n",
    "  (let loop ((n n) (digits (list)))\n    (cond ((zero? n) (apply min digits))\n          (else (loop (quotient n 10) (cons (count (remainder n 10) digits) digits))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)]\n              [f (in-list (map (\u03bb (d) (count d digits)) digits))])\n      (<= f d))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)]\n              [f (in-list (map (\u03bb (x) (count x digits)) digits))])\n      (<= f d))))\n",
    "  (letrec ([digits (string->list (number->string n))]\n           [freq (for/fold ([freq (make-hash)]) ([d digits])\n                   (hash-update! freq d add1 0))])\n    (every? (lambda (d) (<= (hash-ref freq d 0) (string->number (number->string d)))) digits)))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)]\n              [f (in-list (map (\u03bb (x) (count x digits)) digits))])\n      (<= f d))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)]\n              [f (in-list (map (\u03bb (x) (count x digits)) digits))])\n      (<= f d))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([s (number->string n)])\n    (for/and ([d (in-range 10)])\n      (<= (count (string-contains s (number->string d)) s) d))))\n",
    "  (let loop ([n n] [digits '()])\n    (cond [(zero? n) (apply min digits)]\n          [else (loop (quotient n 10) (cons (remainder n 10) digits))])))\n",
    "  (define (count-digit n d)\n    (cond\n      [(zero? n) 0]\n      [(= (remainder n 10) d) (+ 1 (count-digit (quotient n 10) d))]\n      [else (count-digit (quotient n 10) d)]))\n  (define (helper n)\n    (cond\n      [(zero? n) #t]\n      [(<= (count-digit n (remainder n 10)) (remainder n 10)) (helper (quotient n 10))]\n      [else #f]))\n  (helper n))\n",
    "  (define (count-digit n d)\n    (cond\n      [(zero? n) 0]\n      [(= (remainder n 10) d) (+ 1 (count-digit (quotient n 10) d))]\n      [else (count-digit (quotient n 10) d)]))\n  (define (iter n)\n    (cond\n      [(zero? n) #t]\n      [(<= (count-digit n (remainder n 10)) (remainder n 10)) (iter (quotient n 10))]\n      [else #f]))\n  (iter n))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (let loop ([digits digits] [freq (make-hash)])\n      (cond [(empty? digits)\n             (for/and ([(d . f) (in-hash freq)])\n               (<= f (string->number (string d))))]\n            [else\n             (let ([d (first digits)])\n               (hash-update! freq d add1 0)\n               (loop (rest digits) freq))]))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)]\n              [f (in-list (map (lambda (x) (count x digits)) digits))])\n      (<= f d))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (let loop ([digits digits]\n               [valid? #t])\n      (cond [(empty? digits) valid?]\n            [else\n             (let ([digit (car digits)]\n                   [rest (cdr digits)])\n               (let ([freq (count digit digits)])\n                 (if (&gt; freq (string-&gt;number (number-&gt;string digit)))\n                     (loop rest #f)\n                     (loop rest valid?))))])\n      )))\n</code>\n",
    "  (if (zero? n)\n      #t\n      (let* ([d (remainder n 10)]\n             [f (frequency n d)]\n             [n (quotient n 10)])\n        (and (or (= f d) (= f 0))\n             (validate n)))))\n",
    "  (let ([n (string->number (number->string n))])\n    (for/and ([d (in-range 10)])\n      (<= (count (lambda (x) (= x d)) (number->list n)) d))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (define (validate-helper n)\n    (if (zero? n)\n        '()\n        (cons (remainder n 10) (validate-helper (quotient n 10)))))\n  (define (count-helper n lst)\n    (if (null? lst)\n        0\n        (if (= n (car lst))\n            (+ 1 (count-helper n (cdr lst)))\n            (count-helper n (cdr lst)))))\n  (define (validate-helper2 n lst)\n    (if (null? lst)\n        #t\n        (if (<= (count-helper (car lst) lst) (car lst))\n            (validate-helper2 n (cdr lst))\n            #f)))\n  (validate-helper2 n (validate-helper n)))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)]\n              [count (in-list (count-occurrences digits))])\n      (<= (car count) d))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (define (count-digit n d)\n    (if (= n 0) 0\n        (+ (if (= (remainder n 10) d) 1 0)\n           (count-digit (quotient n 10) d))))\n  (define (check-digit n d)\n    (if (= n 0) #t\n        (and (check-digit (quotient n 10) d)\n             (<= (count-digit n d) d))))\n  (check-digit n 9))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)]\n              [f (in-list (map (\u03bb (x) (count x digits)) digits))])\n      (<= f d))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let loop ([n n] [freq (make-hash)])\n    (if (zero? n)\n        (for/and ([(k v) (in-hash freq)])\n          (<= v k))\n        (loop (quotient n 10)\n              (hash-update! freq (remainder n 10) add1 0)))))\n",
    "  (let ([str (number->string n)])\n    (for/and ([d (in-list (string->list str))])\n      (<= (count (string->list str) d) (string->number (string d))))))\n",
    "  (define (count-digits n)\n    (cond [(zero? n) 0]\n          [else (+ 1 (count-digits (quotient n 10)))]))\n  (define (count-digit n d)\n    (cond [(zero? n) 0]\n          [(= (remainder n 10) d) (+ 1 (count-digit (quotient n 10) d))]\n          [else (count-digit (quotient n 10) d)]))\n  (define (validate-helper n d)\n    (cond [(zero? d) #t]\n          [(> (count-digit n d) d) #f]\n          [else (validate-helper n (- d 1))]))\n  (validate-helper n (count-digits n)))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (define (count-digit n d)\n    (if (= n 0)\n        0\n        (+ (if (= (remainder n 10) d) 1 0)\n           (count-digit (quotient n 10) d))))\n  (define (helper n)\n    (if (= n 0)\n        #t\n        (and (<= (count-digit n (remainder n 10)) (remainder n 10))\n             (helper (quotient n 10)))))\n  (helper n))\n",
    "  (define (count-digit n d)\n    (cond\n      [(zero? n) 0]\n      [(= (remainder n 10) d) (+ 1 (count-digit (quotient n 10) d))]\n      [else (count-digit (quotient n 10) d)]))\n  (define (validate-helper n)\n    (cond\n      [(zero? n) #t]\n      [(<= (count-digit n (remainder n 10)) (remainder n 10)) (validate-helper (quotient n 10))]\n      [else #f]))\n  (validate-helper n))\n",
    "  (let ([s (number->string n)])\n    (for/and ([c (in-string s)])\n      (<= (count c s) (string->number c)))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count (lambda (x) (equal? x d)) digits) (string->number (number->string d))))))\n",
    "  (define (validate-helper n)\n    (if (zero? n)\n        '()\n        (cons (remainder n 10) (validate-helper (quotient n 10)))))\n  (define (count-helper lst)\n    (if (null? lst)\n        '()\n        (cons (list (car lst) (count (car lst) lst)) (count-helper (cdr lst)))))\n  (define (count n lst)\n    (if (null? lst)\n        0\n        (if (= n (car lst))\n            (+ 1 (count n (cdr lst)))\n            (count n (cdr lst)))))\n  (define (check lst)\n    (if (null? lst)\n        #t\n        (if (<= (cadr (car lst)) (car (car lst)))\n            (check (cdr lst))\n            #f)))\n  (check (count-helper (validate-helper n))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (define (count-digit n d)\n    (if (zero? n)\n        0\n        (+ (if (= (remainder n 10) d) 1 0)\n           (count-digit (quotient n 10) d))))\n  (define (helper n)\n    (if (zero? n)\n        #t\n        (if (> (count-digit n (remainder n 10)) (remainder n 10))\n            #f\n            (helper (quotient n 10)))))\n  (helper n))\n",
    "  (let loop ([n n] [digits (list)] [freq (list)])\n    (cond [(zero? n) (andmap (lambda (d f) (<= f d)) digits freq)]\n          [else (loop (quotient n 10)\n                      (cons (remainder n 10) digits)\n                      (cons (count (remainder n 10) digits) freq))])))\n",
    "  (define (count-digit n d)\n    (if (zero? n)\n        0\n        (+ (if (= (remainder n 10) d) 1 0)\n           (count-digit (quotient n 10) d))))\n  (define (check-digit n d)\n    (if (zero? n)\n        #t\n        (and (if (<= (count-digit n d) d) #t #f)\n             (check-digit (quotient n 10) d))))\n  (check-digit n 9))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)]\n              [f (in-list (map (\u03bb (x) (count x digits)) digits))])\n      (<= f d))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let loop ([n n] [digits '()])\n    (cond\n      [(zero? n)\n       (let loop ([digits digits] [result #t])\n         (cond\n           [(empty? digits) result]\n           [else\n            (let ([d (first digits)]\n                  [f (count d digits)])\n              (if (&lt;= f d)\n                  (loop (remove d digits) result)\n                  (loop (remove d digits) #f)))]))]\n      [else\n       (loop (quotient n 10) (cons (remainder n 10) digits))])))\n",
    "  (define (helper n)\n    (cond [(zero? n) empty]\n          [else (cons (remainder n 10) (helper (quotient n 10)))]))\n  (define (check-freq lst)\n    (cond [(empty? lst) true]\n          [(<= (count (first lst) lst) (first lst)) (check-freq (rest lst))]\n          [else false]))\n  (check-freq (helper n)))\n",
    "  (let ([digits (string->list (number->string n))])\n    (let ([freq (map (lambda (x) (length (filter (lambda (y) (= x y)) digits))) digits)])\n      (andmap (lambda (x y) (<= x y)) digits freq))))\n",
    "  (define (count-digit n digit)\n    (cond\n      [(zero? n) 0]\n      [(= (remainder n 10) digit) (+ 1 (count-digit (quotient n 10) digit))]\n      [else (count-digit (quotient n 10) digit)]))\n  (define (helper n)\n    (cond\n      [(zero? n) #t]\n      [(<= (count-digit n (remainder n 10)) (remainder n 10)) (helper (quotient n 10))]\n      [else #f]))\n  (helper n))\n",
    "  (define (validate-helper n)\n    (if (= n 0)\n        '()\n        (cons (modulo n 10) (validate-helper (quotient n 10)))))\n  (define (count-digit n lst)\n    (if (null? lst)\n        0\n        (if (= n (car lst))\n            (+ 1 (count-digit n (cdr lst)))\n            (count-digit n (cdr lst)))))\n  (define (validate-helper2 lst)\n    (if (null? lst)\n        #t\n        (if (&lt;= (count-digit (car lst) lst) (car lst))\n            (validate-helper2 (cdr lst))\n            #f)))\n  (validate-helper2 (validate-helper n)))\n</code>\nI get the following error:\n<code>car: expects argument of type &lt;pair&gt;; given 0\n</code>\nI am not sure what is wrong with my code.\n\n\nA:\n\nThe problem is that you're calling <code>count-digit</code> with an empty list, which is causing the error.\n<code>(count-digit (car lst) lst)\n</code>\nYou should check for an empty list before calling <code>count-digit</code>.\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)]\n              [f (in-list (map (\u03bb (x) (count x digits)) digits))])\n      (<= f d))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (define (count-digit d n)\n    (cond\n      [(zero? n) 0]\n      [(= (remainder n 10) d) (+ 1 (count-digit d (quotient n 10)))]\n      [else (count-digit d (quotient n 10))]))\n  (define (loop n)\n    (cond\n      [(zero? n) #t]\n      [(< (count-digit (remainder n 10) n) (remainder n 10)) #f]\n      [else (loop (quotient n 10))]))\n  (loop n))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (define (validate-helper n)\n    (if (zero? n)\n        (list)\n        (cons (remainder n 10) (validate-helper (quotient n 10)))))\n  (let ([digits (validate-helper n)])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) d))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let loop ([n n] [freq (make-hash)])\n    (cond\n      [(zero? n) (every (\u03bb (k v) (<= v k)) freq)]\n      [else\n       (let ([digit (modulo n 10)])\n         (hash-update! freq digit add1 0)\n         (loop (quotient n 10) freq))])))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)]\n              [f (in-list (map (\u03bb (d) (count d digits)) digits))])\n      (<= f d))))\n",
    "  (let ((n (string->number (number->string n))))\n    (for/and ([d (in-list (string->list (number->string n)))]\n              [f (in-list (list-ref (frequency-list (string->list (number->string n))) (sub1 (string->number (number->string d)))))]\n              #:when (and (not (zero? f))\n                          (&gt;= f d)))\n      #t)))\n</code>\n",
    "  (define (helper n)\n    (if (zero? n)\n        '()\n        (cons (remainder n 10) (helper (quotient n 10)))))\n  (define (count-occurrence lst n)\n    (if (null? lst)\n        0\n        (if (= (car lst) n)\n            (+ 1 (count-occurrence (cdr lst) n))\n            (count-occurrence (cdr lst) n))))\n  (define (check lst)\n    (if (null? lst)\n        #t\n        (if (<= (count-occurrence lst (car lst)) (car lst))\n            (check (cdr lst))\n            #f)))\n  (check (helper n)))\n",
    "  (let loop ([n n] [digits (list)] [freq (list)])\n    (cond [(zero? n)\n           (let loop ([digits digits] [freq freq])\n             (cond [(empty? digits) #t]\n             [else (and (or (= (first digits) (first freq))\n                            (&lt; (first digits) (first freq)))\n                        (loop (rest digits) (rest freq)))]))]\n          [else (let ([digit (remainder n 10)])\n                  (loop (quotient n 10)\n                        (cons digit digits)\n                        (cons (add1 (list-ref freq digit)) freq)))])))\n</code>\n",
    "  (define (helper n)\n    (cond\n      [(zero? n) '()]\n      [else (cons (remainder n 10) (helper (quotient n 10)))]))\n  (define (count lst n)\n    (cond\n      [(empty? lst) 0]\n      [(= n (first lst)) (+ 1 (count (rest lst) n))]\n      [else (count (rest lst) n)]))\n  (define (check lst)\n    (cond\n      [(empty? lst) #t]\n      [(<= (count (helper n) (first lst)) (first lst)) (check (rest lst))]\n      [else #f]))\n  (check (helper n)))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)]\n              [f (in-list (map (\u03bb (x) (count x digits)) digits))])\n      (<= f d))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)]\n              [c (in-list digits)]\n              #:when (equal? d c))\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (define (freq-of-digit n digit)\n    (cond\n      [(zero? n) 0]\n      [(= (remainder n 10) digit) (+ 1 (freq-of-digit (quotient n 10) digit))]\n      [else (freq-of-digit (quotient n 10) digit)]))\n  (define (validate-helper n)\n    (cond\n      [(zero? n) #t]\n      [(<= (freq-of-digit n (remainder n 10)) (remainder n 10)) (validate-helper (quotient n 10))]\n      [else #f]))\n  (validate-helper n))\n",
    "  (define (count-digit n d)\n    (cond ((= n 0) 0)\n          ((= (remainder n 10) d) (+ 1 (count-digit (quotient n 10) d)))\n          (else (count-digit (quotient n 10) d))))\n  (define (helper n)\n    (cond ((= n 0) #t)\n          ((< (count-digit n (remainder n 10)) (remainder n 10)) #f)\n          (else (helper (quotient n 10)))))\n  (helper n))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (letrec ([digits (string->list (number->string n))]\n           [count (lambda (d) (length (filter (lambda (x) (equal? x d)) digits)))])\n    (for/and ([d (in-range 10)])\n      (<= (count d) d))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (define (validate-helper n freq)\n    (cond\n      [(zero? n) (freq)]\n      [(<= (remainder n 10) (list-ref freq (- (remainder n 10) 1))) (validate-helper (quotient n 10) freq)]\n      [else (validate-helper (quotient n 10) (list-set freq (- (remainder n 10) 1) (+ 1 (list-ref freq (- (remainder n 10) 1)))))]))\n  (validate-helper n (build-list 10 add1)))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let loop ([n n] [digits (list)] [freq (list)])\n    (cond [(zero? n)\n           (andmap (lambda (d f) (<= f d)) digits freq)]\n          [else\n           (let ([d (modulo n 10)])\n             (loop (quotient n 10)\n                   (cons d digits)\n                   (cons (if (member d digits)\n                             (+ 1 (list-ref freq (list-index d digits)))\n                             1)\n                         freq)))])))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)]\n              [c (in-list digits)])\n      (if (equal? d c)\n          (<= (count d digits) d)\n          #t))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)]\n              [c (in-list digits)])\n      (if (equal? d c)\n          (<= (count c digits) (string->number (number->string d)))\n          #t))))\n",
    "  (define (count-digit n d)\n    (cond\n      [(zero? n) 0]\n      [(= (remainder n 10) d) (+ 1 (count-digit (quotient n 10) d))]\n      [else (count-digit (quotient n 10) d)]))\n  (define (helper n)\n    (cond\n      [(zero? n) #t]\n      [(<= (count-digit n (remainder n 10)) (remainder n 10)) (helper (quotient n 10))]\n      [else #f]))\n  (helper n))\n",
    "  (let ([s (number->string n)])\n    (for/and ([d (in-range 10)])\n      (<= (count (string-contains s (number->string d)) s) d))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (define (validate-helper n)\n    (if (zero? n)\n        '()\n        (cons (remainder n 10) (validate-helper (quotient n 10)))))\n  (let loop ([lst (validate-helper n)]\n             [acc (make-hash)])\n    (cond [(null? lst) (hash-for-each (lambda (k v) (if (&gt; k v) #f)) acc)]\n          [else (loop (cdr lst) (hash-set! acc (car lst) (+ 1 (hash-ref acc (car lst) 0))))])))\n</code>\nI am not sure how to return #f when the condition is met.\n\n\nA:\n\nYou can use <code>for/or</code> to return <code>#f</code> when the condition is met:\n<code>(define (validate n)\n  (define (validate-helper n)\n    (if (zero? n)\n        '()\n        (cons (remainder n 10) (validate-helper (quotient n 10)))))\n  (let loop ([lst (validate-helper n)]\n             [acc (make-hash)])\n    (cond [(null? lst) (for/or ([(k v) (in-hash acc)]) (&gt; k v))]\n          [else (loop (cdr lst) (hash-set! acc (car lst) (+ 1 (hash-ref acc (car lst) 0))))])))\n</code>\n",
    "  (define (count-digit n d)\n    (if (= n 0)\n        0\n        (+ (if (= (remainder n 10) d) 1 0)\n           (count-digit (quotient n 10) d))))\n  (define (validate-helper n)\n    (if (= n 0)\n        #t\n        (and (validate-helper (quotient n 10))\n             (<= (count-digit n (remainder n 10)) (remainder n 10)))))\n  (validate-helper n))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)]\n              [f (in-list (map (\u03bb (x) (count x digits)) digits))])\n      (<= f d))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)]\n              [f (in-list (map (\u03bb (x) (count x digits)) digits))])\n      (<= f d))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)]\n              [f (in-list (map (\u03bb (d) (count d digits)) digits))])\n      (<= f d))))\n",
    "  (let loop ([n n] [digits '()])\n    (cond\n      [(zero? n)\n       (let loop ([digits digits] [result #t])\n         (cond\n           [(empty? digits) result]\n           [else\n            (let ([d (car digits)])\n              (loop (cdr digits)\n                    (and result\n                         (<= (count d digits) d))))]))]\n      [else\n       (loop (quotient n 10)\n             (cons (remainder n 10) digits))])))\n",
    "  (let ([digits (string->list (number->string n))])\n    (andmap (lambda (d)\n              (let ([count (count d digits)])\n                (and (<= count d)\n                     (not (zero? count)))))\n            (range 10))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (let loop ([digits digits]\n               [freq (make-hash)])\n      (cond [(empty? digits)\n             (for/and ([(k v) (in-hash freq)])\n               (<= v (string->number (symbol->string k))))]\n            [else\n             (let ([d (car digits)])\n               (hash-update! freq d add1 0)\n               (loop (cdr digits) freq))]))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d digits])\n      (<= (count d digits) (string->number (char->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (define (count-digit n d)\n    (cond\n      [(zero? n) 0]\n      [(= (remainder n 10) d) (+ 1 (count-digit (quotient n 10) d))]\n      [else (count-digit (quotient n 10) d)]))\n  (define (helper n)\n    (cond\n      [(zero? n) #t]\n      [(<= (count-digit n (remainder n 10)) (remainder n 10)) (helper (quotient n 10))]\n      [else #f]))\n  (helper n))\n",
    "  (define (validate-helper n freq)\n    (cond\n      [(zero? n) (andmap (lambda (x) (<= x (cdr x))) freq)]\n      [(member (modulo n 10) freq) (validate-helper (quotient n 10) (cons (cons (modulo n 10) (add1 (cdr (assoc (modulo n 10) freq)))) (remove (lambda (x) (equal? (car x) (modulo n 10))) freq)))]\n      [else (validate-helper (quotient n 10) (cons (cons (modulo n 10) 1) freq))]))\n  (validate-helper n '()))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)]\n              [f (in-list (map (\u03bb (x) (count x digits)) digits))])\n      (<= f d))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count d digits) (string->number (number->string d))))))\n",
    "  (let loop ([n (number->string n)])\n    (if (empty? n)\n        #t\n        (let* ([d (string->number (string-ref n 0))]\n               [count (count (lambda (c) (=? c (string-ref n 0))) n)])\n          (if (<=? d count)\n              (loop (substring n 1))\n              #f)))))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)])\n      (<= (count (in-list digits) d) (string->number (number->string d))))))\n",
    "  (define (count-digit d n)\n    (cond\n      [(zero? n) 0]\n      [(= (remainder n 10) d) (+ 1 (count-digit d (quotient n 10)))]\n      [else (count-digit d (quotient n 10))]))\n  (define (loop n)\n    (cond\n      [(zero? n) #t]\n      [(<= (count-digit (remainder n 10) n) (remainder n 10)) (loop (quotient n 10))]\n      [else #f]))\n  (loop n))\n",
    "  (let ([digits (string->list (number->string n))])\n    (for/and ([d (in-list digits)]\n              [f (in-list (map (lambda (x) (count x digits)) digits))])\n      (<= f d))))\n"
  ]
}