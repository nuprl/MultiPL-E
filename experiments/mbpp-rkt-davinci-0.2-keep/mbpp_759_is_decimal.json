{
  "name": "mbpp_759_is_decimal",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Write a function to check whether a given string is a decimal number with a precision of 2.\n(define (is_decimal num)\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_759_is_decimal.py",
  "prompt_terminology": "verbatim",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_decimal))\n    (check-equal? (candidate \"123.11\") #t)\n    (check-equal? (candidate \"e666.86\") #f)\n    (check-equal? (candidate \"3.124587\") #f)\n    (check-equal? (candidate \"1.11\") #t)\n    (check-equal? (candidate \"1.1.11\") #f)\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (regexp-match? #rx\"^[0-9]+(\\.[0-9]{1,2})?$\" num))\n",
    "  (and (string? num)\n       (regexp-match? #rx\"^[0-9]+\\.[0-9]{2}$\" num)))\n",
    "  (and (string? num)\n       (regexp-match? #rx\"^[0-9]+\\.[0-9]{2}$\" num)))\n",
    "  (and (string? num)\n       (regexp-match #rx\"^[0-9]+\\.[0-9]{2}$\" num)))\n",
    "  (and (string? num)\n       (regexp-match? #rx\"^[0-9]+(\\.[0-9]{1,2})?$\" num)))\n",
    "  (define (is_decimal_helper num)\n    (if (string-empty? num)\n        #t\n        (if (char-numeric? (string-ref num 0))\n            (is_decimal_helper (substring num 1))\n            #f)))\n  (if (string-empty? num)\n      #f\n      (if (char-numeric? (string-ref num 0))\n          (if (string-empty? (substring num 1))\n              #t\n              (if (string-empty? (substring num 2))\n                  (if (char-numeric? (string-ref num 1))\n                      #t\n                      #f)\n                  #f))\n          #f)))\n</code>\nI'm not sure why this doesn't work. Any help would be appreciated.\n\n\nA:\n\nYou can use <code>regexp-match</code> to check if a string matches a regular expression.\n<code>(regexp-match #rx\"^[0-9]+\\.[0-9]{2}$\" \"123.45\")\n=&gt; #f",
    "  (and (string? num)\n       (regexp-match? #rx\"^[0-9]+\\.[0-9]{2}$\" num)))\n",
    "  (and (regexp-match? #rx\"^[0-9]+\\\\.[0-9]{2}$\" num)\n       (not (regexp-match? #rx\"^[0-9]+\\\\.[0-9]{3}$\" num))))\n",
    "  (and (string? num)\n       (regexp-match #rx\"^[0-9]+\\.[0-9]{2}$\" num)))\n",
    "  (regexp-match? #rx\"^[0-9]+\\.[0-9]{2}$\" num))\n",
    "  (regexp-match? #rx\"^[0-9]+\\.[0-9]{2}$\" num))\n",
    "  (and (string? num)\n       (regexp-match? #rx\"^[0-9]+\\.[0-9]{2}$\" num)))\n",
    "  (cond\n    [(string-contains num #\\.)\n     (let ([parts (string-split num #\\.)])\n       (and (= (length parts) 2)\n            (andmap (\u03bb (x) (char-numeric? x)) (string-&gt;list (first parts)))\n            (andmap (\u03bb (x) (char-numeric? x)) (string-&gt;list (second parts)))\n            (= (length (first parts)) (length (string-&gt;list (first parts))))\n            (= (length (second parts)) 2)))]\n    [else #f]))\n",
    "  (and (string? num)\n       (regexp-match #rx\"^[0-9]+(\\.[0-9]{1,2})?$\" num)))\n",
    "  (and (string? num)\n       (regexp-match? #rx\"^[0-9]+\\.[0-9]{2}$\" num)))\n",
    "  (and (string? num)\n       (regexp-match? #rx\"^[0-9]+\\.[0-9]{2}$\" num)))\n",
    "  (let ([num (string-&gt;number num)])\n    (and (number? num)\n         (not (negative? num))\n         (not (exact? num)))))\n",
    "  (and (string? num)\n       (regexp-match? #rx\"^[0-9]+(\\.[0-9]{1,2})?$\" num)))\n",
    "  (and (regexp-match? #rx\"^[0-9]+\\\\.[0-9]{2}$\" num)\n       (not (regexp-match? #rx\"^[0-9]+\\\\.[0-9]{3}$\" num))))\n",
    "  (regexp-match? #rx\"^[0-9]+\\.[0-9]{2}$\" num))\n"
  ]
}