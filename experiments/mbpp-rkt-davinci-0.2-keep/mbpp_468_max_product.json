{
  "name": "mbpp_468_max_product",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\n(define (max_product arr)\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_468_max_product.py",
  "prompt_terminology": "verbatim",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate max_product))\n    (check-equal? (candidate (list 3 100 4 5 150 6)) 3000)\n    (check-equal? (candidate (list 4 42 55 68 80)) 50265600)\n    (check-equal? (candidate (list 10 22 9 33 21 50 41 60)) 2460)\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (define (helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let* ([curr (car arr)]\n               [max-so-far (if (&gt; curr max-so-far) curr max-so-far)])\n          (helper (cdr arr) max-so-far))))\n  (helper arr 0))\n",
    "  (define (max-product-helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ([curr (car arr)])\n          (max-product-helper (cdr arr) (max max-so-far (* max-so-far curr))))))\n  (max-product-helper arr (car arr)))\n",
    "  (define (max-product-helper arr max-so-far)\n    (cond [(empty? arr) max-so-far]\n          [(= (first arr) 0) (max-product-helper (rest arr) max-so-far)]\n          [else\n           (let ([max-so-far (max max-so-far (first arr))])\n             (max-product-helper (rest arr) max-so-far))]))\n  (max-product-helper arr 0))\n",
    "  (let loop ([i 0] [max-product 0])\n    (if (= i (length arr))\n        max-product\n        (let ([product (* (array-ref arr i) (array-ref arr (+ i 1)))])\n          (loop (+ i 1) (max max-product product))))))\n",
    "  (define (max-product-helper arr max-product-so-far)\n    (cond\n      [(empty? arr) max-product-so-far]\n      [(> (first arr) 0)\n       (max-product-helper (rest arr) (* (first arr) max-product-so-far))]\n      [(< (first arr) 0)\n       (max-product-helper (rest arr) (* (first arr) max-product-so-far))]\n      [else (max-product-helper (rest arr) max-product-so-far)]))\n  (max-product-helper arr 1))\n",
    "  (define (max-product-helper arr max-product-so-far)\n    (if (null? arr)\n        max-product-so-far\n        (max-product-helper (cdr arr)\n                            (if (and (not (null? (cdr arr)))\n                                     (> (* (car arr) (cadr arr)) max-product-so-far))\n                                (* (car arr) (cadr arr))\n                                max-product-so-far))))\n  (max-product-helper arr 0))\n",
    "  (define (max-product-helper arr max-product)\n    (if (empty? arr)\n        max-product\n        (let ([first (first arr)])\n          (if (&gt; first max-product)\n              (max-product-helper (rest arr) (* first max-product))\n              (max-product-helper (rest arr) max-product)))))\n  (max-product-helper arr 1))\n",
    "  (define (max-product-helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ((max-product (apply * (take arr (length arr)))))\n          (max-product-helper (cdr arr) (max max-product max-so-far)))))\n  (max-product-helper arr 1))\n",
    "  (define (max-product-helper arr max-product)\n    (if (empty? arr)\n        max-product\n        (let* ([first (first arr)]\n               [rest (rest arr)]\n               [new-max-product (if (and (not (empty? rest))\n                                          (&gt; (first rest) first))\n                                     (* first max-product)\n                                     max-product)])\n          (max-product-helper rest new-max-product))))\n  (max-product-helper arr 1))\n</code>\n",
    "  (define (max-product-helper arr max-so-far)\n    (cond\n      [(empty? arr) max-so-far]\n      [(> (first arr) (* max-so-far (first arr)))\n       (max-product-helper (rest arr) (first arr))]\n      [else (max-product-helper (rest arr) max-so-far)]))\n  (max-product-helper arr 1))\n",
    "  (define (max-product-helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let* ([first (car arr)]\n               [rest (cdr arr)]\n               [new-max-product (if (&gt; first 0)\n                                    (* first max-product)\n                                    max-product)])\n          (max-product-helper rest new-max-product))))\n  (max-product-helper arr 1))\n",
    "  (define (max-product-helper arr max-product-so-far)\n    (if (null? arr)\n        max-product-so-far\n        (let ([curr-product (apply * arr)])\n          (if (&gt; curr-product max-product-so-far)\n              (max-product-helper (cdr arr) curr-product)\n              (max-product-helper (cdr arr) max-product-so-far)))))\n  (max-product-helper arr 0))\n",
    "  (define (max-product-helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let ([curr-product (* (car arr) (cadr arr))])\n          (if (&gt; curr-product max-product)\n              (max-product-helper (cdr arr) curr-product)\n              (max-product-helper (cdr arr) max-product)))))\n  (max-product-helper arr 0))\n",
    "  (define (max-product-helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ([curr (car arr)])\n          (max-product-helper (cdr arr) (max max-so-far (* max-so-far curr))))))\n  (max-product-helper arr 1))\n",
    "  (let loop ([arr arr] [max-product 0])\n    (cond [(empty? arr) max-product]\n          [(> (first arr) (second arr)) (loop (rest arr) max-product)]\n          [else (loop (rest arr) (* (first arr) (second arr)))])))\n",
    "  (define (max-product-helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let* ([first (car arr)]\n               [rest (cdr arr)]\n               [max-product-rest (max-product-helper rest max-so-far)]\n               [max-product-first (if (null? rest)\n                                      first\n                                      (* first (car rest)))])\n          (max max-product-rest max-product-first))))\n  (max-product-helper arr 0))\n",
    "  (define (max-product-helper arr i j)\n    (cond [(= i j) 1]\n          [(= (+ i 1) j) (list-ref arr i)]\n          [else (max (* (list-ref arr i) (max-product-helper arr (+ i 1) j))\n                      (* (list-ref arr j) (max-product-helper arr i (- j 1))))]))\n  (max-product-helper arr 0 (- (length arr) 1)))\n",
    "  (define (max-product-helper arr max-so-far)\n    (cond [(empty? arr) max-so-far]\n          [else (let* ([first (first arr)]\n                       [rest (rest arr)]\n                       [max-so-far (if (&gt; first max-so-far) first max-so-far)])\n                  (max-product-helper rest max-so-far))]))\n  (max-product-helper arr 0))\n",
    "  (define (max_product_helper arr max-product)\n    (cond\n      [(empty? arr) max-product]\n      [(> (first arr) (* max-product (first arr)))\n       (max_product_helper (rest arr) (first arr))]\n      [else (max_product_helper (rest arr) max-product)]))\n  (max_product_helper arr 1))\n",
    "  (define (max_product_helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (max_product_helper (cdr arr)\n                            (max max-so-far\n                                 (* max-so-far (car arr))))))\n  (max_product_helper arr 1))\n"
  ]
}