{
  "name": "mbpp_468_max_product",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\n(define (max_product arr)\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_468_max_product.py",
  "prompt_terminology": "verbatim",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate max_product))\n    (check-equal? (candidate (list 3 100 4 5 150 6)) 3000)\n    (check-equal? (candidate (list 4 42 55 68 80)) 50265600)\n    (check-equal? (candidate (list 10 22 9 33 21 50 41 60)) 2460)\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (define (helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let* ([curr (car arr)]\n               [max-so-far (if (&gt; curr max-so-far) curr max-so-far)])\n          (helper (cdr arr) max-so-far))))\n  (helper arr 0))\n",
    "  (define (max-product-helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ([curr (car arr)])\n          (max-product-helper (cdr arr) (max max-so-far (* max-so-far curr))))))\n  (max-product-helper arr (car arr)))\n",
    "  (define (max-product-helper arr max-so-far)\n    (cond [(empty? arr) max-so-far]\n          [(= (first arr) 0) (max-product-helper (rest arr) max-so-far)]\n          [else\n           (let ([max-so-far (max max-so-far (first arr))])\n             (max-product-helper (rest arr) max-so-far))]))\n  (max-product-helper arr 0))\n",
    "  (let loop ([i 0] [max-product 0])\n    (if (= i (length arr))\n        max-product\n        (let ([product (* (array-ref arr i) (array-ref arr (+ i 1)))])\n          (loop (+ i 1) (max max-product product))))))\n",
    "  (define (max-product-helper arr max-product-so-far)\n    (cond\n      [(empty? arr) max-product-so-far]\n      [(> (first arr) 0)\n       (max-product-helper (rest arr) (* (first arr) max-product-so-far))]\n      [(< (first arr) 0)\n       (max-product-helper (rest arr) (* (first arr) max-product-so-far))]\n      [else (max-product-helper (rest arr) max-product-so-far)]))\n  (max-product-helper arr 1))\n",
    "  (define (max-product-helper arr max-product-so-far)\n    (if (null? arr)\n        max-product-so-far\n        (max-product-helper (cdr arr)\n                            (if (and (not (null? (cdr arr)))\n                                     (> (* (car arr) (cadr arr)) max-product-so-far))\n                                (* (car arr) (cadr arr))\n                                max-product-so-far))))\n  (max-product-helper arr 0))\n",
    "  (define (max-product-helper arr max-product)\n    (if (empty? arr)\n        max-product\n        (let ([first (first arr)])\n          (if (&gt; first max-product)\n              (max-product-helper (rest arr) (* first max-product))\n              (max-product-helper (rest arr) max-product)))))\n  (max-product-helper arr 1))\n",
    "  (define (max-product-helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ((max-product (apply * (take arr (length arr)))))\n          (max-product-helper (cdr arr) (max max-product max-so-far)))))\n  (max-product-helper arr 1))\n",
    "  (define (max-product-helper arr max-product)\n    (if (empty? arr)\n        max-product\n        (let* ([first (first arr)]\n               [rest (rest arr)]\n               [new-max-product (if (and (not (empty? rest))\n                                          (&gt; (first rest) first))\n                                     (* first max-product)\n                                     max-product)])\n          (max-product-helper rest new-max-product))))\n  (max-product-helper arr 1))\n</code>\n",
    "  (define (max-product-helper arr max-so-far)\n    (cond\n      [(empty? arr) max-so-far]\n      [(> (first arr) (* max-so-far (first arr)))\n       (max-product-helper (rest arr) (first arr))]\n      [else (max-product-helper (rest arr) max-so-far)]))\n  (max-product-helper arr 1))\n",
    "  (define (max-product-helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let* ([first (car arr)]\n               [rest (cdr arr)]\n               [new-max-product (if (&gt; first 0)\n                                    (* first max-product)\n                                    max-product)])\n          (max-product-helper rest new-max-product))))\n  (max-product-helper arr 1))\n",
    "  (define (max-product-helper arr max-product-so-far)\n    (if (null? arr)\n        max-product-so-far\n        (let ([curr-product (apply * arr)])\n          (if (&gt; curr-product max-product-so-far)\n              (max-product-helper (cdr arr) curr-product)\n              (max-product-helper (cdr arr) max-product-so-far)))))\n  (max-product-helper arr 0))\n",
    "  (define (max-product-helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let ([curr-product (* (car arr) (cadr arr))])\n          (if (&gt; curr-product max-product)\n              (max-product-helper (cdr arr) curr-product)\n              (max-product-helper (cdr arr) max-product)))))\n  (max-product-helper arr 0))\n",
    "  (define (max-product-helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ([curr (car arr)])\n          (max-product-helper (cdr arr) (max max-so-far (* max-so-far curr))))))\n  (max-product-helper arr 1))\n",
    "  (let loop ([arr arr] [max-product 0])\n    (cond [(empty? arr) max-product]\n          [(> (first arr) (second arr)) (loop (rest arr) max-product)]\n          [else (loop (rest arr) (* (first arr) (second arr)))])))\n",
    "  (define (max-product-helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let* ([first (car arr)]\n               [rest (cdr arr)]\n               [max-product-rest (max-product-helper rest max-so-far)]\n               [max-product-first (if (null? rest)\n                                      first\n                                      (* first (car rest)))])\n          (max max-product-rest max-product-first))))\n  (max-product-helper arr 0))\n",
    "  (define (max-product-helper arr i j)\n    (cond [(= i j) 1]\n          [(= (+ i 1) j) (list-ref arr i)]\n          [else (max (* (list-ref arr i) (max-product-helper arr (+ i 1) j))\n                      (* (list-ref arr j) (max-product-helper arr i (- j 1))))]))\n  (max-product-helper arr 0 (- (length arr) 1)))\n",
    "  (define (max-product-helper arr max-so-far)\n    (cond [(empty? arr) max-so-far]\n          [else (let* ([first (first arr)]\n                       [rest (rest arr)]\n                       [max-so-far (if (&gt; first max-so-far) first max-so-far)])\n                  (max-product-helper rest max-so-far))]))\n  (max-product-helper arr 0))\n",
    "  (define (max_product_helper arr max-product)\n    (cond\n      [(empty? arr) max-product]\n      [(> (first arr) (* max-product (first arr)))\n       (max_product_helper (rest arr) (first arr))]\n      [else (max_product_helper (rest arr) max-product)]))\n  (max_product_helper arr 1))\n",
    "  (define (max_product_helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (max_product_helper (cdr arr)\n                            (max max-so-far\n                                 (* max-so-far (car arr))))))\n  (max_product_helper arr 1))\n",
    "  (define (max-product-helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ([curr (car arr)])\n          (if (&gt; curr 0)\n              (max-product-helper (cdr arr) (* curr max-so-far))\n              (max-product-helper (cdr arr) max-so-far)))))\n  (max-product-helper arr 1))\n",
    "  (define (max-product-helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let* ([first (car arr)]\n               [rest (cdr arr)]\n               [max-product-rest (max-product-helper rest max-product)]\n               [max-product-first (if (or (null? rest)\n                                          (< first (car rest)))\n                                      (* first max-product-rest)\n                                      max-product-rest)])\n          (if (> max-product-first max-product-rest)\n              max-product-first\n              max-product-rest))))\n  (max-product-helper arr 1))\n",
    "  (define (max-product-helper arr max-product-so-far)\n    (if (null? arr)\n        max-product-so-far\n        (let ([first (car arr)]\n              [rest (cdr arr)])\n          (if (null? rest)\n              max-product-so-far\n              (let ([second (car rest)])\n                (if (&gt; first second)\n                    (max-product-helper rest max-product-so-far)\n                    (max-product-helper rest (* max-product-so-far first))))))))\n  (max-product-helper arr 1))\n</code>\n",
    "  (define (max-product-helper arr max-product)\n    (cond [(empty? arr) max-product]\n          [(> (first arr) max-product) (max-product-helper (rest arr) (first arr))]\n          [else (max-product-helper (rest arr) max-product)]))\n  (max-product-helper arr 0))\n",
    "  (define (max-product-helper arr max-product-so-far)\n    (if (null? arr)\n        max-product-so-far\n        (let ([curr-num (car arr)])\n          (if (&gt; curr-num 0)\n              (max-product-helper (cdr arr) (* curr-num max-product-so-far))\n              (max-product-helper (cdr arr) max-product-so-far)))))\n  (max-product-helper arr 1))\n</code>\n",
    "  (define (max-prod-helper arr max-prod)\n    (if (null? arr)\n        max-prod\n        (let* ([curr (car arr)]\n               [rest (cdr arr)]\n               [new-prod (* curr max-prod)])\n          (if (&lt; curr max-prod)\n              (max-prod-helper rest max-prod)\n              (max-prod-helper rest new-prod)))))\n  (max-prod-helper arr 1))\n",
    "  (let loop ((arr arr) (max 0) (min 0) (max-product 0))\n    (cond\n      [(empty? arr) max-product]\n      [else\n       (let* ([curr (first arr)]\n              [new-max (max curr (* curr max))]\n              [new-min (min curr (* curr min))]\n              [new-max-product (max max-product new-max)])\n         (loop (rest arr) new-max new-min new-max-product))])))\n",
    "  (define (max-product-helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let ((curr-product (apply * arr)))\n          (max-product-helper (cdr arr) (max max-product curr-product)))))\n  (max-product-helper arr 0))\n",
    "  (define (max-product-helper arr max-product-so-far)\n    (if (null? arr)\n        max-product-so-far\n        (let ([curr-num (car arr)])\n          (if (&gt; curr-num 0)\n              (max-product-helper (cdr arr) (* curr-num max-product-so-far))\n              (max-product-helper (cdr arr) max-product-so-far)))))\n  (max-product-helper arr 1))\n</code>\n",
    "  (define (max-product-helper arr max-so-far)\n    (if (empty? arr)\n        max-so-far\n        (let ([curr (first arr)])\n          (max-product-helper (rest arr)\n                              (if (&gt; curr (* max-so-far curr))\n                                  curr\n                                  (* max-so-far curr))))))\n  (max-product-helper arr 1))\n",
    "  (define (max-product-helper arr max-product-so-far)\n    (if (null? arr)\n        max-product-so-far\n        (let ([current-product (apply * arr)])\n          (max-product-helper (cdr arr) (max max-product-so-far current-product)))))\n  (max-product-helper arr 1))\n",
    "  (define (max_product_helper arr max-product)\n    (cond\n      [(empty? arr) max-product]\n      [(> (first arr) (* max-product (first arr)))\n       (max_product_helper (rest arr) (first arr))]\n      [else\n       (max_product_helper (rest arr) (* max-product (first arr)))]))\n  (max_product_helper arr 1))\n",
    "  (define (max_product_helper arr max-so-far)\n    (if (empty? arr)\n        max-so-far\n        (let ([x (first arr)])\n          (max_product_helper (rest arr)\n                              (if (&gt; x 0)\n                                  (max (* x max-so-far) max-so-far)\n                                  max-so-far)))))\n  (max_product_helper arr 1))\n",
    "  (let loop ([i 0] [max-product 0] [cur-product 1])\n    (cond [(= i (length arr)) max-product]\n          [(> (vector-ref arr i) (vector-ref arr (- i 1)))\n           (loop (+ i 1) (max max-product cur-product) (* cur-product (vector-ref arr i)))]\n          [else (loop (+ i 1) max-product 1)])))\n",
    "  (define (max-product-helper arr max-product-so-far)\n    (if (null? arr)\n        max-product-so-far\n        (let ([current-product (apply * arr)])\n          (if (&gt; current-product max-product-so-far)\n              (max-product-helper (cdr arr) current-product)\n              (max-product-helper (cdr arr) max-product-so-far)))))\n  (max-product-helper arr 1))\n</code>\n",
    "  (define (max-product-helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ([curr (car arr)])\n          (max-product-helper (cdr arr)\n                              (if (&gt; curr (* max-so-far curr))\n                                  curr\n                                  (* max-so-far curr))))))\n  (max-product-helper arr 1))\n",
    "  (let loop ([arr arr] [max-product 0])\n    (cond [(empty? arr) max-product]\n          [(> (car arr) (cadr arr)) (loop (cdr arr) max-product)]\n          [else (loop (cdr arr) (* (car arr) (cadr arr)))])))\n",
    "  (let loop ([i 0] [j 0] [max 0])\n    (if (= i (length arr))\n        max\n        (let ([product (* (list-ref arr i) (list-ref arr j))])\n          (if (&lt; product max)\n              (loop (+ i 1) (+ j 1) max)\n              (loop (+ i 1) (+ j 1) product))))))\n</code>\n",
    "  (define (max-product-helper arr max-so-far)\n    (cond\n      [(empty? arr) max-so-far]\n      [else\n       (let ([curr-max (max (first arr) (* (first arr) max-so-far))])\n         (max-product-helper (rest arr) curr-max))]))\n  (max-product-helper arr 1))\n",
    "  (define (max-product-helper arr max-product-so-far)\n    (if (null? arr)\n        max-product-so-far\n        (let ([max-product-so-far (max max-product-so-far (* (car arr) (cadr arr)))])\n          (max-product-helper (cdr arr) max-product-so-far))))\n  (max-product-helper arr 0))\n",
    "  (define (max-product-helper arr max-so-far)\n    (cond\n      [(empty? arr) max-so-far]\n      [(> (first arr) (first (rest arr)))\n       (max-product-helper (rest arr) (* max-so-far (first arr)))]\n      [else (max-product-helper (rest arr) max-so-far)]))\n  (max-product-helper arr 1))\n",
    "  (define (max-product-helper arr max-product)\n    (cond\n      [(empty? arr) max-product]\n      [(> (first arr) (* max-product (first arr)))\n       (max-product-helper (rest arr) (* max-product (first arr)))]\n      [else (max-product-helper (rest arr) max-product)]))\n  (max-product-helper arr 1))\n",
    "  (define (max-product-helper arr i j)\n    (cond\n      [(= i j) 1]\n      [(= i (+ j 1)) (list-ref arr i)]\n      [else\n       (let ([x (max-product-helper arr i (- j 1))])\n         (if (< (list-ref arr j) (list-ref arr (- j 1)))\n             x\n             (* x (list-ref arr j))))]))\n  (max-product-helper arr 0 (length arr)))\n",
    "  (define (max-product-helper arr max-product-so-far)\n    (if (null? arr)\n        max-product-so-far\n        (let ([curr-num (car arr)])\n          (if (&lt; curr-num 0)\n              (max-product-helper (cdr arr) max-product-so-far)\n              (max-product-helper (cdr arr) (* curr-num max-product-so-far))))))\n  (max-product-helper arr 1))\n",
    "  (define (max-product-helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let ([current-product (apply * (car arr))])\n          (if (&gt; current-product max-product)\n              (max-product-helper (cdr arr) current-product)\n              (max-product-helper (cdr arr) max-product)))))\n  (max-product-helper arr 0))\n",
    "  (let loop ([i 0] [j 1] [max-product 0])\n    (cond [(>= i (length arr)) max-product]\n          [(>= j (length arr)) (loop (+ i 1) (+ i 2) max-product)]\n          [else (let ([product (* (list-ref arr i) (list-ref arr j))])\n                  (loop i (+ j 1) (if (> product max-product) product max-product)))])))\n",
    "  (define (max-product-helper arr max-product-so-far)\n    (if (null? arr)\n        max-product-so-far\n        (let ([current-product (apply * arr)])\n          (max-product-helper (cdr arr) (max max-product-so-far current-product)))))\n  (max-product-helper arr 0))\n",
    "  (define (max-product-helper arr max-product-so-far)\n    (cond\n      [(empty? arr) max-product-so-far]\n      [(> (first arr) (* max-product-so-far (first arr)))\n       (max-product-helper (rest arr) (* max-product-so-far (first arr)))]\n      [else (max-product-helper (rest arr) max-product-so-far)]))\n  (max-product-helper arr 1))\n",
    "  (let loop ((arr arr) (max-product 1) (max-product-so-far 1))\n    (if (null? arr)\n        max-product-so-far\n        (let ((product (* max-product (car arr))))\n          (if (&lt; product max-product-so-far)\n              (loop (cdr arr) (car arr) max-product-so-far)\n              (loop (cdr arr) product product))))))\n",
    "  (define (max-product-helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ([curr (car arr)])\n          (if (&lt; curr 0)\n              (max-product-helper (cdr arr) max-so-far)\n              (max-product-helper (cdr arr) (* curr max-so-far))))))\n  (max-product-helper arr 1))\n",
    "  (let loop ((arr arr)\n             (max-product 0)\n             (current-product 1))\n    (if (null? arr)\n        max-product\n        (let ((new-product (* current-product (car arr))))\n          (cond\n            [(> new-product max-product)\n             (loop (cdr arr)\n                   new-product\n                   new-product)]\n            [(< new-product max-product)\n             (loop (cdr arr)\n                   max-product\n                   1)]\n            [else\n             (loop (cdr arr)\n                   max-product\n                   new-product)])))))\n",
    "  (define (max-product-helper arr max-product-so-far)\n    (if (null? arr)\n        max-product-so-far\n        (let ([curr-product (apply * arr)])\n          (max-product-helper (cdr arr) (max max-product-so-far curr-product)))))\n  (max-product-helper arr 0))\n",
    "  (define (helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let ([curr-product (apply * arr)])\n          (if (&gt; curr-product max-product)\n              (helper (cdr arr) curr-product)\n              (helper (cdr arr) max-product)))))\n  (helper arr 0))\n",
    "  (define (max-product-helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let ([curr-product (apply * (take arr (length arr)))])\n          (if (&gt; curr-product max-product)\n              (max-product-helper (rest arr) curr-product)\n              (max-product-helper (rest arr) max-product)))))\n  (max-product-helper arr 0))\n</code>\n",
    "  (define (max-product-helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let ([curr-product (* (car arr) (cadr arr))])\n          (if (&gt; curr-product max-product)\n              (max-product-helper (cdr arr) curr-product)\n              (max-product-helper (cdr arr) max-product)))))\n  (max-product-helper arr 0))\n",
    "  (let loop ([i 0] [j 0] [prod 1])\n    (cond [(= i (length arr)) prod]\n          [(> (vector-ref arr i) (vector-ref arr j)) (loop (+ i 1) i (* prod (vector-ref arr i)))]\n          [else (loop (+ i 1) j prod)])))\n",
    "  (define (max-product-helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ([curr (car arr)])\n          (if (null? (cdr arr))\n              (max max-so-far curr)\n              (let ([next (cadr arr)])\n                (if (&gt; curr next)\n                    (max-product-helper (cdr arr) max-so-far)\n                    (max-product-helper (cdr arr) (* max-so-far curr))))))))\n  (max-product-helper arr 1))\n",
    "  (define (helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let ([curr (car arr)])\n          (if (&lt; curr 0)\n              (helper (cdr arr) max-product)\n              (helper (cdr arr) (* curr max-product))))))\n  (helper arr 1))\n",
    "  (define (max-product-helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let ([current-product (* (car arr) (car (cdr arr)) (car (cdr (cdr arr))))])\n          (if (&lt; current-product max-product)\n              (max-product-helper (cdr arr) max-product)\n              (max-product-helper (cdr arr) current-product)))))\n  (max-product-helper arr 0))\n</code>\n",
    "  (define (max-product-helper arr max-product-so-far)\n    (cond [(empty? arr) max-product-so-far]\n          [(> (first arr) (* max-product-so-far (first arr)))\n           (max-product-helper (rest arr) (* max-product-so-far (first arr)))]\n          [else (max-product-helper (rest arr) max-product-so-far)]))\n  (max-product-helper arr 1))\n",
    "  (define (max-product-helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ([max-so-far (if (&gt; (* (car arr) max-so-far) max-so-far) (* (car arr) max-so-far) max-so-far)])\n          (max-product-helper (cdr arr) max-so-far))))\n  (max-product-helper arr 1))\n",
    "  (define (max-product-helper arr max-product max-product-so-far)\n    (cond\n      [(empty? arr) max-product]\n      [(> (first arr) max-product-so-far) (max-product-helper (rest arr) (* max-product (first arr)) (first arr))]\n      [else (max-product-helper (rest arr) max-product max-product-so-far)]))\n  (max-product-helper arr 1 0))\n",
    "  (define (max-product-helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let* ([new-max (if (&gt; (car arr) max-so-far) (car arr) max-so-far)]\n               [new-max-so-far (if (&gt; (* new-max (car arr)) max-so-far) (* new-max (car arr)) max-so-far)])\n          (max-product-helper (cdr arr) new-max-so-far))))\n  (max-product-helper arr 1))\n",
    "  (let loop ((arr arr) (max 0) (min 0) (max-product 0))\n    (cond\n      [(empty? arr) max-product]\n      [else\n       (let* ([cur (first arr)]\n              [new-max (max cur (* cur max) (* cur min))]\n              [new-min (min cur (* cur max) (* cur min))]\n              [new-max-product (max max-product new-max)])\n         (loop (rest arr) new-max new-min new-max-product))])))\n",
    "  (let loop ([arr arr] [max-product 0])\n    (cond [(empty? arr) max-product]\n          [(> (car arr) (cadr arr)) (loop (cdr arr) max-product)]\n          [else (loop (cdr arr) (* (car arr) (cadr arr)))])))\n",
    "  (define (max-product-helper arr max-product)\n    (cond\n      [(empty? arr) max-product]\n      [(< (first arr) 0)\n       (max-product-helper (rest arr) (max max-product (first arr)))]\n      [else\n       (max-product-helper (rest arr) (max max-product (* max-product (first arr))))]))\n  (max-product-helper arr 1))\n",
    "  (define (max-product-helper arr max-product-so-far)\n    (cond\n      [(empty? arr) max-product-so-far]\n      [(> (first arr) (* max-product-so-far (first arr))) (max-product-helper (rest arr) (* max-product-so-far (first arr)))]\n      [else (max-product-helper (rest arr) max-product-so-far)]))\n  (max-product-helper arr 1))\n",
    "  (define (max-product-helper arr max-product)\n    (cond\n      [(empty? arr) max-product]\n      [(> (first arr) (second arr)) (max-product-helper (rest arr) (* max-product (first arr)))]\n      [else (max-product-helper (rest arr) max-product)]))\n  (max-product-helper arr 1))\n",
    "  (define (helper arr i j)\n    (cond [(= i j) 1]\n          [(> (vector-ref arr i) (vector-ref arr j)) (helper arr (+ i 1) j)]\n          [else (max (* (vector-ref arr i) (helper arr (+ i 1) j))\n                      (helper arr i (+ j 1)))]))\n  (helper arr 0 (- (vector-length arr) 1)))\n",
    "  (let loop ([i 0] [max-prod 1])\n    (if (= i (length arr))\n        max-prod\n        (let ([prod (apply * (sublist arr i (length arr)))]\n              [prod-i (apply * (sublist arr i (+ i 1)))]\n              [prod-i+1 (apply * (sublist arr (+ i 1) (length arr)))])\n          (loop (+ i 1)\n                (max max-prod prod prod-i prod-i+1))))))\n",
    "  (let loop ([i 0] [j 0] [prod 1] [max-prod 1])\n    (if (&lt; i (vector-length arr))\n        (if (&lt; (vector-ref arr i) (vector-ref arr j))\n            (loop (+ i 1) i prod max-prod)\n            (loop (+ i 1) (+ j 1) (* prod (vector-ref arr j)) (max max-prod prod)))\n        max-prod)))\n",
    "  (let loop ([arr arr] [max-product 0] [current-product 1])\n    (if (null? arr)\n        max-product\n        (let ([next-product (* current-product (car arr))])\n          (if (&lt; next-product current-product)\n              (loop (cdr arr) max-product 1)\n              (loop (cdr arr) (max max-product next-product) next-product))))))\n",
    "  (define (max-product-helper arr max-product)\n    (cond\n      [(empty? arr) max-product]\n      [(> (first arr) (* max-product (first arr))) (max-product-helper (rest arr) (* max-product (first arr)))]\n      [else (max-product-helper (rest arr) max-product)]))\n  (max-product-helper arr 1))\n",
    "  (let ([len (length arr)])\n    (let ([max-product (make-vector len 1)])\n      (let loop ([i 0])\n        (if (= i len)\n            (vector-ref max-product (- len 1))\n            (let ([max-product-i (vector-ref max-product (- i 1))])\n              (let loop ([j 0])\n                (if (= j i)\n                    (let ([max-product-i (max max-product-i (* (vector-ref arr i) (vector-ref max-product (- i 1))))])\n                      (vector-set! max-product i max-product-i)\n                      (loop (+ i 1)))\n                    (let ([max-product-j (vector-ref max-product j)])\n                      (if (&lt; (vector-ref arr i) (vector-ref arr j))\n                          (let ([max-product-j (max max-product-j (* (vector-ref arr i) (vector-ref max-product j)))])\n                            (vector-set! max-product j max-product-j)\n                            (loop j))\n                          (loop (+ j 1))))))))))))\n</code>\n",
    "  (let loop ([arr arr] [max-product 0])\n    (if (null? arr)\n        max-product\n        (let ([product (apply * arr)])\n          (if (&gt; product max-product)\n              (loop (cdr arr) product)\n              (loop (cdr arr) max-product))))))\n</code>\n",
    "  (let loop ((arr arr) (max-product 1) (max-product-so-far 1))\n    (cond [(empty? arr) max-product-so-far]\n          [(> (first arr) max-product)\n           (loop (rest arr) (first arr) (max max-product-so-far (* max-product (first arr))))]\n          [else (loop (rest arr) (* max-product (first arr)) max-product-so-far)])))\n",
    "  (define (helper arr max-product)\n    (cond\n      [(empty? arr) max-product]\n      [(< (first arr) 0)\n       (helper (rest arr) (max max-product (first arr)))]\n      [else\n       (helper (rest arr) (max max-product (* (first arr) (helper (rest arr) 1))))]))\n  (helper arr 1))\n",
    "  (define (max_product_helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let* ([first (car arr)]\n               [rest (cdr arr)]\n               [new-max-product (if (and (not (null? rest))\n                                          (> (car rest) first))\n                                     (* first max-product)\n                                     max-product)])\n          (max_product_helper rest new-max-product))))\n  (max_product_helper arr 1))\n",
    "  (define (max-product-helper arr max-product-so-far)\n    (cond\n      [(empty? arr) max-product-so-far]\n      [(< (first arr) 0)\n       (max-product-helper (rest arr) max-product-so-far)]\n      [else\n       (max-product-helper (rest arr) (* max-product-so-far (first arr)))]))\n  (max-product-helper arr 1))\n",
    "  (define (max-product-helper arr max-so-far)\n    (cond ((null? arr) max-so-far)\n          ((&lt; (car arr) 0) (max-product-helper (cdr arr) max-so-far))\n          ((&gt; (car arr) max-so-far) (max-product-helper (cdr arr) (* max-so-far (car arr))))\n          (else (max-product-helper (cdr arr) max-so-far))))\n  (max-product-helper arr 1))\n",
    "  (define (max-product-helper arr max-product-so-far)\n    (if (null? arr)\n        max-product-so-far\n        (let ((current-product (* (car arr) (car (cdr arr)))))\n          (if (&gt; current-product max-product-so-far)\n              (max-product-helper (cdr arr) current-product)\n              (max-product-helper (cdr arr) max-product-so-far)))))\n  (max-product-helper arr 0))\n",
    "  (define (max-product-helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ([curr (car arr)])\n          (if (&gt; curr 0)\n              (max-product-helper (cdr arr) (* curr max-so-far))\n              (max-product-helper (cdr arr) max-so-far)))))\n  (max-product-helper arr 1))\n",
    "  (define (helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let* ([first (car arr)]\n               [rest (cdr arr)]\n               [max-so-far (if (and (not (null? rest))\n                                    (or (positive? first)\n                                        (positive? (car rest))))\n                               (max max-so-far (* first (car rest)))\n                               max-so-far)])\n          (helper rest max-so-far))))\n  (helper arr 0))\n",
    "  (define (max-product-helper arr max-so-far)\n    (cond [(null? arr) max-so-far]\n          [(> (car arr) max-so-far) (max-product-helper (cdr arr) (car arr))]\n          [else (max-product-helper (cdr arr) max-so-far)]))\n  (max-product-helper arr 0))\n",
    "  (define (helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ([curr (car arr)])\n          (if (&lt; curr 0)\n              (helper (cdr arr) max-so-far)\n              (helper (cdr arr) (* curr max-so-far))))))\n  (helper arr 1))\n",
    "  (define (max-product-helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let ((current-product (* (car arr) (cadr arr))))\n          (if (> current-product max-product)\n              (max-product-helper (cdr arr) current-product)\n              (max-product-helper (cdr arr) max-product)))))\n  (max-product-helper arr 0))\n",
    "  (define (helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ([curr (car arr)])\n          (helper (cdr arr)\n                  (if (&gt; curr (* max-so-far curr))\n                      curr\n                      (* max-so-far curr))))))\n  (helper arr 1))\n",
    "  (define (helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ([curr (car arr)])\n          (helper (cdr arr)\n                  (max max-so-far\n                       (if (&gt; curr 0)\n                           (* curr max-so-far)\n                           max-so-far))))))\n  (helper arr 1))\n",
    "  (define (max-product-helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ((curr (car arr)))\n          (if (&gt; curr max-so-far)\n              (max-product-helper (cdr arr) (* curr max-so-far))\n              (max-product-helper (cdr arr) max-so-far)))))\n  (max-product-helper arr 1))\n",
    "  (define (max-product-helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let ([current-product (apply * arr)])\n          (if (&gt; current-product max-product)\n              (max-product-helper (cdr arr) current-product)\n              (max-product-helper (cdr arr) max-product)))))\n  (max-product-helper arr 1))\n",
    "  (define (max-product-helper arr max-product)\n    (cond\n      [(empty? arr) max-product]\n      [(> (first arr) (second arr)) (max-product-helper (rest arr) (* max-product (first arr)))]\n      [else (max-product-helper (rest arr) max-product)]))\n  (max-product-helper arr 1))\n",
    "  (define (max-product-helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let ([curr-product (apply * arr)])\n          (if (&gt; curr-product max-product)\n              (max-product-helper (cdr arr) curr-product)\n              (max-product-helper (cdr arr) max-product)))))\n  (max-product-helper arr 0))\n</code>\n",
    "  (let loop ([arr arr] [max 0] [min 0] [max-so-far 0])\n    (cond [(empty? arr) max-so-far]\n          [else\n           (let ([x (first arr)])\n             (loop (rest arr)\n                   (max (* x max) (* x min) x)\n                   (min (* x max) (* x min) x)\n                   (max max-so-far (max (* x max) (* x min) x))))])))\n",
    "  (define (max-product-helper arr max-product-so-far)\n    (cond\n      [(empty? arr) max-product-so-far]\n      [(> (first arr) (second arr))\n       (max-product-helper (rest arr) (* max-product-so-far (first arr)))]\n      [else (max-product-helper (rest arr) max-product-so-far)]))\n  (max-product-helper arr 1))\n",
    "  (define (max-product-helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ([curr (car arr)])\n          (max-product-helper (cdr arr)\n                              (if (&lt; curr (car max-so-far))\n                                  max-so-far\n                                  (cons curr max-so-far))))))\n  (define (product lst)\n    (if (null? lst)\n        1\n        (* (car lst) (product (cdr lst)))))\n  (product (max-product-helper arr (list (car arr)))))\n",
    "  (let loop ((arr arr)\n             (max-product 0))\n    (if (null? arr)\n        max-product\n        (let ((product (apply * (take (length arr) arr))))\n          (loop (cdr arr)\n                (max max-product product))))))\n",
    "  (let loop ([i 0] [max-prod 0])\n    (if (= i (length arr))\n        max-prod\n        (let ([prod (reduce * (sublist arr i (length arr)) 1)])\n          (loop (+ i 1) (max max-prod prod))))))\n",
    "  (define (max-product-helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let ([curr-product (apply * arr)])\n          (if (&gt; curr-product max-product)\n              (max-product-helper (cdr arr) curr-product)\n              (max-product-helper (cdr arr) max-product)))))\n  (max-product-helper arr 0))\n",
    "  (define (max-product-helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let* ([curr-val (car arr)]\n               [new-max-product (if (&gt; curr-val (* max-product curr-val))\n                                    (* max-product curr-val)\n                                    max-product)])\n          (max-product-helper (cdr arr) new-max-product))))\n  (max-product-helper arr 1))\n",
    "  (define (max-product-helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (max-product-helper (cdr arr)\n                            (max max-so-far (* max-so-far (car arr))))))\n  (max-product-helper arr 1))\n",
    "  (define (max-product-helper arr i j)\n    (cond [(= i j) 1]\n          [(= i (+ j 1)) (list-ref arr i)]\n          [else (max (* (list-ref arr i) (max-product-helper arr (+ i 1) j))\n                      (* (list-ref arr j) (max-product-helper arr i (- j 1))))]))\n  (max-product-helper arr 0 (- (length arr) 1)))\n",
    "  (define (max-product-helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ([curr-max (max (apply * arr) max-so-far)])\n          (max-product-helper (cdr arr) curr-max))))\n  (max-product-helper arr 0))\n",
    "  (define (max-product-helper arr max-so-far)\n    (cond ((null? arr) max-so-far)\n          ((= (car arr) 0) (max-product-helper (cdr arr) max-so-far))\n          ((< (car arr) 0) (max-product-helper (cdr arr) (max max-so-far (* (car arr) (cadr arr)))))))\n  (max-product-helper arr 1))\n",
    "  (define (max-product-helper arr max-product-so-far)\n    (if (null? arr)\n        max-product-so-far\n        (let ([curr-product (apply * arr)])\n          (max-product-helper (cdr arr) (max curr-product max-product-so-far)))))\n  (max-product-helper arr 1))\n",
    "  (define (helper arr max-product)\n    (cond [(empty? arr) max-product]\n          [(> (first arr) (* max-product (first arr)))\n           (helper (rest arr) (first arr))]\n          [else (helper (rest arr) (* max-product (first arr)))]))\n  (helper arr 1))\n",
    "  (define (max-product-helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let ((curr-product (* (car arr) (car (cdr arr)))))\n          (if (&gt; curr-product max-product)\n              (max-product-helper (cdr arr) curr-product)\n              (max-product-helper (cdr arr) max-product)))))\n  (max-product-helper arr 0))\n",
    "  (define (max-product-helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ((curr-max (max (max-product-helper (cdr arr) max-so-far)\n                             (* max-so-far (car arr)))))\n          (max-product-helper (cdr arr) curr-max))))\n  (max-product-helper arr 1))\n",
    "  (define (max-product-helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let ([curr-product (apply * arr)])\n          (if (&gt; curr-product max-product)\n              (max-product-helper (cdr arr) curr-product)\n              (max-product-helper (cdr arr) max-product)))))\n  (max-product-helper arr 0))\n</code>\n",
    "  (define (max-product-helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let ((curr-product (* (car arr) (cadr arr))))\n          (if (&gt; curr-product max-product)\n              (max-product-helper (cdr arr) curr-product)\n              (max-product-helper (cdr arr) max-product)))))\n  (max-product-helper arr 0))\n",
    "  (define (max-product-helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let ([curr-max-product (* max-product (car arr))])\n          (if (&gt; curr-max-product max-product)\n              (max-product-helper (cdr arr) curr-max-product)\n              (max-product-helper (cdr arr) max-product)))))\n  (max-product-helper arr 1))\n",
    "  (define (max_product_helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let* ([curr (car arr)]\n               [rest (cdr arr)]\n               [max-so-far (if (&gt; curr max-so-far) curr max-so-far)])\n          (max_product_helper rest max-so-far))))\n  (max_product_helper arr 0))\n</code>\n",
    "  (define (max-product-helper arr max-so-far)\n    (cond\n      [(empty? arr) max-so-far]\n      [(> (first arr) max-so-far) (max-product-helper (rest arr) (first arr))]\n      [else (max-product-helper (rest arr) max-so-far)]))\n  (max-product-helper arr 0))\n",
    "  (let loop ([i 0] [j 0] [max 0])\n    (cond [(= i (length arr)) max]\n          [(> (vector-ref arr i) (vector-ref arr j))\n           (loop (+ i 1) i (max (* (vector-ref arr i) (vector-ref arr j)) max))]\n          [else (loop (+ i 1) j max)])))\n",
    "  (define (max-product-helper arr max-product-so-far)\n    (if (null? arr)\n        max-product-so-far\n        (let ([curr-product (apply * arr)])\n          (if (&gt; curr-product max-product-so-far)\n              (max-product-helper (cdr arr) curr-product)\n              (max-product-helper (cdr arr) max-product-so-far)))))\n  (max-product-helper arr 0))\n",
    "  (let loop ([arr arr] [max-product 1])\n    (if (null? arr)\n        max-product\n        (loop (cdr arr)\n              (if (&gt; (car arr) (car (cdr arr)))\n                  (* max-product (car arr))\n                  max-product)))))\n</code>\n",
    "  (define (helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ([curr (car arr)])\n          (if (&lt; curr 0)\n              (helper (cdr arr) max-so-far)\n              (helper (cdr arr) (* curr max-so-far))))))\n  (helper arr 1))\n</code>\n",
    "  (define (max-product-helper arr max-so-far)\n    (if (empty? arr)\n        max-so-far\n        (let ([curr (first arr)])\n          (if (empty? (rest arr))\n              (max max-so-far curr)\n              (let ([next (first (rest arr))])\n                (if (> next curr)\n                    (max-product-helper (rest arr) (* max-so-far next))\n                    (max-product-helper (rest arr) max-so-far)))))))\n  (max-product-helper arr 1))\n",
    "  (define (max-product-helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let ([curr-product (apply * arr)])\n          (if (&gt; curr-product max-product)\n              (max-product-helper (cdr arr) curr-product)\n              (max-product-helper (cdr arr) max-product)))))\n  (max-product-helper arr 0))\n",
    "  (define (max-product-helper arr max-product-so-far)\n    (cond\n      [(empty? arr) max-product-so-far]\n      [(< (first arr) 0)\n       (max-product-helper (rest arr)\n                           (max (first arr) max-product-so-far))]\n      [else\n       (max-product-helper (rest arr)\n                           (* (first arr) max-product-so-far))]))\n  (max-product-helper arr 1))\n",
    "  (define (max-product-helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (max-product-helper (cdr arr)\n                            (if (&gt; (car arr) (* max-so-far (car arr)))\n                                (car arr)\n                                (* max-so-far (car arr))))))\n  (max-product-helper arr 1))\n",
    "  (let loop ([arr arr] [max-product 0] [max-product-so-far 0])\n    (cond [(empty? arr) max-product]\n          [(> (first arr) max-product-so-far)\n           (loop (rest arr) (* max-product (first arr)) (first arr))]\n          [else (loop (rest arr) max-product max-product-so-far)])))\n",
    "  (let loop ([i 0] [j 0] [max 0])\n    (if (= i (length arr))\n        max\n        (let ([prod (* (list-ref arr i) (list-ref arr j))])\n          (if (&gt; prod max)\n              (loop (+ i 1) (+ j 1) prod)\n              (loop (+ i 1) (+ j 1) max))))))\n</code>\n",
    "  (define (max-product-helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let* ([first (car arr)]\n               [rest (cdr arr)]\n               [max-so-far (if (&gt; first max-so-far) first max-so-far)]\n               [max-so-far (if (&gt; (* first (car rest)) max-so-far) (* first (car rest)) max-so-far)])\n          (max-product-helper rest max-so-far))))\n  (max-product-helper arr 0))\n</code>\n",
    "  (define (max_product-helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ((max-so-far (if (&gt; (car arr) max-so-far)\n                              (car arr)\n                              max-so-far)))\n          (max_product-helper (cdr arr) max-so-far))))\n  (max_product-helper arr 0))\n",
    "  (define (helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let* ([curr (car arr)]\n               [next (cadr arr)]\n               [new-max (if (< curr next)\n                            (* curr max-so-far)\n                            max-so-far)])\n          (helper (cdr arr) new-max))))\n  (helper arr 1))\n",
    "  (define (helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ([curr (car arr)])\n          (helper (cdr arr)\n                  (if (&gt; curr (* max-so-far curr))\n                      curr\n                      (* max-so-far curr))))))\n  (helper arr 1))\n",
    "  (define (max-product-helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let ([curr-product (* (car arr) (cadr arr))])\n          (if (&gt; curr-product max-product)\n              (max-product-helper (cdr arr) curr-product)\n              (max-product-helper (cdr arr) max-product)))))\n  (max-product-helper arr 0))\n",
    "  (let loop ((arr arr) (max-product 0) (max-product-so-far 0) (min-product-so-far 0))\n    (cond ((null? arr) max-product)\n          ((= (car arr) 0) (loop (cdr arr) (max max-product 0) 0 0))\n          ((< (car arr) 0)\n           (let ((max-product-so-far (max (car arr) (* (car arr) min-product-so-far)))\n                 (min-product-so-far (min (car arr) (* (car arr) max-product-so-far))))\n             (loop (cdr arr) (max max-product max-product-so-far) max-product-so-far min-product-so-far)))\n          (else\n           (let ((max-product-so-far (* (car arr) max-product-so-far))\n                 (min-product-so-far (* (car arr) min-product-so-far)))\n             (loop (cdr arr) (max max-product max-product-so-far) max-product-so-far min-product-so-far))))))\n",
    "  (define (max-product-helper arr max-so-far)\n    (cond [(empty? arr) max-so-far]\n          [else (let ([curr (first arr)])\n                  (cond [(> curr 0) (max-product-helper (rest arr) (* max-so-far curr))]\n                        [else (max-product-helper (rest arr) max-so-far)]))]))\n  (max-product-helper arr 1))\n",
    "  (define (max-product-helper arr max-product-so-far)\n    (if (null? arr)\n        max-product-so-far\n        (let ([x (car arr)])\n          (if (&gt; x 0)\n              (max-product-helper (cdr arr) (* x max-product-so-far))\n              (max-product-helper (cdr arr) max-product-so-far)))))\n  (max-product-helper arr 1))\n",
    "  (define (max-product-helper arr max-product-so-far)\n    (cond [(empty? arr) max-product-so-far]\n          [else (let ([next-max-product (if (&gt; (first arr) 0)\n                                            (* max-product-so-far (first arr))\n                                            max-product-so-far)])\n                   (max-product-helper (rest arr) next-max-product))]))\n  (max-product-helper arr 1))\n",
    "  (define (max_product_helper arr max-so-far)\n    (cond [(empty? arr) max-so-far]\n          [(< (first arr) 0) (max_product_helper (rest arr) max-so-far)]\n          [else (max_product_helper (rest arr) (* (first arr) max-so-far))]))\n  (max_product_helper arr 1))\n",
    "  (define (max_product_helper arr max-so-far)\n    (cond\n      [(empty? arr) max-so-far]\n      [(> (first arr) max-so-far) (max_product_helper (rest arr) (first arr))]\n      [else (max_product_helper (rest arr) max-so-far)]))\n  (max_product_helper arr 0))\n",
    "  (define (max-product-helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ([curr (car arr)])\n          (if (&gt; curr max-so-far)\n              (max-product-helper (cdr arr) (* curr max-so-far))\n              (max-product-helper (cdr arr) max-so-far)))))\n  (max-product-helper arr 1))\n",
    "  (define (max-product-helper arr max-product-so-far)\n    (if (null? arr)\n        max-product-so-far\n        (let ([curr-product (apply * arr)])\n          (max-product-helper (cdr arr)\n                              (max max-product-so-far curr-product)))))\n  (max-product-helper arr 1))\n",
    "  (define (max-product-helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ((max-product (max (apply * arr) max-so-far)))\n          (max-product-helper (cdr arr) max-product))))\n  (max-product-helper arr 0))\n",
    "  (define (max-product-helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let ([max-product (if (and (not (null? (cdr arr)))\n                                    (not (null? (cddr arr)))\n                                    (and (< (car arr) (cadr arr))\n                                         (< (cadr arr) (caddr arr))))\n                               (* max-product (cadr arr))\n                               max-product)])\n          (max-product-helper (cdr arr) max-product))))\n  (max-product-helper arr 1))\n",
    "  (define (max-product-helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ([curr (car arr)])\n          (if (&lt; curr 0)\n              (max-product-helper (cdr arr) max-so-far)\n              (max-product-helper (cdr arr) (* curr max-so-far))))))\n  (max-product-helper arr 1))\n",
    "  (define (max-product-helper arr max-product-so-far)\n    (cond [(empty? arr) max-product-so-far]\n          [(> (first arr) (* max-product-so-far (first arr)))\n           (max-product-helper (rest arr) (* max-product-so-far (first arr)))]\n          [else (max-product-helper (rest arr) max-product-so-far)]))\n  (max-product-helper arr 1))\n",
    "  (define (max-product-helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ([curr (car arr)])\n          (max-product-helper (cdr arr)\n                              (if (&gt; curr (* max-so-far curr))\n                                  curr\n                                  (* max-so-far curr))))))\n  (max-product-helper arr 1))\n",
    "  (define (max-product-helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ((curr (car arr)))\n          (if (&gt; curr max-so-far)\n              (max-product-helper (cdr arr) (* curr max-so-far))\n              (max-product-helper (cdr arr) max-so-far)))))\n  (max-product-helper arr 1))\n",
    "  (define (max-product-helper arr max-product)\n    (cond\n      [(empty? arr) max-product]\n      [(< (first arr) 0)\n       (max-product-helper (rest arr) (max max-product (first arr)))]\n      [else\n       (max-product-helper (rest arr) (max max-product (* (first arr) (max-product-helper (rest arr) 1))))]))\n  (max-product-helper arr 1))\n",
    "  (let loop ((i 0) (j 1) (max 0))\n    (if (&lt; i (length arr))\n        (if (&lt; (vector-ref arr i) (vector-ref arr j))\n            (loop i (+ j 1) (max (vector-ref arr i) (vector-ref arr j)))\n            (loop (+ i 1) (+ j 1) max))\n        max)))\n</code>\n",
    "  (define (max-product-helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let ([curr (car arr)])\n          (if (&gt; curr 0)\n              (max-product-helper (cdr arr) (* curr max-product))\n              (max-product-helper (cdr arr) max-product)))))\n  (max-product-helper arr 1))\n",
    "  (define (helper arr max-so-far)\n    (cond\n      [(empty? arr) max-so-far]\n      [(< (first arr) (second arr))\n       (helper (rest arr) (* max-so-far (first arr)))]\n      [else\n       (helper (rest arr) max-so-far)]))\n  (helper arr 1))\n",
    "  (let loop ([arr arr] [max-prod 1])\n    (if (null? arr)\n        max-prod\n        (loop (cdr arr) (max max-prod (* (car arr) (car (cdr arr))))))))\n",
    "  (define (max-product-helper arr max-product-so-far)\n    (if (null? arr)\n        max-product-so-far\n        (let ([curr-product (apply * arr)])\n          (if (&gt; curr-product max-product-so-far)\n              (max-product-helper (cdr arr) curr-product)\n              (max-product-helper (cdr arr) max-product-so-far)))))\n  (max-product-helper arr 0))\n",
    "  (let loop ((arr arr) (max-product 0))\n    (cond\n      [(empty? arr) max-product]\n      [(empty? (rest arr)) max-product]\n      [else\n       (let ((product (* (first arr) (second arr))))\n         (if (&gt; product max-product)\n             (loop (rest arr) product)\n             (loop (rest arr) max-product)))])))\n</code>\n",
    "  (define (max-product-helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let* ([curr-product (apply * arr)]\n               [new-max-product (if (&gt; curr-product max-product) curr-product max-product)])\n          (max-product-helper (cdr arr) new-max-product))))\n  (max-product-helper arr 0))\n",
    "  (define (max-product-helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let* ([first (car arr)]\n               [rest (cdr arr)]\n               [max-so-far (if (&lt; first max-so-far) max-so-far first)])\n          (max-product-helper rest max-so-far))))\n  (max-product-helper arr 1))\n",
    "  (define (max-product-helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let ([curr (car arr)])\n          (if (&lt; curr 0)\n              (max-product-helper (cdr arr) max-product)\n              (max-product-helper (cdr arr) (* curr max-product))))))\n  (max-product-helper arr 1))\n",
    "  (let loop ((arr arr)\n             (max-product 0)\n             (current-product 1))\n    (cond ((null? arr) max-product)\n          ((< (car arr) 0)\n           (loop (cdr arr)\n                 (max max-product current-product)\n                 (if (< current-product 0)\n                     (* current-product (car arr))\n                     (car arr))))\n          (else\n           (loop (cdr arr)\n                 (max max-product current-product)\n                 (* current-product (car arr)))))))\n",
    "  (let loop ((arr arr) (max 0) (i 0) (j 0))\n    (cond\n      [(null? arr) max]\n      [(>= (car arr) (cadr arr))\n       (loop (cdr arr) max i (add1 j))]\n      [(> (* (car arr) (cadr arr)) max)\n       (loop (cdr arr) (* (car arr) (cadr arr)) (add1 i) (add1 j))]\n      [else\n       (loop (cdr arr) max (add1 i) (add1 j))])))\n",
    "  (define (helper arr max-so-far)\n    (cond\n      [(empty? arr) max-so-far]\n      [(> (first arr) (* max-so-far (first arr))) (helper (rest arr) (* max-so-far (first arr)))]\n      [else (helper (rest arr) max-so-far)]))\n  (helper arr 1))\n",
    "  (define (max_product_helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ([curr (car arr)])\n          (max_product_helper (cdr arr)\n                              (if (&gt; curr (* max-so-far curr))\n                                  curr\n                                  (* max-so-far curr))))))\n  (max_product_helper arr 1))\n",
    "  (define (max-product-helper arr max-product-so-far)\n    (cond\n      [(empty? arr) max-product-so-far]\n      [(> (first arr) 0)\n       (max-product-helper (rest arr) (* max-product-so-far (first arr)))]\n      [(< (first arr) 0)\n       (max-product-helper (rest arr) (first arr))]\n      [else (max-product-helper (rest arr) max-product-so-far)]))\n  (max-product-helper arr 1))\n",
    "  (define (max-product-helper arr max-product-so-far)\n    (if (null? arr)\n        max-product-so-far\n        (let ([max-product-so-far (if (and (not (null? (cdr arr)))\n                                           (not (null? (cddr arr)))\n                                           (> (* (car arr) (cadr arr) (caddr arr))\n                                              max-product-so-far))\n                                      (* (car arr) (cadr arr) (caddr arr))\n                                      max-product-so-far)])\n          (max-product-helper (cdr arr) max-product-so-far))))\n  (max-product-helper arr 0))\n",
    "  (define (max-product-helper arr max-so-far)\n    (if (empty? arr)\n        max-so-far\n        (let ([max-so-far (if (and (positive? (first arr))\n                                   (or (negative? max-so-far)\n                                       (positive? max-so-far)))\n                              (first arr)\n                              max-so-far)])\n          (max-product-helper (rest arr)\n                              (if (and (positive? (first arr))\n                                       (positive? max-so-far))\n                                  (* (first arr) max-so-far)\n                                  max-so-far)))))\n  (max-product-helper arr 1))\n",
    "  (let loop ((arr arr) (max 0))\n    (if (null? arr)\n        max\n        (let* ((cur (car arr))\n               (rest (cdr arr))\n               (next (if (null? rest)\n                        1\n                        (car rest))))\n          (if (> cur next)\n              (loop rest max)\n              (loop rest (max (* cur next) max)))))))\n",
    "  (define (max-product-helper arr max-product-so-far)\n    (if (empty? arr)\n        max-product-so-far\n        (let ([curr-num (first arr)])\n          (max-product-helper (rest arr)\n                              (if (&gt; curr-num (first arr))\n                                  (* curr-num max-product-so-far)\n                                  max-product-so-far)))))\n  (max-product-helper arr 1))\n</code>\n",
    "  (define (max-product-helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let* ((first (car arr))\n               (rest (cdr arr))\n               (first-product (* first (max-product-helper rest max-product))))\n          (if (&gt; first-product max-product)\n              first-product\n              max-product))))\n  (max-product-helper arr 0))\n",
    "  (define (max-product-helper arr max-product-so-far)\n    (if (null? arr)\n        max-product-so-far\n        (let ((max-product-so-far (if (&gt; (car arr) max-product-so-far)\n                                      (car arr)\n                                      max-product-so-far)))\n          (max-product-helper (cdr arr) max-product-so-far))))\n  (max-product-helper arr 0))\n",
    "  (define (helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let ([curr-product (apply * arr)])\n          (if (&gt; curr-product max-product)\n              (helper (cdr arr) curr-product)\n              (helper (cdr arr) max-product)))))\n  (helper arr 0))\n",
    "  (let loop ([arr arr] [max-product 0])\n    (cond [(empty? arr) max-product]\n          [(> (product (first arr)) max-product)\n           (loop (rest arr) (product (first arr)))]\n          [else (loop (rest arr) max-product)])))\n",
    "  (define (helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let ([product (* (car arr) (cadr arr))])\n          (if (&gt; product max-product)\n              (helper (cdr arr) product)\n              (helper (cdr arr) max-product)))))\n  (helper arr 0))\n",
    "  (define (max-product-helper arr max-so-far)\n    (cond [(empty? arr) max-so-far]\n          [else (let ([curr (first arr)])\n                  (cond [(> curr 0) (max-product-helper (rest arr) (* max-so-far curr))]\n                        [else (max-product-helper (rest arr) max-so-far)]))]))\n  (max-product-helper arr 1))\n",
    "  (define (max-product-helper arr max-product)\n    (cond\n      [(empty? arr) max-product]\n      [(> (first arr) (* max-product (first arr)))\n       (max-product-helper (rest arr) (* max-product (first arr)))]\n      [else (max-product-helper (rest arr) max-product)]))\n  (max-product-helper (rest arr) (first arr)))\n",
    "  (define (max-product-helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ((curr-max (max (apply * arr) max-so-far)))\n          (max-product-helper (cdr arr) curr-max))))\n  (max-product-helper arr 1))\n",
    "  (define (max-product-helper arr max-product-so-far)\n    (if (null? arr)\n        max-product-so-far\n        (let ([curr-product (apply * arr)])\n          (max-product-helper (cdr arr) (max max-product-so-far curr-product)))))\n  (max-product-helper arr 0))\n",
    "  (define (helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ([curr (car arr)])\n          (helper (cdr arr)\n                  (if (> (* curr max-so-far) max-so-far)\n                      (* curr max-so-far)\n                      max-so-far)))))\n  (helper arr 1))\n",
    "  (let loop ((arr arr) (max-product 1) (max-product-so-far 1))\n    (if (null? arr)\n        max-product-so-far\n        (let ((product (* max-product (car arr))))\n          (if (&gt; product max-product-so-far)\n              (loop (cdr arr) product product)\n              (loop (cdr arr) product max-product-so-far))))))\n</code>\n",
    "  (define (max-product-helper arr max-product-so-far)\n    (if (null? arr)\n        max-product-so-far\n        (let ((max-product-so-far (if (&gt; (car arr) 0)\n                                      (* max-product-so-far (car arr))\n                                      max-product-so-far)))\n          (max-product-helper (cdr arr) max-product-so-far))))\n  (max-product-helper arr 1))\n",
    "  (define (max-product-helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ([curr (car arr)])\n          (if (&lt; curr 0)\n              (max-product-helper (cdr arr) max-so-far)\n              (max-product-helper (cdr arr) (* curr max-so-far))))))\n  (max-product-helper arr 1))\n",
    "  (define (max-product-helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ((max-product (apply * arr)))\n          (max-product-helper (cdr arr) (max max-product max-so-far)))))\n  (max-product-helper arr 1))\n",
    "  (define (max-product-helper arr max-product-so-far)\n    (cond [(null? arr) max-product-so-far]\n          [(> (* (car arr) max-product-so-far) max-product-so-far)\n           (max-product-helper (cdr arr) (* (car arr) max-product-so-far))]\n          [else (max-product-helper (cdr arr) max-product-so-far)]))\n  (max-product-helper arr 1))\n",
    "  (define (helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let ([curr (car arr)])\n          (if (&gt; curr 0)\n              (helper (cdr arr) (* max-product curr))\n              (helper (cdr arr) max-product)))))\n  (helper arr 1))\n",
    "  (let loop ([arr arr] [max-product 0])\n    (if (null? arr)\n        max-product\n        (let ([product (* (car arr) (cadr arr))])\n          (loop (cdr arr) (if (&gt; product max-product) product max-product))))))\n</code>\n",
    "  (define (max-product-helper arr current-max current-product)\n    (cond [(empty? arr) current-max]\n          [(> (first arr) current-product)\n           (max-product-helper (rest arr)\n                               (max current-max current-product)\n                               (first arr))]\n          [else (max-product-helper (rest arr)\n                                    (max current-max current-product)\n                                    current-product)]))\n  (max-product-helper arr 0 1))\n",
    "  (define (max-product-helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ([curr (car arr)])\n          (max-product-helper (cdr arr)\n                              (if (&gt; curr 0)\n                                  (* curr max-so-far)\n                                  max-so-far)))))\n  (max-product-helper arr 1))\n",
    "  (define (max-product-helper arr max-so-far)\n    (cond\n      [(empty? arr) max-so-far]\n      [(> (first arr) (first max-so-far))\n       (max-product-helper (rest arr) (cons (first arr) (cons (* (first arr) (second max-so-far)) (rest max-so-far))))]\n      [else (max-product-helper (rest arr) max-so-far)]))\n  (max-product-helper arr (cons 0 (cons 1 empty))))\n",
    "  (let loop ((arr arr) (max-product 1))\n    (cond\n      [(empty? arr) max-product]\n      [(< (first arr) (second arr)) (loop (rest arr) (* max-product (first arr)))]\n      [else (loop (rest arr) max-product)])))\n",
    "  (define (max-product-helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let ([curr-product (apply * arr)])\n          (if (&gt; curr-product max-product)\n              (max-product-helper (cdr arr) curr-product)\n              (max-product-helper (cdr arr) max-product)))))\n  (max-product-helper arr 1))\n",
    "  (define (helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let ([curr-product (apply * arr)])\n          (if (> curr-product max-product)\n              (helper (cdr arr) curr-product)\n              (helper (cdr arr) max-product)))))\n  (helper arr 0))\n",
    "  (define (helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let ([curr-product (* (car arr) (cadr arr))])\n          (if (&gt; curr-product max-product)\n              (helper (cdr arr) curr-product)\n              (helper (cdr arr) max-product)))))\n  (helper arr 0))\n",
    "  (let loop ((arr arr) (max-product 0) (product 1))\n    (cond\n      [(null? arr) max-product]\n      [(< (car arr) (* product (car arr)))\n       (loop (cdr arr) max-product (/ product (car arr)))\n       ]\n      [else\n       (loop (cdr arr) (max max-product (* product (car arr))) (car arr))\n       ])))\n",
    "  (define (max-product-helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let ([curr-product (* (car arr) (cadr arr))])\n          (if (&gt; curr-product max-product)\n              (max-product-helper (cdr arr) curr-product)\n              (max-product-helper (cdr arr) max-product)))))\n  (max-product-helper arr 0))\n",
    "  (define (helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ([curr (car arr)])\n          (helper (cdr arr)\n                  (if (&gt; curr (* max-so-far curr))\n                      curr\n                      (* max-so-far curr))))))\n  (helper arr 1))\n",
    "  (define (helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ([curr (car arr)])\n          (helper (cdr arr)\n                  (if (&gt; curr (* max-so-far curr))\n                      curr\n                      (* max-so-far curr))))))\n  (helper arr 1))\n",
    "  (define (max-product-helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let ([curr-product (* (car arr) (cadr arr))])\n          (if (> curr-product max-product)\n              (max-product-helper (cdr arr) curr-product)\n              (max-product-helper (cdr arr) max-product)))))\n  (max-product-helper arr 0))\n",
    "  (define (max-product-helper arr max-product)\n    (if (null? arr)\n        max-product\n        (let ((new-product (* (car arr) max-product)))\n          (if (&lt; new-product max-product)\n              (max-product-helper (cdr arr) max-product)\n              (max-product-helper (cdr arr) new-product)))))\n  (max-product-helper arr 1))\n",
    "  (define (helper arr max-so-far)\n    (cond\n      [(empty? arr) max-so-far]\n      [(> (first arr) (second arr))\n       (helper (rest arr) (* (first arr) max-so-far))]\n      [else (helper (rest arr) max-so-far)]))\n  (helper arr 1))\n",
    "  (define (helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ([curr (car arr)])\n          (helper (cdr arr)\n                  (if (&gt; curr (* max-so-far curr))\n                      curr\n                      (* max-so-far curr))))))\n  (helper arr 1))\n",
    "  (define (max_product-helper arr max-so-far)\n    (cond ((null? arr) max-so-far)\n          ((< (car arr) 0) (max_product-helper (cdr arr) max-so-far))\n          ((> (car arr) max-so-far) (max_product-helper (cdr arr) (* max-so-far (car arr))))\n          (else (max_product-helper (cdr arr) max-so-far))))\n  (max_product-helper arr 1))\n",
    "  (define (max-product-helper arr max-product-so-far)\n    (cond\n      [(empty? arr) max-product-so-far]\n      [(< (first arr) 0) (max-product-helper (rest arr) (max max-product-so-far (* (first arr) max-product-so-far)))]\n      [else (max-product-helper (rest arr) (* (first arr) max-product-so-far))]))\n  (max-product-helper arr 1))\n",
    "  (define (max-product-helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ([curr (car arr)])\n          (if (null? (cdr arr))\n              (max max-so-far curr)\n              (let ([next (cadr arr)])\n                (if (&lt; curr next)\n                    (max-product-helper (cdr arr) (* max-so-far curr))\n                    (max-product-helper (cdr arr) max-so-far)))))))\n  (max-product-helper arr 1))\n</code>\n",
    "  (define (max-product-helper arr max-product-so-far)\n    (cond\n      [(empty? arr) max-product-so-far]\n      [(> (first arr) (* max-product-so-far (first arr)))\n       (max-product-helper (rest arr) (first arr))]\n      [else\n       (max-product-helper (rest arr) max-product-so-far)]))\n  (max-product-helper arr 1))\n",
    "  (define (max-product-helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ([curr-max (max-product-helper (cdr arr) max-so-far)])\n          (if (&gt; (car arr) curr-max)\n              (* curr-max (car arr))\n              curr-max))))\n  (max-product-helper arr 1))\n",
    "  (define (max-product-helper arr max-so-far)\n    (if (null? arr)\n        max-so-far\n        (let ([curr (car arr)])\n          (max-product-helper (cdr arr)\n                              (if (&gt; curr (* max-so-far curr))\n                                  curr\n                                  (* max-so-far curr))))))\n  (max-product-helper arr 1))\n",
    "  (define (max-product-helper arr max-so-far)\n    (cond\n      [(empty? arr) max-so-far]\n      [(< (first arr) 0) (max-product-helper (rest arr) max-so-far)]\n      [else (max-product-helper (rest arr) (* (first arr) max-so-far))]))\n  (max-product-helper arr 1))\n",
    "  (define (max-product-helper arr max-so-far)\n    (cond\n      [(empty? arr) max-so-far]\n      [else\n       (let ([curr (first arr)])\n         (max-product-helper (rest arr) (max max-so-far (* max-so-far curr))))]))\n  (max-product-helper arr 1))\n"
  ]
}