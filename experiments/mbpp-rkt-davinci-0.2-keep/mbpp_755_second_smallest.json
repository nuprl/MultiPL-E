{
  "name": "mbpp_755_second_smallest",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Write a function to find the second smallest number in a list.\n(define (second_smallest numbers)\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_755_second_smallest.py",
  "prompt_terminology": "verbatim",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate second_smallest))\n    (check-equal? (candidate (list 1 2 -8 -2 0 -2)) -2)\n    (check-equal? (candidate (list 1 1 -0.5 0 2 -2 -2)) -0.5)\n    (check-equal? (candidate (list 2 2)) #f)\n    (check-equal? (candidate (list 2 2 2)) #f)\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (apply min (remove (apply min numbers) numbers)))\n",
    "  (apply min (remove (apply min numbers) numbers)))\n",
    "  (define (smallest_of_rest numbers)\n    (if (null? (cdr numbers))\n        (car numbers)\n        (min (car numbers) (smallest_of_rest (cdr numbers)))))\n  (if (null? (cdr numbers))\n      (car numbers)\n      (min (car numbers) (smallest_of_rest (cdr numbers)))))\n",
    "  (define (smallest_number numbers smallest)\n    (cond\n      [(empty? numbers) smallest]\n      [(< (first numbers) smallest) (smallest_number (rest numbers) (first numbers))]\n      [else (smallest_number (rest numbers) smallest)]))\n  (define (second_smallest_number numbers smallest second_smallest)\n    (cond\n      [(empty? numbers) second_smallest]\n      [(< (first numbers) second_smallest) (second_smallest_number (rest numbers) (first numbers) second_smallest)]\n      [(< (first numbers) smallest) (second_smallest_number (rest numbers) smallest (first numbers))]\n      [else (second_smallest_number (rest numbers) smallest second_smallest)]))\n  (second_smallest_number (rest numbers) (first numbers) (first numbers)))\n",
    "  (define (smallest_of_rest numbers smallest)\n    (cond\n      [(empty? numbers) smallest]\n      [(< (first numbers) smallest) (smallest_of_rest (rest numbers) (first numbers))]\n      [else (smallest_of_rest (rest numbers) smallest)]))\n  (smallest_of_rest (rest numbers) (first numbers)))\n",
    "  (define (smallest_of_rest numbers)\n    (cond\n      [(empty? numbers) (error \"empty list\")]\n      [(empty? (rest numbers)) (first numbers)]\n      [else\n       (define smallest (first numbers))\n       (define rest (rest numbers))\n       (define smallest_of_rest (smallest_of_rest rest))\n       (if (< smallest smallest_of_rest)\n           smallest\n           smallest_of_rest)]))\n  (cond\n    [(empty? numbers) (error \"empty list\")]\n    [(empty? (rest numbers)) (error \"list has only one element\")]\n    [else\n     (define smallest (first numbers))\n     (define rest (rest numbers))\n     (define smallest_of_rest (smallest_of_rest rest))\n     (if (< smallest smallest_of_rest)\n         smallest\n         smallest_of_rest)]))\n",
    "  (apply min (remove (apply min numbers) numbers)))\n",
    "  (apply min (remove (apply min numbers) numbers)))\n",
    "  (apply min (remove (apply min numbers) numbers)))\n",
    "  (apply min (remove (apply min numbers) numbers)))\n",
    "  (apply min (remove (apply min numbers) numbers)))\n",
    "  (apply min (remove (apply min numbers) numbers)))\n",
    "  (define (smallest_of_rest numbers smallest)\n    (cond\n      [(empty? numbers) smallest]\n      [(< (first numbers) smallest) (smallest_of_rest (rest numbers) (first numbers))]\n      [else (smallest_of_rest (rest numbers) smallest)]))\n  (smallest_of_rest (rest numbers) (first numbers)))\n",
    "  (apply min (remove (apply min numbers) numbers)))\n",
    "  (apply min (remove (apply min numbers) numbers)))\n",
    "  (if (null? numbers)\n      (error \"Empty list\")\n      (let ([smallest (apply min numbers)])\n        (apply min (filter (lambda (x) (not (= x smallest))) numbers)))))\n",
    "  (define (smallest_of_rest numbers smallest)\n    (cond\n      [(empty? numbers) smallest]\n      [(< (first numbers) smallest) (smallest_of_rest (rest numbers) (first numbers))]\n      [else (smallest_of_rest (rest numbers) smallest)]))\n  (smallest_of_rest (rest numbers) (first numbers)))\n",
    "  (cond\n    [(empty? numbers) (error \"Empty list\")]\n    [(empty? (rest numbers)) (error \"List has only one element\")]\n    [else\n     (let loop ([numbers (sort numbers <)])\n       (if (equal? (first numbers) (second numbers))\n           (loop (rest numbers))\n           (first numbers)))]))\n",
    "  (cond\n    [(empty? numbers) (error \"empty list\")]\n    [(empty? (rest numbers)) (error \"list too short\")]\n    [else\n     (let ([first (first numbers)]\n           [second (first (rest numbers))])\n       (if (< first second)\n           (let loop ([numbers (rest (rest numbers))]\n                      [smallest first]\n                      [second_smallest second])\n             (cond\n               [(empty? numbers) second_smallest]\n               [(< (first numbers) smallest)\n                (loop (rest numbers) (first numbers) smallest)]\n               [(< (first numbers) second_smallest)\n                (loop (rest numbers) smallest (first numbers))]\n               [else (loop (rest numbers) smallest second_smallest)]))\n           (let loop ([numbers (rest (rest numbers))]\n                      [smallest second]\n                      [second_smallest first])\n             (cond\n               [(empty? numbers) second_smallest]\n               [(< (first numbers) smallest)\n                (loop (rest numbers) (first numbers) smallest)]\n               [(< (first numbers) second_smallest)\n                (loop (rest numbers) smallest (first numbers))]\n               [else (loop (rest numbers) smallest second_smallest)]))))]))\n",
    "  (apply min (remove (apply min numbers) numbers)))\n"
  ]
}