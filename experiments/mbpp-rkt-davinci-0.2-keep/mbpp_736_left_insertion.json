{
  "name": "mbpp_736_left_insertion",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Write a function to locate the left insertion point for a specified value in sorted order. https://www.w3resource.com/python-exercises/data-structures-and-algorithms/python-data-structure-exercise-24.php\n(define (left_insertion a x)\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_736_left_insertion.py",
  "prompt_terminology": "verbatim",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate left_insertion))\n    (check-equal? (candidate (list 1 2 4 5) 6) 4)\n    (check-equal? (candidate (list 1 2 4 5) 3) 2)\n    (check-equal? (candidate (list 1 2 4 5) 7) 4)\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (let loop ((i 0) (j (vector-length a)) (k (/ (+ i j) 2)))\n    (cond ((= i j) i)\n          ((< (vector-ref a k) x) (loop (+ k 1) j (+ (/ (+ k j) 2) 1)))\n          (else (loop i k (/ (+ i k) 2))))))\n",
    "  (define (left_insertion_iter a x i)\n    (cond\n      [(> i (sub1 (length a))) (length a)]\n      [(< x (vector-ref a i)) i]\n      [else (left_insertion_iter a x (add1 i))]))\n  (left_insertion_iter a x 0))\n",
    "  (define (left_insertion_iter a x i)\n    (cond\n      [(= i (length a)) i]\n      [(< x (vector-ref a i)) i]\n      [else (left_insertion_iter a x (+ i 1))]))\n  (left_insertion_iter a x 0))\n",
    "  (let loop ([i 0])\n    (if (= i (length a))\n        i\n        (if (<= (list-ref a i) x)\n            (loop (+ i 1))\n            i))))\n",
    "  (define (left_insertion_iter a x i)\n    (cond\n      [(= i (length a)) i]\n      [(>= x (list-ref a i)) (left_insertion_iter a x (+ i 1))]\n      [else i]))\n  (left_insertion_iter a x 0))\n",
    "  (let loop ((i 0) (j (length a)))\n    (if (= i j)\n        i\n        (let ((mid (quotient (+ i j) 2)))\n          (if (< x (vector-ref a mid))\n              (loop i mid)\n              (loop mid j))))))\n",
    "  (let loop ([i 0])\n    (if (= i (length a))\n        i\n        (if (<= (list-ref a i) x)\n            (loop (+ i 1))\n            i))))\n",
    "  (let loop ([i 0])\n    (if (= i (length a))\n        i\n        (if (<= (list-ref a i) x)\n            (loop (+ i 1))\n            i))))\n",
    "  (let loop ((i 0) (j (length a)))\n    (if (= i j)\n        i\n        (let ((mid (quotient (+ i j) 2)))\n          (if (<= x (vector-ref a mid))\n              (loop i mid)\n              (loop mid j))))))\n",
    "  (define (left_insertion_iter a x i)\n    (cond\n      [(empty? a) i]\n      [(>= (first a) x) i]\n      [else (left_insertion_iter (rest a) x (+ i 1))]))\n  (left_insertion_iter a x 0))\n",
    "  (define (left_insertion-iter a x i)\n    (cond\n      [(= i 0) 0]\n      [(< x (vector-ref a i)) i]\n      [else (left_insertion-iter a x (- i 1))]))\n  (left_insertion-iter a x (- (vector-length a) 1)))\n",
    "  (cond [(empty? a) empty]\n        [(< (first a) x) (cons (first a) (left_insertion (rest a) x))]\n        [else empty]))\n",
    "  (let loop ([i 0])\n    (if (= i (length a))\n        i\n        (if (< (list-ref a i) x)\n            (loop (+ i 1))\n            i))))\n",
    "  (cond\n    [(empty? a) empty]\n    [(< x (first a)) empty]\n    [(= x (first a)) a]\n    [else (left_insertion (rest a) x)]))\n",
    "  (let loop ([i 0])\n    (cond\n      [(= i (length a)) i]\n      [(>= (vector-ref a i) x) i]\n      [else (loop (+ i 1))])))\n",
    "  (define (left_insertion_iter a x lo hi)\n    (cond ((> lo hi) lo)\n          ((< x (vector-ref a lo)) lo)\n          ((> x (vector-ref a hi)) (+ hi 1))\n          (else (left_insertion_iter a x (+ lo 1) (- hi 1)))))\n  (left_insertion_iter a x 0 (- (vector-length a) 1)))\n",
    "  (define (left_insertion_iter a x i)\n    (cond\n      [(>= i (length a)) i]\n      [(>= (vector-ref a i) x) i]\n      [else (left_insertion_iter a x (+ i 1))]))\n  (left_insertion_iter a x 0))\n",
    "  (let loop ((i 0) (j (length a)))\n    (if (&lt; i j)\n        (let ((k (quotient (+ i j) 2)))\n          (cond ((&lt; x (vector-ref a k)) (loop i k))\n                ((&gt; x (vector-ref a k)) (loop (+ k 1) j))\n                (else k)))\n        i)))\n</code>\n",
    "  (cond [(empty? a) empty]\n        [(<= x (first a)) 0]\n        [(left_insertion (rest a) x) (+ 1 (left_insertion (rest a) x))]))\n",
    "  (cond\n    [(empty? a) empty]\n    [(< (first a) x) (cons (first a) (left_insertion (rest a) x))]\n    [else empty]))\n"
  ]
}