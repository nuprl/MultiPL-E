{
  "name": "mbpp_87_merge_dictionaries_three",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Write a function to merge three dictionaries into a single dictionary.\n(define (merge_dictionaries_three dict1 dict2 dict3)\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_87_merge_dictionaries_three.py",
  "prompt_terminology": "verbatim",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate merge_dictionaries_three))\n    (check-equal? (candidate #hash((\"R\" .  \"Red\") (\"B\" .  \"Black\") (\"P\" .  \"Pink\")) #hash((\"G\" .  \"Green\") (\"W\" .  \"White\")) #hash((\"O\" .  \"Orange\") (\"W\" .  \"White\") (\"B\" .  \"Black\"))) #hash((\"B\" .  \"Black\") (\"R\" .  \"Red\") (\"P\" .  \"Pink\") (\"G\" .  \"Green\") (\"W\" .  \"White\") (\"O\" .  \"Orange\")))\n    (check-equal? (candidate #hash((\"R\" .  \"Red\") (\"B\" .  \"Black\") (\"P\" .  \"Pink\")) #hash((\"G\" .  \"Green\") (\"W\" .  \"White\")) #hash((\"L\" .  \"lavender\") (\"B\" .  \"Blue\"))) #hash((\"W\" .  \"White\") (\"P\" .  \"Pink\") (\"B\" .  \"Black\") (\"R\" .  \"Red\") (\"G\" .  \"Green\") (\"L\" .  \"lavender\")))\n    (check-equal? (candidate #hash((\"R\" .  \"Red\") (\"B\" .  \"Black\") (\"P\" .  \"Pink\")) #hash((\"L\" .  \"lavender\") (\"B\" .  \"Blue\")) #hash((\"G\" .  \"Green\") (\"W\" .  \"White\"))) #hash((\"B\" .  \"Black\") (\"P\" .  \"Pink\") (\"R\" .  \"Red\") (\"G\" .  \"Green\") (\"L\" .  \"lavender\") (\"W\" .  \"White\")))\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (let ([dict (merge_dictionaries dict1 dict2)])\n    (merge_dictionaries dict dict3)))\n",
    "  (define (merge_dictionaries_two dict1 dict2)\n    (define (merge_dictionaries_one dict1 dict2)\n      (define (merge_dictionaries_one_helper dict1 dict2)\n        (cond ((null? dict1) dict2)\n              ((null? dict2) dict1)\n              (else (cons (cons (car (car dict1)) (cons (cdr (car dict1)) (cdr (car dict2))))\n                         (merge_dictionaries_one_helper (cdr dict1) (cdr dict2))))))\n      (merge_dictionaries_one_helper dict1 dict2))\n    (merge_dictionaries_one (merge_dictionaries_one dict1 dict2) dict3))\n  (merge_dictionaries_two (merge_dictionaries_two dict1 dict2) dict3))\n",
    "  (define (merge_dictionaries_two dict1 dict2)\n    (cond [(empty? dict1) dict2]\n          [(empty? dict2) dict1]\n          [else (define (merge_dictionaries_one dict1 dict2)\n                 (cond [(empty? dict1) dict2]\n                       [(empty? dict2) dict1]\n                       [else (merge_dictionaries_one (rest dict1) (rest dict2))]))\n                (cons (cons (key dict1) (key dict2)) (merge_dictionaries_one (rest dict1) (rest dict2)))]))\n  (merge_dictionaries_two (merge_dictionaries_two dict1 dict2) dict3))\n",
    "  (cond\n    [(empty? dict1) dict2]\n    [(empty? dict2) dict1]\n    [(empty? dict3) (merge_dictionaries_two dict1 dict2)]\n    [else\n     (define key1 (first-key dict1))\n     (define key2 (first-key dict2))\n     (define key3 (first-key dict3))\n     (cond\n       [(and (equal? key1 key2) (equal? key2 key3))\n        (merge_dictionaries_three (rest dict1) (rest dict2) (rest dict3))]\n       [(and (equal? key1 key2) (not (equal? key2 key3)))\n        (merge_dictionaries_three (rest dict1) (rest dict2) dict3)]\n       [(and (not (equal? key1 key2)) (equal? key2 key3))\n        (merge_dictionaries_three dict1 (rest dict2) (rest dict3))]\n       [(and (not (equal? key1 key2)) (not (equal? key2 key3)))\n        (merge_dictionaries_three dict1 dict2 (rest dict3))])]))\n",
    "  (define (merge_dictionaries_two dict1 dict2)\n    (define (merge_dictionaries_one dict1 dict2)\n      (cond ((null? dict1) dict2)\n            ((null? dict2) dict1)\n            (else (cons (cons (car (car dict1)) (cdr (car dict1)))\n                        (merge_dictionaries_one (cdr dict1) dict2)))))\n    (merge_dictionaries_one dict1 dict2))\n  (merge_dictionaries_two (merge_dictionaries_two dict1 dict2) dict3))\n",
    "  (define (merge_dictionaries_two dict1 dict2)\n    (define (merge_dictionaries_one dict1 dict2)\n      (cond\n        [(empty? dict1) dict2]\n        [(empty? dict2) dict1]\n        [(assoc dict1 (first dict2)) (merge_dictionaries_one dict1 (rest dict2))]\n        [else (cons (first dict2) (merge_dictionaries_one dict1 (rest dict2)))]))\n    (merge_dictionaries_one dict1 dict2))\n  (merge_dictionaries_two (merge_dictionaries_two dict1 dict2) dict3))\n",
    "  (let ([merged (merge-dicts dict1 dict2)])\n    (merge-dicts merged dict3)))\n",
    "  (define (merge_dictionaries dict1 dict2)\n    (for/fold ([result '()])\n              ([key (in-list (append (hash-keys dict1) (hash-keys dict2)))]\n               #:when (not (member key result)))\n      (hash-set result key (hash-ref dict1 key (hash-ref dict2 key '())))))\n  (merge_dictionaries (merge_dictionaries dict1 dict2) dict3))\n",
    "  (let ([merged-dict (merge-dicts dict1 dict2)])\n    (merge-dicts merged-dict dict3)))\n",
    "  (let ([dict (merge_dictionaries dict1 dict2)])\n    (merge_dictionaries dict dict3)))\n",
    "  (define (merge_dictionaries_two dict1 dict2)\n    (cond ((null? dict1) dict2)\n          ((null? dict2) dict1)\n          (else (cons (cons (car (car dict1)) (cons (cadr (car dict1)) (cadr (car dict2))))\n                      (merge_dictionaries_two (cdr dict1) (cdr dict2))))))\n  (merge_dictionaries_two (merge_dictionaries_two dict1 dict2) dict3))\n",
    "  (let ([dict (merge-dict dict1 dict2)])\n    (merge-dict dict dict3)))\n",
    "  (let ([keys (append (hash-keys dict1) (hash-keys dict2) (hash-keys dict3))])\n    (hash-map (lambda (key)\n                (cond\n                  [(hash-has-key? dict1 key) (hash-ref dict1 key)]\n                  [(hash-has-key? dict2 key) (hash-ref dict2 key)]\n                  [(hash-has-key? dict3 key) (hash-ref dict3 key)]\n                  [else (error 'merge_dictionaries_three \"Key not found\")]))\n              keys)))\n",
    "  (let ([merged-dict (merge_dictionaries dict1 dict2)])\n    (merge_dictionaries merged-dict dict3)))\n",
    "  (let ([dict (merge-dict dict1 dict2)])\n    (merge-dict dict dict3)))\n",
    "  (define (merge_dictionaries_two dict1 dict2)\n    (define (merge_dictionaries_one dict1 dict2)\n      (cond\n        [(empty? dict1) dict2]\n        [(empty? dict2) dict1]\n        [(equal? (first dict1) (first dict2))\n         (cons (first dict1) (cons (second dict1) (merge_dictionaries_one (rest dict1) (rest dict2))))]\n        [(string<? (first dict1) (first dict2))\n         (cons (first dict1) (merge_dictionaries_one (rest dict1) dict2))]\n        [else\n         (cons (first dict2) (merge_dictionaries_one dict1 (rest dict2)))]))\n    (merge_dictionaries_one dict1 dict2))\n  (merge_dictionaries_two (merge_dictionaries_two dict1 dict2) dict3))\n",
    "  (let ([merged-dict (merge-dicts dict1 dict2)])\n    (merge-dicts merged-dict dict3)))\n",
    "  (define (merge_dictionaries_two dict1 dict2)\n    (define (merge_dictionaries_one dict1 dict2)\n      (cond\n        [(empty? dict1) dict2]\n        [(empty? dict2) dict1]\n        [else (cons (cons (key dict1) (cons (value dict1) (value dict2)))\n                    (merge_dictionaries_one (rest dict1) (rest dict2)))]))\n    (merge_dictionaries_one dict1 dict2))\n  (merge_dictionaries_two (merge_dictionaries_two dict1 dict2) dict3))\n",
    "  (define (merge_dictionaries_two dict1 dict2)\n    (define (merge_dictionaries_one dict1 dict2)\n      (cond\n        [(empty? dict1) dict2]\n        [(empty? dict2) dict1]\n        [else (cons (cons (key dict1) (cons (value dict1) (value dict2)))\n                    (merge_dictionaries_one (rest dict1) (rest dict2)))]))\n    (merge_dictionaries_one dict1 dict2))\n  (merge_dictionaries_two (merge_dictionaries_two dict1 dict2) dict3))\n",
    "  (define (merge_dictionaries_two dict1 dict2)\n    (for/fold ([dict (make-hash)])\n              ([(k v) (in-hash dict1)])\n      (hash-set! dict k v)\n      dict))\n  (define (merge_dictionaries_two_into_one dict1 dict2)\n    (for/fold ([dict (make-hash)])\n              ([(k v) (in-hash dict2)])\n      (hash-set! dict k v)\n      dict))\n  (merge_dictionaries_two_into_one (merge_dictionaries_two dict1 dict2) dict3))\n"
  ]
}