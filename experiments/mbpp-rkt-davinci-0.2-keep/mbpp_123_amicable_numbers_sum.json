{
  "name": "mbpp_123_amicable_numbers_sum",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Write a function to sum all amicable numbers from 1 to a specified number.\n(define (amicable_numbers_sum limit)\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_123_amicable_numbers_sum.py",
  "prompt_terminology": "verbatim",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate amicable_numbers_sum))\n    (check-equal? (candidate 999) 504)\n    (check-equal? (candidate 9999) 31626)\n    (check-equal? (candidate 99) 0)\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (define (amicable-numbers-sum-iter limit sum)\n    (cond ((&gt; limit 1)\n           (let ((d (sum-of-divisors (- limit 1))))\n             (if (and (= d limit) (&gt; d 1))\n                 (amicable-numbers-sum-iter (- limit 1) (+ sum limit))\n               (amicable-numbers-sum-iter (- limit 1) sum))))\n          (else sum)))\n  (amicable-numbers-sum-iter limit 0))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (modulo n x))) (range 1 (add1 (quotient n 2)))))\n  (define (amicable? n)\n    (let ((n2 (sum (divisors n))))\n      (and (= n2 (sum (divisors n2)))\n           (not (= n n2)))))\n  (sum (filter amicable? (range 1 limit))))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (modulo n x))) (range 1 (add1 (quotient n 2)))))\n  (define (sum-divisors n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((m (sum-divisors n)))\n      (and (not (= n m)) (= n (sum-divisors m)))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (amicable-pairs limit)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (when (zero? (modulo n i))\n          i)))\n    (define (sum-divisors n)\n      (apply + (divisors n)))\n    (for/list ([i (in-range 1 limit)])\n      (let ([sum (sum-divisors i)])\n        (when (and (not (zero? sum))\n                   (= (sum-divisors sum) i))\n          (list i sum)))))\n  (apply + (apply append (amicable-pairs limit))))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (modulo n x)))\n            (range 1 (add1 (quotient n 2)))))\n  (define (sum_of_divisors n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((m (sum_of_divisors n)))\n      (and (not (= n m))\n           (= n (sum_of_divisors m)))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= (remainder n x) 0))\n            (range 1 (add1 (quotient n 2)))))\n  (define (amicable? n)\n    (let ((n2 (sum (divisors n))))\n      (and (not (= n n2))\n           (= n (sum (divisors n2))))))\n  (sum (filter amicable? (range 1 limit))))\n",
    "  (define (sum-divisors n)\n    (define (sum-divisors-iter n sum)\n      (if (= n 1)\n          sum\n          (if (= (remainder n 2) 0)\n              (sum-divisors-iter (/ n 2) (+ sum (/ n 2)))\n              (sum-divisors-iter (- n 1) (+ sum (divisor n)))\n              )))\n    (sum-divisors-iter n 0))\n  (define (divisor n)\n    (define (divisor-iter n divisor)\n      (if (= (remainder n divisor) 0)\n          divisor\n          (divisor-iter n (+ divisor 1))))\n    (divisor-iter n 1))\n  (define (amicable-numbers-sum-iter n sum)\n    (if (= n limit)\n        sum\n        (if (= (sum-divisors (+ n 1)) n)\n            (amicable-numbers-sum-iter (+ n 1) (+ sum n))\n            (amicable-numbers-sum-iter (+ n 1) sum))))\n  (amicable-numbers-sum-iter 1 0))\n",
    "  (let loop ((i 1) (sum 0))\n    (cond ((&gt; i limit) sum)\n          ((= (sum_of_divisors i) (+ i (sum_of_divisors (sum_of_divisors i))))\n           (loop (+ i 1) (+ sum i (sum_of_divisors i))))\n          (else (loop (+ i 1) sum)))))\n",
    "  (define (amicable-pair? a b)\n    (and (= a (sum-of-divisors b))\n         (= b (sum-of-divisors a))))\n  (define (sum-of-divisors n)\n    (define (sum-of-divisors-iter n i sum)\n      (cond ((&gt; i n) sum)\n            ((divides? i n) (sum-of-divisors-iter n (+ i 1) (+ sum i)))\n            (else (sum-of-divisors-iter n (+ i 1) sum))))\n    (sum-of-divisors-iter n 1 0))\n  (define (divides? a b)\n    (= (remainder b a) 0))\n  (define (sum-of-amicable-numbers-iter n i sum)\n    (cond ((&gt; i n) sum)\n          ((amicable-pair? i (sum-of-divisors i)) (sum-of-amicable-numbers-iter n (+ i 1) (+ sum i)))\n          (else (sum-of-amicable-numbers-iter n (+ i 1) sum))))\n  (sum-of-amicable-numbers-iter limit 1 0))\n</code>\n",
    "  (define (amicable-pair? a b)\n    (and (= (sum-of-divisors a) b)\n         (= (sum-of-divisors b) a)))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (/ n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (define (amicable-numbers)\n    (for/list ([i (in-range 1 limit)])\n      (for/list ([j (in-range 1 limit)])\n        (if (amicable-pair? i j) i))))\n  (apply + (amicable-numbers)))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (remainder n x)))\n            (range 1 (add1 (quotient n 2)))))\n  (define (amicable? n)\n    (let ((dn (apply + (divisors n))))\n      (and (not (= n dn)) (= n (apply + (divisors dn))))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (amicable-pair? a b)\n    (and (= (sum-of-divisors a) b)\n         (= (sum-of-divisors b) a)))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (quotient n 2))]\n                 #:when (zero? (remainder n i)))\n        i))\n    (apply + (divisors n)))\n  (define (amicable-numbers)\n    (for/list ([i (in-range 1 limit)]\n               [j (in-range 1 limit)])\n      (when (amicable-pair? i j)\n        i)))\n  (apply + (amicable-numbers)))\n",
    "  (define (amicable? n)\n    (let ((n-divisors (divisors n)))\n      (and (not (null? n-divisors))\n           (= n (apply + (map (lambda (x) (- x)) n-divisors)))\n           (= (apply + n-divisors) n))))\n  (define (divisors n)\n    (filter (lambda (x) (= (remainder n x) 0))\n            (range 1 (quotient n 2))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (amicable-number? n)\n    (let ([m (sum-of-divisors n)])\n      (and (not (= n m)) (= n (sum-of-divisors m)))))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (apply + (filter amicable-number? (in-range 1 limit))))\n",
    "  (define (amicable-pair? a b)\n    (and (= (sum-of-divisors a) b)\n         (= (sum-of-divisors b) a)))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (remainder n i)) i)))\n    (apply + (divisors n)))\n  (define (amicable-numbers n)\n    (for/list ([i (in-range 1 n)])\n      (if (amicable-pair? i (sum-of-divisors i)) i)))\n  (apply + (amicable-numbers limit)))\n",
    "  (define (amicable? n)\n    (let ((m (sum_of_divisors n)))\n      (and (not (= n m)) (= n (sum_of_divisors m)))))\n  (define (sum_of_divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (remainder n x)))\n            (range 1 (add1 (quotient n 2)))))\n  (define (sum_divisors n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((m (sum_divisors n)))\n      (and (not (= n m))\n           (= (sum_divisors m) n))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (remainder n x)))\n            (range 1 (add1 (quotient n 2)))))\n  (define (amicable? n)\n    (let ((m (apply + (divisors n))))\n      (and (not (= n m))\n           (= n (apply + (divisors m))))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (sum-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (define (is-amicable? n)\n    (let ([sum-n (sum-divisors n)])\n      (and (not (zero? sum-n))\n           (equal? n (sum-divisors sum-n)))))\n  (apply + (for/list ([i (in-range 1 limit)])\n              (if (is-amicable? i) i))))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (modulo n x))) (range 1 (quotient n 2))))\n  (define (sum_divisors n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (and (= n (sum_divisors (sum_divisors n)))\n         (not (= n (sum_divisors n)))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (modulo n x)))\n            (range 1 (add1 (quotient n 2)))))\n  (define (amicable? n)\n    (let ((n2 (sum (divisors n))))\n      (and (= n (sum (divisors n2)))\n           (/= n n2))))\n  (sum (filter amicable? (range 1 limit))))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (remainder n x)))\n            (range 1 (add1 (quotient n 2)))))\n  (define (sum_divisors n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((m (sum_divisors n)))\n      (and (= n (sum_divisors m))\n           (not (= n m)))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (amicable? a)\n    (let ((b (sum-of-divisors a)))\n      (and (not (= a b)) (= a (sum-of-divisors b)))))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (apply + (for/list ([i (in-range 1 limit)])\n            (if (amicable? i) i))))\n",
    "  (define (sum_divisors n)\n    (define (sum_divisors_iter n sum)\n      (cond\n        [(= n 1) sum]\n        [(= (modulo n 2) 0) (sum_divisors_iter (/ n 2) (+ sum n))]\n        [else (sum_divisors_iter (- n 1) sum)]))\n    (sum_divisors_iter n 0))\n  (define (is_amicable? n)\n    (let ([m (sum_divisors n)])\n      (and (= n (sum_divisors m))\n           (not (= n m)))))\n  (define (amicable_numbers_sum_iter n sum)\n    (cond\n      [(= n limit) sum]\n      [(is_amicable? n) (amicable_numbers_sum_iter (+ n 1) (+ sum n))]\n      [else (amicable_numbers_sum_iter (+ n 1) sum)]))\n  (amicable_numbers_sum_iter 1 0))\n",
    "  (define (divisors n)\n    (for/list ([i (in-range 1 (quotient n 2))]\n               #:when (zero? (modulo n i)))\n      i))\n  (define (sum-divisors n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ([s (sum-divisors n)])\n      (and (not (zero? s))\n           (equal? n (sum-divisors s)))))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (amicable? a)\n    (let ((b (sum-of-divisors a)))\n      (and (= a (sum-of-divisors b))\n           (not (= a b)))))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (quotient n 2))]\n                 #:when (zero? (modulo n i)))\n        i))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (sum_divisors n)\n    (define (sum_divisors-iter n i sum)\n      (cond\n        [(= i n) sum]\n        [(= 0 (modulo n i)) (sum_divisors-iter n (+ i 1) (+ sum i))]\n        [else (sum_divisors-iter n (+ i 1) sum)]))\n    (sum_divisors-iter n 1 0))\n  (define (is_amicable n)\n    (let ([m (sum_divisors n)])\n      (and (= n (sum_divisors m))\n           (not (= n m)))))\n  (define (amicable-numbers-sum-iter n sum)\n    (cond\n      [(= n limit) sum]\n      [(is_amicable n) (amicable-numbers-sum-iter (+ n 1) (+ sum n))]\n      [else (amicable-numbers-sum-iter (+ n 1) sum)]))\n  (amicable-numbers-sum-iter 1 0))\n",
    "  (define (divisors n)\n    (define (divisors-helper n divisors)\n      (if (= n 1)\n          divisors\n          (if (= (modulo n (car divisors)) 0)\n              (divisors-helper (/ n (car divisors)) (cons (car divisors) divisors))\n              (divisors-helper n (cdr divisors)))))\n    (divisors-helper n (range 2 (ceiling (sqrt n)))))\n  (define (sum-divisors n)\n    (apply + (divisors n)))\n  (define (amicable-numbers-sum-helper n sum)\n    (if (= n limit)\n        sum\n        (let ((sum-of-divisors (sum-divisors n)))\n          (if (= (sum-divisors sum-of-divisors) n)\n              (if (and (/= n sum-of-divisors)\n                       (/= n 1))\n                  (amicable-numbers-sum-helper (+ n 1) (+ sum n sum-of-divisors))\n                  (amicable-numbers-sum-helper (+ n 1) sum))\n              (amicable-numbers-sum-helper (+ n 1) sum)))))\n  (amicable-numbers-sum-helper 1 0))\n",
    "  (define (amicable? n)\n    (let ((m (sum_of_divisors n)))\n      (and (= n (sum_of_divisors m))\n           (/= n m))))\n  (define (sum_of_divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (amicable-pair? n)\n    (let ((m (sum-of-proper-divisors n)))\n      (and (not (= n m))\n           (= (sum-of-proper-divisors m) n))))\n  (define (sum-of-proper-divisors n)\n    (define (divisors n)\n      (define (divisors-iter n i)\n        (cond ((= n 1) '())\n              ((= (remainder n i) 0) (cons i (divisors-iter (/ n i) i)))\n              (else (divisors-iter n (+ i 1)))))\n      (divisors-iter n 2))\n    (apply + (divisors n)))\n  (define (amicable-numbers-sum-iter n sum)\n    (cond ((&gt; n limit) sum)\n          ((amicable-pair? n) (amicable-numbers-sum-iter (+ n 1) (+ sum n)))\n          (else (amicable-numbers-sum-iter (+ n 1) sum))))\n  (amicable-numbers-sum-iter 1 0))\n</code>\n",
    "  (define (amicable-numbers-sum-iter limit sum)\n    (cond\n      [(= limit 1) sum]\n      [(amicable? limit) (amicable-numbers-sum-iter (- limit 1) (+ limit sum))]\n      [else (amicable-numbers-sum-iter (- limit 1) sum)]))\n  (amicable-numbers-sum-iter limit 0))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= (modulo n x) 0)) (range 1 (add1 (quotient n 2)))))\n  (define (sum_divisors n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((s (sum_divisors n)))\n      (and (not (= n s)) (= (sum_divisors s) n))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (modulo n x))) (range 1 (add1 (quotient n 2)))))\n  (define (sum_divisors n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (define (amicable?-helper n)\n      (let ((sum-divisors (sum_divisors n)))\n        (and (not (= n sum-divisors)) (= (sum_divisors sum-divisors) n))))\n    (amicable?-helper n))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (amicable? n)\n    (let ((m (sum_of_proper_divisors n)))\n      (and (not (= n m)) (= n (sum_of_proper_divisors m)))))\n  (define (sum_of_proper_divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (quotient n 2))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (apply + (for/list ([n (in-range 1 limit)])\n            (if (amicable? n) n 0))))\n",
    "  (define (amicable? a)\n    (let ((b (sum-divisors a)))\n      (and (not (= a b))\n           (= a (sum-divisors b)))))\n  (define (sum-divisors n)\n    (let loop ((i 1) (sum 0))\n      (cond ((= i n) sum)\n            ((divides? i n) (loop (+ i 1) (+ sum i)))\n            (else (loop (+ i 1) sum)))))\n  (define (divides? a b)\n    (= (remainder b a) 0))\n  (let loop ((i 1) (sum 0))\n    (cond ((&gt; i limit) sum)\n          ((amicable? i) (loop (+ i 1) (+ sum i)))\n          (else (loop (+ i 1) sum)))))\n</code>\n",
    "  (define (amicable-pair? a b)\n    (and (= (sum-of-divisors a) b) (= (sum-of-divisors b) a)))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (define (amicable-numbers n)\n    (for/list ([i (in-range 1 n)])\n      (if (amicable-pair? i (sum-of-divisors i)) i)))\n  (apply + (amicable-numbers limit)))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (modulo n x))) (range 1 (add1 (quotient n 2)))))\n  (define (sum_divisors n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((n2 (sum_divisors n)))\n      (and (= n (sum_divisors n2))\n           (not (= n n2)))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (amicable? n)\n    (let ((m (sum_proper_divisors n)))\n      (and (not (= n m)) (= (sum_proper_divisors m) n))))\n  (define (sum_proper_divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (quotient n 2))]\n                 #:when (zero? (remainder n i)))\n        i))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (sum-divisors n)\n    (define (sum-divisors-iter n sum)\n      (cond\n        [(= n 1) sum]\n        [(= (remainder n 2) 0) (sum-divisors-iter (/ n 2) (+ sum n))]\n        [(= (remainder n 3) 0) (sum-divisors-iter (/ n 3) (+ sum n))]\n        [(= (remainder n 5) 0) (sum-divisors-iter (/ n 5) (+ sum n))]\n        [(= (remainder n 7) 0) (sum-divisors-iter (/ n 7) (+ sum n))]\n        [else (sum-divisors-iter (/ n 11) (+ sum n))]))\n    (sum-divisors-iter n 0))\n  (define (sum-amicable-numbers-iter n sum)\n    (cond\n      [(= n limit) sum]\n      [(= (sum-divisors n) (sum-divisors (sum-divisors n))) (sum-amicable-numbers-iter (+ n 1) (+ sum n))]\n      [else (sum-amicable-numbers-iter (+ n 1) sum)]))\n  (sum-amicable-numbers-iter 1 0))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (modulo n x)))\n            (range 1 (add1 (quotient n 2)))))\n  (define (sum_divisors n)\n    (apply + (divisors n)))\n  (define (is_amicable? n)\n    (let ((m (sum_divisors n)))\n      (and (not (= n m)) (= n (sum_divisors m)))))\n  (apply + (filter is_amicable? (range 1 limit))))\n",
    "  (define (amicable-sum n)\n    (define (divisors n)\n      (filter (lambda (x) (= 0 (modulo n x))) (range 1 (add1 (quotient n 2)))))\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((n2 (amicable-sum n)))\n      (and (not (= n n2)) (= n (amicable-sum n2)))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= (remainder n x) 0)) (range 1 (add1 (quotient n 2)))))\n  (define (divisors-sum n)\n    (apply + (divisors n)))\n  (define (amicable-pair? n)\n    (let ((m (divisors-sum n)))\n      (and (not (= n m)) (= (divisors-sum m) n))))\n  (apply + (filter amicable-pair? (range 1 limit))))\n",
    "  (define (amicable-pair? a b)\n    (and (= (sum-of-divisors a) b)\n         (= (sum-of-divisors b) a)))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (define (divisors-helper n i)\n        (if (> i n)\n            '()\n            (if (zero? (modulo n i))\n                (cons i (divisors-helper n (+ i 1)))\n                (divisors-helper n (+ i 1)))))\n      (divisors-helper n 1))\n    (apply + (divisors n)))\n  (define (amicable-numbers-sum-helper n sum)\n    (if (= n limit)\n        sum\n        (if (amicable-pair? n (sum-of-divisors n))\n            (amicable-numbers-sum-helper (+ n 1) (+ sum n))\n            (amicable-numbers-sum-helper (+ n 1) sum))))\n  (amicable-numbers-sum-helper 1 0))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (modulo n x)))\n            (range 1 (add1 (quotient n 2)))))\n  (define (sum_divisors n)\n    (apply + (divisors n)))\n  (define (is_amicable n)\n    (let ((sum_divisors_n (sum_divisors n)))\n      (and (not (= n sum_divisors_n))\n           (= n (sum_divisors sum_divisors_n)))))\n  (apply + (filter is_amicable (range 1 limit))))\n",
    "  (define (amicable? n)\n    (let ((m (sum_of_divisors n)))\n      (and (not (= n m)) (= n (sum_of_divisors m)))))\n  (define (sum_of_divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (amicable? n)\n    (let ((m (sum-of-divisors n)))\n      (and (not (= n m)) (= (sum-of-divisors m) n))))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (quotient n 2))]\n                 #:when (zero? (remainder n i)))\n        i))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (sum-of-divisors n)\n    (define (sum-of-divisors-iter n acc)\n      (cond ((= n 1) acc)\n            ((= (remainder n 2) 0) (sum-of-divisors-iter (/ n 2) (+ acc n)))\n            ((= (remainder n 3) 0) (sum-of-divisors-iter (/ n 3) (+ acc n)))\n            ((= (remainder n 5) 0) (sum-of-divisors-iter (/ n 5) (+ acc n)))\n            ((= (remainder n 7) 0) (sum-of-divisors-iter (/ n 7) (+ acc n)))\n            (else (sum-of-divisors-iter (- n 1) (+ acc n)))))\n    (sum-of-divisors-iter n 0))\n  (define (is-amicable? n)\n    (let ((m (sum-of-divisors n)))\n      (and (= (sum-of-divisors m) n)\n           (not (= n m)))))\n  (define (amicable-numbers-sum-iter n acc)\n    (cond ((= n limit) acc)\n          ((is-amicable? n) (amicable-numbers-sum-iter (+ n 1) (+ acc n)))\n          (else (amicable-numbers-sum-iter (+ n 1) acc))))\n  (amicable-numbers-sum-iter 1 0))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (modulo n x))) (range 1 (add1 (quotient n 2)))))\n  (define (sum_divisors n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((sum_n (sum_divisors n)))\n      (and (not (= n sum_n)) (= n (sum_divisors sum_n)))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (amicable? a)\n    (let ((b (sum_of_divisors a)))\n      (and (not (= a b)) (= (sum_of_divisors b) a))))\n  (define (sum_of_divisors n)\n    (define (divisors n)\n      (let loop ((i 1) (acc '()))\n        (cond ((= i n) acc)\n              ((divides? i n) (loop (+ i 1) (cons i acc)))\n              (else (loop (+ i 1) acc)))))\n    (foldl + 0 (divisors n)))\n  (define (divides? a b) (= (remainder b a) 0))\n  (foldl + 0 (filter amicable? (range 1 limit))))\n",
    "  (define (amicable? a)\n    (let ([b (sum_of_divisors a)])\n      (and (not (= a b)) (= a (sum_of_divisors b)))))\n  (define (sum_of_divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))]\n                  #:when (zero? (remainder n i)))\n        i))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (amicable-pair? a b)\n    (and (= (sum-of-divisors a) b)\n         (= (sum-of-divisors b) a)))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (filter (lambda (x) (= (modulo n x) 0))\n              (range 1 (add1 (quotient n 2)))))\n    (apply + (divisors n)))\n  (apply +\n         (filter (lambda (x) (amicable-pair? x (sum-of-divisors x)))\n                 (range 1 limit))))\n",
    "  (define (amicable-pair? a b)\n    (and (= (sum-of-divisors a) b) (= (sum-of-divisors b) a)))\n  (define (sum-of-divisors n)\n    (apply + (filter (lambda (x) (= 0 (modulo n x))) (range 1 (quotient n 2)))))\n  (define (amicable-numbers-sum-helper n sum)\n    (if (&gt; n limit)\n        sum\n        (if (amicable-pair? n (sum-of-divisors n))\n            (amicable-numbers-sum-helper (+ n 1) (+ sum n))\n            (amicable-numbers-sum-helper (+ n 1) sum))))\n  (amicable-numbers-sum-helper 1 0))\n</code>\nI'm not sure if this is the best way to do it, but it seems to work.\n",
    "  (define (amicable? n)\n    (let ([m (sum_of_divisors n)])\n      (and (not (= n m)) (= (sum_of_divisors m) n))))\n  (define (sum_of_divisors n)\n    (let loop ([i 1] [sum 0])\n      (if (&gt; i (/ n 2))\n          sum\n          (if (zero? (modulo n i))\n              (loop (+ i 1) (+ sum i))\n              (loop (+ i 1) sum)))))\n  (let loop ([i 1] [sum 0])\n    (if (&gt; i limit)\n        sum\n        (if (amicable? i)\n            (loop (+ i 1) (+ sum i))\n            (loop (+ i 1) sum)))))\n</code>\n",
    "  (define (amicable-number? n)\n    (let ((m (sum-of-divisors n)))\n      (and (not (= n m)) (= (sum-of-divisors m) n))))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (= (remainder n i) 0) i)))\n    (apply + (divisors n)))\n  (apply + (filter amicable-number? (in-range 1 limit))))\n",
    "  (define (amicable-pair? a b)\n    (and (= (sum-of-divisors a) b)\n         (= (sum-of-divisors b) a)))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (define (amicable-pairs limit)\n    (for/list ([i (in-range 1 limit)])\n      (for/list ([j (in-range 1 limit)])\n        (if (and (amicable-pair? i j)\n                 (not (zero? (modulo i j))))\n            (list i j)))))\n  (apply + (apply append (amicable-pairs limit))))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (modulo n x)))\n            (range 1 (add1 (quotient n 2)))))\n  (define (sum_divisors n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((sum (sum_divisors n)))\n      (and (not (= n sum))\n           (= n (sum_divisors sum)))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= (remainder n x) 0)) (range 1 (add1 (quotient n 2)))))\n  (define (sum_divisors n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((sum (sum_divisors n)))\n      (and (= n (sum_divisors sum)) (not (= n sum)))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= (remainder n x) 0))\n            (range 1 (add1 (quotient n 2)))))\n  (define (amicable? n)\n    (let ((d (divisors n)))\n      (and (not (= n (apply + d)))\n           (= n (apply + (divisors (apply + d)))))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (divisors n)\n    (for/list ([i (in-range 1 (quotient n 2))] #:when (zero? (remainder n i)))\n      i))\n  (define (sum_divisors n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ([sum (sum_divisors n)])\n      (and (not (= n sum))\n           (= (sum_divisors sum) n))))\n  (apply + (for/list ([i (in-range 1 limit)] #:when (amicable? i))\n             i)))\n",
    "  (define (amicable-number? n)\n    (let ((n-divisors-sum (sum-divisors n)))\n      (and (not (= n n-divisors-sum))\n           (= n (sum-divisors n-divisors-sum)))))\n  (define (sum-divisors n)\n    (let loop ((n n) (divisors (list 1)))\n      (if (= n 1)\n          (apply + divisors)\n          (loop (quotient n (gcd n (sub1 n)))\n                (cons (quotient n (gcd n (sub1 n))) divisors)))))\n  (define (gcd a b)\n    (if (= b 0)\n        a\n        (gcd b (remainder a b))))\n  (let loop ((n 1) (sum 0))\n    (if (= n limit)\n        sum\n        (loop (add1 n)\n              (if (amicable-number? n)\n                  (+ sum n)\n                  sum)))))\n",
    "  (define (amicable? n)\n    (let* ([n-divisors (divisors n)]\n           [n-divisors-sum (apply + n-divisors)])\n      (and (not (= n n-divisors-sum))\n           (= n (apply + (divisors n-divisors-sum))))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (amicable-pair? a b)\n    (and (= (sum-of-divisors a) b)\n         (= (sum-of-divisors b) a)))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (define (amicable-numbers)\n    (for/list ([i (in-range 1 limit)])\n      (for/list ([j (in-range 1 limit)])\n        (if (amicable-pair? i j) i))))\n  (apply + (amicable-numbers)))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (modulo n x))) (range 1 (add1 (quotient n 2)))))\n  (define (amicable? n)\n    (let ((m (apply + (divisors n))))\n      (and (= n (apply + (divisors m))) (not (= n m)))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (modulo n x)))\n            (range 1 (add1 (quotient n 2)))))\n  (define (amicable? n)\n    (let ((m (apply + (divisors n))))\n      (and (not (= n m))\n           (= n (apply + (divisors m))))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (amicable? n)\n    (let ((m (sum-of-divisors n)))\n      (and (not (= n m)) (= n (sum-of-divisors m)))))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (let loop ((i 1) (acc '()))\n        (cond ((= i n) acc)\n              ((divides? i n) (loop (+ i 1) (cons i acc)))\n              (else (loop (+ i 1) acc)))))\n    (apply + (divisors n)))\n  (define (divides? a b) (= (remainder b a) 0))\n  (define (sum-of-amicable-numbers limit)\n    (let loop ((i 1) (acc 0))\n      (cond ((= i limit) acc)\n            ((amicable? i) (loop (+ i 1) (+ acc i)))\n            (else (loop (+ i 1) acc)))))\n  (sum-of-amicable-numbers limit))\n",
    "  (define (amicable-pair? a b)\n    (and (= (sum-of-divisors a) b)\n         (= (sum-of-divisors b) a)))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (quotient n 2))]\n                 #:when (zero? (remainder n i)))\n        i))\n    (apply + (divisors n)))\n  (define (amicable-numbers limit)\n    (for/list ([i (in-range 1 limit)]\n               #:when (amicable-pair? i (sum-of-divisors i)))\n      i))\n  (apply + (amicable-numbers limit)))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (remainder n x)))\n            (range 1 (add1 (quotient n 2)))))\n  (define (sum_divisors n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((m (sum_divisors n)))\n      (and (not (= n m)) (= n (sum_divisors m)))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (amicable? a)\n    (let ([b (sum_of_proper_divisors a)])\n      (and (not (= a b)) (= a (sum_of_proper_divisors b)))))\n  (define (sum_of_proper_divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (quotient n 2))]\n                 #:when (zero? (remainder n i)))\n        i))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (amicable-numbers-sum-iter limit sum)\n    (if (= limit 0)\n        sum\n        (let ((divisors-sum (divisors-sum limit)))\n          (if (= (divisors-sum divisors-sum) limit)\n              (amicable-numbers-sum-iter (- limit 1) (+ sum limit))\n              (amicable-numbers-sum-iter (- limit 1) sum)))))\n  (amicable-numbers-sum-iter limit 0))\n",
    "  (define (amicable-numbers-sum-iter limit sum)\n    (cond\n      [(= limit 1) sum]\n      [(amicable? limit) (amicable-numbers-sum-iter (- limit 1) (+ sum limit))]\n      [else (amicable-numbers-sum-iter (- limit 1) sum)]))\n  (amicable-numbers-sum-iter limit 0))\n",
    "  (define (sum-of-divisors n)\n    (define (sum-of-divisors-iter n sum)\n      (cond ((= n 1) sum)\n            ((= (modulo n 2) 0) (sum-of-divisors-iter (/ n 2) (+ sum n)))\n            ((= (modulo n 3) 0) (sum-of-divisors-iter (/ n 3) (+ sum n)))\n            (else (sum-of-divisors-iter (- n 1) sum))))\n    (sum-of-divisors-iter n 1))\n  (define (is-amicable? n)\n    (let ((n-sum (sum-of-divisors n))\n          (n-sum-sum (sum-of-divisors (sum-of-divisors n))))\n      (and (= n-sum-sum n)\n           (/= n-sum n))))\n  (define (amicable-numbers-sum-iter n sum)\n    (cond ((= n limit) sum)\n          ((is-amicable? n) (amicable-numbers-sum-iter (+ n 1) (+ sum n)))\n          (else (amicable-numbers-sum-iter (+ n 1) sum))))\n  (amicable-numbers-sum-iter 1 0))\n",
    "  (define (amicable? n)\n    (let ((m (sum_of_divisors n)))\n      (and (not (= n m)) (= n (sum_of_divisors m)))))\n  (define (sum_of_divisors n)\n    (define (divisors n)\n      (let loop ((n n) (d 2) (divs '()))\n        (cond ((= n 1) (reverse divs))\n              ((= (remainder n d) 0) (loop (quotient n d) d (cons d divs)))\n              (else (loop n (+ d 1) divs)))))\n    (apply + (divisors n)))\n  (define (loop n sum)\n    (cond ((= n limit) sum)\n          ((amicable? n) (loop (+ n 1) (+ n sum)))\n          (else (loop (+ n 1) sum))))\n  (loop 1 0))\n",
    "  (define (amicable-pair? a b)\n    (and (= (sum-of-divisors a) b)\n         (= (sum-of-divisors b) a)))\n  (define (sum-of-divisors n)\n    (accumulate + 0 (divisors n)))\n  (define (divisors n)\n    (filter (lambda (x) (= (modulo n x) 0))\n            (range 1 (add1 (quotient n 2)))))\n  (accumulate + 0 (filter (lambda (x) (amicable-pair? x (sum-of-divisors x)))\n                          (range 1 limit))))\n",
    "  (define (amicable? n)\n    (let ([m (sum_of_proper_divisors n)])\n      (and (not (= n m)) (= (sum_of_proper_divisors m) n))))\n  (define (sum_of_proper_divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (quotient n 2))])\n        (if (= 0 (remainder n i)) i)))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (amicable-pair? a b)\n    (and (= (sum-of-divisors a) b)\n         (= (sum-of-divisors b) a)))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (filter (lambda (x) (= (remainder n x) 0))\n              (range 1 (add1 (floor (/ n 2))))))\n    (apply + (divisors n)))\n  (define (amicable-numbers-below n)\n    (filter (lambda (x) (amicable-pair? x (sum-of-divisors x)))\n            (range 1 n)))\n  (apply + (amicable-numbers-below limit)))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (modulo n x))) (range 1 (add1 (quotient n 2)))))\n  (define (sum_divisors n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((sum (sum_divisors n)))\n      (and (not (= n sum)) (= (sum_divisors sum) n))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (amicable-pair? a b)\n    (and (= (sum-of-divisors a) b)\n         (= (sum-of-divisors b) a)))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (quotient n 2))]\n                 #:when (zero? (remainder n i)))\n        i))\n    (apply + (divisors n)))\n  (define (amicable-numbers)\n    (for/list ([i (in-range 1 limit)]\n               [j (in-range 1 limit)])\n      (when (amicable-pair? i j)\n        (list i j))))\n  (apply + (apply append (amicable-numbers))))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (modulo n x)))\n            (range 1 (add1 (quotient n 2)))))\n  (define (amicable? n)\n    (let ((n2 (apply + (divisors n))))\n      (and (not (= n n2))\n           (= n (apply + (divisors n2))))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (amicable-pair? a b)\n    (and (= (sum-of-divisors a) b)\n         (= (sum-of-divisors b) a)))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (quotient n 2))]\n                 #:when (zero? (modulo n i)))\n        i))\n    (apply + (divisors n)))\n  (define (amicable-pairs limit)\n    (for/list ([i (in-range 1 limit)]\n               [j (in-range 1 limit)])\n      (when (amicable-pair? i j)\n        (list i j))))\n  (apply + (apply append (amicable-pairs limit))))\n",
    "  (define (amicable-pair? a b)\n    (and (= (sum-of-divisors a) b)\n         (= (sum-of-divisors b) a)))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (define (amicable-numbers n)\n    (for/list ([i (in-range 1 n)])\n      (for/list ([j (in-range 1 n)])\n        (if (amicable-pair? i j) i))))\n  (apply + (amicable-numbers limit)))\n",
    "  (define (amicable-pairs-sum limit)\n    (define (amicable-pairs-sum-iter limit acc)\n      (if (= limit 1)\n          acc\n          (let ((divisor-sum (divisor-sum limit)))\n            (if (= (divisor-sum divisor-sum) limit)\n                (amicable-pairs-sum-iter (- limit 1) (+ acc limit divisor-sum))\n                (amicable-pairs-sum-iter (- limit 1) acc)))))\n  (amicable-pairs-sum-iter limit 0))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (modulo n x))) (range 1 (add1 (quotient n 2)))))\n  (define (sum_divisors n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((sum (sum_divisors n)))\n      (and (= n (sum_divisors sum))\n           (not (= n sum)))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (amicable? n)\n    (let ((m (sum_of_divisors n)))\n      (and (not (= n m)) (= (sum_of_divisors m) n))))\n  (define (sum_of_divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (sum-divisors n)\n    (define (sum-divisors-iter n sum)\n      (cond ((= n 1) sum)\n            ((= (remainder n 2) 0) (sum-divisors-iter (/ n 2) (+ sum n)))\n            ((= (remainder n 3) 0) (sum-divisors-iter (/ n 3) (+ sum n)))\n            ((= (remainder n 5) 0) (sum-divisors-iter (/ n 5) (+ sum n)))\n            ((= (remainder n 7) 0) (sum-divisors-iter (/ n 7) (+ sum n)))\n            (else (sum-divisors-iter (- n 1) (+ sum n)))))\n    (sum-divisors-iter n 0))\n  (define (amicable-numbers-sum-iter n sum)\n    (cond ((= n limit) sum)\n          ((= (sum-divisors n) (sum-divisors (+ n 1))) (amicable-numbers-sum-iter (+ n 2) (+ sum n n)))\n          (else (amicable-numbers-sum-iter (+ n 1) sum))))\n  (amicable-numbers-sum-iter 1 0))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (modulo n x))) (range 1 (add1 (quotient n 2)))))\n  (define (sum_divisors n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((n2 (sum_divisors n)))\n      (and (= n (sum_divisors n2))\n           (not (= n n2)))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (amicable-pair? a b)\n    (and (= (sum-of-divisors a) b) (= (sum-of-divisors b) a)))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (quotient n 2))]\n                 #:when (zero? (modulo n i)))\n        i))\n    (apply + (divisors n)))\n  (define (amicable-numbers)\n    (for/list ([i (in-range 1 limit)]\n               [j (in-range 1 limit)])\n      (when (amicable-pair? i j)\n        (list i j))))\n  (apply + (apply append (amicable-numbers))))\n",
    "  (define (sum-of-divisors n)\n    (define (sum-of-divisors-iter n sum)\n      (cond\n        [(= n 1) sum]\n        [(divides? n (sub1 n)) (sum-of-divisors-iter (sub1 n) (+ sum (sub1 n)))]\n        [else (sum-of-divisors-iter (sub1 n) sum)]))\n    (sum-of-divisors-iter n 0))\n  (define (sum-of-amicable-numbers-iter n sum)\n    (cond\n      [(= n limit) sum]\n      [(and (not (= n (sum-of-divisors n))) (= (sum-of-divisors n) n)) (sum-of-amicable-numbers-iter (add1 n) sum)]\n      [(and (= n (sum-of-divisors n)) (= (sum-of-divisors (sum-of-divisors n)) n)) (sum-of-amicable-numbers-iter (add1 n) (+ sum n (sum-of-divisors n)))]\n      [else (sum-of-amicable-numbers-iter (add1 n) sum)]))\n  (sum-of-amicable-numbers-iter 1 0))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (modulo n x)))\n            (range 1 (add1 (quotient n 2)))))\n  (define (amicable? n)\n    (let ((sum (apply + (divisors n))))\n      (and (= n (apply + (divisors sum)))\n           (not (= n sum)))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (modulo n x)))\n            (range 1 (add1 (quotient n 2)))))\n  (define (sum_divisors n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((m (sum_divisors n)))\n      (and (not (= n m)) (= n (sum_divisors m)))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (amicable-pair? a b)\n    (and (= (sum-of-proper-divisors a) b)\n         (= (sum-of-proper-divisors b) a)))\n  (define (sum-of-proper-divisors n)\n    (define (divisors n)\n      (filter (lambda (x) (= (modulo n x) 0))\n              (range 1 (add1 (quotient n 2)))))\n    (apply + (divisors n)))\n  (define (range a b)\n    (if (> a b)\n        '()\n        (cons a (range (add1 a) b))))\n  (define (filter pred lst)\n    (cond ((null? lst) '())\n          ((pred (car lst)) (cons (car lst) (filter pred (cdr lst))))\n          (else (filter pred (cdr lst)))))\n  (define (sum-of-amicable-numbers-from-1-to limit)\n    (define (sum-of-amicable-numbers-from-1-to-n n)\n      (define (sum-of-amicable-numbers-from-1-to-n-iter n sum)\n        (if (= n 1)\n            sum\n            (if (amicable-pair? n (sum-of-proper-divisors n))\n                (sum-of-amicable-numbers-from-1-to-n-iter (sub1 n) (add1 sum))\n                (sum-of-amicable-numbers-from-1-to-n-iter (sub1 n) sum))))\n      (sum-of-amicable-numbers-from-1-to-n-iter n 0))\n    (sum-of-amicable-numbers-from-1-to-n limit))\n  (sum-of-amicable-numbers-from-1-to limit))\n",
    "  (define (amicable? n)\n    (let* ([d (sum-of-divisors n)]\n           [d2 (sum-of-divisors d)])\n      (and (not (= n d)) (= n d2))))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (modulo n x))) (range 1 (add1 (quotient n 2)))))\n  (define (sum_divisors n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ([m (sum_divisors n)])\n      (and (= n (sum_divisors m))\n           (not (= n m)))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= (remainder n x) 0))\n            (range 1 (add1 (quotient n 2)))))\n  (define (sum_divisors n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((sum (sum_divisors n)))\n      (and (= n (sum_divisors sum))\n           (not (= n sum)))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (quotient n 2))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (define (amicable-pairs n)\n    (define (pair-p n)\n      (define (pair-p-helper n)\n        (define (pair-p-helper-helper n)\n          (define (pair-p-helper-helper-helper n)\n            (define (pair-p-helper-helper-helper-helper n)\n              (define (pair-p-helper-helper-helper-helper-helper n)\n                (define (pair-p-helper-helper-helper-helper-helper-helper n)\n                  (define (pair-p-helper-helper-helper-helper-helper-helper-helper n)\n                    (define (pair-p-helper-helper-helper-helper-helper-helper-helper-helper n)\n                      (define (pair-p-helper-helper-helper-helper-helper-helper-helper-helper-helper n)\n                        (define (pair-p-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper n)\n                          (define (pair-p-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper n)\n                            (define (pair-p-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper n)\n                              (define (pair-p-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper n)\n                                (define (pair-p-helper-",
    "  (define (amicable-pair? a b)\n    (and (= (sum-of-divisors a) b)\n         (= (sum-of-divisors b) a)))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (filter (lambda (x) (= (modulo n x) 0)) (range 1 n)))\n    (apply + (divisors n)))\n  (define (range a b)\n    (if (> a b)\n        '()\n        (cons a (range (+ a 1) b))))\n  (define (filter pred lst)\n    (cond ((null? lst) '())\n          ((pred (car lst)) (cons (car lst) (filter pred (cdr lst))))\n          (else (filter pred (cdr lst)))))\n  (apply + (filter (lambda (x) (amicable-pair? x (sum-of-divisors x))) (range 1 limit))))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= (remainder n x) 0))\n            (range 1 (add1 (quotient n 2)))))\n  (define (sum_divisors n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((sum (sum_divisors n)))\n      (and (not (= n sum))\n           (= (sum_divisors sum) n))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (amicable-pair? a b)\n    (and (= (sum-of-divisors a) b) (= (sum-of-divisors b) a)))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (define (amicable-numbers limit)\n    (for/list ([i (in-range 1 limit)])\n      (define j (sum-of-divisors i))\n      (if (and (amicable-pair? i j) (< i j)) j)))\n  (apply + (amicable-numbers limit)))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= (remainder n x) 0))\n            (range 1 (add1 (quotient n 2)))))\n  (define (sum_divisors n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((m (sum_divisors n)))\n      (and (not (= n m))\n           (= (sum_divisors m) n))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (amicable? a)\n    (let ((b (sum_of_divisors a)))\n      (and (not (= a b))\n           (= a (sum_of_divisors b)))))\n  (define (sum_of_divisors n)\n    (define (divisors n)\n      (let loop ((i 1) (acc '()))\n        (if (= i n)\n            acc\n            (if (zero? (modulo n i))\n                (loop (+ i 1) (cons i acc))\n                (loop (+ i 1) acc)))))\n    (apply + (divisors n)))\n  (define (amicable-numbers n)\n    (let loop ((i 1) (acc '()))\n      (if (= i n)\n          acc\n          (if (amicable? i)\n              (loop (+ i 1) (cons i acc))\n              (loop (+ i 1) acc)))))\n  (apply + (amicable-numbers limit)))\n",
    "  (define (amicable? n)\n    (let ((m (sum_of_divisors n)))\n      (and (not (= n m)) (= (sum_of_divisors m) n))))\n  (define (sum_of_divisors n)\n    (let loop ((i 1) (sum 0))\n      (cond ((&gt; i (/ n 2)) sum)\n            ((zero? (modulo n i)) (loop (+ i 1) (+ sum i)))\n            (else (loop (+ i 1) sum)))))\n  (let loop ((i 1) (sum 0))\n    (cond ((&gt; i limit) sum)\n          ((amicable? i) (loop (+ i 1) (+ sum i)))\n          (else (loop (+ i 1) sum)))))\n</code>\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (modulo n x))) (range 1 (add1 (quotient n 2)))))\n  (define (sum_divisors n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((sum (sum_divisors n)))\n      (and (not (= n sum)) (= (sum_divisors sum) n))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (modulo n x))) (range 1 (add1 (quotient n 2)))))\n  (define (sum_divisors n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((n2 (sum_divisors n)))\n      (and (not (= n n2)) (= n (sum_divisors n2)))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (amicable-number? n)\n    (let* ((n-divisors (divisors n))\n           (n-divisors-sum (apply + n-divisors))\n           (n-divisors-sum-divisors (divisors n-divisors-sum)))\n      (and (not (equal? n n-divisors-sum))\n           (equal? n-divisors-sum-divisors n-divisors))))\n  (define (divisors n)\n    (let loop ((i 1) (acc '()))\n      (cond ((= i n) acc)\n            ((divides? i n) (loop (+ i 1) (cons i acc)))\n            (else (loop (+ i 1) acc)))))\n  (define (divides? a b)\n    (= (remainder b a) 0))\n  (define (sum-amicable-numbers n)\n    (let loop ((i 1) (acc 0))\n      (cond ((= i n) acc)\n            ((amicable-number? i) (loop (+ i 1) (+ acc i)))\n            (else (loop (+ i 1) acc)))))\n  (sum-amicable-numbers limit))\n",
    "  (define (sum-divisors n)\n    (define (sum-divisors-iter n i sum)\n      (cond ((= i n) sum)\n            ((= 0 (modulo n i)) (sum-divisors-iter n (+ i 1) (+ sum i)))\n            (else (sum-divisors-iter n (+ i 1) sum))))\n    (sum-divisors-iter n 1 0))\n  (define (is-amicable n)\n    (let ((n-sum (sum-divisors n)))\n      (and (= n (sum-divisors n-sum))\n           (/= n n-sum))))\n  (define (sum-amicable-numbers-iter n sum)\n    (cond ((= n limit) sum)\n          ((is-amicable n) (sum-amicable-numbers-iter (+ n 1) (+ sum n)))\n          (else (sum-amicable-numbers-iter (+ n 1) sum))))\n  (sum-amicable-numbers-iter 1 0))\n",
    "  (define (amicable? a)\n    (let ([b (sum_of_divisors a)])\n      (and (not (= a b)) (= (sum_of_divisors b) a))))\n  (define (sum_of_divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (amicable-pair? a b)\n    (and (= a (sum-divisors b))\n         (= b (sum-divisors a))))\n  (define (sum-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (define (amicable-numbers limit)\n    (for/list ([i (in-range 1 limit)])\n      (if (amicable-pair? i (sum-divisors i)) i)))\n  (apply + (amicable-numbers limit)))\n",
    "  (define (amicable-sum n)\n    (define (divisors n)\n      (filter (lambda (x) (= 0 (remainder n x)))\n              (range 1 (add1 (quotient n 2)))))\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((n-sum (amicable-sum n)))\n      (and (not (= n n-sum))\n           (= (amicable-sum n-sum) n))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (sum_of_divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (quotient n 2))]\n                 #:when (zero? (modulo n i)))\n        i))\n    (apply + (divisors n)))\n  (define (is_amicable? n)\n    (let ([m (sum_of_divisors n)])\n      (and (not (= n m))\n           (= (sum_of_divisors m) n))))\n  (apply + (for/list ([i (in-range 1 limit)]\n                      #:when (is_amicable? i))\n              i)))\n",
    "  (define (amicable? n)\n    (let ((m (sum_of_divisors n)))\n      (and (not (= n m)) (= (sum_of_divisors m) n))))\n  (define (sum_of_divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (amicable-pair? a b)\n    (and (= (sum-of-divisors a) b)\n         (= (sum-of-divisors b) a)))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (when (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (define (amicable-numbers n)\n    (for/list ([i (in-range 1 n)])\n      (when (amicable-pair? i (sum-of-divisors i)) i)))\n  (apply + (amicable-numbers limit)))\n",
    "  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (define (is-amicable? n)\n    (let ([m (sum-of-divisors n)])\n      (and (not (= n m)) (= n (sum-of-divisors m)))))\n  (apply + (for/list ([i (in-range 1 limit)])\n            (if (is-amicable? i) i))))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= (remainder n x) 0)) (range 1 (add1 (quotient n 2)))))\n  (define (sum_divisors n)\n    (apply + (divisors n)))\n  (define (is_amicable? n)\n    (let ((m (sum_divisors n)))\n      (and (not (= n m)) (= (sum_divisors m) n))))\n  (apply + (filter is_amicable? (range 1 limit))))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (modulo n x))) (range 1 (add1 (quotient n 2)))))\n  (define (sum_divisors n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((m (sum_divisors n)))\n      (and (not (= n m)) (= n (sum_divisors m)))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (amicable? n)\n    (let ((m (sum_divisors n)))\n      (and (not (= n m)) (= (sum_divisors m) n))))\n  (define (sum_divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (quotient n 2))]\n                 #:when (zero? (modulo n i)))\n        i))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (sum-divisors n)\n    (let loop ((i 1) (sum 0))\n      (cond ((&gt; i (/ n 2)) sum)\n            ((= (modulo n i) 0) (loop (+ i 1) (+ sum i)))\n            (else (loop (+ i 1) sum)))))\n  (let loop ((i 1) (sum 0))\n    (cond ((&gt; i limit) sum)\n          ((= (sum-divisors i) (sum-divisors (sum-divisors i)))\n           (loop (+ i 1) (+ sum i)))\n          (else (loop (+ i 1) sum)))))\n</code>\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (modulo n x))) (range 1 (add1 (quotient n 2)))))\n  (define (sum_divisors n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((m (sum_divisors n)))\n      (and (not (= n m)) (= n (sum_divisors m)))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (modulo n x)))\n            (range 1 (add1 (quotient n 2)))))\n  (define (amicable? n)\n    (let ((m (apply + (divisors n))))\n      (and (= n (apply + (divisors m)))\n           (not (= n m)))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (sum-of-divisors n)\n    (define (sum-of-divisors-iter n sum)\n      (cond ((= n 1) sum)\n            ((= (remainder n 2) 0)\n             (sum-of-divisors-iter (/ n 2) (+ sum n)))\n            (else (sum-of-divisors-iter (- n 1) sum))))\n    (sum-of-divisors-iter n 1))\n  (define (is-amicable? n)\n    (let ((sum-of-n (sum-of-divisors n)))\n      (and (not (= n sum-of-n)) (= n (sum-of-divisors sum-of-n)))))\n  (define (amicable-numbers-sum-iter n sum)\n    (cond ((= n limit) sum)\n          ((is-amicable? n) (amicable-numbers-sum-iter (+ n 1) (+ sum n)))\n          (else (amicable-numbers-sum-iter (+ n 1) sum))))\n  (amicable-numbers-sum-iter 1 0))\n",
    "  (define (amicable-numbers-sum-iter limit sum)\n    (if (= limit 0)\n        sum\n        (let ((sum-of-divisors (sum-of-divisors limit)))\n          (if (and (= sum-of-divisors (sum-of-divisors sum-of-divisors))\n                   (not (= limit sum-of-divisors)))\n              (amicable-numbers-sum-iter (- limit 1) (+ sum limit))\n              (amicable-numbers-sum-iter (- limit 1) sum)))))\n  (amicable-numbers-sum-iter limit 0))\n",
    "  (define (amicable? a)\n    (let ((b (sum_of_divisors a)))\n      (and (not (= a b)) (= a (sum_of_divisors b)))))\n  (define (sum_of_divisors n)\n    (define (divisors n)\n      (filter (lambda (x) (= 0 (modulo n x))) (range 1 (add1 (quotient n 2)))))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= (remainder n x) 0))\n            (range 1 (add1 (quotient n 2)))))\n  (define (amicable? n)\n    (let ((sum-of-divisors (apply + (divisors n))))\n      (and (not (= n sum-of-divisors))\n           (= (apply + (divisors sum-of-divisors)) n))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (amicable-pair? a b)\n    (and (= (sum-of-divisors a) b)\n         (= (sum-of-divisors b) a)))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (filter (lambda (x) (= (remainder n x) 0))\n              (range 1 (add1 (quotient n 2)))))\n    (apply + (divisors n)))\n  (define (range a b)\n    (if (> a b)\n        '()\n        (cons a (range (add1 a) b))))\n  (define (filter pred lst)\n    (cond ((null? lst) '())\n          ((pred (car lst)) (cons (car lst) (filter pred (cdr lst))))\n          (else (filter pred (cdr lst)))))\n  (apply + (filter (lambda (x) (amicable-pair? x (sum-of-divisors x)))\n                   (range 1 limit))))\n",
    "  (define (amicable? n)\n    (let ((m (sum_of_divisors n)))\n      (and (not (= n m)) (= n (sum_of_divisors m)))))\n  (define (sum_of_divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= (modulo n x) 0)) (range 1 n)))\n  (define (amicable? n)\n    (let ((m (apply + (divisors n))))\n      (and (= n (apply + (divisors m)))\n           (not (= n m)))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (quotient n 2))])\n        (when (zero? (modulo n i))\n          i)))\n    (apply + (divisors n)))\n  (define (is-amicable? n)\n    (let ([n2 (sum-of-divisors n)])\n      (and (not (= n n2))\n           (= n (sum-of-divisors n2)))))\n  (apply + (for/list ([i (in-range 1 limit)])\n              (when (is-amicable? i)\n                i))))\n",
    "  (define (amicable-pair? a b)\n    (and (= (sum-of-divisors a) b)\n         (= (sum-of-divisors b) a)))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (filter (lambda (x) (= (modulo n x) 0))\n              (range 1 (add1 (quotient n 2)))))\n    (apply + (divisors n)))\n  (define (amicable-numbers limit)\n    (filter (lambda (x) (amicable-pair? x (sum-of-divisors x)))\n            (range 1 limit)))\n  (apply + (amicable-numbers limit)))\n",
    "  (define (sum-of-divisors n)\n    (define (divisors n)\n      (filter (lambda (x) (= (modulo n x) 0)) (range 1 (add1 (quotient n 2)))))\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((m (sum-of-divisors n)))\n      (and (= (sum-of-divisors m) n)\n           (not (= m n)))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= (remainder n x) 0))\n            (range 1 (add1 (quotient n 2)))))\n  (define (sum_divisors n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((n2 (sum_divisors n)))\n      (and (not (= n n2))\n           (= (sum_divisors n2) n))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (modulo n x)))\n            (range 1 (add1 (floor (sqrt n))))))\n  (define (sum_divisors n)\n    (apply + (divisors n)))\n  (define (amicable? a b)\n    (and (= (sum_divisors a) b)\n         (= (sum_divisors b) a)))\n  (define (amicable-pairs limit)\n    (filter (lambda (pair) (amicable? (car pair) (cdr pair)))\n            (map (lambda (x) (cons x (sum_divisors x)))\n                 (range 1 limit))))\n  (apply + (map car (amicable-pairs limit))))\n",
    "  (define (amicable-pair? a b)\n    (and (= (sum-of-divisors a) b)\n         (= (sum-of-divisors b) a)))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (quotient n 2))]\n                 #:when (zero? (remainder n i)))\n        i))\n    (apply + (divisors n)))\n  (define (amicable-numbers-below n)\n    (for/list ([i (in-range 1 n)]\n               #:when (amicable-pair? i (sum-of-divisors i)))\n      i))\n  (apply + (amicable-numbers-below limit)))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (modulo n x)))\n            (range 1 (add1 (quotient n 2)))))\n  (define (sum_divisors n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((m (sum_divisors n)))\n      (and (not (= n m))\n           (= (sum_divisors m) n))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (quotient n 2))]\n                 #:when (zero? (modulo n i)))\n        i))\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ([m (sum-of-divisors n)])\n      (and (not (= n m)) (= n (sum-of-divisors m)))))\n  (apply + (for/list ([i (in-range 1 limit)]\n                     #:when (amicable? i))\n            i)))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= (remainder n x) 0))\n            (range 1 (add1 (quotient n 2)))))\n  (define (sum_divisors n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((sum (sum_divisors n)))\n      (and (not (= n sum))\n           (= (sum_divisors sum) n))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (amicable-number? n)\n    (let ((m (sum-of-divisors n)))\n      (and (not (= n m)) (= n (sum-of-divisors m)))))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (apply + (filter amicable-number? (in-range 1 limit))))\n",
    "  (define (amicable? n)\n    (let ((m (sum_of_divisors n)))\n      (and (not (= n m)) (= (sum_of_divisors m) n))))\n  (define (sum_of_divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (quotient n 2))]\n                 #:when (zero? (modulo n i)))\n        i))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (modulo n x)))\n            (range 1 (add1 (quotient n 2)))))\n  (define (sum_divisors n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((n2 (sum_divisors n)))\n      (and (= n (sum_divisors n2))\n           (not (= n n2)))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (amicable? n)\n    (let ((m (sum-of-divisors n)))\n      (and (not (= n m)) (= n (sum-of-divisors m)))))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (quotient n 2))]\n                 #:when (zero? (modulo n i)))\n        i))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (modulo n x)))\n            (range 1 (add1 (quotient n 2)))))\n  (define (sum_divisors n)\n    (apply + (divisors n)))\n  (define (is_amicable? n)\n    (let ((m (sum_divisors n)))\n      (and (= n (sum_divisors m))\n           (not (= n m)))))\n  (apply + (filter is_amicable? (range 1 limit))))\n",
    "  (define (amicable-numbers-sum-iter limit sum)\n    (cond ((= limit 1) sum)\n          ((= (sum-of-divisors (sum-of-divisors limit)) limit)\n           (amicable-numbers-sum-iter (- limit 1) (+ limit sum)))\n          (else (amicable-numbers-sum-iter (- limit 1) sum))))\n  (amicable-numbers-sum-iter limit 0))\n",
    "  (define (sum-divisors n)\n    (define (sum-divisors-iter n divisor sum)\n      (cond ((= n 1) sum)\n            ((= 0 (modulo n divisor))\n             (sum-divisors-iter (/ n divisor) divisor (+ sum divisor)))\n            (else (sum-divisors-iter n (+ divisor 1) sum))))\n    (sum-divisors-iter n 2 0))\n  (define (is-amicable n)\n    (let ((m (sum-divisors n)))\n      (and (= m (/ n 2))\n           (= (sum-divisors m) n))))\n  (define (amicable-numbers-sum-iter n sum)\n    (cond ((= n limit) sum)\n          ((is-amicable n) (amicable-numbers-sum-iter (+ n 1) (+ sum n)))\n          (else (amicable-numbers-sum-iter (+ n 1) sum))))\n  (amicable-numbers-sum-iter 1 0))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (modulo n x))) (range 1 (add1 (quotient n 2)))))\n  (define (amicable? n)\n    (let ([m (apply + (divisors n))])\n      (and (= n (apply + (divisors m)))\n           (not (= n m)))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (let loop ((i 1) (sum 0))\n    (cond ((&gt; i limit) sum)\n          ((= (sum_of_divisors i) (+ i (sum_of_divisors (sum_of_divisors i))))\n           (loop (+ i 1) (+ sum i (sum_of_divisors i))))\n          (else (loop (+ i 1) sum)))))\n",
    "  (define (amicable? a)\n    (let ((b (sum_of_divisors a)))\n      (and (= a (sum_of_divisors b))\n           (/= a b))))\n  (define (sum_of_divisors n)\n    (define (divisors n)\n      (filter (lambda (x) (= 0 (modulo n x)))\n              (range 1 (add1 (quotient n 2)))))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (quotient n 2))]\n                 #:when (zero? (modulo n i)))\n        i))\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ([m (sum-of-divisors n)])\n      (and (not (= n m)) (= (sum-of-divisors m) n))))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (amicable-numbers-sum-iter limit sum)\n    (cond ((&gt; limit 1)\n           (let ((divisor-sum (divisor-sum limit)))\n             (if (and (&gt; divisor-sum 1)\n                      (= (divisor-sum divisor-sum) limit)\n                      (&lt; limit divisor-sum))\n                 (amicable-numbers-sum-iter (- limit 1) (+ sum limit divisor-sum))\n                 (amicable-numbers-sum-iter (- limit 1) sum))))\n          (else sum)))\n  (amicable-numbers-sum-iter limit 0))\n",
    "  (define (divisors n)\n    (define (divisors-iter n i acc)\n      (if (= n i)\n          acc\n          (if (= (modulo n i) 0)\n              (divisors-iter n (+ i 1) (cons i acc))\n              (divisors-iter n (+ i 1) acc))))\n    (divisors-iter n 1 '()))\n  (define (sum-divisors n)\n    (apply + (divisors n)))\n  (define (is-amicable? n)\n    (let ((sum-n (sum-divisors n)))\n      (and (= (sum-divisors sum-n) n)\n           (not (= n sum-n)))))\n  (define (amicable-numbers-sum-iter n acc)\n    (if (= n limit)\n        acc\n        (if (is-amicable? n)\n            (amicable-numbers-sum-iter (+ n 1) (+ n acc))\n            (amicable-numbers-sum-iter (+ n 1) acc))))\n  (amicable-numbers-sum-iter 1 0))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= (remainder n x) 0)) (range 1 (add1 (quotient n 2)))))\n  (define (sum_of_divisors n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((m (sum_of_divisors n)))\n      (and (not (= n m)) (= (sum_of_divisors m) n))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (remainder n x))) (range 1 (add1 (quotient n 2)))))\n  (define (sum_divisors n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((m (sum_divisors n)))\n      (and (not (= n m)) (= n (sum_divisors m)))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (amicable-pair? a b)\n    (and (= (sum-of-divisors a) b)\n         (= (sum-of-divisors b) a)))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (define (amicable-numbers)\n    (for/list ([i (in-range 1 limit)])\n      (let ([s (sum-of-divisors i)])\n        (if (and (amicable-pair? i s)\n                 (not (zero? s)))\n            i))))\n  (apply + (amicable-numbers)))\n",
    "  (define (amicable-numbers-sum-iter limit sum)\n    (cond\n      [(= limit 1) sum]\n      [(amicable? limit) (amicable-numbers-sum-iter (- limit 1) (+ limit sum))]\n      [else (amicable-numbers-sum-iter (- limit 1) sum)]))\n  (amicable-numbers-sum-iter limit 0))\n",
    "  (define (amicable-pairs limit)\n    (for/list ([i (in-range 1 limit)])\n      (let ([d (sum-of-divisors i)])\n        (when (and (= (sum-of-divisors d) i)\n                   (not (= i d)))\n          (list i d)))))\n  (apply + (apply append (amicable-pairs limit))))\n",
    "  (define (amicable? n)\n    (let ((m (sum-of-divisors n)))\n      (and (not (= n m)) (= (sum-of-divisors m) n))))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (amicable-numbers-sum-iter limit sum)\n    (cond\n      [(= limit 1) sum]\n      [(amicable? limit) (amicable-numbers-sum-iter (- limit 1) (+ limit sum))]\n      [else (amicable-numbers-sum-iter (- limit 1) sum)]))\n  (amicable-numbers-sum-iter limit 0))\n",
    "  (define (amicable-pair? a b)\n    (and (= (sum-of-divisors a) b) (= (sum-of-divisors b) a)))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (quotient n 2))]\n                 #:when (zero? (remainder n i)))\n        i))\n    (apply + (divisors n)))\n  (define (amicable-numbers)\n    (for/list ([i (in-range 1 limit)]\n               [j (in-range 1 limit)])\n      (when (amicable-pair? i j)\n        i)))\n  (apply + (amicable-numbers)))\n",
    "  (define (amicable-pair? n)\n    (let ((m (sum-of-divisors n)))\n      (and (not (= n m)) (= (sum-of-divisors m) n))))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (let loop ((i 1) (divisors '()))\n        (cond ((= i n) (cons i divisors))\n              ((divides? i n) (loop (+ i 1) (cons i divisors)))\n              (else (loop (+ i 1) divisors)))))\n    (apply + (divisors n)))\n  (define (divides? a b) (= (remainder b a) 0))\n  (define (amicable-numbers n)\n    (let loop ((i 1) (amicable-numbers '()))\n      (cond ((= i n) amicable-numbers)\n            ((amicable-pair? i) (loop (+ i 1) (cons i amicable-numbers)))\n            (else (loop (+ i 1) amicable-numbers)))))\n  (apply + (amicable-numbers limit)))\n",
    "  (define (amicable? n)\n    (let ((m (sum-of-divisors n)))\n      (and (not (= n m)) (= n (sum-of-divisors m)))))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (remainder n x))) (range 1 (add1 (quotient n 2)))))\n  (define (sum_divisors n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((n2 (sum_divisors n)))\n      (and (not (= n n2)) (= n (sum_divisors n2)))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (amicable? n)\n    (let ([m (sum_of_proper_divisors n)])\n      (and (not (= n m)) (= n (sum_of_proper_divisors m)))))\n  (define (sum_of_proper_divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (quotient n 2))]\n                 #:when (zero? (remainder n i)))\n        i))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (amicable-sum n)\n    (define (sum-of-divisors n)\n      (define (divisors n)\n        (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n          (if (zero? (modulo n i)) i)))\n      (apply + (divisors n)))\n    (define (amicable-pair? n)\n      (let ([m (sum-of-divisors n)])\n        (and (not (zero? m))\n             (= n (sum-of-divisors m)))))\n    (for/sum ([i (in-range 1 limit)])\n      (if (amicable-pair? i) i)))\n  (amicable-sum limit))\n",
    "  (define (amicable-pair? a b)\n    (and (= (sum-of-divisors a) b)\n         (= (sum-of-divisors b) a)))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (quotient n 2))]\n                 #:when (zero? (modulo n i)))\n        i))\n    (apply + (divisors n)))\n  (define (amicable-numbers limit)\n    (for/list ([i (in-range 1 limit)]\n               [j (in-range 1 limit)])\n      (if (amicable-pair? i j)\n          i)))\n  (apply + (amicable-numbers limit)))\n",
    "  (define (amicable-pair? n)\n    (let ((m (sum-of-divisors n)))\n      (and (not (= n m)) (= n (sum-of-divisors m)))))\n  (define (sum-of-divisors n)\n    (accumulate + 0 (filter (lambda (x) (divides? x n)) (range 1 n))))\n  (accumulate + 0 (filter amicable-pair? (range 1 limit))))\n",
    "  (define (sum_divisors n)\n    (define (sum_divisors-iter n divisor sum)\n      (cond ((= n 1) sum)\n            ((= 0 (modulo n divisor))\n             (sum_divisors-iter (/ n divisor) divisor (+ sum divisor)))\n            (else (sum_divisors-iter n (+ divisor 1) sum))))\n    (sum_divisors-iter n 2 0))\n  (define (is-amicable? n)\n    (let ((m (sum_divisors n)))\n      (and (= n (sum_divisors m))\n           (not (= n m)))))\n  (define (amicable-numbers-sum-iter n sum)\n    (cond ((= n limit) sum)\n          ((is-amicable? n) (amicable-numbers-sum-iter (+ n 1) (+ sum n)))\n          (else (amicable-numbers-sum-iter (+ n 1) sum))))\n  (amicable-numbers-sum-iter 1 0))\n",
    "  (let loop ((i 1) (sum 0))\n    (cond ((&gt; i limit) sum)\n          ((= (sum_of_divisors i) (+ i (sum_of_divisors (sum_of_divisors i))))\n           (loop (+ i 1) (+ sum i (sum_of_divisors i))))\n          (else (loop (+ i 1) sum)))))\n",
    "  (define (amicable-pair? a b)\n    (and (= (sum-of-divisors a) b)\n         (= (sum-of-divisors b) a)))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (define (amicable-numbers n)\n    (for/list ([i (in-range 1 n)])\n      (let ([sum (sum-of-divisors i)])\n        (if (and (amicable-pair? i sum)\n                 (not (zero? sum)))\n            i))))\n  (apply + (amicable-numbers limit)))\n",
    "  (define (sum-of-divisors n)\n    (define (sum-of-divisors-iter n i sum)\n      (cond ((= i n) sum)\n            ((= 0 (modulo n i)) (sum-of-divisors-iter n (+ i 1) (+ sum i)))\n            (else (sum-of-divisors-iter n (+ i 1) sum))))\n    (sum-of-divisors-iter n 1 0))\n  (define (amicable-numbers-sum-iter n sum)\n    (cond ((= n limit) sum)\n          ((= (sum-of-divisors (sum-of-divisors n)) n) (amicable-numbers-sum-iter (+ n 1) (+ sum n)))\n          (else (amicable-numbers-sum-iter (+ n 1) sum))))\n  (amicable-numbers-sum-iter 1 0))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= (remainder n x) 0)) (range 1 n)))\n  (define (sum_divisors n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((sum (sum_divisors n)))\n      (and (not (= n sum)) (= (sum_divisors sum) n))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (amicable? n)\n    (let ([m (sum_of_divisors n)])\n      (and (not (= n m)) (= (sum_of_divisors m) n))))\n  (define (sum_of_divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (sum-of-divisors n)\n    (define (divisors n)\n      (filter (lambda (x) (= (modulo n x) 0))\n              (range 1 (add1 (quotient n 2)))))\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((m (sum-of-divisors n)))\n      (and (not (= n m)) (= (sum-of-divisors m) n))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= (remainder n x) 0))\n            (range 1 (add1 (quotient n 2)))))\n  (define (proper-divisors n)\n    (filter (lambda (x) (not (= x n))) (divisors n)))\n  (define (sum-proper-divisors n)\n    (apply + (proper-divisors n)))\n  (define (amicable? n)\n    (let ((m (sum-proper-divisors n)))\n      (and (= (sum-proper-divisors m) n)\n           (not (= n m)))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (amicable? n)\n    (let ((m (sum_of_divisors n)))\n      (and (not (= n m)) (= n (sum_of_divisors m)))))\n  (define (sum_of_divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (sum_of_divisors n)\n    (define (divisors n)\n      (filter (lambda (x) (= (modulo n x) 0))\n              (range 1 (add1 (truncate (sqrt n))))))\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((m (sum_of_divisors n)))\n      (and (not (= n m)) (= (sum_of_divisors m) n))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (amicable? a)\n    (let ((b (sum_of_divisors a)))\n      (and (not (= a b)) (= (sum_of_divisors b) a))))\n  (define (sum_of_divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (sum-of-divisors n)\n    (define (sum-of-divisors-iter n sum)\n      (cond ((= n 1) sum)\n            ((= (remainder n 2) 0)\n             (sum-of-divisors-iter (/ n 2) (+ sum n)))\n            (else (sum-of-divisors-iter (- n 1) sum))))\n    (sum-of-divisors-iter n 1))\n  (define (is-amicable? n)\n    (let ((n-sum (sum-of-divisors n)))\n      (and (= n-sum (sum-of-divisors n-sum))\n           (not (= n n-sum)))))\n  (define (amicable-numbers-sum-iter n sum)\n    (cond ((= n limit) sum)\n          ((is-amicable? n) (amicable-numbers-sum-iter (+ n 1) (+ sum n)))\n          (else (amicable-numbers-sum-iter (+ n 1) sum))))\n  (amicable-numbers-sum-iter 1 0))\n",
    "  (define (divisors n)\n    (for/list ([i (in-range 1 (quotient n 2))]\n               #:when (zero? (modulo n i)))\n      i))\n  (define (amicable? n)\n    (let ([d (divisors n)])\n      (and (not (empty? d))\n           (= n (apply + (divisors (apply + d)))))))\n  (apply + (for/list ([i (in-range 1 limit)]\n                      #:when (amicable? i))\n                i)))\n",
    "  (define (sum-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (quotient n 2))]\n                 #:when (zero? (modulo n i)))\n        i))\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ([m (sum-divisors n)])\n      (and (not (= n m)) (= (sum-divisors m) n))))\n  (apply + (for/list ([i (in-range 1 limit)]\n                     #:when (amicable? i))\n              i)))\n",
    "  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (define (is-amicable? n)\n    (let ([m (sum-of-divisors n)])\n      (and (not (= n m)) (= n (sum-of-divisors m)))))\n  (apply + (filter is-amicable? (in-range 1 limit))))\n",
    "  (define (sum-divisors n)\n    (define (sum-divisors-iter n acc)\n      (cond\n        [(= n 1) acc]\n        [(= (remainder n 2) 0) (sum-divisors-iter (/ n 2) (+ acc n))]\n        [(= (remainder n 3) 0) (sum-divisors-iter (/ n 3) (+ acc n))]\n        [(= (remainder n 5) 0) (sum-divisors-iter (/ n 5) (+ acc n))]\n        [(= (remainder n 7) 0) (sum-divisors-iter (/ n 7) (+ acc n))]\n        [else (sum-divisors-iter (- n 1) (+ acc n))]))\n    (sum-divisors-iter n 0))\n  (define (amicable-numbers-sum-iter n acc)\n    (cond\n      [(= n limit) acc]\n      [(= (sum-divisors n) (sum-divisors (+ n 1))) (amicable-numbers-sum-iter (+ n 1) (+ acc n))]\n      [else (amicable-numbers-sum-iter (+ n 1) acc)]))\n  (amicable-numbers-sum-iter 1 0))\n",
    "  (define (amicable-pair? a b)\n    (and (= (sum-of-divisors a) b)\n         (= (sum-of-divisors b) a)))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (quotient n 2))]\n                 #:when (zero? (remainder n i)))\n        i))\n    (apply + (divisors n)))\n  (define (amicable-numbers n)\n    (for/list ([i (in-range 1 n)]\n               #:when (amicable-pair? i (sum-of-divisors i)))\n      i))\n  (apply + (amicable-numbers limit)))\n",
    "  (define (amicable-numbers-sum-iter limit sum)\n    (cond ((= limit 0) sum)\n          ((amicable? limit) (amicable-numbers-sum-iter (- limit 1) (+ limit sum)))\n          (else (amicable-numbers-sum-iter (- limit 1) sum))))\n  (amicable-numbers-sum-iter limit 0))\n",
    "  (define (amicable-pair? a b)\n    (and (= (sum-of-divisors a) b)\n         (= (sum-of-divisors b) a)))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (quotient n 2))]\n                 #:when (zero? (remainder n i)))\n        i))\n    (apply + (divisors n)))\n  (define (amicable-numbers-under n)\n    (for/list ([i (in-range 1 n)]\n               [j (in-range 1 n)]\n               #:when (and (amicable-pair? i j)\n                           (not (zero? i))\n                           (not (zero? j))))\n      i))\n  (apply + (amicable-numbers-under limit)))\n",
    "  (define (amicable? n)\n    (let ((m (sum_of_divisors n)))\n      (and (not (= n m))\n           (= n (sum_of_divisors m)))))\n  (define (sum_of_divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i))\n            i)))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (amicable-pairs-sum limit)\n    (define (divisors n)\n      (filter (lambda (x) (= 0 (modulo n x)))\n              (range 1 (add1 (quotient n 2)))))\n    (define (sum-divisors n)\n      (apply + (divisors n)))\n    (define (amicable-pair? n)\n      (let ((m (sum-divisors n)))\n        (and (= n (sum-divisors m))\n             (not (= n m)))))\n    (define (amicable-pairs limit)\n      (filter amicable-pair? (range 1 limit)))\n    (apply + (amicable-pairs limit)))\n  (amicable-pairs-sum limit))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (modulo n x))) (range 1 (add1 (quotient n 2)))))\n  (define (sum_divisors n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((sum (sum_divisors n)))\n      (and (not (= n sum)) (= n (sum_divisors sum)))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (amicable? n)\n    (let* ([m (sum_of_divisors n)]\n           [n2 (sum_of_divisors m)])\n      (and (not (= n m)) (= n n2))))\n  (define (sum_of_divisors n)\n    (define (divisors n)\n      (filter (lambda (x) (= 0 (remainder n x)))\n              (range 1 (add1 (quotient n 2)))))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (amicable-pair? a b)\n    (and (= (sum-of-divisors a) b) (= (sum-of-divisors b) a)))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (quotient n 2))]\n                 #:when (zero? (remainder n i)))\n        i))\n    (apply + (divisors n)))\n  (define (amicable-numbers)\n    (for/list ([i (in-range 1 limit)]\n               [j (in-range 1 limit)])\n      (when (amicable-pair? i j)\n        (list i j))))\n  (apply + (apply append (amicable-numbers))))\n",
    "  (define (amicable? n)\n    (let ((m (sum-of-divisors n)))\n      (and (not (= n m)) (= (sum-of-divisors m) n))))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (remainder n i)) i)))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (amicable? n)\n    (let ([m (sum_of_divisors n)])\n      (and (not (= n m)) (= (sum_of_divisors m) n))))\n  (define (sum_of_divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (sum-divisors n)\n    (define (sum-divisors-iter n i sum)\n      (cond ((&gt; i n) sum)\n            ((= (modulo n i) 0) (sum-divisors-iter n (+ i 1) (+ sum i)))\n            (else (sum-divisors-iter n (+ i 1) sum))))\n    (sum-divisors-iter n 1 0))\n  (define (sum-amicable-numbers-iter n sum)\n    (cond ((&gt; n limit) sum)\n          ((= (sum-divisors n) (sum-divisors (sum-divisors n)))\n           (sum-amicable-numbers-iter (+ n 1) (+ sum n)))\n          (else (sum-amicable-numbers-iter (+ n 1) sum))))\n  (sum-amicable-numbers-iter 1 0))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (modulo n x))) (range 1 (add1 (quotient n 2)))))\n  (define (sum_of_divisors n)\n    (apply + (divisors n)))\n  (define (is_amicable n)\n    (let ((m (sum_of-divisors n)))\n      (and (= m (sum_of_divisors m))\n           (not (= n m)))))\n  (apply + (filter is_amicable (range 1 limit))))\n",
    "  (define (sum-divisors n)\n    (define (sum-divisors-iter n sum)\n      (cond ((= n 1) sum)\n            ((= (remainder n 2) 0)\n             (sum-divisors-iter (/ n 2) (+ sum n)))\n            (else (sum-divisors-iter (- n 1) sum))))\n    (sum-divisors-iter n 1))\n  (define (is-amicable? n)\n    (let ((sum-n (sum-divisors n)))\n      (and (= (sum-divisors sum-n) n)\n           (/= sum-n n))))\n  (define (amicable-numbers-sum-iter n sum)\n    (cond ((= n limit) sum)\n          ((is-amicable? n) (amicable-numbers-sum-iter (+ n 1) (+ sum n)))\n          (else (amicable-numbers-sum-iter (+ n 1) sum))))\n  (amicable-numbers-sum-iter 1 0))\n",
    "  (define (amicable? n)\n    (let ((m (sum-of-divisors n)))\n      (and (not (= n m)) (= (sum-of-divisors m) n))))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= (modulo n x) 0))\n            (range 1 (add1 (quotient n 2)))))\n  (define (amicable? n)\n    (let ((n2 (sum (divisors n))))\n      (and (= n2 (sum (divisors n2)))\n           (not (= n n2)))))\n  (sum (filter amicable? (range 1 limit))))\n",
    "  (define (amicable-numbers-sum-iter limit sum)\n    (if (= limit 1)\n        sum\n        (let ((divisors-sum (divisors-sum limit)))\n          (if (and (= (divisors-sum divisors-sum) limit)\n                   (not (= limit divisors-sum)))\n              (amicable-numbers-sum-iter (- limit 1) (+ sum limit))\n              (amicable-numbers-sum-iter (- limit 1) sum)))))\n  (amicable-numbers-sum-iter limit 0))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (modulo n x))) (range 1 (add1 (quotient n 2)))))\n  (define (sum_divisors n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((m (sum_divisors n)))\n      (and (= n (sum_divisors m))\n           (not (= n m)))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (amicable? n)\n    (let ([m (sum_proper_divisors n)])\n      (and (not (= n m)) (= (sum_proper_divisors m) n))))\n  (define (sum_proper_divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (amicable? n)\n    (let ((m (sum_of_divisors n)))\n      (and (not (= n m)) (= (sum_of_divisors m) n))))\n  (define (sum_of_divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (quotient n 2))]\n                 #:when (zero? (remainder n i)))\n        i))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (amicable-pair? a b)\n    (and (= (sum-of-divisors a) b)\n         (= (sum-of-divisors b) a)))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (filter (lambda (x) (= (modulo n x) 0))\n              (range 1 (add1 (quotient n 2)))))\n    (apply + (divisors n)))\n  (apply +\n         (filter (lambda (x)\n                   (let ((y (sum-of-divisors x)))\n                     (and (not (= x y))\n                          (amicable-pair? x y))))\n                 (range 1 limit))))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= (remainder n x) 0))\n            (range 1 (add1 (quotient n 2)))))\n  (define (sum_divisors n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((m (sum_divisors n)))\n      (and (not (= n m))\n           (= n (sum_divisors m)))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (modulo n x)))\n            (range 1 (add1 (quotient n 2)))))\n  (define (sum_of_divisors n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((m (sum_of_divisors n)))\n      (and (not (= n m))\n           (= (sum_of_divisors m) n))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (divisors n)\n    (define (divisors-iter n i)\n      (if (&gt; i n)\n          '()\n          (if (zero? (modulo n i))\n              (cons i (divisors-iter n (+ i 1)))\n              (divisors-iter n (+ i 1)))))\n    (divisors-iter n 1))\n  (define (sum-divisors n)\n    (apply + (divisors n)))\n  (define (is-amicable n)\n    (let ((sum-divisors-n (sum-divisors n)))\n      (and (not (= n sum-divisors-n))\n           (= n (sum-divisors sum-divisors-n)))))\n  (define (amicable-numbers-sum-iter n sum)\n    (if (&gt; n limit)\n        sum\n        (if (is-amicable n)\n            (amicable-numbers-sum-iter (+ n 1) (+ sum n))\n            (amicable-numbers-sum-iter (+ n 1) sum))))\n  (amicable-numbers-sum-iter 1 0))\n"
  ]
}