{
  "name": "mbpp_123_amicable_numbers_sum",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Write a function to sum all amicable numbers from 1 to a specified number.\n(define (amicable_numbers_sum limit)\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_123_amicable_numbers_sum.py",
  "prompt_terminology": "verbatim",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate amicable_numbers_sum))\n    (check-equal? (candidate 999) 504)\n    (check-equal? (candidate 9999) 31626)\n    (check-equal? (candidate 99) 0)\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (define (amicable-numbers-sum-iter limit sum)\n    (cond ((&gt; limit 1)\n           (let ((d (sum-of-divisors (- limit 1))))\n             (if (and (= d limit) (&gt; d 1))\n                 (amicable-numbers-sum-iter (- limit 1) (+ sum limit))\n               (amicable-numbers-sum-iter (- limit 1) sum))))\n          (else sum)))\n  (amicable-numbers-sum-iter limit 0))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (modulo n x))) (range 1 (add1 (quotient n 2)))))\n  (define (amicable? n)\n    (let ((n2 (sum (divisors n))))\n      (and (= n2 (sum (divisors n2)))\n           (not (= n n2)))))\n  (sum (filter amicable? (range 1 limit))))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (modulo n x))) (range 1 (add1 (quotient n 2)))))\n  (define (sum-divisors n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((m (sum-divisors n)))\n      (and (not (= n m)) (= n (sum-divisors m)))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (amicable-pairs limit)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (when (zero? (modulo n i))\n          i)))\n    (define (sum-divisors n)\n      (apply + (divisors n)))\n    (for/list ([i (in-range 1 limit)])\n      (let ([sum (sum-divisors i)])\n        (when (and (not (zero? sum))\n                   (= (sum-divisors sum) i))\n          (list i sum)))))\n  (apply + (apply append (amicable-pairs limit))))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (modulo n x)))\n            (range 1 (add1 (quotient n 2)))))\n  (define (sum_of_divisors n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((m (sum_of_divisors n)))\n      (and (not (= n m))\n           (= n (sum_of_divisors m)))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= (remainder n x) 0))\n            (range 1 (add1 (quotient n 2)))))\n  (define (amicable? n)\n    (let ((n2 (sum (divisors n))))\n      (and (not (= n n2))\n           (= n (sum (divisors n2))))))\n  (sum (filter amicable? (range 1 limit))))\n",
    "  (define (sum-divisors n)\n    (define (sum-divisors-iter n sum)\n      (if (= n 1)\n          sum\n          (if (= (remainder n 2) 0)\n              (sum-divisors-iter (/ n 2) (+ sum (/ n 2)))\n              (sum-divisors-iter (- n 1) (+ sum (divisor n)))\n              )))\n    (sum-divisors-iter n 0))\n  (define (divisor n)\n    (define (divisor-iter n divisor)\n      (if (= (remainder n divisor) 0)\n          divisor\n          (divisor-iter n (+ divisor 1))))\n    (divisor-iter n 1))\n  (define (amicable-numbers-sum-iter n sum)\n    (if (= n limit)\n        sum\n        (if (= (sum-divisors (+ n 1)) n)\n            (amicable-numbers-sum-iter (+ n 1) (+ sum n))\n            (amicable-numbers-sum-iter (+ n 1) sum))))\n  (amicable-numbers-sum-iter 1 0))\n",
    "  (let loop ((i 1) (sum 0))\n    (cond ((&gt; i limit) sum)\n          ((= (sum_of_divisors i) (+ i (sum_of_divisors (sum_of_divisors i))))\n           (loop (+ i 1) (+ sum i (sum_of_divisors i))))\n          (else (loop (+ i 1) sum)))))\n",
    "  (define (amicable-pair? a b)\n    (and (= a (sum-of-divisors b))\n         (= b (sum-of-divisors a))))\n  (define (sum-of-divisors n)\n    (define (sum-of-divisors-iter n i sum)\n      (cond ((&gt; i n) sum)\n            ((divides? i n) (sum-of-divisors-iter n (+ i 1) (+ sum i)))\n            (else (sum-of-divisors-iter n (+ i 1) sum))))\n    (sum-of-divisors-iter n 1 0))\n  (define (divides? a b)\n    (= (remainder b a) 0))\n  (define (sum-of-amicable-numbers-iter n i sum)\n    (cond ((&gt; i n) sum)\n          ((amicable-pair? i (sum-of-divisors i)) (sum-of-amicable-numbers-iter n (+ i 1) (+ sum i)))\n          (else (sum-of-amicable-numbers-iter n (+ i 1) sum))))\n  (sum-of-amicable-numbers-iter limit 1 0))\n</code>\n",
    "  (define (amicable-pair? a b)\n    (and (= (sum-of-divisors a) b)\n         (= (sum-of-divisors b) a)))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (/ n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (define (amicable-numbers)\n    (for/list ([i (in-range 1 limit)])\n      (for/list ([j (in-range 1 limit)])\n        (if (amicable-pair? i j) i))))\n  (apply + (amicable-numbers)))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (remainder n x)))\n            (range 1 (add1 (quotient n 2)))))\n  (define (amicable? n)\n    (let ((dn (apply + (divisors n))))\n      (and (not (= n dn)) (= n (apply + (divisors dn))))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (amicable-pair? a b)\n    (and (= (sum-of-divisors a) b)\n         (= (sum-of-divisors b) a)))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (quotient n 2))]\n                 #:when (zero? (remainder n i)))\n        i))\n    (apply + (divisors n)))\n  (define (amicable-numbers)\n    (for/list ([i (in-range 1 limit)]\n               [j (in-range 1 limit)])\n      (when (amicable-pair? i j)\n        i)))\n  (apply + (amicable-numbers)))\n",
    "  (define (amicable? n)\n    (let ((n-divisors (divisors n)))\n      (and (not (null? n-divisors))\n           (= n (apply + (map (lambda (x) (- x)) n-divisors)))\n           (= (apply + n-divisors) n))))\n  (define (divisors n)\n    (filter (lambda (x) (= (remainder n x) 0))\n            (range 1 (quotient n 2))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (amicable-number? n)\n    (let ([m (sum-of-divisors n)])\n      (and (not (= n m)) (= n (sum-of-divisors m)))))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (apply + (filter amicable-number? (in-range 1 limit))))\n",
    "  (define (amicable-pair? a b)\n    (and (= (sum-of-divisors a) b)\n         (= (sum-of-divisors b) a)))\n  (define (sum-of-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (remainder n i)) i)))\n    (apply + (divisors n)))\n  (define (amicable-numbers n)\n    (for/list ([i (in-range 1 n)])\n      (if (amicable-pair? i (sum-of-divisors i)) i)))\n  (apply + (amicable-numbers limit)))\n",
    "  (define (amicable? n)\n    (let ((m (sum_of_divisors n)))\n      (and (not (= n m)) (= n (sum_of_divisors m)))))\n  (define (sum_of_divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (apply + (filter amicable? (in-range 1 limit))))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (remainder n x)))\n            (range 1 (add1 (quotient n 2)))))\n  (define (sum_divisors n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (let ((m (sum_divisors n)))\n      (and (not (= n m))\n           (= (sum_divisors m) n))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (remainder n x)))\n            (range 1 (add1 (quotient n 2)))))\n  (define (amicable? n)\n    (let ((m (apply + (divisors n))))\n      (and (not (= n m))\n           (= n (apply + (divisors m))))))\n  (apply + (filter amicable? (range 1 limit))))\n",
    "  (define (sum-divisors n)\n    (define (divisors n)\n      (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n        (if (zero? (modulo n i)) i)))\n    (apply + (divisors n)))\n  (define (is-amicable? n)\n    (let ([sum-n (sum-divisors n)])\n      (and (not (zero? sum-n))\n           (equal? n (sum-divisors sum-n)))))\n  (apply + (for/list ([i (in-range 1 limit)])\n              (if (is-amicable? i) i))))\n",
    "  (define (divisors n)\n    (filter (lambda (x) (= 0 (modulo n x))) (range 1 (quotient n 2))))\n  (define (sum_divisors n)\n    (apply + (divisors n)))\n  (define (amicable? n)\n    (and (= n (sum_divisors (sum_divisors n)))\n         (not (= n (sum_divisors n)))))\n  (apply + (filter amicable? (range 1 limit))))\n"
  ]
}