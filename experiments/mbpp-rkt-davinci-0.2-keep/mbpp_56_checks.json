{
  "name": "mbpp_56_checks",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Write a python function to check if a given number is one less than twice its reverse.\n(define (checks n)\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_56_checks.py",
  "prompt_terminology": "verbatim",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate checks))\n    (check-equal? (candidate 70) #f)\n    (check-equal? (candidate 23) #f)\n    (check-equal? (candidate 73) #t)\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (let ([r (reverse n)])\n    (and (equal? (sub1 (* 2 r)) n)\n         (not (equal? (sub1 (* 2 (sub1 r))) n)))))\n",
    "  (let ([rev (reverse n)])\n    (= (- (* 2 rev) 1) n)))\n",
    "  (let ([r (string->number (string-reverse (number->string n)))])\n    (= (- n 1) (* 2 r))))\n",
    "  (let ([n (number->string n)])\n    (let ([n (string-reverse n)])\n      (let ([n (string->number n)])\n        (let ([n (+ n 1)])\n          (let ([n (* n 2)])\n            (let ([n (number->string n)])\n              (let ([n (string-reverse n)])\n                (let ([n (string->number n)])\n                  (let ([n (+ n 1)])\n                    (let ([n (* n 2)])\n                      (let ([n (number->string n)])\n                        (let ([n (string-reverse n)])\n                          (let ([n (string->number n)])\n                            (let ([n (+ n 1)])\n                              (let ([n (* n 2)])\n                                (let ([n (number->string n)])\n                                  (let ([n (string-reverse n)])\n                                    (let ([n (string->number n)])\n                                      (let ([n (+ n 1)])\n                                        (let ([n (* n 2)])\n                                          (let ([n (number->string n)])\n                                            (let ([n (string-reverse n)])\n                                              (let ([n (string->number n)])\n                                                (let ([n (+ n 1)])\n                                                  (let ([n (* n 2)])\n                                                    (let ([n (number->string n)])\n                                                      (let ([n (string-reverse n)])\n                                                        (let ([n (string->number n)])\n                                                          (let ([n (+ n 1)])\n                                                            (let ([n (* n 2)])\n                                                              (let ([n (number->string n)])\n                                                                (let ([n (string-reverse n)])\n                                                                  (let ([n (string->number n)])\n                                                                    (let ([n (+ n 1)])\n                                                                      (let ([n (* n 2)])\n                                                                        (let ([n (number->string n)])\n                                                                          (let ([n (string-reverse n)])\n                                                                            (",
    "  (let ([r (string->number (string-reverse (number->string n)))])\n    (= (- n r) 1)))\n",
    "  (if (= n (+ 1 (* 2 (reverse-digits n))))\n      #t\n      #f))\n",
    "  (let ([rev (string->number (string-reverse (number->string n)))])\n    (= n (- (* 2 rev) 1))))\n",
    "  (if (= n (+ (- (* 2 (reverse-number n)) 1) 1))\n      #t\n      #f))\n",
    "  (let ([r (reverse n)])\n    (= (- (* 2 r) 1) n)))\n",
    "  (let ([r (reverse n)])\n    (= (- (* 2 r) 1) n)))\n",
    "  (if (= (- n (* 2 (reverse-digits n))) 1)\n      #t\n      #f))\n",
    "  (let ([n-rev (string->number (string-reverse (number->string n)))])\n    (= (- n 1) (* 2 n-rev))))\n",
    "  (let ([n-str (number->string n)]\n        [n-rev (string->number (string-reverse n-str))])\n    (= (- (* 2 n-rev) 1) n)))\n",
    "  (let ([rev (string->number (string-reverse (number->string n)))])\n    (= n (- (* 2 rev) 1))))\n",
    "  (let ([r (reverse n)])\n    (= (- n 1) (* 2 r))))\n",
    "  (let ([r (reverse n)])\n    (and (equal? (sub1 (* 2 r)) n)\n         (not (zero? (modulo n 10))))))\n",
    "  (let ((n-str (number->string n))\n        (n-rev (number->string (reverse-number n))))\n    (if (= (- (string->number n-str) (string->number n-rev)) 1)\n        #t\n        #f)))\n",
    "  (define (reverse n)\n    (define (iter n r)\n      (if (zero? n)\n          r\n          (iter (quotient n 10) (+ (* r 10) (remainder n 10)))))\n    (iter n 0))\n  (if (= (- n (reverse n)) 1)\n      #t\n      #f))\n",
    "  (let ([r (string->number (string-reverse (number->string n)))])\n    (= n (- (* 2 r) 1))))\n",
    "  (let ([r (reverse-number n)])\n    (= (- (* 2 r) 1) n)))\n"
  ]
}