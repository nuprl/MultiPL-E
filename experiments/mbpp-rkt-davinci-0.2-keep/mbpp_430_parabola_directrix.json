{
  "name": "mbpp_430_parabola_directrix",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Write a function to find the directrix of a parabola.\n(define (parabola_directrix a b c)\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_430_parabola_directrix.py",
  "prompt_terminology": "verbatim",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parabola_directrix))\n    (check-equal? (candidate 5 3 2) -198)\n    (check-equal? (candidate 9 8 4) -2336)\n    (check-equal? (candidate 2 4 6) -130)\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (let ([x (/ (* -1 b) (* 2 a))])\n    (let ([y (+ (* a (sqr x)) (* b x) c)])\n      (let ([d (- y (/ b (* 2 a)))])\n        d))))\n",
    "  (define (directrix x)\n    (+ (* a x) b))\n  (directrix 0))\n",
    "  (define (parabola_directrix_helper x)\n    (sqrt (+ (* a x) b)))\n  (parabola_directrix_helper (- c)))\n",
    "  (define (directrix x)\n    (/ (- c (* a x)) b))\n  directrix)\n",
    "  (let ((x (- (/ b (* 2 a)))))\n    (if (negative? a)\n        (list x (parabola_y a b c x))\n        (list x (parabola_y a b c x)))))\n",
    "  (define (parabola-directrix-helper x)\n    (sqrt (- (* a x) b)))\n  (parabola-directrix-helper c))\n",
    "  (let ([x (/ (- b) (* 2 a))])\n    (let ([y (- (/ b (* 2 a)) (* x x))])\n      (list x y))))\n",
    "  (/ (+ (* -1 a) (* -1 c)) (* 2 b)))\n",
    "  (define (directrix x)\n    (- (/ b (* 2 a)) (* a x)))\n  directrix)\n",
    "  (define (x) (/ (* -1 b) (* 2 a)))\n  (define (y) (+ (/ (* b b) (* 4 a)) (/ c)))\n  (list x y))\n",
    "  (let ([x (- (/ b (* 2 a)) (/ (sqrt (- (* b b) (* 4 a c))) (* 2 a)))])\n    (if (and (number? x) (not (nan? x)))\n        x\n        (error \"No real solution\"))))\n",
    "  (let ((x-value (/ (* -1 b) (* 2 a))))\n    (let ((y-value (+ (* a (sqr x-value)) (* b x-value) c)))\n      (cons x-value y-value))))\n",
    "  (let ((x (- (/ b (* 2 a)))))\n    (- (/ c (+ (* a (sqr x)) (* b x) c)))))\n",
    "  (define (directrix x)\n    (- (/ b (* 2 a))\n       (/ (+ (* x x) (* b x) c) (* 2 a))))\n  directrix)\n",
    "  (define (directrix x)\n    (sqrt (+ (* a x) b)))\n  (directrix))\n",
    "  (let ((x (/ (- b) (* 2 a))))\n    (if (zero? a)\n        (error \"Not a parabola\")\n        (- (/ c (* 2 a)) (* x x)))))\n",
    "  (define (directrix x)\n    (+ (/ b (* 2 a))\n       (sqrt (- (sqr (- x (/ b (* 2 a))))\n                (/ c a)))))\n  directrix)\n",
    "  (- (/ b (* 2 a))))\n",
    "  (- (/ b (* 2 a))))\n",
    "  (let ([x (/ (- b) (* 2 a))])\n    (if (positive? a)\n        (- (/ c a) (* x x))\n        (+ (/ c a) (* x x)))))\n",
    "  (define (directrix x)\n    (+ (/ b (* 2 a))\n       (sqrt (- (sqr b) (* 4 a c)))))\n  directrix)\n",
    "  (define (directrix x)\n    (- (/ b (* 2 a))\n       (sqrt (- (sqr b) (* 4 a c)))))\n  directrix)\n",
    "  (- (/ b (* 2 a))))\n",
    "  (define (directrix x)\n    (define (parabola y)\n      (+ (* a y) (* b y) c))\n    (define (derivative y)\n      (* a 2))\n    (define (newton_raphson y)\n      (define (newton_raphson_iter guess)\n        (if (close-enough? guess (newton_raphson_next guess))\n            guess\n            (newton_raphson_iter (newton_raphson_next guess))))\n      (define (newton_raphson_next guess)\n        (- guess (/ (parabola guess) (derivative guess))))\n      (newton_raphson_iter y))\n    (newton_raphson x))\n  directrix)\n",
    "  (define (f x)\n    (+ (* a x) (* b x x) c))\n  (define (df x)\n    (+ (* a 1) (* b 2 x)))\n  (define (newton x)\n    (newton-help x (f x) (df x)))\n  (define (newton-help x fx dfx)\n    (let ((x1 (- x (/ fx dfx))))\n      (if (close-enough? x x1)\n          x\n          (newton-help x1 (f x1) (df x1)))))\n  (define (close-enough? x1 x2)\n    (< (abs (- x1 x2)) 0.001))\n  (newton 0))\n",
    "  (define (f x)\n    (+ (* a x) (* b x x) c))\n  (define (g x)\n    (- (* a x) (* b x x) c))\n  (define (h x)\n    (f x))\n  (define (k x)\n    (g x))\n  (define (df dx)\n    (/ (- (f (+ x dx)) (f x))\n       dx))\n  (define (dg dx)\n    (/ (- (g (+ x dx)) (g x))\n       dx))\n  (define (dh dx)\n    (/ (- (h (+ x dx)) (h x))\n       dx))\n  (define (dk dx)\n    (/ (- (k (+ x dx)) (k x))\n       dx))\n  (define (newton transform guess)\n    (define tolerance 0.00001)\n    (define (close-enough? v1 v2)\n      (< (abs (- v1 v2)) tolerance))\n    (define (try guess)\n      (let ((next (transform guess)))\n        (if (close-enough? guess next)\n            next\n            (try next))))\n    (try guess))\n  (define (transform guess)\n    (- guess (/ (transform guess) (dtransform guess))))\n  (newton transform 1.0))\n",
    "  (let* ([x-vertex (/ (- b) (* 2 a))]\n         [y-vertex (+ (* a (sqr x-vertex)) (* b x-vertex) c)])\n    (- y-vertex (/ (sqr b) (* 4 a)))))\n",
    "  (define (f x)\n    (+ (* a x) (* b x x) c))\n  (define (g x)\n    (- (/ b (* 2 a)) x))\n  (define (h x)\n    (- (/ c a) (* b x) (* x x)))\n  (define (i x)\n    (- (/ c a) (* b x) (* x x)))\n  (define (j x)\n    (- (/ c a) (* b x) (* x x)))\n  (define (k x)\n    (- (/ c a) (* b x) (* x x)))\n  (define (l x)\n    (- (/ c a) (* b x) (* x x)))\n  (define (m x)\n    (- (/ c a) (* b x) (* x x)))\n  (define (n x)\n    (- (/ c a) (* b x) (* x x)))\n  (define (o x)\n    (- (/ c a) (* b x) (* x x)))\n  (define (p x)\n    (- (/ c a) (* b x) (* x x)))\n  (define (q x)\n    (- (/ c a) (* b x) (* x x)))\n  (define (r x)\n    (- (/ c a) (* b x) (* x x)))\n  (define (s x)\n    (- (/ c a) (* b x) (* x x)))\n  (define (t x)\n    (- (/ c a) (* b x) (* x x)))\n  (define (u x)\n    (- (/ c a) (* b x) (* x x)))\n  (define (v x)\n    (- (/ c a) (* b x) (* x x)))\n  (define (w x)\n    (- (/ c a) (* b x) (* x x)))\n  (define (x x)\n    (- (/ c a) (* b x) (* x x)))\n  (define (y x)\n    (- (/ c a) (* b x) (* x x)))\n  (define (z x)\n    (- (/ c a) (* b x) (* x x)))\n  (define (aa x)\n    (- (/ c a) (* b x) (* x x)))\n  (define (bb x)\n    (-",
    "  (define (directrix x)\n    (- (/ b (* 2 a))\n       (sqrt (- (sqr b) (* 4 a c)))))\n  directrix)\n",
    "  (let ([x (- (/ b (* 2 a)) (/ (sqrt (- (* b b) (* 4 a c))) (* 2 a)))])\n    (if (and (number? x) (not (complex? x)))\n        x\n        (error \"No directrix\"))))\n",
    "  (define (directrix x)\n    (define (parabola y)\n      (+ (* a y) (* b y y) c))\n  (define (derivative y)\n    (+ (* b y) (* b 2)))\n  (define (newton-transform g)\n    (lambda (x)\n      (- x (/ (g x) ((derivative x))))))\n  (define (fixed-point f x)\n    (if (close-enough? (f x) x)\n        x\n        (fixed-point f (f x))))\n  (define (close-enough? x y)\n    (< (abs (- x y)) 0.0001))\n  (define (derivative x)\n    (/ (- (parabola (+ x 0.0001)) (parabola x)) 0.0001))\n  (define (newton-transform g)\n    (lambda (x)\n      (- x (/ (g x) ((derivative x))))))\n  (define (fixed-point f x)\n    (if (close-enough? (f x) x)\n        x\n        (fixed-point f (f x))))\n  (define (close-enough? x y)\n    (< (abs (- x y)) 0.0001))\n  (define (derivative x)\n    (/ (- (parabola (+ x 0.0001)) (parabola x)) 0.0001))\n  (define (newton-transform g)\n    (lambda (x)\n      (- x (/ (g x) ((derivative x))))))\n  (define (fixed-point f x)\n    (if (close-enough? (f x) x)\n        x\n        (fixed-point f (f x))))\n  (define (close-enough? x y)\n    (< (abs (- x y)) 0.0001))\n  (define (derivative x)\n    (/ (- (parabola (+ x 0.0001)) (parabola x)) 0.0001))\n  (define (newton-transform g)\n    (lambda (x)\n      (- x (/ (g x) ((derivative x))))))\n  (define (fixed-point f x)\n    (if (close-enough? (f x) x",
    "  (define (directrix x)\n    (+ (/ b (* 2 a))\n       (sqrt (- (sqr b) (* 4 a c)))))\n  directrix)\n",
    "  (define (directrix x)\n    (define (parabola y)\n      (+ (* a y y) (* b y) c))\n  (define (derivative y)\n    (* 2 a y))\n  (define (newton-transform g)\n    (lambda (x)\n      (- x (/ (g x) ((derivative x))))))\n  (define (fixed-point f x)\n    (define (close-enough? v1 v2)\n      (< (abs (- v1 v2)) 0.00001))\n    (define (try guess)\n      (let ((next (f guess)))\n        (if (close-enough? guess next)\n            next\n            (try next))))\n    (try x))\n  (define (find-zero f)\n    (fixed-point (newton-transform f) 1.0))\n  (define (find-y x)\n    (find-zero (lambda (y) (- (parabola y) x))))\n  (- (find-y x) (/ b 2)))\n",
    "  (define (directrix x)\n    (- (/ b (* 2 a))\n       (/ (sqrt (+ (sqr (- (/ b (* 2 a))))\n                   (* 4 a c)))\n          (* 2 a))))\n  directrix)\n",
    "  (let ((d (- (* b b) (* 4 a c))))\n    (if (&lt; d 0)\n        (error \"No real solution\")\n        (let ((x1 (/ (+ b (sqrt d)) (* 2 a)))\n              (x2 (/ (- b (sqrt d)) (* 2 a))))\n          (if (&lt; x1 x2)\n              x1\n              x2)))))\n",
    "  (define (directrix x)\n    (+ (/ b 2) (* a x) (/ (- (sqr x)) (4 c))))\n  directrix)\n",
    "  (define (directrix x)\n    (/ (- b) (* 2 a)))\n  (directrix 0))\n",
    "  (let ([x (- (/ b (* 2 a)))]\n        [y (- (/ c b))])\n    (list x y)))\n",
    "  (let ([x (- (* b b) (* 4 a c))])\n    (if (&lt; x 0)\n        (error \"No real solution\")\n        (let ([y (/ (- b) (* 2 a))])\n          (if (&lt; y 0)\n              (error \"No real solution\")\n              (sqrt y))))))\n",
    "  (define (directrix x)\n    (+ (/ b (* -2 a))\n       (sqrt (- (sqr b) (* 4 a c)))))\n  directrix)\n",
    "  (let ([d (/ (* -1 b) (* 2 a))])\n    (if (negative? a)\n        (+ d)\n        (- d))))\n",
    "  (let ([x (- (/ b 2) (/ (* a b) (sqrt (* 4 a c))))])\n    (if (and (number? x) (not (nan? x)))\n        x\n        (error \"No directrix\"))))\n",
    "  (define (f x)\n    (+ (* a x) (* b x x) c))\n  (define (g x)\n    (- (/ c x) (/ b x)))\n  (define (h x)\n    (- (/ c x) (/ b x)))\n  (define (i x)\n    (- (/ c x) (/ b x)))\n  (define (j x)\n    (- (/ c x) (/ b x)))\n  (define (k x)\n    (- (/ c x) (/ b x)))\n  (define (l x)\n    (- (/ c x) (/ b x)))\n  (define (m x)\n    (- (/ c x) (/ b x)))\n  (define (n x)\n    (- (/ c x) (/ b x)))\n  (define (o x)\n    (- (/ c x) (/ b x)))\n  (define (p x)\n    (- (/ c x) (/ b x)))\n  (define (q x)\n    (- (/ c x) (/ b x)))\n  (define (r x)\n    (- (/ c x) (/ b x)))\n  (define (s x)\n    (- (/ c x) (/ b x)))\n  (define (t x)\n    (- (/ c x) (/ b x)))\n  (define (u x)\n    (- (/ c x) (/ b x)))\n  (define (v x)\n    (- (/ c x) (/ b x)))\n  (define (w x)\n    (- (/ c x) (/ b x)))\n  (define (x x)\n    (- (/ c x) (/ b x)))\n  (define (y x)\n    (- (/ c x) (/ b x)))\n  (define (z x)\n    (- (/ c x) (/ b x)))\n  (define (aa x)\n    (- (/ c x) (/ b x)))\n  (define (bb x)\n    (- (/ c x) (/ b x)))\n  (define (cc x)\n    (- (/ c x) (/ b x)))\n  (define (dd x)\n    (- (/ c x) (/ b x)))\n  (define (ee x)\n    (- (/ c x) (/ b x)))\n  (define (ff x)\n    (- (/ c x)",
    "  (define (f x)\n    (+ (* a x) (* b x x) c))\n  (/ (- c (f 0)) b))\n",
    "  (define (directrix x)\n    (+ (/ b (* 2 a))\n       (sqrt (- (sqr b) (* 4 a c)))))\n  directrix)\n",
    "  (let ((d (sqrt (- (* b b) (* 4 a c)))))\n    (/ (- b d) (* 2 a))))\n",
    "  (define (directrix x)\n    (+ (/ (- b) (* 2 a))\n       (sqrt (- (sqr (- b)) (* 4 a c)))))\n  directrix)\n",
    "  (let ([x (/ (* -1 b) (* 2 a))])\n    (let ([y (- (/ b (* 2 a)) (* a (sqr x)))])\n      (list x y))))\n",
    "  (let ((x0 (/ (* -1 b) (* 2 a))))\n    (let ((y0 (+ (* a (sqr x0)) (* b x0) c)))\n      (let ((m (/ (* -1 a) b)))\n        (let ((b (+ y0 (* m x0))))\n          (list m b))))))\n",
    "  (define (parabola_directrix_helper a b c x)\n    (- (/ b 2) (* a x)))\n  (define (parabola_directrix_helper_2 a b c x)\n    (- (/ b 2) (* a x)))\n  (define (parabola_directrix_helper_3 a b c x)\n    (- (/ b 2) (* a x)))\n  (define (parabola_directrix_helper_4 a b c x)\n    (- (/ b 2) (* a x)))\n  (define (parabola_directrix_helper_5 a b c x)\n    (- (/ b 2) (* a x)))\n  (define (parabola_directrix_helper_6 a b c x)\n    (- (/ b 2) (* a x)))\n  (define (parabola_directrix_helper_7 a b c x)\n    (- (/ b 2) (* a x)))\n  (define (parabola_directrix_helper_8 a b c x)\n    (- (/ b 2) (* a x)))\n  (define (parabola_directrix_helper_9 a b c x)\n    (- (/ b 2) (* a x)))\n  (define (parabola_directrix_helper_10 a b c x)\n    (- (/ b 2) (* a x)))\n  (define (parabola_directrix_helper_11 a b c x)\n    (- (/ b 2) (* a x)))\n  (define (parabola_directrix_helper_12 a b c x)\n    (- (/ b 2) (* a x)))\n  (define (parabola_directrix_helper_13 a b c x)\n    (- (/ b 2) (* a x)))\n  (define (parabola_directrix_helper_14 a b c x)\n    (- (/ b 2) (* a x)))\n  (define (parabola_directrix_helper_15 a b c x)\n    (- (/ b 2) (* a x)))\n  (define (parabola_directrix_helper_16 a b c x)\n    (- (/ b 2) (* a x)))\n ",
    "  (define (f x)\n    (+ (* a x) (* b x x) c))\n  (define (g x)\n    (- (f x) (* 2 a x)))\n  (define (h x)\n    (- (g x) b))\n  (define (i x)\n    (/ (h x) (* 2 a)))\n  (i 0))\n",
    "  (let ([x (- (/ b (* 2 a)) (/ (sqrt (- (* b b) (* 4 a c))) (* 2 a)))])\n    (if (and (number? x) (not (nan? x)))\n        x\n        (error \"No real solution\"))))\n",
    "  (let ((d (- (* 4 a c) (sqr b))))\n    (if (negative? d)\n        (error \"The parabola has no directrix.\")\n        (let ((x (/ (- b) (* 2 a))))\n          (cons x (- (/ d (* 4 a)))))))\n",
    "  (let ([x (- (/ b 2) (/ (sqrt (- (* b b) (* 4 a c))) 2))])\n    (if (and (number? x) (not (nan? x)))\n        x\n        (error \"no directrix\"))))\n",
    "  (let ([x (- (/ b (* 2 a)) (/ (sqrt (- (* b b) (* 4 a c))) (* 2 a)))])\n    (if (and (number? x) (not (nan? x)))\n        x\n        (error \"No real solution\"))))\n",
    "  (define (directrix x)\n    (- (/ b (* 2 a))\n       (sqrt (- (sqr b) (* 4 a c)))))\n  directrix)\n",
    "  (let ([d (/ b (* 2 a))])\n    (if (zero? a)\n        (error \"Not a parabola\")\n        (- (/ c a) (* d d)))))\n",
    "  (let ([x (/ (- b) (* 2 a))])\n    (if (zero? a)\n        (error \"a cannot be zero\")\n        (+ c (* a (square x))))))\n",
    "  (define (f x)\n    (+ (* a x) (* b x x) c))\n  (define (df x)\n    (+ (* (* 2 a) x) b))\n  (define (newton f df guess)\n    (define (close-enough? v1 v2)\n      (< (abs (- v1 v2)) 0.001))\n    (define (try guess)\n      (let ((next (newton-transform guess)))\n        (if (close-enough? guess next)\n            next\n            (try next))))\n    (define (newton-transform x)\n      (- x (/ (f x) (df x))))\n    (try guess))\n  (newton f df 0))\n",
    "  (let ([x (- (/ b (* 2 a)) (/ (sqrt (- (* b b) (* 4 a c))) (* 2 a)))])\n    (if (and (number? x) (not (nan? x)))\n        x\n        (error \"No directrix\"))))\n",
    "  (let ((x (- (/ b (* 2 a)))))\n    (let ((y (- (/ (+ (* a (expt x 2)) (* b x) c) a))))\n      (list x y))))\n",
    "  (let* ([x-vertex (/ (- b) (* 2 a))]\n         [y-vertex (- (/ (+ (* a (expt x-vertex 2)) (* b x-vertex) c) a))])\n    (cons x-vertex y-vertex)))\n",
    "  (let ((x0 (/ (- b) (* 2 a))))\n    (let ((y0 (+ c (* a (expt x0 2)) (* b x0))))\n      (let ((m (/ (- c) (- y0))))\n        (let ((x1 (+ x0 (/ 1 m))))\n          (let ((y1 (+ y0 (/ 1 m))))\n            (list x1 y1)))))))\n",
    "  (define (directrix x)\n    (- (/ b (* 2 a))\n       (/ (sqrt (+ (* b b) (* 4 a c) (* 4 a x))) (* 2 a))))\n  directrix)\n",
    "  (- (/ b (* 2 a))))\n",
    "  (define (parabola_directrix_helper x)\n    (sqrt (+ (* a x) b)))\n  (parabola_directrix_helper c))\n",
    "  (- (/ b 2) (/ (* a b) (2 c))))\n",
    "  (let ((x-axis-intercept (/ (- b) (* 2 a))))\n    (let ((y-axis-intercept (+ c (* a (expt x-axis-intercept 2)) (* b x-axis-intercept))))\n      (list x-axis-intercept y-axis-intercept))))\n",
    "  (define (f x)\n    (+ (* a x) (* b x x) c))\n  (define (df x)\n    (+ (* b x) b))\n  (define (newton-transform g)\n    (lambda (x)\n      (- x (/ (g x) (df x)))))\n  (define (fixed-point f x)\n    (if (close-enough? (f x) x)\n        x\n        (fixed-point f (f x))))\n  (define (close-enough? v1 v2)\n    (< (abs (- v1 v2)) tolerance))\n  (define tolerance 0.00001)\n  (define (try guess)\n    (fixed-point (newton-transform f) guess))\n  (try 1.0))\n",
    "  (define (x)\n    (/ (- b) (* 2 a)))\n  (define (y)\n    (- (/ b (* 2 a)) (* a (x) (x)) b (x)))\n  (list (x) (y)))\n",
    "  (let ((d (sqrt (+ (* b b) (* 4 a c)))))\n    (/ (- b d) (* 2 a))))\n",
    "  (define (f x)\n    (+ (* a x) (* b x x) c))\n  (define (df x)\n    (+ (* b x) b))\n  (define (newton x)\n    (newton-help x (df x) 0.000001))\n  (define (newton-help x dx epsilon)\n    (if (&lt; (abs (- x (newton-next x dx))) epsilon)\n        x\n        (newton-help (newton-next x dx) dx epsilon)))\n  (define (newton-next x dx)\n    (/ (- (f x) 0) dx))\n  (newton 0))\n</code>\nI'm not sure why this is not working. I've tried to debug it, but I'm not sure what's going on.\nI'm trying to find the directrix of a parabola with the equation <code>y = x^2 + 2x + 3</code>.\nI'm trying to use Newton's method to find the root of the derivative of the function, which is <code>y' = 2x + 2</code>.\nI'm trying to find the root of <code>2x + 2</code> using Newton's method.\nI'm trying to find the root of <code>2x + 2</code> using Newton's method.\nI'm trying to find the root of <code>2x + 2</code> using Newton's method.\nI'm trying to find the root of <code>2x + 2</code> using Newton's method.\nI'm trying to find the root of <code>2x + 2</code> using Newton's method.\nI'm trying to find the root of <code>2x + 2</code> using Newton's method.\nI'm trying to find the root of <code>2x + 2</code> using Newton's method.\nI'm trying to find the root of <code>2x + 2</code> using Newton's method.\nI'm trying to find the root of <code>2x + 2</code> using Newton's method.\nI'm trying to find the root of <code>2x + 2</code> using Newton's method.\nI'm trying to find the root of <code>2x +",
    "  (define (f x)\n    (+ (* a x) (* b x x) c))\n  (define (g x)\n    (- (f x) (* a x)))\n  (define (h x)\n    (- (g x) (* b x)))\n  (define (i x)\n    (- (h x) c))\n  (define (j x)\n    (/ (i x) (* 2 b)))\n  (define (k x)\n    (- (j x) (/ a (* 2 b))))\n  (define (l x)\n    (- (k x) (/ c (* 2 b))))\n  (define (m x)\n    (/ (l x) 2))\n  (define (n x)\n    (- (m x) (/ a 2)))\n  (define (o x)\n    (- (n x) (/ c 2)))\n  (define (p x)\n    (/ (o x) 2))\n  (define (q x)\n    (- (p x) (/ a 2)))\n  (define (r x)\n    (- (q x) (/ c 2)))\n  (define (s x)\n    (/ (r x) 2))\n  (define (t x)\n    (- (s x) (/ a 2)))\n  (define (u x)\n    (- (t x) (/ c 2)))\n  (define (v x)\n    (/ (u x) 2))\n  (define (w x)\n    (- (v x) (/ a 2)))\n  (define (x x)\n    (- (w x) (/ c 2)))\n  (define (y x)\n    (/ (x x) 2))\n  (define (z x)\n    (- (y x) (/ a 2)))\n  (define (aa x)\n    (- (z x) (/ c 2)))\n  (define (bb x)\n    (/ (aa x) 2))\n  (define (cc x)\n    (- (bb x) (/ a 2)))\n  (define (dd x)\n    (- (cc x) (/ c 2)))\n  (define (ee x)\n    (/ (dd x) 2))\n  (define (ff x)\n    (- (ee x) (/ a 2)))\n  (define (gg x)",
    "  (define (directrix x)\n    (+ (/ b (* 2 a))\n       (* (/ (* -1 a) (* 2 a))\n          (* x x))))\n  (directrix 0))\n",
    "  (define (directrix x)\n    (- (/ b (* 2 a))\n       (sqrt (- (sqr b) (* 4 a c)))))\n  directrix)\n",
    "  (- (/ b (* 2 a))))\n",
    "  (let ([x (- b (/ (* b b) (4*a)))])\n    (if (negative? a)\n        (list x)\n        (list (add1 x)))))\n",
    "  (define (directrix x)\n    (define (parabola y)\n      (+ (* a y) (* b y) c))\n    (define (derivative y)\n      (+ (* a 2) b))\n    (define (newton-transform g)\n      (lambda (x)\n        (- x (/ (g x) (derivative x)))))\n    (define (try guess)\n      (let ((next (newton-transform parabola guess)))\n        (if (close-enough? guess (next guess))\n            guess\n            (try (next guess)))))\n    (define (close-enough? v1 v2)\n      (< (abs (- v1 v2)) 0.001))\n    (try x))\n  (directrix 0))\n",
    "  (let ([x (- (/ b (* 2 a)))]\n        [y (+ (/ (* b b) (* 4 a)) (/ c a))])\n    (list x y)))\n",
    "  (define (directrix x)\n    (- (/ b (* 2 a))\n       (sqrt (- (sqr b) (* 4 a c)))))\n  directrix)\n",
    "  (define (directrix x)\n    (+ (* a x) b))\n  (directrix (/ (- 0 c) (* 2 a))))\n",
    "  (let ((x (- (/ b (* 2 a)))))\n    (if (zero? a)\n        (error \"Not a parabola\")\n        (if (positive? a)\n            (- (/ c (+ (* 2 a) (* b x))))\n            (- (/ c (+ (* 2 a) (* b x))))))))\n",
    "  (define (directrix x)\n    (+ (/ b 2) (* a x) (* b x) c))\n  (define (directrix-helper x)\n    (define (f x)\n      (- (directrix x) x))\n    (define (f-prime x)\n      (- (* a 2) b))\n    (define (f-prime-prime x)\n      0)\n    (define (newton-helper x)\n      (newton-method f f-prime f-prime-prime x))\n    (newton-helper x))\n  (directrix-helper (/ b 2)))\n",
    "  (define (f x) (+ (* a x) (* b x x) c))\n  (define (df x) (+ (* a 1) (* b 2 x)))\n  (define (newton x)\n    (if (close-enough? (f x) 0)\n        x\n        (newton (average x (- x (/ (f x) (df x)))))))\n  (define (average x y) (/ (+ x y) 2))\n  (define (close-enough? x y) (< (abs (- x y)) 0.001))\n  (newton 0))\n",
    "  (let ([x (/ (- b) (* 2 a))])\n    (- (/ c a) (* x x))))\n",
    "  (define (directrix x)\n    (- (/ b (* 2 a)) x))\n  directrix)\n",
    "  (let ((x (- (/ b (* 2 a)))))\n    (if (positive? a)\n        (parabola_directrix_positive a b c x)\n        (parabola_directrix_negative a b c x))))\n",
    "  (let* ([x0 (/ (- b) (* 2 a))]\n         [y0 (+ (* a (sqr x0)) (* b x0) c)])\n    (line x0 y0 (angle (point x0 y0) (point 0 y0)))))\n",
    "  (let ([d (/ (* -2 a) b)])\n    (if (zero? b)\n        (error \"The parabola is vertical.\")\n        (if (zero? a)\n            (error \"The parabola is horizontal.\")\n            (if (zero? c)\n                (error \"The parabola is a line.\")\n                (if (zero? d)\n                    (error \"The parabola is a point.\")\n                    (if (zero? (- (* a d) c))\n                        (error \"The parabola is a point.\")\n                        (if (zero? (- (* a d) c))\n                            (error \"The parabola is a point.\")\n                            (if (zero? (- (* a d) c))\n                                (error \"The parabola is a point.\")\n                                (if (zero? (- (* a d) c))\n                                    (error \"The parabola is a point.\")\n                                    (if (zero? (- (* a d) c))\n                                        (error \"The parabola is a point.\")\n                                        (if (zero? (- (* a d) c))\n                                            (error \"The parabola is a point.\")\n                                            (if (zero? (- (* a d) c))\n                                                (error \"The parabola is a point.\")\n                                                (if (zero? (- (* a d) c))\n                                                    (error \"The parabola is a point.\")\n                                                    (if (zero? (- (* a d) c))\n                                                        (error \"The parabola is a point.\")\n                                                        (if (zero? (- (* a d) c))\n                                                            (error \"The parabola is a point.\")\n                                                            (if (zero? (- (* a d) c))\n                                                                (error \"The parabola is a point.\")\n                                                                (if (zero? (- (* a d) c))\n                                                                    (error \"The parabola is a point.\")\n                                                                    (if (zero? (- (* a d) c))\n                                                                        (error \"The parabola is a point.\")\n                                                                        (if (zero? (- (* a d)",
    "  (let ([x (- (/ b (* 2 a)))]\n        [y (- (/ c b))])\n    (list x y)))\n",
    "  (let ((x (- b (/ (sqrt (* (- (* b b) (* 4 a c)))) (* 2 a)))))\n    (if (negative? a)\n        (if (negative? c)\n            (+ x)\n            (- x))\n        (if (negative? c)\n            (- x)\n            (+ x)))))\n",
    "  (let ([x (- (/ b (* 2 a)))]\n        [y (- (/ c b))])\n    (if (zero? a)\n        (error \"a is zero\")\n        (if (zero? b)\n            (error \"b is zero\")\n            (if (zero? c)\n                (error \"c is zero\")\n                (if (zero? x)\n                    (error \"x is zero\")\n                    (if (zero? y)\n                        (error \"y is zero\")\n                        (if (zero? (- y))\n                            (error \"y is zero\")\n                            (if (zero? (- x))\n                                (error \"x is zero\")\n                                (if (zero? (- y x))\n                                    (error \"y - x is zero\")\n                                    (if (zero? (- y x))\n                                        (error \"y - x is zero\")\n                                        (if (zero? (- y x))\n                                            (error \"y - x is zero\")\n                                            (if (zero? (- y x))\n                                                (error \"y - x is zero\")\n                                                (if (zero? (- y x))\n                                                    (error \"y - x is zero\")\n                                                    (if (zero? (- y x))\n                                                        (error \"y - x is zero\")\n                                                        (if (zero? (- y x))\n                                                            (error \"y - x is zero\")\n                                                            (if (zero? (- y x))\n                                                                (error \"y - x is zero\")\n                                                                (if (zero? (- y x))\n                                                                    (error \"y - x is zero\")\n                                                                    (if (zero? (- y x))\n                                                                        (error \"y - x is zero\")\n                                                                        (if (zero? (- y x))\n                                                                            (error \"y - x is zero\")\n                                                                            (if (zero? (- y x))\n                                                                                (error \"y - x is zero\")\n                                                                                (if (zero? (- y x))\n                                                                                    (error \"y - x is zero\")\n                                                                                   ",
    "  (define (directrix x)\n    (+ (/ b (* 2 a))\n       (sqrt (- (sqr (- x (/ b (* 2 a))))\n                (/ c a)))))\n  directrix)\n",
    "  (define (parabola_directrix_helper x)\n    (+ (* a x) (* b x x) c))\n  (define (parabola_directrix_helper_derivative x)\n    (+ (* 2 a) (* 4 b x)))\n  (define (newton_raphson_helper x)\n    (- x (/ (parabola_directrix_helper x) (parabola_directrix_helper_derivative x))))\n  (define (newton_raphson_helper_iter x)\n    (newton_raphson_helper (newton_raphson_helper x)))\n  (define (newton_raphson_helper_iter_iter x)\n    (newton_raphson_helper_iter (newton_raphson_helper_iter x)))\n  (define (newton_raphson_helper_iter_iter_iter x)\n    (newton_raphson_helper_iter_iter (newton_raphson_helper_iter_iter x)))\n  (define (newton_raphson_helper_iter_iter_iter_iter x)\n    (newton_raphson_helper_iter_iter_iter (newton_raphson_helper_iter_iter_iter x)))\n  (define (newton_raphson_helper_iter_iter_iter_iter_iter x)\n    (newton_raphson_helper_iter_iter_iter_iter (newton_raphson_helper_iter_iter_iter_iter x)))\n  (define (newton_raphson_helper_iter_iter_iter_iter_iter_iter x)\n    (newton_raphson_helper_iter_iter_iter_iter_iter (newton_raphson_helper_iter_iter_iter_iter_iter x)))\n  (define (newton_raphson_helper_iter_iter_iter_iter_iter_iter_iter x)\n    (newton_raphson_helper_iter_iter_iter_iter_iter_iter (newton_raphson_helper_iter_iter_iter_iter_iter_iter x)))\n  (",
    "  (define (directrix x)\n    (+ (* a x) b))\n  directrix)\n",
    "  (let ((x (- b (/ (sqrt (* b b (- 4 (* 4 a c)))) (* 2 a)))))\n    (if (and (number? x) (not (complex? x)))\n        x\n        (error \"No real solution\"))))\n",
    "  (- (/ b (* 2 a)) (sqrt (- (sqr b) (* 4 a c)))))\n",
    "  (- (/ b (* 2 a))))\n",
    "  (let ((x (- (* b b) (* 4 a c))))\n    (if (&lt; x 0)\n        (error \"No real solution\")\n        (/ (- b) (* 2 a)))))\n",
    "  (define (f x) (+ (* a x) (* b x x) c))\n  (define (g x) (- (f x) (* a x)))\n  (define (h x) (- (g x) (* b x)))\n  (define (i x) (- (h x) c))\n  (define (j x) (- (i x) b))\n  (define (k x) (- (j x) a))\n  (define (l x) (/ (k x) (* -2 a)))\n  (l 0))\n",
    "  (define (x)\n    (- (/ b (* 2 a))))\n  (define (y)\n    (+ (/ (* b b) (* 4 a)) c))\n  (cons x y))\n",
    "  (let ([x (- (/ b (* 2 a)) (/ (sqrt (- (* b b) (* 4 a c))) (* 2 a)))])\n    (if (and (number? x) (not (complex? x)))\n        (let ([y (- (/ (+ (* a x) b) (* 2 a)) (/ (sqrt (- (* b b) (* 4 a c))) (* 2 a)))])\n          (if (and (number? y) (not (complex? y)))\n              (list x y)\n              (error \"The directrix is not a real number\")))\n        (error \"The directrix is not a real number\"))))\n",
    "  (define (f x)\n    (+ (* a x) (* b x x) c))\n  (define (df x)\n    (+ (* b x) b))\n  (define (ddf x)\n    b)\n  (define (newton-raphson f df x)\n    (define (iter x)\n      (let ((x1 (- x (/ (f x) (df x)))))\n        (if (close-enough? x x1)\n            x1\n            (iter x1))))\n    (iter x))\n  (define (close-enough? x y)\n    (< (abs (- x y)) 0.00001))\n  (define (derivative f)\n    (lambda (x)\n      (/ (- (f (+ x 0.00001)) (f x)) 0.00001)))\n  (define (ddf x)\n    (define (f x)\n      (+ (* a x) (* b x x) c))\n    ((derivative (derivative f)) x))\n  (define (dddf x)\n    (define (f x)\n      (+ (* a x) (* b x x) c))\n    ((derivative (derivative (derivative f))) x))\n  (define (ddddf x)\n    (define (f x)\n      (+ (* a x) (* b x x) c))\n    ((derivative (derivative (derivative (derivative f)))) x))\n  (define (dddddf x)\n    (define (f x)\n      (+ (* a x) (* b x x) c))\n    ((derivative (derivative (derivative (derivative (derivative f))))) x))\n  (define (ddddddf x)\n    (define (f x)\n      (+ (* a x) (* b x x) c))\n    ((derivative (derivative (derivative (derivative (derivative (derivative f)))))) x))\n  (define (dddddddf x)\n    (define (f x)\n      (+ (* a x) (* b x x) c))\n    ((derivative (derivative (derivative (derivative (der",
    "  (define (f x)\n    (+ (* a x) (* b x x) c))\n  (define (df x)\n    (+ (* b x) b))\n  (define (newton-transform g)\n    (lambda (x)\n      (- x (/ (g x) (df x)))))\n  (define (fixed-point f x)\n    (define (close-enough? v1 v2)\n      (< (abs (- v1 v2)) 0.00001))\n    (define (try guess)\n      (let ((next (f guess)))\n        (if (close-enough? guess next)\n            next\n            (try next))))\n    (try x))\n  (define (find-zero f)\n    (fixed-point (newton-transform f) 1.0))\n  (define (find-y f x)\n    (f x))\n  (- (/ 1 a) (find-y f (find-zero f))))\n",
    "  (let ([x (/ b (* -2 a))])\n    (let ([y (- c (* a (sqr x)))])\n      (list x y))))\n",
    "  (define (x) (/ (- b) (* 2 a)))\n  (define (y) (- (/ b (* 2 a)) (sqrt (- (sqr b) (* 4 a c)))))\n  (list x y))\n",
    "  (define (f x)\n    (+ (* a x) (* b x x) c))\n  (define (df x)\n    (+ (* b x) b))\n  (define (ddf x)\n    b)\n  (define (newton-raphson f df x)\n    (define (iter x)\n      (let ((x1 (- x (/ (f x) (df x)))))\n        (if (close-enough? x x1)\n            x1\n            (iter x1))))\n    (iter x))\n  (define (close-enough? x y)\n    (< (abs (- x y)) 0.001))\n  (define (derivative f)\n    (lambda (x)\n      (/ (- (f (+ x 0.001)) (f x)) 0.001)))\n  (define (newton-raphson f df x)\n    (define (iter x)\n      (let ((x1 (- x (/ (f x) (df x)))))\n        (if (close-enough? x x1)\n            x1\n            (iter x1))))\n    (iter x))\n  (define (newton-raphson f x)\n    (newton-raphson f (derivative f) x))\n  (define (newton-raphson f x)\n    (define (iter x)\n      (let ((x1 (- x (/ (f x) (df x)))))\n        (if (close-enough? x x1)\n            x1\n            (iter x1))))\n    (iter x))\n  (define (newton-raphson f x)\n    (define (iter x)\n      (let ((x1 (- x (/ (f x) (df x)))))\n        (if (close-enough? x x1)\n            x1\n            (iter x1))))\n    (iter x))\n  (define (newton-raphson f x)\n    (define (iter x)\n      (let ((x1 (- x (/ (f x) (df x)))))\n        (if (close-enough? x x1)\n            x1\n            (iter x1))))\n    (iter x))\n  (define (newton-raphson f x)\n    (",
    "  (let ([x-vertex (/ (- b) (* 2 a))])\n    (- (/ c) (* a (sqr x-vertex)))))\n",
    "  (let ([x (- (/ b (* 2 a)) (/ (sqrt (- (* b b) (* 4 a c))) (* 2 a)))])\n    (if (and (number? x) (not (complex? x)))\n        x\n        (error \"No real solution\"))))\n",
    "  (define (x)\n    (/ (- b) (* 2 a)))\n  (define (y)\n    (- (/ b (* 2 a))\n       (* a (square (/ b (* 2 a))))\n       c))\n  (list x y))\n",
    "  (define (x)\n    (/ (* -1 a) b))\n  (define (y)\n    (+ (* -1 c) (* (x) (x))))\n  (list (x) (y)))\n",
    "  (let* ([x-vertex (/ (* -1 b) (* 2 a))]\n         [y-vertex (+ (* a (sqr x-vertex)) (* b x-vertex) c)])\n    (- y-vertex (/ (sqr b) (* 4 a)))))\n",
    "  (let ([x (/ (- b) (* 2 a))])\n    (let ([y (- (/ (+ (* a (sqr x)) (* b x) c) b))])\n      (list x y))))\n",
    "  (define (directrix x)\n    (- (/ b (* 2 a))\n       (/ (+ (* a (sqr x)) (* b x) c)\n          (* 2 a))))\n  directrix)\n",
    "  (define (directrix x)\n    (- (/ b (* 2 a))\n       (sqrt (- (sqr (- (/ b (* 2 a)) x))\n                (/ c a)))))\n  directrix)\n",
    "  (let ((d (/ (- b) (* 2 a))))\n    (if (negative? a)\n        (+ d)\n        (- d))))\n",
    "  (define (directrix x)\n    (/ (- b) (* 2 a)))\n  (directrix))\n",
    "  (let ([x (- (/ b (* 2 a)) (/ (sqrt (- (* b b) (* 4 a c))) (* 2 a)))])\n    (if (and (number? x) (not (nan? x)))\n        x\n        (error \"No directrix exists for this parabola.\"))))\n",
    "  (let ([d (/ b (* 2 a))])\n    (- d (/ (sqrt (+ (sqr d) (* 4 a c))) (* 2 a)))))\n",
    "  (let ((x (- (/ b (* 2 a)))))\n    (if (positive? a)\n        (line_from_points (make-point x 0) (make-point x 1))\n        (line_from_points (make-point x 0) (make-point x -1)))))\n",
    "  (let ([x (- (/ b 2) (/ (* a b) (sqrt (* 4 a c))))])\n    (- (/ c x))))\n",
    "  (let ([x (- (* b b) (* 4 a c))])\n    (cond\n      [(> x 0) (/ (- b) (* 2 a))]\n      [(= x 0) (/ (- b) (* 2 a))]\n      [(< x 0) (/ (- b) (* 2 a))])))\n",
    "  (define (directrix x)\n    (- (/ b (* 2 a))\n       (sqrt (- (sqr b) (* 4 a c)))))\n  directrix)\n",
    "  (define (directrix x)\n    (+ (/ b (* 2 a))\n       (sqrt (- (sqr b) (* 4 a c)))))\n  directrix)\n",
    "  (define (f x)\n    (+ (* a x) (* b x x) c))\n  (define (g x)\n    (- (* a x) (* b x x) c))\n  (define (h x)\n    (- (* a x) (* b x x) c))\n  (define (i x)\n    (+ (* a x) (* b x x) c))\n  (define (j x)\n    (- (* a x) (* b x x) c))\n  (define (k x)\n    (- (* a x) (* b x x) c))\n  (define (l x)\n    (+ (* a x) (* b x x) c))\n  (define (m x)\n    (- (* a x) (* b x x) c))\n  (define (n x)\n    (- (* a x) (* b x x) c))\n  (define (o x)\n    (+ (* a x) (* b x x) c))\n  (define (p x)\n    (- (* a x) (* b x x) c))\n  (define (q x)\n    (- (* a x) (* b x x) c))\n  (define (r x)\n    (+ (* a x) (* b x x) c))\n  (define (s x)\n    (- (* a x) (* b x x) c))\n  (define (t x)\n    (- (* a x) (* b x x) c))\n  (define (u x)\n    (+ (* a x) (* b x x) c))\n  (define (v x)\n    (- (* a x) (* b x x) c))\n  (define (w x)\n    (- (* a x) (* b x x) c))\n  (define (x x)\n    (+ (* a x) (* b x x) c))\n  (define (y x)\n    (- (* a x) (* b x x) c))\n  (define (z x)\n    (- (* a x) (* b x x) c))\n  (define (aa x)\n    (+ (* a x) (* b x x) c))\n  (define (bb x)\n    (- (* a x) (* b x x) c))\n  (define (cc",
    "  (define (directrix x)\n    (- (/ b (* 2 a)) (/ (+ (* x x) (* b x) c) (* 2 a))))\n  directrix)\n",
    "  (let ([x (- (/ b (* 2 a)) (/ (sqrt (- (* b b) (* 4 a c))) (* 2 a)))])\n    (- (/ c x))))\n",
    "  (let ([x (- (/ b (* 2 a)) (/ (sqrt (- (* b b) (* 4 a c))) (* 2 a)))])\n    (if (and (number? x) (not (nan? x)))\n        x\n        (error \"No directrix\"))))\n",
    "  (let ([x (sqrt (/ (sqr b) (* 4 a c)))])\n    (cond [(> a 0) (+ x (/ b (* 2 a)))]\n          [(< a 0) (- x (/ b (* 2 a))))])))\n",
    "  (let ([x (/ (* -1 b) (* 2 a))])\n    (let ([y (+ (* a (sqr x)) (* b x) c)])\n      (let ([d (/ (* -1 y) a)])\n        (list x d)))))\n",
    "  (define (x)\n    (/ (- b) (* 2 a)))\n  (define (y)\n    (- (/ c a)))\n  (list x y))\n",
    "  (define (directrix x)\n    (- (/ b (* 2 a))\n       (/ (+ (* a (square x)) (* b x) c)\n          (* 2 a))))\n  directrix)\n",
    "  (define (directrix x)\n    (- (/ b (* 2 a))\n       (sqrt (- (sqr b) (* 4 a c)))))\n  directrix)\n",
    "  (define (directrix x)\n    (sqrt (- (sqr (+ (sqr x) (* a x))) (* b x))))\n  directrix)\n",
    "  (define (f x)\n    (+ (* a x) (* b x x) c))\n  (define (g x)\n    (- (/ c x) (/ b x)))\n  (define (h x)\n    (- (/ c x) (/ b x)))\n  (define (i x)\n    (- (/ c x) (/ b x)))\n  (define (j x)\n    (- (/ c x) (/ b x)))\n  (define (k x)\n    (- (/ c x) (/ b x)))\n  (define (l x)\n    (- (/ c x) (/ b x)))\n  (define (m x)\n    (- (/ c x) (/ b x)))\n  (define (n x)\n    (- (/ c x) (/ b x)))\n  (define (o x)\n    (- (/ c x) (/ b x)))\n  (define (p x)\n    (- (/ c x) (/ b x)))\n  (define (q x)\n    (- (/ c x) (/ b x)))\n  (define (r x)\n    (- (/ c x) (/ b x)))\n  (define (s x)\n    (- (/ c x) (/ b x)))\n  (define (t x)\n    (- (/ c x) (/ b x)))\n  (define (u x)\n    (- (/ c x) (/ b x)))\n  (define (v x)\n    (- (/ c x) (/ b x)))\n  (define (w x)\n    (- (/ c x) (/ b x)))\n  (define (x x)\n    (- (/ c x) (/ b x)))\n  (define (y x)\n    (- (/ c x) (/ b x)))\n  (define (z x)\n    (- (/ c x) (/ b x)))\n  (define (aa x)\n    (- (/ c x) (/ b x)))\n  (define (bb x)\n    (- (/ c x) (/ b x)))\n  (define (cc x)\n    (- (/ c x) (/ b x)))\n  (define (dd x)\n    (- (/ c x) (/ b x)))\n  (define (ee x)\n    (- (/ c x) (/ b x)))\n  (define (ff x)\n    (- (/ c x)",
    "  (define (directrix x)\n    (- (/ b 2) (* a x)))\n  directrix)\n",
    "  (let ((d (- (* 4 a c) (* b b))))\n    (if (negative? d)\n        (error \"No real solution\")\n        (let ((x (/ (- (* -2 a) b) (* 2 a))))\n          (if (positive? a)\n              (list x)\n              (list x (list x)))))))\n",
    "  (define (directrix x)\n    (sqrt (- (sqr (- x a)) (* b c))))\n  directrix)\n",
    "  (define (directrix x)\n    (- (/ b (* 2 a))\n       (/ (+ (* a (sqr x)) (* b x) c)\n          (* 2 a))))\n  directrix)\n",
    "  (define (parabola_directrix_helper x)\n    (- (/ b (* 2 a))\n       (/ (+ (* b x) (* c x x)) (* 2 a))))\n  (parabola_directrix_helper 0))\n",
    "  (define (f x)\n    (+ (* a x) (* b x x) c))\n  (define (g x)\n    (- (* a x) (* b x x) c))\n  (define (h x)\n    (- (* a x) (* b x x) c))\n  (define (i x)\n    (- (* a x) (* b x x) c))\n  (define (j x)\n    (- (* a x) (* b x x) c))\n  (define (k x)\n    (- (* a x) (* b x x) c))\n  (define (l x)\n    (- (* a x) (* b x x) c))\n  (define (m x)\n    (- (* a x) (* b x x) c))\n  (define (n x)\n    (- (* a x) (* b x x) c))\n  (define (o x)\n    (- (* a x) (* b x x) c))\n  (define (p x)\n    (- (* a x) (* b x x) c))\n  (define (q x)\n    (- (* a x) (* b x x) c))\n  (define (r x)\n    (- (* a x) (* b x x) c))\n  (define (s x)\n    (- (* a x) (* b x x) c))\n  (define (t x)\n    (- (* a x) (* b x x) c))\n  (define (u x)\n    (- (* a x) (* b x x) c))\n  (define (v x)\n    (- (* a x) (* b x x) c))\n  (define (w x)\n    (- (* a x) (* b x x) c))\n  (define (x x)\n    (- (* a x) (* b x x) c))\n  (define (y x)\n    (- (* a x) (* b x x) c))\n  (define (z x)\n    (- (* a x) (* b x x) c))\n  (define (aa x)\n    (- (* a x) (* b x x) c))\n  (define (bb x)\n    (- (* a x) (* b x x) c))\n  (define (cc",
    "  (define (f x)\n    (+ (* a x) (* b x x) c))\n  (define (g x)\n    (- (/ c x) (/ b x x)))\n  (define (h x)\n    (- (/ c x) (/ b x x)))\n  (define (i x)\n    (- (/ c x) (/ b x x)))\n  (define (j x)\n    (- (/ c x) (/ b x x)))\n  (define (k x)\n    (- (/ c x) (/ b x x)))\n  (define (l x)\n    (- (/ c x) (/ b x x)))\n  (define (m x)\n    (- (/ c x) (/ b x x)))\n  (define (n x)\n    (- (/ c x) (/ b x x)))\n  (define (o x)\n    (- (/ c x) (/ b x x)))\n  (define (p x)\n    (- (/ c x) (/ b x x)))\n  (define (q x)\n    (- (/ c x) (/ b x x)))\n  (define (r x)\n    (- (/ c x) (/ b x x)))\n  (define (s x)\n    (- (/ c x) (/ b x x)))\n  (define (t x)\n    (- (/ c x) (/ b x x)))\n  (define (u x)\n    (- (/ c x) (/ b x x)))\n  (define (v x)\n    (- (/ c x) (/ b x x)))\n  (define (w x)\n    (- (/ c x) (/ b x x)))\n  (define (x x)\n    (- (/ c x) (/ b x x)))\n  (define (y x)\n    (- (/ c x) (/ b x x)))\n  (define (z x)\n    (- (/ c x) (/ b x x)))\n  (define (aa x)\n    (- (/ c x) (/ b x x)))\n  (define (bb x)\n    (- (/ c x) (/ b x x)))\n  (define (cc x)\n    (- (/ c x) (/ b x x)))\n  (define (dd x)\n    (- (/ c x) (/ b x x)))\n  (define (ee x)\n   ",
    "  (let ((x (- b (/ (sqrt (* (- (* b b) (* 4 a c)) (* 4 a))) (* 2 a)))))\n    (- x (/ c (* 2 a)))))\n",
    "  (define (parabola_directrix_helper x)\n    (+ (* a x) (* b x x) c))\n  (define (parabola_directrix_helper2 x)\n    (- (* a x) (* b x x) c))\n  (define (parabola_directrix_helper3 x)\n    (+ (* a x) (* b x x) c))\n  (define (parabola_directrix_helper4 x)\n    (- (* a x) (* b x x) c))\n  (define (parabola_directrix_helper5 x)\n    (+ (* a x) (* b x x) c))\n  (define (parabola_directrix_helper6 x)\n    (- (* a x) (* b x x) c))\n  (define (parabola_directrix_helper7 x)\n    (+ (* a x) (* b x x) c))\n  (define (parabola_directrix_helper8 x)\n    (- (* a x) (* b x x) c))\n  (define (parabola_directrix_helper9 x)\n    (+ (* a x) (* b x x) c))\n  (define (parabola_directrix_helper10 x)\n    (- (* a x) (* b x x) c))\n  (define (parabola_directrix_helper11 x)\n    (+ (* a x) (* b x x) c))\n  (define (parabola_directrix_helper12 x)\n    (- (* a x) (* b x x) c))\n  (define (parabola_directrix_helper13 x)\n    (+ (* a x) (* b x x) c))\n  (define (parabola_directrix_helper14 x)\n    (- (* a x) (* b x x) c))\n  (define (parabola_directrix_helper15 x)\n    (+ (* a x) (* b x x) c))\n  (define (parabola_directrix_helper16 x)\n    (- (* a x) (* b x x) c))\n  (define (parabola_directrix_helper17 x)",
    "  (define (f x)\n    (+ (* a x) (* b x x) c))\n  (define (g x)\n    (- (f x) (f 0)))\n  (define (h x)\n    (/ (g x) x))\n  (define (k x)\n    (- (h x) (/ b a)))\n  (define (l x)\n    (- (k x) (/ c a)))\n  (define (m x)\n    (* (l x) (l x)))\n  (define (n x)\n    (* 4 a (m x)))\n  (define (o x)\n    (- (n x) (m b)))\n  (define (p x)\n    (sqrt (o x)))\n  (define (q x)\n    (- (l x) (p x)))\n  (define (r x)\n    (- (l x) (p x)))\n  (define (s x)\n    (/ (q x) (r x)))\n  (define (t x)\n    (* a (s x)))\n  (define (u x)\n    (- (t x) b))\n  (define (v x)\n    (- (u x) c))\n  (define (w x)\n    (/ (v x) (s x)))\n  (define (x x)\n    (* -1 (w x)))\n  (x 0))\n",
    "  (- (/ b (* 2 a))))\n",
    "  (let ([x (- (/ b 2) a)])\n    (- c (* a x x))))\n",
    "  (let* ([x1 (- b)]\n         [x2 (/ (+ (* a a) (* b b) (* c c)) (* 2 a))])\n    (if (zero? a)\n        (error \"The parabola is vertical.\")\n        (if (zero? b)\n            (error \"The parabola is horizontal.\")\n            (if (zero? c)\n                (error \"The parabola is a line.\")\n                (if (zero? (+ (* a x1) (* b x1) c))\n                    (error \"The parabola is a line.\")\n                    (if (zero? (+ (* a x2) (* b x2) c))\n                        (error \"The parabola is a line.\")\n                        (if (zero? (+ (* a x1) (* b x1) c))\n                            (error \"The parabola is a line.\")\n                            (if (zero? (+ (* a x2) (* b x2) c))\n                                (error \"The parabola is a line.\")\n                                (if (zero? (+ (* a x1) (* b x1) c))\n                                    (error \"The parabola is a line.\")\n                                    (if (zero? (+ (* a x2) (* b x2) c))\n                                        (error \"The parabola is a line.\")\n                                        (if (zero? (+ (* a x1) (* b x1) c))\n                                            (error \"The parabola is a line.\")\n                                            (if (zero? (+ (* a x2) (* b x2) c))\n                                                (error \"The parabola is a line.\")\n                                                (if (zero? (+ (* a x1) (* b x1) c))\n                                                    (error \"The parabola is a line.\")\n                                                    (if (zero? (+ (* a x2) (* b x2) c))\n                                                        (error \"The parabola is a line.\")\n                                                        (if (zero? (+ (* a x1) (* b x1) c))\n                                                            (error \"The parabola is a line.\")\n                                                            (if (zero? (+ (* a x2) (* b x2) c))",
    "  (let ([x (- (/ b (* 2 a)) (/ (sqrt (- (* b b) (* 4 a c))) (* 2 a)))])\n    (if (and (number? x) (not (complex? x)))\n        x\n        (error \"No real solution\"))))\n",
    "  (define (x)\n    (sqrt (/ (- b) (* 2 a))))\n  (define (y)\n    (- (/ c) (* a (sqr x))))\n  (list x y))\n",
    "  (let ([d (/ b (* 2 a))])\n    (- d (/ (sqrt (+ (sqr d) (* 4 a c))) (* 2 a)))))\n",
    "  (define (directrix x)\n    (/ (+ (* a x) b) (- 0 c)))\n  directrix)\n",
    "  (- (/ b 2) a))\n",
    "  (define (directrix x)\n    (- (/ b (* 2 a))\n       (sqrt (- (sqr b) (* 4 a c)))))\n  directrix)\n",
    "  (let ([x (- b (/ (sqrt (* b b (- 4 (* 4 a c)))) (* 2 a)))])\n    (- (/ c x))))\n",
    "  (- (/ b (* 2 a))))\n",
    "  (define (directrix x)\n    (define (parabola y)\n      (+ (* a y) (* b y) c))\n    (define (derivative y)\n      (+ (* a 2) b))\n    (define (newton-transform g)\n      (lambda (x)\n        (- x (/ (g x) (derivative x)))))\n    (define (fixed-point f x)\n      (define (close-enough? v1 v2)\n        (< (abs (- v1 v2)) 0.00001))\n      (define (try guess)\n        (let ((next (f guess)))\n          (if (close-enough? guess next)\n              next\n              (try next))))\n      (try x))\n    (define (find-zero f)\n      (fixed-point (newton-transform f) 1))\n    (find-zero parabola))\n  (directrix 0))\n",
    "  (let ((x-axis-intercept (/ (- b) (* 2 a))))\n    (let ((y-axis-intercept (+ c (* a (expt x-axis-intercept 2)) (* b x-axis-intercept))))\n      (let ((slope (- (/ b) (* 2 a))))\n        (let ((y-intercept (- y-axis-intercept (* slope x-axis-intercept))))\n          (cons slope y-intercept))))))\n",
    "  (let* ([x-axis-intercept (parabola_x-axis-intercept a b c)]\n         [y-axis-intercept (parabola_y-axis-intercept a b c)]\n         [focus (make-posn (real-part x-axis-intercept)\n                           (real-part y-axis-intercept))]\n         [directrix (make-posn (real-part x-axis-intercept)\n                               (- (real-part y-axis-intercept)))])\n    (list focus directrix)))\n",
    "  (- (/ b 2) a))\n",
    "  (let ([x (/ (* -1 b) (* 2 a))])\n    (let ([y (+ (* a (sqr x)) (* b x) c)])\n      (let ([d (/ (+ y c) (* -1 a))])\n        (list x d)))))\n",
    "  (define (directrix x)\n    (+ (* a x) b))\n  (directrix))\n",
    "  (define (f x)\n    (+ (* a x) (* b x x) c))\n  (define (df x)\n    (+ (* (* 2 a) x) b))\n  (define (newton x)\n    (newton-help x 0.00001))\n  (define (newton-help x epsilon)\n    (if (&lt; (abs (- (f x) 0)) epsilon)\n        x\n        (newton-help (- x (/ (f x) (df x))) epsilon)))\n  (newton (/ b (* 2 a))))\n",
    "  (define (f x)\n    (+ (* a x) (* b x x) c))\n  (define (df x)\n    (+ (* b x) b))\n  (define (ddf x)\n    b)\n  (define (newton x)\n    (newton-help x (f x) (df x) (ddf x)))\n  (define (newton-help x f df ddf)\n    (define (next x)\n      (- x (/ f df)))\n    (define (close-enough? x y)\n      (< (abs (- x y)) 0.00001))\n    (if (close-enough? x (next x))\n        x\n        (newton-help (next x) (f x) (df x) (ddf x))))\n  (newton 0))\n",
    "  (define (parabola_directrix_helper x)\n    (+ (* a x) (* b x x) c))\n  (define (parabola_directrix_helper_derivative x)\n    (+ (* a 1) (* b 2 x)))\n  (define (parabola_directrix_helper_derivative_derivative x)\n    (* b 2))\n  (define (newton_raphson_helper x)\n    (- x (/ (parabola_directrix_helper x)\n            (parabola_directrix_helper_derivative x))))\n  (define (newton_raphson_helper_derivative x)\n    (/ (- 1 (/ (parabola_directrix_helper_derivative x)\n               (parabola_directrix_helper_derivative x)))\n       (parabola_directrix_helper_derivative x)))\n  (define (newton_raphson_helper_derivative_derivative x)\n    (/ (- (/ (parabola_directrix_helper_derivative_derivative x)\n            (parabola_directrix_helper_derivative x))\n          (/ (parabola_directrix_helper_derivative x)\n             (parabola_directrix_helper_derivative x)))\n       (parabola_directrix_helper_derivative x)))\n  (define (newton_raphson_helper_derivative_derivative_derivative x)\n    (/ (- (/ (parabola_directrix_helper_derivative_derivative_derivative x)\n            (parabola_directrix_helper_derivative x))\n          (* 3 (/ (parabola_directrix_helper_derivative_derivative x)\n                  (parabola_directrix_helper_derivative x))))\n       (parabola_directrix_helper_derivative x)))\n  (define (newton_raphson_helper_derivative_derivative_derivative_derivative x)\n    (/ (- (/ (",
    "  (- (/ b (* 2 a))))\n",
    "  (- (/ b 2) a))\n",
    "  (define (f x)\n    (+ (* a x) (* b x x) c))\n  (define (df x)\n    (+ (* a 2) (* b 4 x)))\n  (define (newton x)\n    (newton-help f df x))\n  (define (newton-help f df guess)\n    (let ((next (newton-transform f df guess)))\n      (if (good-enough? guess next)\n          next\n          (newton-help f df next))))\n  (define (newton-transform f df guess)\n    (- guess (/ (f guess) (df guess))))\n  (define (good-enough? x y)\n    (< (abs (- x y)) 0.001))\n  (newton 0))\n",
    "  (define (directrix x)\n    (define (parabola y)\n      (+ (* a y) (* b y) c))\n    (define (derivative y)\n      (+ (* a 2) b))\n    (define (newton y)\n      (newton-raphson parabola derivative y))\n    (newton x))\n  directrix)\n",
    "  (let ((d (/ (* -1 b) (* 2 a))))\n    (list d (parabola_y d a b c))))\n",
    "  (define (directrix x)\n    (+ (/ b (* 2 a))\n       (sqrt (- (sqr (- x (/ b (* 2 a))))\n                (/ (+ (* 4 a c) (sqr b)) (* 4 a))))))\n  directrix)\n",
    "  (define (f x)\n    (+ (* a x) (* b x x) c))\n  (define (df x)\n    (+ (* 2 a) (* 4 b x)))\n  (define (newton x)\n    (newton-help x (df x) (f x)))\n  (define (newton-help x dx fx)\n    (if (close-enough? x dx)\n        x\n        (newton-help (improve x dx fx) dx fx)))\n  (define (improve x dx fx)\n    (- x (/ fx dx)))\n  (define (close-enough? x dx)\n    (< (abs (- x dx)) 0.001))\n  (newton 0))\n",
    "  (let ([d (/ b (* 2 a))])\n    (if (zero? a)\n        (error \"a cannot be zero\")\n        (if (zero? b)\n            (error \"b cannot be zero\")\n            (if (zero? c)\n                (error \"c cannot be zero\")\n                (- d)))))\n",
    "  (let* ([x1 (- b)]\n         [x2 (/ (- b) 2)])\n    (cond [(> a 0) (+ x1 c)]\n          [(< a 0) (+ x2 c)]\n          [else (error \"a cannot be 0\")])))\n",
    "  (define (directrix x)\n    (- (/ b 2) (* a x)))\n  (directrix (/ (- c b) (2 * a))))\n",
    "  (let ((x1 (/ (- b) (* 2 a))))\n    (let ((y1 (+ (* a (sqr x1)) (* b x1) c)))\n      (let ((x2 (/ (- b) (* 2 a))))\n        (let ((y2 (+ (* a (sqr x2)) (* b x2) c)))\n          (let ((slope (/ (- y2 y1) (- x2 x1))))\n            (let ((y-intercept (- y1 (* slope x1))))\n              (let ((directrix-slope (/ -1 slope)))\n                (let ((directrix-y-intercept (- y-intercept (* directrix-slope x1))))\n                  (list directrix-slope directrix-y-intercept))))))))))\n",
    "  (let* ([x-squared (* a a)]\n         [x-squared-times-b (* x-squared b)]\n         [x-squared-times-c (* x-squared c)]\n         [x-squared-times-b-times-2 (* x-squared-times-b 2)]\n         [x-squared-times-c-times-2 (* x-squared-times-c 2)]\n         [x-squared-times-b-times-4 (* x-squared-times-b-times-2 2)]\n         [x-squared-times-c-times-4 (* x-squared-times-c-times-2 2)]\n         [x-squared-times-b-times-4-plus-1 (+ x-squared-times-b-times-4 1)]\n         [x-squared-times-c-times-4-plus-1 (+ x-squared-times-c-times-4 1)]\n         [x-squared-times-b-times-4-plus-1-sqrt (sqrt x-squared-times-b-times-4-plus-1)]\n         [x-squared-times-c-times-4-plus-1-sqrt (sqrt x-squared-times-c-times-4-plus-1)])\n    (cond [(= a 0) (error \"a cannot be 0\")]\n          [(= b 0) (error \"b cannot be 0\")]\n          [(= c 0) (error \"c cannot be 0\")]\n          [(= x-squared-times-b-times-4-plus-1 0) (error \"x-squared-times-b-times-4-plus-1 cannot be 0\")]\n          [(= x-squared-times-c-times-4-plus-1 0) (error \"x-squared-times-c-times-4-plus-1 cannot be 0\")]\n          [else (let* ([x-squared-times-b-times-4-plus-1-sqrt-times-2 (* x-squared-times-b-times-4-plus-1-sqrt 2)]\n                     ",
    "  (define (directrix x)\n    (/ (- c (* a x)) b))\n  directrix)\n",
    "  (define (directrix x)\n    (+ (/ b (* 2 a))\n       (sqrt (- (sqr b) (* 4 a c)))))\n  directrix)\n",
    "  (define (directrix x)\n    (/ (+ (* a x) b) (- 0 c)))\n  directrix)\n",
    "  (define (directrix x)\n    (/ (- c (* a x)) b))\n  directrix)\n",
    "  (define (directrix x)\n    (- (/ b (* 2 a)) (/ (+ (* a (sqr x)) (* b x) c) (* 2 a))))\n  directrix)\n",
    "  (define (f x)\n    (+ (* a x) (* b x x) c))\n  (define (df x)\n    (+ (* 2 a) (* 4 b x)))\n  (define (newton x)\n    (newton-help f df x))\n  (define (newton-help f df guess)\n    (let ((next (newton-transform f df guess)))\n      (if (good-enough? guess next)\n          next\n          (newton-help f df next))))\n  (define (newton-transform f df guess)\n    (- guess (/ (f guess) (df guess))))\n  (define (good-enough? guess next)\n    (< (abs (- guess next)) 0.001))\n  (newton 0))\n",
    "  (let ((d (/ (* -1 b) (* 2 a))))\n    (list d (parabola_y d a b c))))\n",
    "  (let ((x0 (/ (* -1 b) (* 2 a))))\n    (let ((y0 (+ (* a (sqr x0)) (* b x0) c)))\n      (let ((m (/ (* -1 a) b)))\n        (let ((b (- y0 (* m x0))))\n          (list m b))))))\n",
    "  (define (directrix x)\n    (- (/ b (* 2 a))\n       (/ (+ (* a (sqr x)) (* b x) c)\n          (* 2 a))))\n  directrix)\n",
    "  (- (/ b 2) a))\n",
    "  (define (f x)\n    (+ (* a x) (* b x x) c))\n  (define (df x)\n    (+ (* 2 a) (* 4 b x)))\n  (define (newton x)\n    (newton-help x (f x) (df x)))\n  (define (newton-help guess old-guess df)\n    (let ((next-guess (- guess (/ (f guess) df))))\n      (if (close-enough? guess next-guess)\n          next-guess\n          (newton-help next-guess guess df))))\n  (define (close-enough? x y)\n    (< (abs (- x y)) 0.001))\n  (newton 0))\n",
    "  (define (directrix x)\n    (- (/ b (* 2 a))\n       (sqrt (- (sqr b) (* 4 a c)))))\n  directrix)\n",
    "  (define (directrix x)\n    (- (/ b 2) (* a x)))\n  directrix)\n",
    "  (let ((d (- (* b b) (* 4 a c))))\n    (if (&lt; d 0)\n        (error \"No real solution\")\n        (let ((x1 (/ (+ b (sqrt d)) (* 2 a)))\n              (x2 (/ (- b (sqrt d)) (* 2 a))))\n          (if (&lt; x1 x2)\n              x1\n              x2)))))\n",
    "  (let ((d (/ (* -1 b) (* 2 a))))\n    (if (and (number? d) (not (infinite? d)))\n        (list d)\n        '())))\n",
    "  (let ([x (- (/ b 2) (/ (* a b) (sqrt (* 4 a c))))])\n    (if (and (number? x) (not (nan? x)))\n        x\n        (error \"No directrix exists for this parabola.\"))))\n",
    "  (- (/ b 2) (/ c a)))\n",
    "  (define (directrix x)\n    (+ (/ b (* -2 a))\n       (* x x (/ c a))))\n  directrix)\n",
    "  (define (x)\n    (/ (- b) (* 2 a)))\n  (define (y)\n    (- (/ c a) (* a (x) (x))))\n  (list (x) (y)))\n",
    "  (let* ((x (sqrt (- (sqr b) (* 4 a c))))\n         (x1 (- b x))\n         (x2 (+ b x)))\n    (cond ((< x1 x2) x1)\n          ((> x1 x2) x2)\n          (else (error \"The parabola is a straight line.\")))))\n",
    "  (define (x)\n    (- (/ b (* 2 a))))\n  (define (y)\n    (- (/ c b)))\n  (cons x y))\n",
    "  (- (/ b (* 2 a))))\n",
    "  (define (directrix x)\n    (- (/ b (* 2 a)) (sqrt (- (sqr b) (* 4 a c)))))\n  directrix)\n"
  ]
}