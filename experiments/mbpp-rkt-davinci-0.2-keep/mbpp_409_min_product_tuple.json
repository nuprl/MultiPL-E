{
  "name": "mbpp_409_min_product_tuple",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Write a function to find the minimum product from the pairs of tuples within a given list.\n(define (min_product_tuple list1)\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_409_min_product_tuple.py",
  "prompt_terminology": "verbatim",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate min_product_tuple))\n    (check-equal? (candidate (list (list 2 7) (list 2 6) (list 1 8) (list 4 9))) 8)\n    (check-equal? (candidate (list (list 10 20) (list 15 2) (list 5 10))) 30)\n    (check-equal? (candidate (list (list 11 44) (list 10 15) (list 20 5) (list 12 9))) 100)\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (apply min (map * (map car list1) (map cadr list1))))\n",
    "  (apply min (map * (map car list1) (map cadr list1))))\n",
    "  (apply min (map (lambda (x) (* (car x) (cadr x))) list1)))\n",
    "  (apply min (map * (apply append (map (lambda (x) (list (car x) (cadr x))) list1)))))\n",
    "  (apply min (map * (map car list1) (map cadr list1))))\n",
    "  (apply min (map (lambda (x) (apply * x)) (combinations 2 list1))))\n",
    "  (apply min (map (lambda (x) (* (car x) (cadr x))) list1)))\n",
    "  (apply min (map * (flatten list1))))\n",
    "  (apply min (map * (map first list1) (map second list1))))\n",
    "  (apply min (map * list1)))\n",
    "  (if (null? list1)\n      0\n      (min (apply * (car list1)) (min_product_tuple (cdr list1)))))\n",
    "  (cond\n    [(empty? list1) 0]\n    [(empty? (rest list1)) 0]\n    [else (min (apply * (car list1)) (min_product_tuple (rest list1)))]))\n",
    "  (apply min (map * (map car list1) (map cadr list1))))\n",
    "  (apply min (map * (car list1) (car (cdr list1)))))\n",
    "  (let ([min (apply min (map (lambda (x) (apply * x)) list1))])\n    (list min (filter (lambda (x) (= (apply * x) min)) list1))))\n",
    "  (define (min_product_tuple_helper list1 min)\n    (if (null? list1)\n        min\n        (let* ((tuple1 (car list1))\n               (tuple2 (cdr list1))\n               (product (if (null? tuple2)\n                            min\n                            (* (car tuple1) (car tuple2)))))\n          (min_product_tuple_helper (cdr list1) (min product min)))))\n  (min_product_tuple_helper list1 (car (car list1))))\n",
    "  (apply min (map * (map first list1) (map second list1))))\n",
    "  (apply min (map * (apply append (map list1 (range 1 (length list1)))))))\n",
    "  (apply min (map * (map car list1) (map cadr list1))))\n",
    "  (apply min (map * (apply append (map (lambda (x) (map list x)) list1)))))\n"
  ]
}