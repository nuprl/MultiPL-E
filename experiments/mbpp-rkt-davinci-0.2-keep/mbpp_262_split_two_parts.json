{
  "name": "mbpp_262_split_two_parts",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Write a function that takes in a list and an integer L and splits the given list into two parts where the length of the first part of the list is L, and returns the resulting lists in a tuple.\n(define (split_two_parts list1 L)\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_262_split_two_parts.py",
  "prompt_terminology": "verbatim",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate split_two_parts))\n    (check-equal? (candidate (list 1 1 2 3 4 4 5 1) 3) (list (list 1 1 2) (list 3 4 4 5 1)))\n    (check-equal? (candidate (list \"a\" \"b\" \"c\" \"d\") 2) (list (list \"a\" \"b\") (list \"c\" \"d\")))\n    (check-equal? (candidate (list \"p\" \"y\" \"t\" \"h\" \"o\" \"n\") 4) (list (list \"p\" \"y\" \"t\" \"h\") (list \"o\" \"n\")))\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (if (null? list1)\n      (cons '() '())\n      (if (= L 0)\n          (cons '() list1)\n          (let ((rest (split_two_parts (cdr list1) (- L 1))))\n            (cons (cons (car list1) (car rest)) (cdr rest))))))\n",
    "  (define (split_two_parts_iter list1 L list2 list3)\n    (cond ((null? list1) (list list2 list3))\n          ((zero? L) (list (append list2 list1) list3))\n          (else (split_two_parts_iter (cdr list1) (- L 1) (append list2 (list (car list1))) list3))))\n  (split_two_parts_iter list1 L '() '()))\n",
    "  (if (empty? list1)\n      (values '() '())\n      (let ((first (first list1))\n            (rest (rest list1)))\n        (if (= L 1)\n            (values (list first) rest)\n            (let-values (((first-part rest-part) (split_two_parts rest (- L 1))))\n              (values (cons first first-part) rest-part))))))\n",
    "  (if (empty? list1)\n      (list '() '())\n      (if (= L 0)\n          (list '() list1)\n          (let* ((first (car list1))\n                 (rest (cdr list1))\n                 (result (split_two_parts rest (- L 1))))\n            (list (cons first (car result)) (cadr result))))))\n",
    "  (let ([list1 (reverse list1)])\n    (let loop ([list1 list1] [list2 '()] [list3 '()] [counter 0])\n      (cond [(empty? list1) (values (reverse list2) (reverse list3))]\n            [(= counter L) (loop (rest list1) list2 (cons (first list1) list3))]\n            [else (loop (rest list1) (cons (first list1) list2))]))))\n",
    "  (if (empty? list1)\n      (list '() '())\n      (if (= L 0)\n          (list '() list1)\n          (let ((first (first list1))\n                (rest (rest list1)))\n            (let ((result (split_two_parts rest (- L 1))))\n              (list (cons first (first result)) (second result)))))))\n",
    "  (if (null? list1)\n      (cons '() '())\n      (if (= L 0)\n          (cons '() list1)\n          (cons (cons (car list1) (car (split_two_parts (cdr list1) (- L 1)))) (cdr (split_two_parts (cdr list1) (- L 1)))))))\n",
    "  (define (split_two_parts_iter list1 L list2)\n    (cond\n      [(empty? list1) (cons list2 list1)]\n      [(= L 0) (cons list2 list1)]\n      [else (split_two_parts_iter (rest list1) (- L 1) (cons (first list1) list2))]))\n  (split_two_parts_iter list1 L '()))\n",
    "  (if (= L 0)\n      (values '() list1)\n      (let* ([first (car list1)]\n             [rest (cdr list1)]\n             [result (split_two_parts rest (- L 1))])\n        (values (cons first (car result)) (cadr result)))))\n",
    "  (if (null? list1)\n      (cons '() '())\n      (if (= L 0)\n          (cons '() list1)\n          (cons (cons (car list1) (car (split_two_parts (cdr list1) (- L 1))))\n                (cdr (split_two_parts (cdr list1) (- L 1)))))))\n",
    "  (define (split_two_parts_iter list1 L list2 list3)\n    (cond ((= L 0) (list list2 list3))\n          ((null? list1) (list list2 list3))\n          (else (split_two_parts_iter (cdr list1) (- L 1) (append list2 (list (car list1))) list3))))\n  (split_two_parts_iter list1 L '() '()))\n",
    "  (if (null? list1)\n      (cons '() '())\n      (if (= L 0)\n          (cons '() list1)\n          (cons (cons (car list1) (car (split_two_parts (cdr list1) (- L 1))))\n                (cdr (split_two_parts (cdr list1) (- L 1)))))))\n",
    "  (if (null? list1)\n      (cons '() '())\n      (if (= L 0)\n          (cons '() list1)\n          (let ((first (car list1))\n                (rest (cdr list1)))\n            (let ((result (split_two_parts rest (- L 1))))\n              (cons (cons first (car result))\n                    (cdr result)))))))\n",
    "  (if (= L 0)\n      (values '() list1)\n      (values (cons (car list1) (car (split_two_parts (cdr list1) (- L 1))))\n              (cdr (split_two_parts (cdr list1) (- L 1))))))\n",
    "  (if (null? list1)\n      '()\n      (if (= L 0)\n          (cons '() (cons list1 '()))\n          (cons (cons (car list1) (car (split_two_parts (cdr list1) (- L 1))))\n                (cdr (split_two_parts (cdr list1) (- L 1)))))))\n",
    "  (if (empty? list1)\n      (cons '() '())\n      (if (= L 0)\n          (cons '() list1)\n          (cons (cons (first list1) (first (split_two_parts (rest list1) (- L 1))))\n                (rest (split_two_parts (rest list1) (- L 1)))))))\n",
    "  (if (null? list1)\n      '()\n      (if (= L 0)\n          (cons '() (cons list1 '()))\n          (cons (cons (car list1) (car (split_two_parts (cdr list1) (- L 1))))\n                (cdr (split_two_parts (cdr list1) (- L 1)))))))\n",
    "  (if (empty? list1)\n      (list '() '())\n      (if (= L 0)\n          (list '() list1)\n          (let* ([first (first list1)]\n                 [rest (rest list1)]\n                 [split (split_two_parts rest (- L 1))])\n            (list (cons first (first split)) (second split))))))\n",
    "  (if (or (null? list1) (= L 0))\n      (values '() list1)\n      (let* ([first (first list1)]\n             [rest (rest list1)]\n             [first-part (values-append (split_two_parts rest (- L 1)) (list first))])\n        (values first-part rest))))\n",
    "  (list (take list1 L) (drop list1 L)))\n"
  ]
}