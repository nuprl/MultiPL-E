{
  "name": "mbpp_558_digit_distance_nums",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Write a python function to find the sum of the per-digit difference between two integers.\n(define (digit_distance_nums n1 n2)\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_558_digit_distance_nums.py",
  "prompt_terminology": "verbatim",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate digit_distance_nums))\n    (check-equal? (candidate 1 2) 1)\n    (check-equal? (candidate 23 56) 6)\n    (check-equal? (candidate 123 256) 7)\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (define (digit_distance_helper n1 n2 acc)\n    (if (or (zero? n1) (zero? n2))\n        acc\n        (digit_distance_helper (quotient n1 10) (quotient n2 10) (+ acc (abs (- (remainder n1 10) (remainder n2 10)))))))\n  (digit_distance_helper n1 n2 0))\n",
    "  (define (digit_distance_helper n1 n2)\n    (if (zero? n1)\n        0\n        (+ (abs (- (remainder n1 10) (remainder n2 10)))\n           (digit_distance_helper (quotient n1 10) (quotient n2 10)))))\n  (digit_distance_helper n1 n2))\n",
    "  (define (digit_distance_helper n1 n2 acc)\n    (if (zero? n1)\n        acc\n        (let ([d1 (remainder n1 10)]\n              [d2 (remainder n2 10)])\n          (digit_distance_helper (quotient n1 10) (quotient n2 10) (+ acc (abs (- d1 d2)))))))\n  (digit_distance_helper n1 n2 0))\n",
    "  (define (digit_distance_helper n1 n2 acc)\n    (if (zero? n1)\n        acc\n        (digit_distance_helper (quotient n1 10) (quotient n2 10) (+ acc (abs (- (remainder n1 10) (remainder n2 10)))))))\n  (digit_distance_helper n1 n2 0))\n",
    "  (define (digit_distance_helper n1 n2 acc)\n    (if (zero? n1)\n        acc\n        (digit_distance_helper (quotient n1 10) (quotient n2 10) (+ acc (abs (- (remainder n1 10) (remainder n2 10)))))))\n  (digit_distance_helper n1 n2 0))\n",
    "  (define (digit-distance-helper n1 n2)\n    (if (zero? n1)\n        0\n        (+ (abs (- (remainder n1 10) (remainder n2 10)))\n           (digit-distance-helper (quotient n1 10) (quotient n2 10)))))\n  (digit-distance-helper n1 n2))\n",
    "  (cond\n    [(zero? n1) 0]\n    [(zero? n2) 0]\n    [else (+ (abs (- (modulo n1 10) (modulo n2 10)))\n             (digit_distance_nums (quotient n1 10) (quotient n2 10)))]))\n",
    "  (let ([n1 (number->string n1)]\n        [n2 (number->string n2)])\n    (if (or (zero? (string-length n1))\n            (zero? (string-length n2)))\n        0\n        (+ (abs (- (string-&gt;number (string-take n1 1))\n                   (string-&gt;number (string-take n2 1))))\n           (digit_distance_nums (string-drop n1 1)\n                                (string-drop n2 1))))))\n",
    "  (define (digit_distance_helper n1 n2)\n    (if (zero? n1)\n        0\n        (+ (abs (- (remainder n1 10) (remainder n2 10)))\n           (digit_distance_helper (quotient n1 10) (quotient n2 10)))))\n  (digit_distance_helper n1 n2))\n",
    "  (define (digit_distance_nums_helper n1 n2 sum)\n    (if (or (zero? n1) (zero? n2))\n        sum\n        (let* ([d1 (remainder n1 10)]\n               [d2 (remainder n2 10)]\n               [diff (abs (- d1 d2))])\n          (digit_distance_nums_helper (quotient n1 10) (quotient n2 10) (+ sum diff)))))\n  (digit_distance_nums_helper n1 n2 0))\n",
    "  (let ((n1 (number->string n1))\n        (n2 (number->string n2)))\n    (if (or (string=? n1 \"\") (string=? n2 \"\"))\n        0\n        (+ (abs (- (string-&gt;number (string-ref n1 0))\n                   (string-&gt;number (string-ref n2 0))))\n           (digit_distance_nums (substring n1 1) (substring n2 1))))))\n",
    "  (define (digit_distance_helper n1 n2 acc)\n    (if (or (zero? n1) (zero? n2))\n        acc\n        (digit_distance_helper (quotient n1 10) (quotient n2 10) (+ acc (abs (- (remainder n1 10) (remainder n2 10)))))))\n  (digit_distance_helper n1 n2 0))\n",
    "  (define (digit_distance_nums_iter n1 n2 acc)\n    (if (zero? n1)\n        acc\n        (digit_distance_nums_iter (quotient n1 10) (quotient n2 10) (+ acc (abs (- (remainder n1 10) (remainder n2 10)))))))\n  (digit_distance_nums_iter n1 n2 0))\n",
    "  (define (digit_distance_helper n1 n2 acc)\n    (cond\n      [(zero? n1) acc]\n      [(zero? n2) acc]\n      [else\n       (digit_distance_helper (quotient n1 10) (quotient n2 10) (+ acc (abs (- (remainder n1 10) (remainder n2 10)))))]))\n  (digit_distance_helper n1 n2 0))\n",
    "  (define (digit_distance_nums-iter n1 n2 sum)\n    (if (zero? n1)\n        sum\n        (digit_distance_nums-iter (quotient n1 10) (quotient n2 10) (+ sum (abs (- (remainder n1 10) (remainder n2 10)))))))\n  (digit_distance_nums-iter n1 n2 0))\n",
    "  (let ([n1 (number->string n1)]\n        [n2 (number->string n2)])\n    (cond [(or (empty? n1) (empty? n2)) 0]\n          [else (+ (abs (- (string->number (first n1))\n                           (string->number (first n2))))\n                   (digit_distance_nums (rest n1) (rest n2)))])))\n",
    "  (define (helper n1 n2 acc)\n    (cond [(zero? n1) acc]\n          [(zero? n2) acc]\n          [(= (remainder n1 10) (remainder n2 10)) (helper (quotient n1 10) (quotient n2 10) acc)]\n          [else (helper (quotient n1 10) (quotient n2 10) (+ acc 1))]))\n  (helper n1 n2 0))\n",
    "  (define (digit_distance_nums_iter n1 n2 sum)\n    (if (zero? n1)\n        sum\n        (digit_distance_nums_iter (quotient n1 10) (quotient n2 10) (+ sum (abs (- (remainder n1 10) (remainder n2 10)))))))\n  (digit_distance_nums_iter n1 n2 0))\n",
    "  (define (digit_distance_helper n1 n2)\n    (if (or (zero? n1) (zero? n2))\n        0\n        (+ (abs (- (modulo n1 10) (modulo n2 10)))\n           (digit_distance_helper (quotient n1 10) (quotient n2 10)))))\n  (digit_distance_helper n1 n2))\n",
    "  (define (helper n1 n2)\n    (if (zero? n1)\n        0\n        (+ (abs (- (modulo n1 10) (modulo n2 10)))\n           (helper (quotient n1 10) (quotient n2 10)))))\n  (helper n1 n2))\n",
    "  (define (digit_distance_helper n1 n2 sum)\n    (cond\n      [(zero? n1) sum]\n      [(zero? n2) sum]\n      [else\n       (digit_distance_helper (quotient n1 10) (quotient n2 10) (+ sum (abs (- (remainder n1 10) (remainder n2 10)))))]))\n  (digit_distance_helper n1 n2 0))\n",
    "  (define (digit_distance_helper n1 n2)\n    (if (zero? n1)\n        0\n        (+ (abs (- (remainder n1 10) (remainder n2 10)))\n           (digit_distance_helper (quotient n1 10) (quotient n2 10)))))\n  (digit_distance_helper n1 n2))\n",
    "  (define (digit_distance_helper n1 n2)\n    (if (or (zero? n1) (zero? n2))\n        0\n        (+ (abs (- (modulo n1 10) (modulo n2 10)))\n           (digit_distance_helper (quotient n1 10) (quotient n2 10)))))\n  (digit_distance_helper n1 n2))\n",
    "  (define (digit_distance_helper n1 n2)\n    (if (zero? n1)\n        0\n        (+ (abs (- (modulo n1 10) (modulo n2 10)))\n           (digit_distance_helper (quotient n1 10) (quotient n2 10)))))\n  (digit_distance_helper n1 n2))\n",
    "  (define (digit_distance_helper n1 n2)\n    (if (zero? n1)\n        0\n        (+ (abs (- (modulo n1 10) (modulo n2 10)))\n           (digit_distance_helper (quotient n1 10) (quotient n2 10)))))\n  (digit_distance_helper n1 n2))\n",
    "  (cond\n    [(zero? n1) n2]\n    [(zero? n2) n1]\n    [else\n     (let* ([d1 (remainder n1 10)]\n            [d2 (remainder n2 10)]\n            [d (abs (- d1 d2))])\n       (+ d (digit_distance_nums (quotient n1 10) (quotient n2 10))))]))\n",
    "  (cond\n    [(zero? n1) (abs n2)]\n    [(zero? n2) (abs n1)]\n    [else (+ (abs (- (modulo n1 10) (modulo n2 10)))\n             (digit_distance_nums (quotient n1 10) (quotient n2 10)))]))\n",
    "  (cond\n    [(zero? n1) n2]\n    [(zero? n2) n1]\n    [else\n     (+ (abs (- (modulo n1 10) (modulo n2 10)))\n        (digit_distance_nums (quotient n1 10) (quotient n2 10)))]))\n",
    "  (define (digit_distance_helper n1 n2 acc)\n    (if (zero? n1)\n        acc\n        (digit_distance_helper (quotient n1 10)\n                               (quotient n2 10)\n                               (+ acc (abs (- (remainder n1 10) (remainder n2 10)))))))\n  (digit_distance_helper n1 n2 0))\n",
    "  (define (digit_distance_helper n1 n2 acc)\n    (cond\n      [(zero? n1) acc]\n      [(zero? n2) acc]\n      [else (digit_distance_helper (quotient n1 10) (quotient n2 10) (+ acc (abs (- (remainder n1 10) (remainder n2 10)))))]))\n  (digit_distance_helper n1 n2 0))\n",
    "  (define (digit_distance_helper n1 n2)\n    (if (zero? n1)\n        0\n        (+ (abs (- (remainder n1 10) (remainder n2 10)))\n           (digit_distance_helper (quotient n1 10) (quotient n2 10)))))\n  (digit_distance_helper n1 n2))\n",
    "  (define (digit_distance_helper n1 n2 acc)\n    (if (or (zero? n1) (zero? n2))\n        acc\n        (digit_distance_helper (quotient n1 10) (quotient n2 10) (+ acc (abs (- (remainder n1 10) (remainder n2 10)))))))\n  (digit_distance_helper n1 n2 0))\n",
    "  (let ([n1-digits (string->list (number->string n1))]\n        [n2-digits (string->list (number->string n2))])\n    (if (or (empty? n1-digits) (empty? n2-digits))\n        0\n        (+ (abs (- (string->number (list->string (car n1-digits)))\n                   (string->number (list->string (car n2-digits)))))\n           (digit_distance_nums (string->number (list->string (cdr n1-digits)))\n                                (string->number (list->string (cdr n2-digits))))))))\n",
    "  (cond\n    [(= n1 n2) 0]\n    [(< n1 n2) (- n2 n1)]\n    [else (- n1 n2)]))\n",
    "  (define (digit_distance_helper n1 n2)\n    (if (zero? n1)\n        0\n        (+ (abs (- (remainder n1 10) (remainder n2 10)))\n           (digit_distance_helper (quotient n1 10) (quotient n2 10)))))\n  (digit_distance_helper n1 n2))\n",
    "  (let ([d1 (string->list (number->string n1))]\n        [d2 (string->list (number->string n2))])\n    (if (or (null? d1) (null? d2))\n        0\n        (+ (abs (- (string->number (list->string (car d1)))\n                   (string->number (list->string (car d2)))))\n           (digit_distance_nums (string->number (list->string (cdr d1)))\n                                (string->number (list->string (cdr d2))))))))\n",
    "  (define (digit_distance_helper n1 n2)\n    (if (or (zero? n1) (zero? n2))\n        0\n        (+ (abs (- (modulo n1 10) (modulo n2 10)))\n           (digit_distance_helper (quotient n1 10) (quotient n2 10)))))\n  (digit_distance_helper n1 n2))\n",
    "  (define (digit-distance-helper n1 n2)\n    (if (zero? n1)\n        0\n        (+ (abs (- (remainder n1 10) (remainder n2 10)))\n           (digit-distance-helper (quotient n1 10) (quotient n2 10)))))\n  (digit-distance-helper n1 n2))\n",
    "  (let ([n1 (string->number (number->string n1))]\n        [n2 (string->number (number->string n2))])\n    (if (or (zero? n1) (zero? n2))\n        0\n        (+ (abs (- (modulo n1 10) (modulo n2 10)))\n           (digit_distance_nums (quotient n1 10) (quotient n2 10))))))\n",
    "  (let loop ([n1 n1] [n2 n2] [sum 0])\n    (if (and (zero? n1) (zero? n2))\n        sum\n        (let ([d1 (remainder n1 10)]\n              [d2 (remainder n2 10)])\n          (loop (quotient n1 10) (quotient n2 10) (+ sum (abs (- d1 d2))))))))\n",
    "  (define (digit_distance_helper n1 n2 acc)\n    (if (and (zero? n1) (zero? n2))\n        acc\n        (digit_distance_helper (quotient n1 10) (quotient n2 10) (+ acc (abs (- (remainder n1 10) (remainder n2 10)))))))\n  (digit_distance_helper n1 n2 0))\n",
    "  (cond\n    [(zero? n1) (abs n2)]\n    [(zero? n2) (abs n1)]\n    [else (+ (abs (- (remainder n1 10) (remainder n2 10)))\n             (digit_distance_nums (quotient n1 10) (quotient n2 10)))]))\n",
    "  (define (digit_distance_nums_iter n1 n2 acc)\n    (if (zero? n1)\n        acc\n        (digit_distance_nums_iter (quotient n1 10) (quotient n2 10) (+ acc (abs (- (remainder n1 10) (remainder n2 10)))))))\n  (digit_distance_nums_iter n1 n2 0))\n",
    "  (define (sum-digits n)\n    (if (zero? n)\n        0\n        (+ (remainder n 10) (sum-digits (quotient n 10)))))\n  (abs (- (sum-digits n1) (sum-digits n2))))\n",
    "  (define (digit_distance_helper n1 n2)\n    (if (or (zero? n1) (zero? n2))\n        0\n        (+ (abs (- (remainder n1 10) (remainder n2 10)))\n           (digit_distance_helper (quotient n1 10) (quotient n2 10)))))\n  (digit_distance_helper n1 n2))\n",
    "  (cond\n    [(zero? n1) n2]\n    [(zero? n2) n1]\n    [else\n     (abs (- (modulo n1 10) (modulo n2 10)))\n     + (digit_distance_nums (quotient n1 10) (quotient n2 10))]))\n",
    "  (let ([n1 (number->string n1)]\n        [n2 (number->string n2)])\n    (if (or (empty? n1) (empty? n2))\n        0\n        (+ (abs (- (string->number (first n1)) (string->number (first n2))))\n           (digit_distance_nums (rest n1) (rest n2))))))\n",
    "  (define (digit_distance_helper n1 n2 sum)\n    (if (or (zero? n1) (zero? n2))\n        sum\n        (digit_distance_helper (quotient n1 10) (quotient n2 10) (+ sum (abs (- (remainder n1 10) (remainder n2 10)))))))\n  (digit_distance_helper n1 n2 0))\n",
    "  (define (digit_distance_helper n1 n2 sum)\n    (cond\n      [(zero? n1) sum]\n      [(zero? n2) sum]\n      [else (digit_distance_helper (quotient n1 10) (quotient n2 10) (+ sum (abs (- (remainder n1 10) (remainder n2 10)))))]))\n  (digit_distance_helper n1 n2 0))\n",
    "  (define (digit_distance_nums_helper n1 n2)\n    (if (zero? n1)\n        0\n        (+ (abs (- (modulo n1 10) (modulo n2 10)))\n           (digit_distance_nums_helper (quotient n1 10) (quotient n2 10)))))\n  (digit_distance_nums_helper (abs n1) (abs n2)))\n",
    "  (define (digit_distance_helper n1 n2 sum)\n    (if (and (zero? n1) (zero? n2))\n        sum\n        (let ([d1 (remainder n1 10)]\n              [d2 (remainder n2 10)])\n          (digit_distance_helper (quotient n1 10) (quotient n2 10) (+ sum (abs (- d1 d2)))))))\n  (digit_distance_helper n1 n2 0))\n",
    "  (let ([n1 (number->string n1)])\n    (let ([n2 (number->string n2)])\n      (let ([n1-len (string-length n1)])\n        (let ([n2-len (string-length n2)])\n          (let ([n1-digits (string->list n1)])\n            (let ([n2-digits (string->list n2)])\n              (let ([n1-digits-reversed (reverse n1-digits)])\n                (let ([n2-digits-reversed (reverse n2-digits)])\n                  (let ([n1-digits-reversed-len (length n1-digits-reversed)])\n                    (let ([n2-digits-reversed-len (length n2-digits-reversed)])\n                      (let ([n1-digits-reversed-iter (in-naturals)])\n                        (let ([n2-digits-reversed-iter (in-naturals)])\n                          (let ([n1-digits-reversed-iter-next (in-naturals)])\n                            (let ([n2-digits-reversed-iter-next (in-naturals)])\n                              (let ([n1-digits-reversed-iter-next-next (in-naturals)])\n                                (let ([n2-digits-reversed-iter-next-next (in-naturals)])\n                                  (let ([n1-digits-reversed-iter-next-next-next (in-naturals)])\n                                    (let ([n2-digits-reversed-iter-next-next-next (in-naturals)])\n                                      (let ([n1-digits-reversed-iter-next-next-next-next (in-naturals)])\n                                        (let ([n2-digits-reversed-iter-next-next-next-next (in-naturals)])\n                                          (let ([n1-digits-reversed-iter-next",
    "  (let loop ([n1 n1] [n2 n2] [sum 0])\n    (if (zero? n1)\n        sum\n        (loop (quotient n1 10) (quotient n2 10) (+ sum (abs (- (remainder n1 10) (remainder n2 10))))))))\n",
    "  (define (digit_distance_nums_iter n1 n2 acc)\n    (if (zero? n1)\n        acc\n        (digit_distance_nums_iter (quotient n1 10) (quotient n2 10) (+ acc (abs (- (remainder n1 10) (remainder n2 10)))))))\n  (digit_distance_nums_iter n1 n2 0))\n",
    "  (define (digit_distance_nums_iter n1 n2 sum)\n    (cond\n      [(zero? n1) sum]\n      [(zero? n2) sum]\n      [else (digit_distance_nums_iter (quotient n1 10) (quotient n2 10) (+ sum (abs (- (remainder n1 10) (remainder n2 10)))))]))\n  (digit_distance_nums_iter n1 n2 0))\n",
    "  (define (digit_distance_nums_iter n1 n2 acc)\n    (if (zero? n1)\n        acc\n        (digit_distance_nums_iter (quotient n1 10)\n                                  (quotient n2 10)\n                                  (+ acc (abs (- (remainder n1 10)\n                                                 (remainder n2 10)))))))\n  (digit_distance_nums_iter n1 n2 0))\n",
    "  (define (digit_distance_helper n1 n2)\n    (if (zero? n1)\n        0\n        (let* ([d1 (remainder n1 10)]\n               [d2 (remainder n2 10)]\n               [diff (abs (- d1 d2))])\n          (+ diff (digit_distance_helper (quotient n1 10) (quotient n2 10))))))\n  (digit_distance_helper n1 n2))\n",
    "  (let ([n1-digits (string->list (number->string n1))]\n        [n2-digits (string->list (number->string n2))])\n    (let loop ([n1-digits n1-digits]\n               [n2-digits n2-digits]\n               [acc 0])\n      (if (or (null? n1-digits) (null? n2-digits))\n          acc\n          (loop (cdr n1-digits)\n                (cdr n2-digits)\n                (+ acc (abs (- (string->number (list->string (car n1-digits)))\n                               (string->number (list->string (car n2-digits)))))))))))\n",
    "  (define (digit_distance_nums_iter n1 n2 sum)\n    (if (zero? n1)\n        sum\n        (digit_distance_nums_iter (quotient n1 10) (quotient n2 10) (+ sum (abs (- (remainder n1 10) (remainder n2 10)))))))\n  (digit_distance_nums_iter n1 n2 0))\n",
    "  (if (or (zero? n1) (zero? n2))\n      0\n      (+ (abs (- (modulo n1 10) (modulo n2 10)))\n         (digit_distance_nums (quotient n1 10) (quotient n2 10)))))\n",
    "  (define (digit_distance_nums_iter n1 n2 acc)\n    (cond\n      [(zero? n1) acc]\n      [(zero? n2) acc]\n      [else (digit_distance_nums_iter (quotient n1 10) (quotient n2 10) (+ acc (abs (- (remainder n1 10) (remainder n2 10)))))]))\n  (digit_distance_nums_iter n1 n2 0))\n",
    "  (define (digit_distance_helper n1 n2)\n    (if (and (zero? n1) (zero? n2))\n        0\n        (+ (abs (- (modulo n1 10) (modulo n2 10)))\n           (digit_distance_helper (quotient n1 10) (quotient n2 10)))))\n  (digit_distance_helper n1 n2))\n",
    "  (define (digit_distance_helper n1 n2 sum)\n    (cond\n      [(zero? n1) sum]\n      [(zero? n2) sum]\n      [else (digit_distance_helper (quotient n1 10) (quotient n2 10) (+ sum (abs (- (remainder n1 10) (remainder n2 10)))))]))\n  (digit_distance_helper n1 n2 0))\n",
    "  (cond\n    [(= n1 n2) 0]\n    [(< n1 n2) (- n2 n1)]\n    [else (- n1 n2)]))\n",
    "  (define (digit_distance_helper n1 n2 acc)\n    (cond\n      [(zero? n1) acc]\n      [(zero? n2) acc]\n      [else (digit_distance_helper (quotient n1 10) (quotient n2 10) (+ acc (abs (- (remainder n1 10) (remainder n2 10)))))]))\n  (digit_distance_helper n1 n2 0))\n",
    "  (define (digit_distance_helper n1 n2 sum)\n    (cond\n      [(= n1 0) sum]\n      [(= n2 0) sum]\n      [else (digit_distance_helper (quotient n1 10) (quotient n2 10) (+ sum (abs (- (remainder n1 10) (remainder n2 10)))))]))\n  (digit_distance_helper n1 n2 0))\n",
    "  (let loop ([n1 n1] [n2 n2] [sum 0])\n    (cond\n      [(zero? n1) sum]\n      [(zero? n2) sum]\n      [else (loop (quotient n1 10) (quotient n2 10) (+ sum (abs (- (remainder n1 10) (remainder n2 10)))))])))\n",
    "  (define (digit_distance_nums_iter n1 n2 sum)\n    (if (zero? n1)\n        sum\n        (digit_distance_nums_iter (quotient n1 10) (quotient n2 10) (+ sum (abs (- (remainder n1 10) (remainder n2 10)))))))\n  (digit_distance_nums_iter n1 n2 0))\n",
    "  (define (digit_distance_helper n1 n2 acc)\n    (if (zero? n1)\n        acc\n        (digit_distance_helper (quotient n1 10) (quotient n2 10) (+ acc (abs (- (remainder n1 10) (remainder n2 10)))))))\n  (digit_distance_helper n1 n2 0))\n",
    "  (let ([d1 (number->string n1)]\n        [d2 (number->string n2)])\n    (if (or (empty? d1) (empty? d2))\n        0\n        (+ (abs (- (string-&gt;number (string-ref d1 0))\n                   (string-&gt;number (string-ref d2 0))))\n           (digit_distance_nums (string-&gt;number (substring d1 1))\n                                (string-&gt;number (substring d2 1)))))))\n",
    "  (define (digit_distance_helper n1 n2)\n    (if (or (zero? n1) (zero? n2))\n        0\n        (+ (abs (- (modulo n1 10) (modulo n2 10)))\n           (digit_distance_helper (quotient n1 10) (quotient n2 10)))))\n  (digit_distance_helper n1 n2))\n",
    "  (define (sum_of_digits n)\n    (if (zero? n)\n        0\n        (+ (remainder n 10) (sum_of_digits (quotient n 10)))))\n  (abs (- (sum_of_digits n1) (sum_of_digits n2))))\n",
    "  (let loop ([n1 n1] [n2 n2] [sum 0])\n    (if (and (zero? n1) (zero? n2))\n        sum\n        (let ([d1 (remainder n1 10)]\n              [d2 (remainder n2 10)])\n          (loop (quotient n1 10) (quotient n2 10) (+ sum (abs (- d1 d2))))))))\n",
    "  (cond\n    [(zero? n1) n2]\n    [(zero? n2) n1]\n    [else\n     (let ([d1 (modulo n1 10)]\n           [d2 (modulo n2 10)])\n       (+ (abs (- d1 d2))\n          (digit_distance_nums (quotient n1 10) (quotient n2 10))))]))\n",
    "  (define (digit_distance_helper n1 n2)\n    (if (zero? n1)\n        0\n        (+ (abs (- (remainder n1 10) (remainder n2 10)))\n           (digit_distance_helper (quotient n1 10) (quotient n2 10)))))\n  (digit_distance_helper n1 n2))\n",
    "  (define (digit_distance_helper n1 n2 acc)\n    (cond\n      [(zero? n1) acc]\n      [(zero? n2) acc]\n      [else (digit_distance_helper (quotient n1 10) (quotient n2 10) (+ acc (abs (- (modulo n1 10) (modulo n2 10)))))]))\n  (digit_distance_helper n1 n2 0))\n",
    "  (define (digit_distance_nums_helper n1 n2 acc)\n    (cond\n      [(zero? n1) acc]\n      [(zero? n2) acc]\n      [else (digit_distance_nums_helper (quotient n1 10) (quotient n2 10) (+ acc (abs (- (remainder n1 10) (remainder n2 10)))))]))\n  (digit_distance_nums_helper n1 n2 0))\n",
    "  (let ([n1 (number->string n1)]\n        [n2 (number->string n2)])\n    (if (or (null? n1) (null? n2))\n        0\n        (+ (abs (- (string->number (string-ref n1 0))\n                   (string->number (string-ref n2 0))))\n           (digit_distance_nums (substring n1 1) (substring n2 1))))))\n",
    "  (define (abs-diff x y)\n    (if (&lt; x y) (- y x) (- x y)))\n  (define (digit-distance-helper n1 n2 acc)\n    (if (zero? n1)\n        acc\n        (digit-distance-helper (quotient n1 10) (quotient n2 10)\n                               (+ acc (abs-diff (remainder n1 10) (remainder n2 10))))))\n  (digit-distance-helper n1 n2 0))\n",
    "  (define (digit_distance_nums_iter n1 n2 sum)\n    (cond [(zero? n1) sum]\n          [(zero? n2) sum]\n          [else (digit_distance_nums_iter (quotient n1 10) (quotient n2 10) (+ sum (abs (- (remainder n1 10) (remainder n2 10)))))]))\n  (digit_distance_nums_iter n1 n2 0))\n",
    "  (let ([n1 (number->string n1)]\n        [n2 (number->string n2)])\n    (if (or (null? n1) (null? n2))\n        0\n        (+ (abs (- (string-&gt;number (string-ref n1 0))\n                   (string-&gt;number (string-ref n2 0))))\n           (digit_distance_nums (string-drop n1 1)\n                                (string-drop n2 1))))))\n",
    "  (define (digit_distance_helper n1 n2)\n    (if (zero? n1)\n        0\n        (+ (abs (- (remainder n1 10) (remainder n2 10)))\n           (digit_distance_helper (quotient n1 10) (quotient n2 10)))))\n  (digit_distance_helper n1 n2))\n",
    "  (define (digit_distance_helper n1 n2 acc)\n    (cond\n      [(zero? n1) acc]\n      [(zero? n2) (digit_distance_helper (quotient n1 10) (quotient n2 10) (+ acc (abs (- (remainder n1 10) (remainder n2 10)))))]\n      [else (digit_distance_helper (quotient n1 10) (quotient n2 10) (+ acc (abs (- (remainder n1 10) (remainder n2 10))))]))\n  (digit_distance_helper n1 n2 0))\n",
    "  (define (digit_distance_nums_iter n1 n2 sum)\n    (cond\n      [(zero? n1) sum]\n      [(zero? n2) sum]\n      [else\n       (let ([d1 (remainder n1 10)]\n             [d2 (remainder n2 10)])\n         (digit_distance_nums_iter (quotient n1 10) (quotient n2 10) (+ sum (abs (- d1 d2)))))]))\n  (digit_distance_nums_iter n1 n2 0))\n",
    "  (define (digit_distance_nums_iter n1 n2 acc)\n    (if (zero? n1)\n        acc\n        (digit_distance_nums_iter (quotient n1 10) (quotient n2 10) (+ acc (abs (- (remainder n1 10) (remainder n2 10)))))))\n  (digit_distance_nums_iter n1 n2 0))\n",
    "  (define (digit_distance_nums_iter n1 n2 acc)\n    (if (zero? n1)\n        acc\n        (digit_distance_nums_iter (quotient n1 10) (quotient n2 10) (+ acc (abs (- (remainder n1 10) (remainder n2 10)))))))\n  (digit_distance_nums_iter n1 n2 0))\n",
    "  (define (digit_distance_helper n1 n2)\n    (if (zero? n1)\n        0\n        (+ (abs (- (modulo n1 10) (modulo n2 10)))\n           (digit_distance_helper (quotient n1 10) (quotient n2 10)))))\n  (digit_distance_helper n1 n2))\n",
    "  (define (digit_distance_helper n1 n2 acc)\n    (cond\n      [(zero? n1) acc]\n      [(zero? n2) acc]\n      [else (digit_distance_helper (quotient n1 10) (quotient n2 10) (+ acc (abs (- (remainder n1 10) (remainder n2 10)))))]))\n  (digit_distance_helper n1 n2 0))\n",
    "  (define (digit_distance_helper n1 n2)\n    (if (zero? n1)\n        0\n        (+ (abs (- (modulo n1 10) (modulo n2 10)))\n           (digit_distance_helper (quotient n1 10) (quotient n2 10)))))\n  (digit_distance_helper n1 n2))\n",
    "  (let loop ([n1 n1] [n2 n2] [sum 0])\n    (if (or (zero? n1) (zero? n2))\n        sum\n        (let ([d1 (remainder n1 10)]\n              [d2 (remainder n2 10)])\n          (loop (quotient n1 10) (quotient n2 10) (+ sum (abs (- d1 d2))))))))\n",
    "  (define (digit_distance_helper n1 n2 acc)\n    (cond\n      [(zero? n1) acc]\n      [(zero? n2) acc]\n      [else (digit_distance_helper (quotient n1 10) (quotient n2 10) (+ acc (abs (- (remainder n1 10) (remainder n2 10)))))]))\n  (digit_distance_helper n1 n2 0))\n",
    "  (define (digit_distance_helper n1 n2)\n    (if (or (zero? n1) (zero? n2))\n        0\n        (+ (abs (- (remainder n1 10) (remainder n2 10)))\n           (digit_distance_helper (quotient n1 10) (quotient n2 10)))))\n  (digit_distance_helper n1 n2))\n",
    "  (define (digit_distance_helper n1 n2 acc)\n    (if (zero? n1)\n        acc\n        (let ([d1 (remainder n1 10)]\n              [d2 (remainder n2 10)])\n          (digit_distance_helper (quotient n1 10) (quotient n2 10) (+ acc (abs (- d1 d2)))))))\n  (digit_distance_helper n1 n2 0))\n",
    "  (define (digit-distance n1 n2)\n    (if (and (not (zero? n1)) (not (zero? n2)))\n        (+ (abs (- (remainder n1 10) (remainder n2 10)))\n           (digit-distance (quotient n1 10) (quotient n2 10)))\n        0))\n  (digit-distance n1 n2))\n",
    "  (define (digit_distance_helper n1 n2)\n    (if (and (zero? n1) (zero? n2))\n        0\n        (+ (abs (- (remainder n1 10) (remainder n2 10)))\n           (digit_distance_helper (quotient n1 10) (quotient n2 10)))))\n  (digit_distance_helper n1 n2))\n",
    "  (define (digit_distance_helper n1 n2 acc)\n    (if (zero? n1)\n        acc\n        (digit_distance_helper (quotient n1 10) (quotient n2 10) (+ acc (abs (- (remainder n1 10) (remainder n2 10)))))))\n  (digit_distance_helper n1 n2 0))\n",
    "  (let loop ([n1 n1] [n2 n2] [sum 0])\n    (cond [(zero? n1) sum]\n          [(zero? n2) sum]\n          [else (loop (quotient n1 10) (quotient n2 10) (+ sum (abs (- (remainder n1 10) (remainder n2 10)))))])))\n",
    "  (define (digit_distance_helper n1 n2)\n    (if (zero? n1)\n        0\n        (+ (abs (- (modulo n1 10) (modulo n2 10)))\n           (digit_distance_helper (quotient n1 10) (quotient n2 10)))))\n  (digit_distance_helper n1 n2))\n",
    "  (define (digit_distance_helper n1 n2 acc)\n    (cond\n      [(zero? n1) acc]\n      [(zero? n2) acc]\n      [else (digit_distance_helper (quotient n1 10) (quotient n2 10) (+ acc (abs (- (remainder n1 10) (remainder n2 10)))))]))\n  (digit_distance_helper n1 n2 0))\n",
    "  (define (digit-distance n1 n2)\n    (if (and (zero? n1) (zero? n2))\n        0\n        (let ([d1 (modulo n1 10)]\n              [d2 (modulo n2 10)])\n          (abs (- d1 d2)))))\n  (define (helper n1 n2 acc)\n    (if (and (zero? n1) (zero? n2))\n        acc\n        (helper (quotient n1 10) (quotient n2 10) (+ acc (digit-distance n1 n2)))))\n  (helper n1 n2 0))\n",
    "  (let ([n1 (number->string n1)]\n        [n2 (number->string n2)])\n    (if (or (zero? (string-length n1))\n            (zero? (string-length n2)))\n        0\n        (+ (abs (- (string-&gt;number (string-take n1 1))\n                   (string-&gt;number (string-take n2 1))))\n           (digit_distance_nums (string-drop n1 1)\n                                (string-drop n2 1))))))\n</code>\n",
    "  (let ([d1 (string->list (number->string n1))]\n        [d2 (string->list (number->string n2))])\n    (apply + (map (lambda (x y) (abs (- x y))) d1 d2))))\n",
    "  (define (digit_distance_helper n1 n2 acc)\n    (if (or (= n1 0) (= n2 0))\n        acc\n        (digit_distance_helper (quotient n1 10) (quotient n2 10) (+ acc (abs (- (remainder n1 10) (remainder n2 10)))))))\n  (digit_distance_helper n1 n2 0))\n",
    "  (let ([n1 (number->string n1)])\n    (let ([n2 (number->string n2)])\n      (let ([n1 (string->list n1)])\n        (let ([n2 (string->list n2)])\n          (let ([n1 (map string->number n1)])\n            (let ([n2 (map string->number n2)])\n              (let ([n1 (map abs (- n1 n2))])\n                (apply + n1)))))))))\n",
    "  (let ([n1 (string->number (number->string n1))]\n        [n2 (string->number (number->string n2))])\n    (if (or (zero? n1) (zero? n2))\n        0\n        (+ (abs (- (modulo n1 10) (modulo n2 10)))\n           (digit_distance_nums (quotient n1 10) (quotient n2 10))))))\n",
    "  (define (digit_distance_nums-iter n1 n2 acc)\n    (if (zero? n1)\n        acc\n        (digit_distance_nums-iter (quotient n1 10) (quotient n2 10) (+ acc (abs (- (remainder n1 10) (remainder n2 10)))))))\n  (digit_distance_nums-iter n1 n2 0))\n",
    "  (define (digit_distance_helper n1 n2 acc)\n    (cond\n      [(zero? n1) acc]\n      [(zero? n2) acc]\n      [else\n       (let ([d1 (remainder n1 10)]\n             [d2 (remainder n2 10)])\n         (digit_distance_helper (quotient n1 10) (quotient n2 10) (+ acc (abs (- d1 d2)))))]))\n  (digit_distance_helper n1 n2 0))\n",
    "  (define (digit_distance_helper n1 n2 acc)\n    (cond\n      [(zero? n1) acc]\n      [(zero? n2) acc]\n      [else (digit_distance_helper (quotient n1 10) (quotient n2 10) (+ acc (abs (- (modulo n1 10) (modulo n2 10)))))]))\n  (digit_distance_helper n1 n2 0))\n",
    "  (define (digit_distance_helper n1 n2)\n    (if (zero? n1)\n        0\n        (+ (abs (- (modulo n1 10) (modulo n2 10)))\n           (digit_distance_helper (quotient n1 10) (quotient n2 10)))))\n  (digit_distance_helper n1 n2))\n",
    "  (let ([d1 (string->number (number->string n1))]\n        [d2 (string->number (number->string n2))])\n    (if (or (zero? d1) (zero? d2))\n        0\n        (+ (abs (- (modulo d1 10) (modulo d2 10)))\n           (digit_distance_nums (quotient d1 10) (quotient d2 10))))))\n",
    "  (let loop ([n1 n1] [n2 n2] [sum 0])\n    (if (and (zero? n1) (zero? n2))\n        sum\n        (let ([d1 (remainder n1 10)]\n              [d2 (remainder n2 10)])\n          (loop (quotient n1 10) (quotient n2 10) (+ sum (abs (- d1 d2))))))))\n",
    "  (define (digit_distance_helper n1 n2 acc)\n    (cond\n      [(zero? n1) acc]\n      [(zero? n2) acc]\n      [else (digit_distance_helper (quotient n1 10) (quotient n2 10) (+ acc (abs (- (remainder n1 10) (remainder n2 10)))))]))\n  (digit_distance_helper n1 n2 0))\n",
    "  (let loop ([n1 n1] [n2 n2] [sum 0])\n    (if (and (zero? n1) (zero? n2))\n        sum\n        (loop (quotient n1 10)\n              (quotient n2 10)\n              (+ sum (abs (- (remainder n1 10) (remainder n2 10))))))))\n",
    "  (define (digit_distance_nums_iter n1 n2 sum)\n    (if (or (zero? n1) (zero? n2))\n        sum\n        (let* ([d1 (remainder n1 10)]\n               [d2 (remainder n2 10)]\n               [diff (abs (- d1 d2))])\n          (digit_distance_nums_iter (quotient n1 10) (quotient n2 10) (+ sum diff)))))\n  (digit_distance_nums_iter n1 n2 0))\n",
    "  (define (digit_distance_helper n1 n2 acc)\n    (if (zero? n1)\n        acc\n        (digit_distance_helper (quotient n1 10) (quotient n2 10) (+ acc (abs (- (remainder n1 10) (remainder n2 10)))))))\n  (digit_distance_helper n1 n2 0))\n",
    "  (define (digit_distance_nums_iter n1 n2 sum)\n    (cond\n      [(zero? n1) sum]\n      [(zero? n2) sum]\n      [else (digit_distance_nums_iter (quotient n1 10) (quotient n2 10) (+ sum (abs (- (remainder n1 10) (remainder n2 10)))))]))\n  (digit_distance_nums_iter n1 n2 0))\n",
    "  (let ([d1 (string->list (number->string n1))]\n        [d2 (string->list (number->string n2))])\n    (if (or (null? d1) (null? d2))\n        0\n        (+ (abs (- (string->number (list->string (car d1)))\n                   (string->number (list->string (car d2)))))\n           (digit_distance_nums (string->number (list->string (cdr d1)))\n                                (string->number (list->string (cdr d2))))))))\n",
    "  (define (digit_distance_helper n1 n2)\n    (if (or (zero? n1) (zero? n2))\n        0\n        (+ (abs (- (remainder n1 10) (remainder n2 10)))\n           (digit_distance_helper (quotient n1 10) (quotient n2 10)))))\n  (digit_distance_helper n1 n2))\n",
    "  (define (digit_distance_helper n1 n2 sum)\n    (cond\n      [(zero? n1) sum]\n      [(zero? n2) sum]\n      [else (digit_distance_helper (quotient n1 10) (quotient n2 10) (+ sum (abs (- (remainder n1 10) (remainder n2 10)))))]))\n  (digit_distance_helper n1 n2 0))\n",
    "  (let ([n1 (number->string n1)]\n        [n2 (number->string n2)])\n    (if (or (empty? n1) (empty? n2))\n        0\n        (+ (abs (- (string->number (substring n1 0 1))\n                   (string->number (substring n2 0 1))))\n           (digit_distance_nums (substring n1 1)\n                                (substring n2 1))))))\n",
    "  (define (digit_distance_helper n1 n2 acc)\n    (if (or (zero? n1) (zero? n2))\n        acc\n        (digit_distance_helper (quotient n1 10) (quotient n2 10) (+ acc (abs (- (remainder n1 10) (remainder n2 10)))))))\n  (digit_distance_helper n1 n2 0))\n",
    "  (define (digit_distance_helper n1 n2)\n    (if (zero? n1)\n        0\n        (+ (abs (- (modulo n1 10) (modulo n2 10)))\n           (digit_distance_helper (quotient n1 10) (quotient n2 10)))))\n  (digit_distance_helper n1 n2))\n",
    "  (let ([n1-digits (string->list (number->string n1))]\n        [n2-digits (string->list (number->string n2))])\n    (if (or (null? n1-digits) (null? n2-digits))\n        0\n        (+ (abs (- (string->number (list->string n1-digits))\n                   (string->number (list->string n2-digits))))\n           (digit_distance_nums (string->number (list->string (cdr n1-digits)))\n                                (string->number (list->string (cdr n2-digits))))))))\n",
    "  (define (digit_distance_helper n1 n2)\n    (if (and (zero? n1) (zero? n2))\n        0\n        (+ (abs (- (modulo n1 10) (modulo n2 10)))\n           (digit_distance_helper (quotient n1 10) (quotient n2 10)))))\n  (digit_distance_helper n1 n2))\n",
    "  (define (digit_distance_helper n1 n2 acc)\n    (cond\n      [(zero? n1) acc]\n      [(zero? n2) acc]\n      [else (digit_distance_helper (quotient n1 10) (quotient n2 10) (+ acc (abs (- (remainder n1 10) (remainder n2 10)))))]))\n  (digit_distance_helper n1 n2 0))\n",
    "  (define (digit_distance_num n)\n    (if (zero? n)\n        0\n        (+ (abs (- (modulo n 10) (modulo (quotient n 10) 10)))\n           (digit_distance_num (quotient n 10)))))\n  (digit_distance_num n1)\n  (digit_distance_num n2))\n",
    "  (define (digit_distance_helper n1 n2 acc)\n    (cond [(= n1 0) acc]\n          [(= n2 0) acc]\n          [else (digit_distance_helper (quotient n1 10) (quotient n2 10) (+ acc (abs (- (remainder n1 10) (remainder n2 10)))))]))\n  (digit_distance_helper n1 n2 0))\n",
    "  (define (digit_distance_nums-iter n1 n2 sum)\n    (cond [(zero? n1) sum]\n          [(zero? n2) sum]\n          [else (digit_distance_nums-iter (quotient n1 10) (quotient n2 10) (+ sum (abs (- (remainder n1 10) (remainder n2 10)))))]))\n  (digit_distance_nums-iter n1 n2 0))\n",
    "  (define (digit_distance_helper n1 n2 acc)\n    (if (zero? n1)\n        acc\n        (digit_distance_helper (quotient n1 10) (quotient n2 10) (+ acc (abs (- (modulo n1 10) (modulo n2 10)))))))\n  (digit_distance_helper n1 n2 0))\n",
    "  (define (digit_distance_helper n1 n2)\n    (if (or (zero? n1) (zero? n2))\n        0\n        (+ (abs (- (remainder n1 10) (remainder n2 10)))\n           (digit_distance_helper (quotient n1 10) (quotient n2 10)))))\n  (digit_distance_helper n1 n2))\n",
    "  (define (digit_distance_helper n1 n2)\n    (if (or (zero? n1) (zero? n2))\n        0\n        (+ (abs (- (remainder n1 10) (remainder n2 10)))\n           (digit_distance_helper (quotient n1 10) (quotient n2 10)))))\n  (digit_distance_helper n1 n2))\n",
    "  (define (digit_distance_helper n1 n2)\n    (if (zero? n1)\n        0\n        (+ (abs (- (remainder n1 10) (remainder n2 10)))\n           (digit_distance_helper (quotient n1 10) (quotient n2 10)))))\n  (digit_distance_helper n1 n2))\n",
    "  (define (digit_distance_helper n1 n2)\n    (if (or (= n1 0) (= n2 0))\n        0\n        (+ (abs (- (modulo n1 10) (modulo n2 10)))\n           (digit_distance_helper (quotient n1 10) (quotient n2 10)))))\n  (digit_distance_helper n1 n2))\n",
    "  (let ([n1 (number->string n1)]\n        [n2 (number->string n2)])\n    (if (or (not (string=? (string-length n1) (string-length n2)))\n            (not (string-&gt;number n1))\n            (not (string-&gt;number n2)))\n        -1\n        (let ([n1 (string-&gt;number n1)]\n              [n2 (string-&gt;number n2)])\n          (let loop ([n1 n1]\n                     [n2 n2]\n                     [sum 0])\n            (if (zero? n1)\n                sum\n                (loop (quotient n1 10)\n                      (quotient n2 10)\n                      (+ sum (abs (- (remainder n1 10) (remainder n2 10)))))))))))\n",
    "  (define (helper n1 n2 acc)\n    (if (zero? n1)\n        acc\n        (helper (quotient n1 10) (quotient n2 10) (+ acc (abs (- (remainder n1 10) (remainder n2 10)))))))\n  (helper n1 n2 0))\n",
    "  (define (digit-distance n1 n2)\n    (if (zero? n1)\n        0\n        (if (zero? n2)\n            0\n            (+ (abs (- (remainder n1 10) (remainder n2 10)))\n               (digit-distance (quotient n1 10) (quotient n2 10))))))\n  (digit-distance n1 n2))\n",
    "  (define (digit_distance_helper n1 n2 acc)\n    (if (or (zero? n1) (zero? n2))\n        acc\n        (digit_distance_helper (quotient n1 10) (quotient n2 10) (+ acc (abs (- (remainder n1 10) (remainder n2 10)))))))\n  (digit_distance_helper n1 n2 0))\n",
    "  (let ([d1 (string->list (number->string n1))]\n        [d2 (string->list (number->string n2))])\n    (cond\n      [(empty? d1) 0]\n      [(empty? d2) 0]\n      [else (+ (abs (- (string->number (list->string (list (car d1))))\n                       (string->number (list->string (list (car d2))))))\n                (digit_distance_nums (list->string (cdr d1))\n                                     (list->string (cdr d2))))])))\n",
    "  (let ([n1-digits (number->string n1)]\n        [n2-digits (number->string n2)])\n    (cond [(empty? n1-digits) 0]\n          [(empty? n2-digits) 0]\n          [else (+ (abs (- (string-&gt;number (string-ref n1-digits 0))\n                          (string-&gt;number (string-ref n2-digits 0))))\n                   (digit_distance_nums (string-&gt;number (substring n1-digits 1))\n                                        (string-&gt;number (substring n2-digits 1))))])))\n</code>\nI'm not sure if this is the most efficient way to do it, but it works.\n",
    "  (define (digit-distance-helper n1 n2 acc)\n    (cond [(= n1 0) acc]\n          [(= n2 0) acc]\n          [else (digit-distance-helper (quotient n1 10) (quotient n2 10) (+ acc (abs (- (remainder n1 10) (remainder n2 10)))))]))\n  (digit-distance-helper n1 n2 0))\n",
    "  (define (digit_distance_nums_iter n1 n2 acc)\n    (cond\n      [(zero? n1) acc]\n      [(zero? n2) acc]\n      [else (digit_distance_nums_iter (quotient n1 10) (quotient n2 10) (+ acc (abs (- (remainder n1 10) (remainder n2 10)))))]))\n  (digit_distance_nums_iter n1 n2 0))\n",
    "  (define (digit-distance n1 n2)\n    (if (and (not (zero? n1)) (not (zero? n2)))\n        (+ (abs (- (remainder n1 10) (remainder n2 10)))\n           (digit-distance (quotient n1 10) (quotient n2 10)))\n        0))\n  (digit-distance n1 n2))\n",
    "  (define (digit_distance_nums_iter n1 n2 acc)\n    (if (zero? n1)\n        acc\n        (digit_distance_nums_iter (quotient n1 10) (quotient n2 10) (+ acc (abs (- (remainder n1 10) (remainder n2 10)))))))\n  (digit_distance_nums_iter n1 n2 0))\n",
    "  (define (digit_distance_nums_helper n1 n2 sum)\n    (if (zero? n1)\n        sum\n        (digit_distance_nums_helper (quotient n1 10) (quotient n2 10) (+ sum (abs (- (remainder n1 10) (remainder n2 10)))))))\n  (digit_distance_nums_helper n1 n2 0))\n",
    "  (if (zero? n1)\n      (abs (- n1 n2))\n      (+ (abs (- (modulo n1 10) (modulo n2 10)))\n         (digit_distance_nums (quotient n1 10) (quotient n2 10)))))\n",
    "  (define (digit_distance_helper n1 n2)\n    (if (zero? n1)\n        0\n        (+ (abs (- (remainder n1 10) (remainder n2 10)))\n           (digit_distance_helper (quotient n1 10) (quotient n2 10)))))\n  (digit_distance_helper n1 n2))\n",
    "  (define (digit_distance_helper n1 n2 acc)\n    (if (zero? n1)\n        acc\n        (digit_distance_helper (quotient n1 10) (quotient n2 10) (+ acc (abs (- (remainder n1 10) (remainder n2 10)))))))\n  (digit_distance_helper n1 n2 0))\n",
    "  (define (sum_digits n)\n    (if (zero? n)\n        0\n        (+ (remainder n 10) (sum_digits (quotient n 10)))))\n  (abs (- (sum_digits n1) (sum_digits n2))))\n",
    "  (let ([d1 (string->list (number->string n1))]\n        [d2 (string->list (number->string n2))])\n    (if (or (null? d1) (null? d2))\n        0\n        (+ (abs (- (string->number (list->string (car d1)))\n                   (string->number (list->string (car d2)))))\n           (digit_distance_nums (string->number (list->string (cdr d1)))\n                                (string->number (list->string (cdr d2))))))))\n",
    "  (define (digit_distance_helper n1 n2)\n    (if (and (zero? n1) (zero? n2))\n        0\n        (+ (abs (- (remainder n1 10) (remainder n2 10)))\n           (digit_distance_helper (quotient n1 10) (quotient n2 10)))))\n  (digit_distance_helper n1 n2))\n",
    "  (let ([n1 (number->string n1)]\n        [n2 (number->string n2)])\n    (if (or (null? n1) (null? n2))\n        0\n        (+ (abs (- (string->number (string-ref n1 0))\n                   (string->number (string-ref n2 0))))\n           (digit_distance_nums (string-drop n1 1)\n                                (string-drop n2 1))))))\n",
    "  (let ([n1 (number->string n1)]\n        [n2 (number->string n2)])\n    (if (or (not (string=? (string-length n1) (string-length n2)))\n            (not (andmap char-numeric? n1))\n            (not (andmap char-numeric? n2)))\n        (error \"Inputs must be the same length and contain only digits.\"))\n    (let ([n1 (string->number n1)]\n          [n2 (string->number n2)])\n      (for/sum ([i (in-range (string-length n1))])\n        (abs (- (modulo n1 (expt 10 i))\n                (modulo n2 (expt 10 i))))))))\n",
    "  (let ([n1-digits (number->string n1)]\n        [n2-digits (number->string n2)])\n    (if (or (empty? n1-digits) (empty? n2-digits))\n        0\n        (+ (abs (- (string-&gt;number (first n1-digits))\n                   (string-&gt;number (first n2-digits))))\n           (digit_distance_nums (string-&gt;number (rest n1-digits))\n                                (string-&gt;number (rest n2-digits)))))))\n",
    "  (define (digit_distance_helper n1 n2 sum)\n    (cond [(= n1 0) sum]\n          [(= n2 0) sum]\n          [else (digit_distance_helper (quotient n1 10) (quotient n2 10) (+ sum (abs (- (remainder n1 10) (remainder n2 10)))))]))\n  (digit_distance_helper n1 n2 0))\n",
    "  (let ([n1 (number->string n1)]\n        [n2 (number->string n2)])\n    (if (or (empty? n1) (empty? n2))\n        0\n        (+ (abs (- (string->number (substring n1 0 1))\n                   (string->number (substring n2 0 1))))\n           (digit_distance_nums (substring n1 1) (substring n2 1))))))\n",
    "  (define (digit_distance_nums-iter n1 n2 sum)\n    (cond\n      [(zero? n1) sum]\n      [(zero? n2) sum]\n      [else (digit_distance_nums-iter (quotient n1 10) (quotient n2 10) (+ sum (abs (- (remainder n1 10) (remainder n2 10)))))]))\n  (digit_distance_nums-iter n1 n2 0))\n",
    "  (define (digit_distance_helper n1 n2)\n    (if (zero? n1)\n        0\n        (+ (abs (- (modulo n1 10) (modulo n2 10)))\n           (digit_distance_helper (quotient n1 10) (quotient n2 10)))))\n  (digit_distance_helper n1 n2))\n",
    "  (define (digit_distance_helper n1 n2 acc)\n    (cond\n      [(zero? n1) acc]\n      [(zero? n2) acc]\n      [else (digit_distance_helper (quotient n1 10) (quotient n2 10) (+ acc (abs (- (remainder n1 10) (remainder n2 10)))))]))\n  (digit_distance_helper n1 n2 0))\n",
    "  (define (digit_distance_helper n1 n2 acc)\n    (cond ((zero? n1) acc)\n          ((zero? n2) acc)\n          (else (digit_distance_helper (quotient n1 10) (quotient n2 10) (+ acc (abs (- (remainder n1 10) (remainder n2 10))))))))\n  (digit_distance_helper n1 n2 0))\n",
    "  (define (digit_distance_helper n1 n2 acc)\n    (if (and (zero? n1) (zero? n2))\n        acc\n        (let ([d1 (modulo n1 10)]\n              [d2 (modulo n2 10)])\n          (digit_distance_helper (quotient n1 10) (quotient n2 10) (+ acc (abs (- d1 d2)))))))\n  (digit_distance_helper n1 n2 0))\n",
    "  (cond\n    [(zero? n1) n2]\n    [(zero? n2) n1]\n    [else\n     (let ([d1 (remainder n1 10)]\n           [d2 (remainder n2 10)])\n       (add1 (digit_distance_nums (quotient n1 10) (quotient n2 10))))]))\n",
    "  (define (digit_distance_helper n1 n2 sum)\n    (cond\n      [(zero? n1) sum]\n      [(zero? n2) sum]\n      [else (digit_distance_helper (quotient n1 10) (quotient n2 10) (+ sum (abs (- (remainder n1 10) (remainder n2 10)))))]))\n  (digit_distance_helper n1 n2 0))\n",
    "  (define (digit_distance_helper n1 n2 sum)\n    (if (and (zero? n1) (zero? n2))\n        sum\n        (let* ([d1 (modulo n1 10)]\n               [d2 (modulo n2 10)]\n               [diff (abs (- d1 d2))])\n          (digit_distance_helper (quotient n1 10) (quotient n2 10) (+ sum diff)))))\n  (digit_distance_helper n1 n2 0))\n",
    "  (define (digit_distance_nums_iter n1 n2 sum)\n    (cond\n      [(= n1 0) sum]\n      [(= n2 0) sum]\n      [else\n       (let ([d1 (remainder n1 10)]\n             [d2 (remainder n2 10)])\n         (digit_distance_nums_iter (quotient n1 10) (quotient n2 10) (+ sum (abs (- d1 d2)))))]))\n  (digit_distance_nums_iter n1 n2 0))\n",
    "  (define (digit_distance_helper n1 n2 sum)\n    (if (zero? n1)\n        sum\n        (digit_distance_helper (quotient n1 10)\n                               (quotient n2 10)\n                               (+ sum (abs (- (remainder n1 10) (remainder n2 10)))))))\n  (digit_distance_helper n1 n2 0))\n",
    "  (define (digit_distance_helper n1 n2 acc)\n    (cond\n      [(= n1 0) acc]\n      [(= n2 0) acc]\n      [else (digit_distance_helper (quotient n1 10) (quotient n2 10) (+ acc (abs (- (remainder n1 10) (remainder n2 10)))))]))\n  (digit_distance_helper n1 n2 0))\n",
    "  (if (zero? n1)\n      (if (zero? n2)\n          0\n          (digit_distance_nums 0 (- n2 1)))\n      (if (zero? n2)\n          (digit_distance_nums (- n1 1) 0)\n          (+ (abs (- (modulo n1 10) (modulo n2 10)))\n             (digit_distance_nums (quotient n1 10) (quotient n2 10))))))\n",
    "  (define (digit_distance_helper n1 n2 acc)\n    (cond [(= n1 0) acc]\n          [(= n2 0) acc]\n          [else (digit_distance_helper (quotient n1 10) (quotient n2 10) (+ acc (abs (- (remainder n1 10) (remainder n2 10)))))]))\n  (digit_distance_helper n1 n2 0))\n",
    "  (define (digit_distance_nums_helper n1 n2 acc)\n    (cond [(= n1 0) acc]\n          [(= n2 0) acc]\n          [else (digit_distance_nums_helper (quotient n1 10) (quotient n2 10) (+ acc (abs (- (remainder n1 10) (remainder n2 10)))))]))\n  (digit_distance_nums_helper n1 n2 0))\n",
    "  (let loop ([n1 n1] [n2 n2] [sum 0])\n    (cond [(zero? n1) sum]\n          [(zero? n2) sum]\n          [else (loop (quotient n1 10) (quotient n2 10) (+ sum (abs (- (remainder n1 10) (remainder n2 10)))))])))\n",
    "  (define (digit_distance_nums_iter n1 n2 sum)\n    (cond\n      [(zero? n1) sum]\n      [(zero? n2) sum]\n      [else (digit_distance_nums_iter (quotient n1 10) (quotient n2 10) (+ sum (abs (- (remainder n1 10) (remainder n2 10)))))]))\n  (digit_distance_nums_iter n1 n2 0))\n",
    "  (define (digit_distance_helper n1 n2 acc)\n    (if (zero? n1)\n        acc\n        (let* ([d1 (remainder n1 10)]\n               [d2 (remainder n2 10)]\n               [diff (abs (- d1 d2))])\n          (digit_distance_helper (quotient n1 10) (quotient n2 10) (+ acc diff)))))\n  (digit_distance_helper n1 n2 0))\n",
    "  (define (distance-helper n1 n2)\n    (if (zero? n1)\n        0\n        (+ (abs (- (remainder n1 10) (remainder n2 10)))\n           (distance-helper (quotient n1 10) (quotient n2 10)))))\n  (distance-helper n1 n2))\n",
    "  (define (digit_distance_helper n1 n2)\n    (if (zero? n1)\n        0\n        (+ (abs (- (remainder n1 10) (remainder n2 10)))\n           (digit_distance_helper (quotient n1 10) (quotient n2 10)))))\n  (digit_distance_helper n1 n2))\n",
    "  (define (digit_distance_helper n1 n2 acc)\n    (if (and (zero? n1) (zero? n2))\n        acc\n        (digit_distance_helper (quotient n1 10) (quotient n2 10) (+ acc (abs (- (remainder n1 10) (remainder n2 10)))))))\n  (digit_distance_helper n1 n2 0))\n",
    "  (define (abs x)\n    (if (&lt; x 0) (- x) x))\n  (define (sum-digits n)\n    (if (&lt; n 10) n\n        (+ (remainder n 10) (sum-digits (quotient n 10)))))\n  (abs (- (sum-digits n1) (sum-digits n2))))\n",
    "  (define (digit_distance_nums_iter n1 n2 sum)\n    (if (zero? n1)\n        sum\n        (digit_distance_nums_iter (quotient n1 10) (quotient n2 10) (+ sum (abs (- (remainder n1 10) (remainder n2 10)))))))\n  (digit_distance_nums_iter n1 n2 0))\n",
    "  (define (digit_distance_helper n1 n2 acc)\n    (if (or (zero? n1) (zero? n2))\n        acc\n        (digit_distance_helper (quotient n1 10) (quotient n2 10) (+ acc (abs (- (remainder n1 10) (remainder n2 10)))))))\n  (digit_distance_helper n1 n2 0))\n",
    "  (define (digit_distance_helper n1 n2)\n    (if (zero? n1)\n        0\n        (+ (abs (- (modulo n1 10) (modulo n2 10)))\n           (digit_distance_helper (quotient n1 10) (quotient n2 10)))))\n  (digit_distance_helper n1 n2))\n",
    "  (define (digit_distance_helper n1 n2)\n    (if (or (zero? n1) (zero? n2))\n        0\n        (+ (abs (- (remainder n1 10) (remainder n2 10)))\n           (digit_distance_helper (quotient n1 10) (quotient n2 10)))))\n  (digit_distance_helper n1 n2))\n",
    "  (define (sum-digits n)\n    (if (zero? n)\n        0\n        (+ (remainder n 10) (sum-digits (quotient n 10)))))\n  (abs (- (sum-digits n1) (sum-digits n2))))\n",
    "  (let ([n1-digits (string->list (number->string n1))]\n        [n2-digits (string->list (number->string n2))])\n    (if (or (empty? n1-digits) (empty? n2-digits))\n        0\n        (+ (abs (- (string->number (list->string (car n1-digits)))\n                   (string->number (list->string (car n2-digits)))))\n           (digit_distance_nums (string->number (list->string (cdr n1-digits)))\n                                (string->number (list->string (cdr n2-digits))))))))\n",
    "  (let loop ([n1 n1] [n2 n2] [sum 0])\n    (cond [(zero? n1) sum]\n          [(zero? n2) sum]\n          [else (loop (quotient n1 10) (quotient n2 10) (+ sum (abs (- (remainder n1 10) (remainder n2 10)))))])))\n",
    "  (define (digit_distance_nums_iter n1 n2 sum)\n    (if (zero? n1)\n        sum\n        (digit_distance_nums_iter (quotient n1 10) (quotient n2 10) (+ sum (abs (- (remainder n1 10) (remainder n2 10)))))))\n  (digit_distance_nums_iter n1 n2 0))\n",
    "  (define (digit_distance_nums_iter n1 n2 acc)\n    (cond [(= n1 0) acc]\n          [(= n2 0) acc]\n          [else (digit_distance_nums_iter (quotient n1 10) (quotient n2 10) (+ acc (abs (- (remainder n1 10) (remainder n2 10)))))]))\n  (digit_distance_nums_iter n1 n2 0))\n",
    "  (define (digit_distance_nums_helper n1 n2 acc)\n    (if (zero? n1)\n        acc\n        (digit_distance_nums_helper (quotient n1 10) (quotient n2 10) (+ acc (abs (- (remainder n1 10) (remainder n2 10)))))))\n  (digit_distance_nums_helper n1 n2 0))\n",
    "  (let loop ([n1 (number->string n1)]\n             [n2 (number->string n2)]\n             [acc 0])\n    (cond [(empty? n1) acc]\n          [(empty? n2) acc]\n          [else (loop (rest n1)\n                      (rest n2)\n                      (+ acc (abs (- (string->number (string (first n1)))\n                                     (string->number (string (first n2)))))))])))\n",
    "  (let ([n1-digits (string->list (number->string n1))]\n        [n2-digits (string->list (number->string n2))])\n    (if (or (empty? n1-digits) (empty? n2-digits))\n        0\n        (+ (abs (- (string->number (list->string (car n1-digits)))\n                   (string->number (list->string (car n2-digits)))))\n           (digit_distance_nums (string->number (list->string (cdr n1-digits)))\n                                (string->number (list->string (cdr n2-digits))))))))\n",
    "  (define (digit_distance_helper n1 n2 acc)\n    (if (zero? n1)\n        acc\n        (digit_distance_helper (quotient n1 10) (quotient n2 10) (+ acc (abs (- (remainder n1 10) (remainder n2 10)))))))\n  (digit_distance_helper n1 n2 0))\n",
    "  (cond\n    [(zero? n1) n2]\n    [(zero? n2) n1]\n    [else\n     (let* ([d1 (remainder n1 10)]\n            [d2 (remainder n2 10)]\n            [d (abs (- d1 d2))])\n       (+ d (digit_distance_nums (quotient n1 10) (quotient n2 10))))]))\n",
    "  (cond\n    [(zero? n1) (abs (- n2))]\n    [(zero? n2) (abs (- n1))]\n    [else\n     (+ (abs (- (remainder n1 10) (remainder n2 10)))\n        (digit_distance_nums (quotient n1 10) (quotient n2 10)))]))\n",
    "  (define (digit_distance_helper n1 n2 acc)\n    (if (zero? n1)\n        acc\n        (let* ([d1 (remainder n1 10)]\n               [d2 (remainder n2 10)]\n               [d (abs (- d1 d2))])\n          (digit_distance_helper (quotient n1 10) (quotient n2 10) (+ acc d)))))\n  (digit_distance_helper n1 n2 0))\n",
    "  (define (digit_distance_nums_iter n1 n2 sum)\n    (if (zero? n1)\n        sum\n        (digit_distance_nums_iter (quotient n1 10)\n                                  (quotient n2 10)\n                                  (+ sum (abs (- (remainder n1 10) (remainder n2 10)))))))\n  (digit_distance_nums_iter n1 n2 0))\n",
    "  (define (digit_distance_helper n1 n2 acc)\n    (cond [(zero? n1) acc]\n          [(zero? n2) acc]\n          [else (digit_distance_helper (quotient n1 10) (quotient n2 10) (+ acc (abs (- (remainder n1 10) (remainder n2 10)))))]))\n  (digit_distance_helper n1 n2 0))\n",
    "  (define (digit_distance_helper n1 n2)\n    (if (or (zero? n1) (zero? n2))\n        0\n        (+ (abs (- (remainder n1 10) (remainder n2 10)))\n           (digit_distance_helper (quotient n1 10) (quotient n2 10)))))\n  (digit_distance_helper n1 n2))\n",
    "  (define (digit_distance_helper n1 n2)\n    (if (and (zero? n1) (zero? n2))\n        0\n        (+ (abs (- (remainder n1 10) (remainder n2 10)))\n           (digit_distance_helper (quotient n1 10) (quotient n2 10)))))\n  (digit_distance_helper n1 n2))\n",
    "  (define (digit_distance_nums_iter n1 n2 sum)\n    (if (zero? n1)\n        sum\n        (digit_distance_nums_iter (quotient n1 10)\n                                  (quotient n2 10)\n                                  (+ sum (abs (- (remainder n1 10) (remainder n2 10)))))))\n  (digit_distance_nums_iter n1 n2 0))\n",
    "  (define (digit_distance_helper n1 n2)\n    (if (zero? n1)\n        0\n        (+ (abs (- (modulo n1 10) (modulo n2 10)))\n           (digit_distance_helper (quotient n1 10) (quotient n2 10)))))\n  (digit_distance_helper n1 n2))\n",
    "  (let ([n1-digits (string->list (number->string n1))]\n        [n2-digits (string->list (number->string n2))])\n    (if (or (null? n1-digits) (null? n2-digits))\n        0\n        (+ (abs (- (string->number (list->string (list (car n1-digits))))\n                  (string->number (list->string (list (car n2-digits))))))\n           (digit_distance_nums (string->number (list->string (cdr n1-digits)))\n                                (string->number (list->string (cdr n2-digits))))))))\n",
    "  (define (digit_distance_helper n1 n2)\n    (if (zero? n1)\n        0\n        (+ (abs (- (remainder n1 10) (remainder n2 10)))\n           (digit_distance_helper (quotient n1 10) (quotient n2 10)))))\n  (digit_distance_helper n1 n2))\n"
  ]
}