{
  "name": "mbpp_558_digit_distance_nums",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Write a python function to find the sum of the per-digit difference between two integers.\n(define (digit_distance_nums n1 n2)\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_558_digit_distance_nums.py",
  "prompt_terminology": "verbatim",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate digit_distance_nums))\n    (check-equal? (candidate 1 2) 1)\n    (check-equal? (candidate 23 56) 6)\n    (check-equal? (candidate 123 256) 7)\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (define (digit_distance_helper n1 n2 acc)\n    (if (or (zero? n1) (zero? n2))\n        acc\n        (digit_distance_helper (quotient n1 10) (quotient n2 10) (+ acc (abs (- (remainder n1 10) (remainder n2 10)))))))\n  (digit_distance_helper n1 n2 0))\n",
    "  (define (digit_distance_helper n1 n2)\n    (if (zero? n1)\n        0\n        (+ (abs (- (remainder n1 10) (remainder n2 10)))\n           (digit_distance_helper (quotient n1 10) (quotient n2 10)))))\n  (digit_distance_helper n1 n2))\n",
    "  (define (digit_distance_helper n1 n2 acc)\n    (if (zero? n1)\n        acc\n        (let ([d1 (remainder n1 10)]\n              [d2 (remainder n2 10)])\n          (digit_distance_helper (quotient n1 10) (quotient n2 10) (+ acc (abs (- d1 d2)))))))\n  (digit_distance_helper n1 n2 0))\n",
    "  (define (digit_distance_helper n1 n2 acc)\n    (if (zero? n1)\n        acc\n        (digit_distance_helper (quotient n1 10) (quotient n2 10) (+ acc (abs (- (remainder n1 10) (remainder n2 10)))))))\n  (digit_distance_helper n1 n2 0))\n",
    "  (define (digit_distance_helper n1 n2 acc)\n    (if (zero? n1)\n        acc\n        (digit_distance_helper (quotient n1 10) (quotient n2 10) (+ acc (abs (- (remainder n1 10) (remainder n2 10)))))))\n  (digit_distance_helper n1 n2 0))\n",
    "  (define (digit-distance-helper n1 n2)\n    (if (zero? n1)\n        0\n        (+ (abs (- (remainder n1 10) (remainder n2 10)))\n           (digit-distance-helper (quotient n1 10) (quotient n2 10)))))\n  (digit-distance-helper n1 n2))\n",
    "  (cond\n    [(zero? n1) 0]\n    [(zero? n2) 0]\n    [else (+ (abs (- (modulo n1 10) (modulo n2 10)))\n             (digit_distance_nums (quotient n1 10) (quotient n2 10)))]))\n",
    "  (let ([n1 (number->string n1)]\n        [n2 (number->string n2)])\n    (if (or (zero? (string-length n1))\n            (zero? (string-length n2)))\n        0\n        (+ (abs (- (string-&gt;number (string-take n1 1))\n                   (string-&gt;number (string-take n2 1))))\n           (digit_distance_nums (string-drop n1 1)\n                                (string-drop n2 1))))))\n",
    "  (define (digit_distance_helper n1 n2)\n    (if (zero? n1)\n        0\n        (+ (abs (- (remainder n1 10) (remainder n2 10)))\n           (digit_distance_helper (quotient n1 10) (quotient n2 10)))))\n  (digit_distance_helper n1 n2))\n",
    "  (define (digit_distance_nums_helper n1 n2 sum)\n    (if (or (zero? n1) (zero? n2))\n        sum\n        (let* ([d1 (remainder n1 10)]\n               [d2 (remainder n2 10)]\n               [diff (abs (- d1 d2))])\n          (digit_distance_nums_helper (quotient n1 10) (quotient n2 10) (+ sum diff)))))\n  (digit_distance_nums_helper n1 n2 0))\n",
    "  (let ((n1 (number->string n1))\n        (n2 (number->string n2)))\n    (if (or (string=? n1 \"\") (string=? n2 \"\"))\n        0\n        (+ (abs (- (string-&gt;number (string-ref n1 0))\n                   (string-&gt;number (string-ref n2 0))))\n           (digit_distance_nums (substring n1 1) (substring n2 1))))))\n",
    "  (define (digit_distance_helper n1 n2 acc)\n    (if (or (zero? n1) (zero? n2))\n        acc\n        (digit_distance_helper (quotient n1 10) (quotient n2 10) (+ acc (abs (- (remainder n1 10) (remainder n2 10)))))))\n  (digit_distance_helper n1 n2 0))\n",
    "  (define (digit_distance_nums_iter n1 n2 acc)\n    (if (zero? n1)\n        acc\n        (digit_distance_nums_iter (quotient n1 10) (quotient n2 10) (+ acc (abs (- (remainder n1 10) (remainder n2 10)))))))\n  (digit_distance_nums_iter n1 n2 0))\n",
    "  (define (digit_distance_helper n1 n2 acc)\n    (cond\n      [(zero? n1) acc]\n      [(zero? n2) acc]\n      [else\n       (digit_distance_helper (quotient n1 10) (quotient n2 10) (+ acc (abs (- (remainder n1 10) (remainder n2 10)))))]))\n  (digit_distance_helper n1 n2 0))\n",
    "  (define (digit_distance_nums-iter n1 n2 sum)\n    (if (zero? n1)\n        sum\n        (digit_distance_nums-iter (quotient n1 10) (quotient n2 10) (+ sum (abs (- (remainder n1 10) (remainder n2 10)))))))\n  (digit_distance_nums-iter n1 n2 0))\n",
    "  (let ([n1 (number->string n1)]\n        [n2 (number->string n2)])\n    (cond [(or (empty? n1) (empty? n2)) 0]\n          [else (+ (abs (- (string->number (first n1))\n                           (string->number (first n2))))\n                   (digit_distance_nums (rest n1) (rest n2)))])))\n",
    "  (define (helper n1 n2 acc)\n    (cond [(zero? n1) acc]\n          [(zero? n2) acc]\n          [(= (remainder n1 10) (remainder n2 10)) (helper (quotient n1 10) (quotient n2 10) acc)]\n          [else (helper (quotient n1 10) (quotient n2 10) (+ acc 1))]))\n  (helper n1 n2 0))\n",
    "  (define (digit_distance_nums_iter n1 n2 sum)\n    (if (zero? n1)\n        sum\n        (digit_distance_nums_iter (quotient n1 10) (quotient n2 10) (+ sum (abs (- (remainder n1 10) (remainder n2 10)))))))\n  (digit_distance_nums_iter n1 n2 0))\n",
    "  (define (digit_distance_helper n1 n2)\n    (if (or (zero? n1) (zero? n2))\n        0\n        (+ (abs (- (modulo n1 10) (modulo n2 10)))\n           (digit_distance_helper (quotient n1 10) (quotient n2 10)))))\n  (digit_distance_helper n1 n2))\n",
    "  (define (helper n1 n2)\n    (if (zero? n1)\n        0\n        (+ (abs (- (modulo n1 10) (modulo n2 10)))\n           (helper (quotient n1 10) (quotient n2 10)))))\n  (helper n1 n2))\n"
  ]
}