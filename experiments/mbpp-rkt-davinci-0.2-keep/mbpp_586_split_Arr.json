{
  "name": "mbpp_586_split_Arr",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Write a python function to split a list at the nth eelment and add the first part to the end.\n(define (split_Arr l n)\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_586_split_Arr.py",
  "prompt_terminology": "verbatim",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate split_Arr))\n    (check-equal? (candidate (list 12 10 5 6 52 36) 2) (list 5 6 52 36 12 10))\n    (check-equal? (candidate (list 1 2 3 4) 1) (list 2 3 4 1))\n    (check-equal? (candidate (list 0 1 2 3 4 5 6 7) 3) (list 3 4 5 6 7 0 1 2))\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (define (split_Arr_helper l n acc)\n    (if (= n 0)\n        (append (reverse acc) l)\n        (split_Arr_helper (cdr l) (- n 1) (cons (car l) acc))))\n  (split_Arr_helper l n '()))\n",
    "  (if (equal? n 0)\n      (append (cdr l) (list (car l)))\n      (append (cdr l) (list (car l)) (split_Arr (cdr l) (- n 1)))))\n",
    "  (if (zero? n)\n      (append (cdr l) (list (car l)))\n      (append (cdr l) (list (car l)))))\n",
    "  (if (= n 0)\n      (append (cdr l) (list (car l)))\n      (append (cdr l) (list (car l)) (split_Arr (cdr l) (- n 1)))))\n",
    "  (append (cdr (drop l n)) (take l n)))\n",
    "  (if (zero? n)\n      (append (cdr l) (list (car l)))\n      (cons (car l) (split_Arr (cdr l) (- n 1)))))\n",
    "  (define (split_Arr_helper l n acc)\n    (if (zero? n)\n        (append acc (cdr l))\n        (split_Arr_helper (cdr l) (- n 1) (append acc (list (car l))))))\n  (split_Arr_helper l n '()))\n",
    "  (cond\n    [(empty? l) empty]\n    [(= n 0) (append (rest l) (list (first l)))]\n    [else (cons (first l) (split_Arr (rest l) (- n 1)))]))\n",
    "  (cond\n    [(= n 0) (append (cdr l) (list (car l)))]\n    [else (cons (car l) (split_Arr (cdr l) (- n 1)))]))\n",
    "  (if (empty? l)\n      '()\n      (if (= n 0)\n          (append (rest l) (list (first l)))\n          (cons (first l) (split_Arr (rest l) (- n 1))))))\n",
    "  (if (zero? n)\n      (append (cdr l) (list (car l)))\n      (append (cdr l) (list (car l)))))\n",
    "  (define (split_Arr_h l n)\n    (if (zero? n)\n        (list (reverse l))\n        (split_Arr_h (cdr l) (- n 1))))\n  (append (split_Arr_h l n) (list (reverse (split_Arr_h l n)))))\n",
    "  (if (zero? n)\n      (append (cdr l) (list (car l)))\n      (cons (car l) (split_Arr (cdr l) (- n 1)))))\n",
    "  (if (null? l)\n      '()\n      (if (= n 1)\n          (append (cdr l) (list (car l)))\n          (cons (car l) (split_Arr (cdr l) (- n 1))))))\n",
    "  (append (cdr (cdr (cdr (cdr (cdr l))))) (list (car (cdr (cdr (cdr (cdr l)))))) (list (car (cdr (cdr (cdr l))))) (list (car (cdr (cdr l)))) (list (car (cdr l)))))\n",
    "  (append (rest (drop l n)) (take l n)))\n",
    "  (if (empty? l)\n      '()\n      (if (= n 0)\n          (append (cdr l) (list (car l)))\n          (cons (car l) (split_Arr (cdr l) (- n 1))))))\n",
    "  (if (eq? n 0)\n      (append (cdr l) (list (car l)))\n      (append (cdr l) (list (car l)))))\n",
    "  (append (cdr (drop l n)) (take l n)))\n",
    "  (if (zero? n)\n      (append (cdr l) (list (car l)))\n      (cons (car l) (split_Arr (cdr l) (- n 1)))))\n",
    "  (let ([l1 (take l n)]\n        [l2 (drop l n)])\n    (append l2 l1)))\n",
    "  (cond ((= n 0) (append (cdr l) (list (car l))))\n        ((= n (length l)) l)\n        (else (append (cdr l) (list (car l))))))\n",
    "  (append (cdr (drop l n)) (take l n)))\n",
    "  (if (zero? n)\n      (append (cdr l) (list (car l)))\n      (cons (car l) (split_Arr (cdr l) (- n 1)))))\n",
    "  (if (= n 0)\n      (append (cdr l) (list (car l)))\n      (cons (car l) (split_Arr (cdr l) (- n 1)))))\n",
    "  (if (zero? n)\n      (append (cdr l) (list (car l)))\n      (cons (car l) (split_Arr (cdr l) (sub1 n)))))\n",
    "  (append (cdr (take l n)) (take l n)))\n",
    "  (if (zero? n)\n      (append (cdr l) (list (car l)))\n      (cons (car l) (split_Arr (cdr l) (- n 1)))))\n",
    "  (append (rest (append l (list (first l)))) (take l n)))\n",
    "  (if (zero? n)\n      (append (cdr l) (list (car l)))\n      (cons (car l) (split_Arr (cdr l) (- n 1)))))\n",
    "  (cond [(empty? l) empty]\n        [(= n 0) (append (rest l) (list (first l)))]\n        [else (cons (first l) (split_Arr (rest l) (- n 1)))]))\n",
    "  (if (empty? l)\n      '()\n      (if (= n 0)\n          (append (cdr l) (list (car l)))\n          (cons (car l) (split_Arr (cdr l) (- n 1))))))\n",
    "  (if (equal? n 0)\n      (append (cdr l) (list (car l)))\n      (append (cdr l) (list (car l)) (split_Arr (cdr l) (- n 1)))))\n",
    "  (define (split_Arr_helper l n acc)\n    (if (zero? n)\n        (append (reverse acc) l)\n        (split_Arr_helper (cdr l) (- n 1) (cons (car l) acc))))\n  (split_Arr_helper l n '()))\n",
    "  (if (empty? l)\n      '()\n      (if (= n 0)\n          (append (rest l) (list (first l)))\n          (cons (first l) (split_Arr (rest l) (- n 1))))))\n",
    "  (if (= n 0)\n      (append (cdr l) (list (car l)))\n      (append (cdr l) (list (car l)) (split_Arr (cdr l) (- n 1)))))\n",
    "  (if (zero? n)\n      (append (cdr l) (list (car l)))\n      (cons (car l) (split_Arr (cdr l) (sub1 n)))))\n",
    "  (append (cdr (drop l n)) (take l n)))\n",
    "  (append (cdr (drop l n)) (take l n)))\n",
    "  (append (cdr (drop l n)) (take l n)))\n",
    "  (define (split_Arr_helper l n)\n    (if (zero? n)\n        (cons (car l) '())\n        (cons (car l) (split_Arr_helper (cdr l) (- n 1)))))\n  (append (cdr (split_Arr_helper l n)) (list (car (split_Arr_helper l n)))))\n",
    "  (define (split_Arr_helper l n)\n    (if (= n 0)\n        (list l)\n        (cons (car l) (split_Arr_helper (cdr l) (- n 1)))))\n  (append (cdr (split_Arr_helper l n)) (list (car (split_Arr_helper l n)))))\n",
    "  (if (zero? n)\n      (append (cdr l) (list (car l)))\n      (cons (car l) (split_Arr (cdr l) (- n 1)))))\n",
    "  (define (split_Arr_helper l n result)\n    (if (= n 0)\n        (append result (cdr l))\n        (split_Arr_helper (cdr l) (- n 1) (append result (list (car l))))))\n  (split_Arr_helper l n '()))\n",
    "  (let ([l1 (take l n)]\n        [l2 (drop l n)])\n    (append l2 l1)))\n",
    "  (if (= n 0)\n      (append (cdr l) (list (car l)))\n      (append (cdr l) (list (car l)) (split_Arr (cdr l) (- n 1)))))\n",
    "  (if (zero? n)\n      (append (cdr l) (list (car l)))\n      (cons (car l) (split_Arr (cdr l) (- n 1)))))\n",
    "  (if (null? l)\n      '()\n      (if (= n 0)\n          (append (cdr l) (list (car l)))\n          (cons (car l) (split_Arr (cdr l) (- n 1))))))\n",
    "  (if (zero? n)\n      (append (cdr l) (list (car l)))\n      (cons (car l) (split_Arr (cdr l) (- n 1)))))\n",
    "  (if (equal? n 0)\n      (append (cdr l) (list (car l)))\n      (append (cdr l) (list (car l)) (split_Arr (cdr l) (- n 1)))))\n",
    "  (append (rest (take l n)) (take l n)))\n",
    "  (if (zero? n)\n      (append (cdr l) (list (car l)))\n      (cons (car l) (split_Arr (cdr l) (- n 1)))))\n",
    "  (if (null? l)\n      '()\n      (if (= n 0)\n          (append (cdr l) (list (car l)))\n          (cons (car l) (split_Arr (cdr l) (- n 1))))))\n",
    "  (if (zero? n)\n      (append (cdr l) (list (car l)))\n      (cons (car l) (split_Arr (cdr l) (- n 1)))))\n",
    "  (if (equal? n 0)\n      (append (cdr l) (list (car l)))\n      (append (cdr l) (list (car l)) (split_Arr (cdr l) (- n 1)))))\n",
    "  (define (split_Arr_helper l n)\n    (if (= n 0)\n        (cons (car l) '())\n        (cons (car l) (split_Arr_helper (cdr l) (- n 1)))))\n  (append (cdr (split_Arr_helper l n)) (list (car (split_Arr_helper l n)))))\n",
    "  (if (zero? n)\n      (append (cdr l) (list (car l)))\n      (cons (car l) (split_Arr (cdr l) (- n 1)))))\n",
    "  (if (zero? n)\n      (append l (list (car l)))\n      (append (cdr l) (list (car l)))))\n",
    "  (cond\n    [(empty? l) empty]\n    [(= n 0) (append (rest l) (list (first l)))]\n    [else (cons (first l) (split_Arr (rest l) (- n 1)))]))\n",
    "  (if (zero? n)\n      (append (cdr l) (list (car l)))\n      (append (cdr l) (list (car l)) (split_Arr (cdr l) (- n 1)))))\n",
    "  (if (zero? n)\n      (append (cdr l) (list (car l)))\n      (append (cdr l) (list (car l)) (split_Arr (cdr l) (- n 1)))))\n",
    "  (if (zero? n)\n      (append (cdr l) (list (car l)))\n      (cons (car l) (split_Arr (cdr l) (- n 1)))))\n",
    "  (if (zero? n)\n      (append (cdr l) (list (car l)))\n      (cons (car l) (split_Arr (cdr l) (- n 1)))))\n",
    "  (append (cdr (append (take l n) (list (car (drop l n))))) (take l n)))\n",
    "  (if (null? l)\n      '()\n      (if (= n 0)\n          (append (cdr l) (list (car l)))\n          (cons (car l) (split_Arr (cdr l) (- n 1))))))\n",
    "  (if (zero? n)\n      (append (cdr l) (list (car l)))\n      (cons (car l) (split_Arr (cdr l) (sub1 n)))))\n",
    "  (if (zero? n)\n      (append (cdr l) (list (car l)))\n      (cons (car l) (split_Arr (cdr l) (sub1 n)))))\n",
    "  (cond\n    [(empty? l) empty]\n    [(= n 0) (append (rest l) (list (first l)))]\n    [else (cons (first l) (split_Arr (rest l) (- n 1)))]))\n",
    "  (cond [(empty? l) empty]\n        [(= n 0) (append (rest l) (list (first l)))]\n        [else (cons (first l) (split_Arr (rest l) (- n 1)))]))\n",
    "  (if (zero? n)\n      (append (cdr l) (list (car l)))\n      (cons (car l) (split_Arr (cdr l) (- n 1)))))\n",
    "  (append (cdr (append l (list (car l)))) (list (car (append l (list (car l)))))))\n",
    "  (if (zero? n)\n      (append (cdr l) (list (car l)))\n      (cons (car l) (split_Arr (cdr l) (- n 1)))))\n",
    "  (if (null? l)\n      '()\n      (if (= n 0)\n          (append (cdr l) (list (car l)))\n          (cons (car l) (split_Arr (cdr l) (- n 1))))))\n",
    "  (if (null? l)\n      '()\n      (append (cdr (split-list l n)) (list (car (split-list l n))))))\n",
    "  (if (zero? n)\n      (append (cdr l) (list (car l)))\n      (append (cdr l) (list (car l)))))\n",
    "  (append (cdr (drop l n)) (take l n)))\n",
    "  (if (null? l)\n      '()\n      (if (= n 0)\n          (append (cdr l) (list (car l)))\n          (cons (car l) (split_Arr (cdr l) (- n 1))))))\n",
    "  (if (zero? n)\n      (append (cdr l) (list (car l)))\n      (cons (car l) (split_Arr (cdr l) (sub1 n)))))\n",
    "  (if (equal? n 0)\n      (append (cdr l) (list (car l)))\n      (cons (car l) (split_Arr (cdr l) (- n 1)))))\n",
    "  (if (= n 0)\n      (append (cdr l) (list (car l)))\n      (cons (car l) (split_Arr (cdr l) (- n 1)))))\n",
    "  (if (empty? l)\n      '()\n      (if (= n 0)\n          (append (cdr l) (list (car l)))\n          (cons (car l) (split_Arr (cdr l) (- n 1))))))\n",
    "  (append (cdr (append l (take l n))) (take l n)))\n",
    "  (define (split_Arr_help l n acc)\n    (if (zero? n)\n        (append acc (cdr l))\n        (split_Arr_help (cdr l) (- n 1) (append acc (list (car l))))))\n  (split_Arr_help l n '()))\n",
    "  (cond [(empty? l) empty]\n        [(= n 0) (append l empty)]\n        [else (cons (first l) (split_Arr (rest l) (- n 1)))]))\n",
    "  (cond\n    [(= n 0) (append (cdr l) (list (car l)))]\n    [else (append (list (car l)) (split_Arr (cdr l) (- n 1)))]))\n",
    "  (if (empty? l)\n      '()\n      (if (= n 0)\n          (append (rest l) (list (first l)))\n          (cons (first l) (split_Arr (rest l) (- n 1))))))\n",
    "  (append (cdr (drop l n)) (take l n)))\n",
    "  (if (null? l)\n      '()\n      (if (= n 0)\n          (append (cdr l) (list (car l)))\n          (cons (car l) (split_Arr (cdr l) (- n 1))))))\n",
    "  (append (cdr (drop l n)) (take l n)))\n",
    "  (if (zero? n)\n      (append (cdr l) (list (car l)))\n      (cons (car l) (split_Arr (cdr l) (- n 1)))))\n",
    "  (define (split_Arr_helper l n)\n    (if (= n 0)\n        (list (car l) (cdr l))\n        (split_Arr_helper (cdr l) (- n 1))))\n  (define (append_Arr l1 l2)\n    (if (null? l1)\n        l2\n        (cons (car l1) (append_Arr (cdr l1) l2))))\n  (define (split_Arr_helper2 l n)\n    (if (= n 0)\n        (list (car l) (cdr l))\n        (split_Arr_helper2 (cdr l) (- n 1))))\n  (define (append_Arr2 l1 l2)\n    (if (null? l1)\n        l2\n        (cons (car l1) (append_Arr2 (cdr l1) l2))))\n  (append_Arr (cdr (split_Arr_helper l n)) (car (split_Arr_helper2 l n))))\n",
    "  (append (cdr (drop l n)) (take l n)))\n",
    "  (if (zero? n)\n      (append (cdr l) (list (car l)))\n      (cons (car l) (split_Arr (cdr l) (- n 1)))))\n",
    "  (if (zero? n)\n      (append (cdr l) (list (car l)))\n      (cons (car l) (split_Arr (cdr l) (- n 1)))))\n",
    "  (if (equal? n 0)\n      (append (cdr l) (list (car l)))\n      (append (cdr l) (list (car l)) (split_Arr (cdr l) (- n 1)))))\n",
    "  (if (empty? l)\n      '()\n      (if (= n 0)\n          (append (rest l) (list (first l)))\n          (cons (first l) (split_Arr (rest l) (- n 1))))))\n",
    "  (define (split_Arr_helper l n)\n    (if (= n 0)\n        (list (list (car l)) (cdr l))\n        (let* ((splitted (split_Arr_helper (cdr l) (- n 1)))\n               (first (car splitted))\n               (second (cadr splitted)))\n          (list (cons (car l) first) second))))\n  (let* ((splitted (split_Arr_helper l n))\n         (first (car splitted))\n         (second (cadr splitted)))\n    (append second first)))\n",
    "  (if (empty? l)\n      '()\n      (append (drop l n) (take l n))))\n",
    "  (if (zero? n)\n      (append l (list (car l)))\n      (split_Arr (cdr l) (- n 1))))\n",
    "  (if (zero? n)\n      (append (cdr l) (list (car l)))\n      (cons (car l) (split_Arr (cdr l) (- n 1)))))\n",
    "  (cond [(empty? l) empty]\n        [(= n 0) (append l empty)]\n        [else (cons (first l) (split_Arr (rest l) (- n 1)))]))\n",
    "  (if (empty? l)\n      '()\n      (if (= n 0)\n          (append (cdr l) (list (car l)))\n          (cons (car l) (split_Arr (cdr l) (- n 1))))))\n",
    "  (define (split_Arr_helper l n acc)\n    (cond\n      [(= n 0) (append (reverse acc) l)]\n      [else (split_Arr_helper (cdr l) (- n 1) (cons (car l) acc))]))\n  (split_Arr_helper l n '()))\n",
    "  (define (split_Arr_helper l n acc)\n    (if (or (null? l) (= n 0))\n        (append acc l)\n        (split_Arr_helper (cdr l) (- n 1) (cons (car l) acc))))\n  (split_Arr_helper l n '()))\n",
    "  (if (zero? n)\n      (append (cdr l) (list (car l)))\n      (split_Arr (cdr l) (- n 1))))\n",
    "  (if (equal? n 0)\n      (append (cdr l) (list (car l)))\n      (append (cdr l) (list (car l)) (split_Arr (cdr l) (- n 1)))))\n",
    "  (define (split_Arr_helper l n)\n    (if (= n 0)\n        (list (car l) '())\n        (let ((temp (split_Arr_helper (cdr l) (- n 1))))\n          (list (car temp) (cons (car l) (cadr temp))))))\n  (let ((temp (split_Arr_helper l n)))\n    (append (cadr temp) (car temp))))\n",
    "  (if (zero? n)\n      (append (cdr l) (list (car l)))\n      (cons (car l) (split_Arr (cdr l) (- n 1)))))\n",
    "  (define (split_Arr_helper l n)\n    (if (= n 0)\n        (list l)\n        (cons (car l) (split_Arr_helper (cdr l) (- n 1)))))\n  (append (cdr (split_Arr_helper l n)) (list (car (split_Arr_helper l n)))))\n",
    "  (define (helper l n)\n    (if (= n 0)\n        (list (car l))\n        (cons (car l) (helper (cdr l) (- n 1)))))\n  (append (cdr (helper l n)) (helper l n)))\n",
    "  (append (cdr (drop l n)) (take l n)))\n",
    "  (append (cdr (cdr l)) (list (car (cdr l))) (list (car l))))\n",
    "  (if (null? l)\n      '()\n      (if (= n 0)\n          (append (cdr l) (list (car l)))\n          (cons (car l) (split_Arr (cdr l) (- n 1))))))\n",
    "  (if (null? l)\n      '()\n      (if (= n 0)\n          (append (cdr l) (list (car l)))\n          (cons (car l) (split_Arr (cdr l) (- n 1))))))\n",
    "  (if (zero? n)\n      (append (cdr l) (list (car l)))\n      (cons (car l) (split_Arr (cdr l) (sub1 n)))))\n",
    "  (let ([first (take l n)]\n        [second (drop l n)])\n    (append second first)))\n",
    "  (if (zero? n)\n      (append (cdr l) (list (car l)))\n      (append (cdr l) (list (car l)))))\n",
    "  (if (zero? n)\n      (append (cdr l) (list (car l)))\n      (cons (car l) (split_Arr (cdr l) (- n 1)))))\n",
    "  (if (zero? n)\n      (append (cdr l) (list (car l)))\n      (cons (car l) (split_Arr (cdr l) (- n 1)))))\n",
    "  (if (eq? n 0)\n      (append (cdr l) (list (car l)))\n      (append (cdr l) (list (car l)))))\n",
    "  (if (zero? n)\n      (append (cdr l) (list (car l)))\n      (cons (car l) (split_Arr (cdr l) (- n 1)))))\n",
    "  (if (zero? n)\n      (append (cdr l) (list (car l)))\n      (append (cdr l) (list (car l)))))\n",
    "  (append (cdr (cdr (cdr l))) (list (car (cdr l))) (list (car l))))\n",
    "  (append (cdr (drop l n)) (take l n)))\n",
    "  (if (zero? n)\n      (append (cdr l) (list (car l)))\n      (cons (car l) (split_Arr (cdr l) (- n 1)))))\n",
    "  (let ([l1 (take l n)]\n        [l2 (drop l n)])\n    (append l2 l1)))\n",
    "  (append (cdr (drop l n)) (take l n)))\n",
    "  (append (cdr (drop l n)) (take l n)))\n",
    "  (if (null? l)\n      '()\n      (if (= n 0)\n          (append (cdr l) (list (car l)))\n          (cons (car l) (split_Arr (cdr l) (- n 1))))))\n",
    "  (append (cdr (drop l n)) (take l n)))\n",
    "  (append (cdr (drop l n)) (take l n)))\n",
    "  (define (helper l n)\n    (if (zero? n)\n        (list (reverse l))\n        (helper (cdr l) (- n 1))))\n  (append (cdr (helper l n)) (car (helper l n))))\n",
    "  (cond\n    [(empty? l) empty]\n    [(= n 0) (append (rest l) (list (first l)))]\n    [else (cons (first l) (split_Arr (rest l) (- n 1)))]))\n",
    "  (if (zero? n)\n      (append (cdr l) (list (car l)))\n      (append (cdr l) (list (car l)))))\n",
    "  (cond\n    [(empty? l) empty]\n    [(= n 0) (append l empty)]\n    [else (cons (first l) (split_Arr (rest l) (- n 1)))]))\n",
    "  (if (zero? n)\n      (append (cdr l) (list (car l)))\n      (cons (car l) (split_Arr (cdr l) (- n 1)))))\n",
    "  (if (zero? n)\n      (append (cdr l) (list (car l)))\n      (cons (car l) (split_Arr (cdr l) (- n 1)))))\n",
    "  (if (zero? n)\n      (append (cdr l) (list (car l)))\n      (cons (car l) (split_Arr (cdr l) (sub1 n)))))\n",
    "  (let ([first (take l n)]\n        [second (drop l n)])\n    (append second first)))\n",
    "  (if (empty? l)\n      '()\n      (if (= n 0)\n          (append (rest l) (list (first l)))\n          (cons (first l) (split_Arr (rest l) (- n 1))))))\n",
    "  (cond\n    [(= n 0) l]\n    [(= n (length l)) l]\n    [else (append (cdr l) (list (car l)))]))\n",
    "  (append (cdr (drop l n)) (take l n)))\n",
    "  (if (empty? l)\n      '()\n      (if (= n 0)\n          (append (rest l) (list (first l)))\n          (cons (first l) (split_Arr (rest l) (- n 1))))))\n",
    "  (let ([l1 (take l n)]\n        [l2 (drop l n)])\n    (append l2 l1)))\n",
    "  (if (zero? n)\n      (append (cdr l) (list (car l)))\n      (cons (car l) (split_Arr (cdr l) (- n 1)))))\n",
    "  (define (split_Arr_helper l n)\n    (if (= n 0)\n        (list (reverse l))\n        (split_Arr_helper (cdr l) (- n 1))))\n  (append (cdr (split_Arr_helper l n)) (list (car (split_Arr_helper l n)))))\n",
    "  (append (cdr (drop l n)) (take l n)))\n",
    "  (cond\n    [(= n 0) l]\n    [else (append (cdr l) (list (car l)))]))\n",
    "  (if (equal? n 0)\n      (append (cdr l) (list (car l)))\n      (append (cdr l) (list (car l)) (split_Arr (cdr l) (- n 1)))))\n",
    "  (define (split_Arr_helper l n acc)\n    (if (or (null? l) (= n 0))\n        (append acc l)\n        (split_Arr_helper (cdr l) (- n 1) (cons (car l) acc))))\n  (split_Arr_helper l n '()))\n",
    "  (if (zero? n)\n      (append (cdr l) (list (car l)))\n      (cons (car l) (split_Arr (cdr l) (- n 1)))))\n",
    "  (cond\n    [(empty? l) empty]\n    [(= n 0) (append l empty)]\n    [else (cons (first l) (split_Arr (rest l) (- n 1)))]))\n",
    "  (if (equal? n 0)\n      (append (cdr l) (list (car l)))\n      (append (cdr l) (list (car l)) (split_Arr (cdr l) (- n 1)))))\n",
    "  (cond\n    [(empty? l) empty]\n    [(= n 0) (append l empty)]\n    [else (cons (first l) (split_Arr (rest l) (- n 1)))]))\n",
    "  (if (zero? n)\n      (append (cdr l) (list (car l)))\n      (cons (car l) (split_Arr (cdr l) (- n 1)))))\n",
    "  (if (= n 0)\n      (append (cdr l) (list (car l)))\n      (append (cdr l) (list (car l)) (split_Arr (cdr l) (- n 1)))))\n",
    "  (if (= n 0)\n      (append (cdr l) (list (car l)))\n      (append (cdr l) (list (car l)) (split_Arr (cdr l) (- n 1)))))\n",
    "  (if (null? l)\n      '()\n      (if (= n 0)\n          (append (cdr l) (list (car l)))\n          (cons (car l) (split_Arr (cdr l) (- n 1))))))\n",
    "  (if (zero? n)\n      (append (cdr l) (list (car l)))\n      (cons (car l) (split_Arr (cdr l) (- n 1)))))\n",
    "  (append (cdr (drop l n)) (take l n)))\n",
    "  (append (cdr (drop l n)) (take l n)))\n",
    "  (if (zero? n)\n      (append (cdr l) (list (car l)))\n      (cons (car l) (split_Arr (cdr l) (- n 1)))))\n",
    "  (if (zero? n)\n      (append (cdr l) (list (car l)))\n      (cons (car l) (split_Arr (cdr l) (- n 1)))))\n",
    "  (if (empty? l)\n      '()\n      (if (= n 0)\n          (append (cdr l) (list (car l)))\n          (cons (car l) (split_Arr (cdr l) (- n 1))))))\n",
    "  (append (cdr (cdr (cdr l))) (list (car (cdr l))) (list (car l))))\n",
    "  (if (empty? l)\n      '()\n      (if (= n 0)\n          (append (rest l) (list (first l)))\n          (cons (first l) (split_Arr (rest l) (- n 1))))))\n",
    "  (define (split_Arr_helper l n)\n    (if (zero? n)\n        (cons (car l) '())\n        (cons (car l) (split_Arr_helper (cdr l) (- n 1)))))\n  (append (split_Arr_helper l n) (cdr (split_Arr_helper l n))))\n",
    "  (define (helper l n)\n    (if (= n 0)\n        (list (reverse l))\n        (helper (cdr l) (- n 1))))\n  (append (cdr (helper l n)) (list (car (helper l n)))))\n",
    "  (if (zero? n)\n      (append (cdr l) (list (car l)))\n      (cons (car l) (split_Arr (cdr l) (- n 1)))))\n",
    "  (cond\n    [(empty? l) empty]\n    [(= n 0) (append (rest l) (list (first l)))]\n    [else (cons (first l) (split_Arr (rest l) (- n 1)))]))\n",
    "  (if (zero? n)\n      (append (cdr l) (list (car l)))\n      (cons (car l) (split_Arr (cdr l) (- n 1)))))\n",
    "  (define (split_Arr_helper l n result)\n    (cond ((= n 0) (append result (cdr l)))\n          (else (split_Arr_helper (cdr l) (- n 1) (append result (list (car l)))))))\n  (split_Arr_helper l n '()))\n",
    "  (cond\n    [(= n 0) (append (cdr l) (list (car l)))]\n    [else (cons (car l) (split_Arr (cdr l) (- n 1)))]))\n",
    "  (append (cdr (take l n)) (take l n)))\n",
    "  (cond\n    [(empty? l) empty]\n    [(= n 0) (append l empty)]\n    [else (cons (first l) (split_Arr (rest l) (- n 1)))]))\n",
    "  (append (cdr (append (take l n) (list (car (take l n))))) (take l (- n 1))))\n",
    "  (append (cdr (drop l n)) (take l n)))\n",
    "  (if (null? l)\n      '()\n      (if (= n 0)\n          (append (cdr l) (list (car l)))\n          (cons (car l) (split_Arr (cdr l) (- n 1))))))\n",
    "  (if (zero? n)\n      (append (cdr l) (list (car l)))\n      (append (cdr l) (list (car l)) (split_Arr (cdr l) (- n 1)))))\n",
    "  (if (zero? n)\n      (append l (list (car l)))\n      (split_Arr (cdr l) (- n 1))))\n",
    "  (append (cdr (drop l n)) (take l n)))\n",
    "  (if (= n 0)\n      (append (cdr l) (list (car l)))\n      (append (cdr l) (list (car l)) (split_Arr (cdr l) (- n 1)))))\n",
    "  (append (cdr (append (take l n) (list (car (take l n))))) (take l n)))\n",
    "  (append (cdr (drop l n)) (take l n)))\n",
    "  (if (= n 0)\n      (append (cdr l) (list (car l)))\n      (cons (car l) (split_Arr (cdr l) (- n 1)))))\n",
    "  (define (split_Arr_helper l n)\n    (if (= n 0)\n        (list (cdr l) (car l))\n        (let* ((res (split_Arr_helper (cdr l) (- n 1)))\n               (lst (car res))\n               (last (cadr res)))\n          (list (cons last lst) (car l)))))\n  (car (split_Arr_helper l n)))\n",
    "  (if (zero? n)\n      (append (cdr l) (list (car l)))\n      (cons (car l) (split_Arr (cdr l) (- n 1)))))\n",
    "  (define (split_Arr_helper l n acc)\n    (if (= n 0)\n        (append acc (cdr l))\n        (split_Arr_helper (cdr l) (- n 1) (append acc (list (car l))))))\n  (split_Arr_helper l n '()))\n",
    "  (if (empty? l)\n      '()\n      (if (= n 0)\n          (append (cdr l) (list (car l)))\n          (cons (car l) (split_Arr (cdr l) (- n 1))))))\n",
    "  (append (cdr (drop l n)) (take l n)))\n",
    "  (let ([l1 (take l n)]\n        [l2 (drop l n)])\n    (append l2 l1)))\n",
    "  (if (zero? n)\n      (append (cdr l) (list (car l)))\n      (cons (car l) (split_Arr (cdr l) (- n 1)))))\n",
    "  (if (empty? l)\n      '()\n      (if (= n 0)\n          (append (rest l) (list (first l)))\n          (cons (first l) (split_Arr (rest l) (- n 1))))))\n",
    "  (if (zero? n)\n      (append (cdr l) (list (car l)))\n      (cons (car l) (split_Arr (cdr l) (- n 1)))))\n",
    "  (append (cdr (drop l n)) (take l n)))\n",
    "  (cond\n    [(empty? l) empty]\n    [(= n 0) (append l empty)]\n    [else (cons (first l) (split_Arr (rest l) (- n 1)))]))\n",
    "  (if (zero? n)\n      (append (cdr l) (list (car l)))\n      (cons (car l) (split_Arr (cdr l) (sub1 n)))))\n",
    "  (if (zero? n)\n      (append (cdr l) (list (car l)))\n      (cons (car l) (split_Arr (cdr l) (- n 1)))))\n",
    "  (if (zero? n)\n      (append (cdr l) (list (car l)))\n      (cons (car l) (split_Arr (cdr l) (sub1 n)))))\n",
    "  (if (eq? n 0)\n      (append (cdr l) (list (car l)))\n      (append (cdr l) (list (car l)) (split_Arr (cdr l) (- n 1)))))\n"
  ]
}