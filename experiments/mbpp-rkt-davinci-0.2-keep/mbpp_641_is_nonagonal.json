{
  "name": "mbpp_641_is_nonagonal",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Write a function to find the nth nonagonal number.\n(define (is_nonagonal n)\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_641_is_nonagonal.py",
  "prompt_terminology": "verbatim",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_nonagonal))\n    (check-equal? (candidate 10) 325)\n    (check-equal? (candidate 15) 750)\n    (check-equal? (candidate 18) 1089)\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (let* ([n-sqrt (sqrt (+ (* 8 n) 1))]\n         [n-sqrt-int (floor n-sqrt)])\n    (and (= n-sqrt-int n-sqrt)\n         (= n-sqrt (modulo n-sqrt 2)))))\n",
    "  (define (is_nonagonal-iter n i)\n    (if (= n (+ i (* i 2)))\n        #t\n        (is_nonagonal-iter n (+ i 1))))\n  (is_nonagonal-iter n 1))\n",
    "  (let loop ([i 1])\n    (if (= i n)\n        #t\n        (if (is_nonagonal (+ i 1))\n            #f\n            (let ([d (- n i)])\n              (if (= d (+ i 1))\n                  #t\n                  (loop (+ i 1))))))))\n",
    "  (let loop ([i 1])\n    (if (= i n)\n        #t\n        (if (is_triangular (+ i 1))\n            (loop (+ i 1))\n            #f))))\n",
    "  (and (integer? n)\n       (integer? (/ (- (sqrt (+ (* 8 n) 1)) 1) 2))))\n",
    "  (and (integer? n)\n       (zero? (modulo n 2))))\n",
    "  (let loop ((n n) (i 1))\n    (if (= n (+ i (* i 2)))\n        #t\n        (loop n (+ i 1)))))\n",
    "  (let loop ((i 1) (j 1))\n    (cond ((= n i) #t)\n          ((&gt; n i) (loop (+ i j) (+ j 1)))\n          (else #f))))\n",
    "  (let loop ((i 1))\n    (if (= n (* i (+ i 1) (/ (+ i 1) 2)))\n        #t\n        (loop (+ i 1)))))\n",
    "  (let loop ([n n] [i 1])\n    (cond [(= n (quotient (* i (- i 1)) 2)) #t]\n          [(> n (quotient (* i (- i 1)) 2)) (loop (- n (quotient (* i (- i 1)) 2)) (+ i 1))]\n          [else #f])))\n",
    "  (let ((n-1 (- n 1)))\n    (or (and (integer? (/ n-1 3))\n             (integer? (/ n-1 2)))\n        (and (integer? (/ n-1 3))\n             (integer? (/ n-1 2)))\n        (and (integer? (/ n-1 3))\n             (integer? (/ n-1 2))))))\n",
    "  (let loop ((n n) (i 1))\n    (if (= n 0)\n        #t\n        (if (&lt; n 0)\n            #f\n            (loop (- n i) (+ i 1))))))\n",
    "  (equal? n (nonagonal (nonagonal-index n))))\n",
    "  (letrec ([n-1 (- n 1)]\n           [n-2 (- n 2)]\n           [n-3 (- n 3)])\n    (and (integer? n-1)\n         (integer? n-2)\n         (integer? n-3))))\n",
    "  (let ((n (sqrt (+ (* 8 n) 1))))\n    (and (integer? n)\n         (not (zero? (modulo n 2))))))\n",
    "  (let loop ([i 1] [j 1])\n    (cond\n      [(= n (+ i j)) #t]\n      [(> n (+ i j)) (loop (+ i 1) j)]\n      [else (loop i (+ j 1))])))\n",
    "  (and (integer? n)\n       (integer? (sqrt (+ (* 8 n) 1)))))\n",
    "  (and (integer? n)\n       (or (zero? n)\n           (and (positive? n)\n                (integer? (/ (- 8 (* 3 n)) 2))))))\n",
    "  (let loop ((i 1) (j 1))\n    (if (= n (+ i j))\n        #t\n        (if (&gt; n (+ i j))\n            (loop (+ i 1) j)\n            (loop i (+ j 1))))))\n",
    "  (let loop ([i 1] [j 0])\n    (cond\n      [(= i n) #t]\n      [(= j n) (loop (+ i 1) 0)]\n      [else (loop i (+ j 1))])))\n"
  ]
}