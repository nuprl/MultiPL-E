{
  "name": "mbpp_99_decimal_to_binary",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Write a function to convert the given decimal number to its binary equivalent, represented as a string with no leading zeros.\n(define (decimal_to_binary n)\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_99_decimal_to_binary.py",
  "prompt_terminology": "verbatim",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate decimal_to_binary))\n    (check-equal? (candidate 8) \"1000\")\n    (check-equal? (candidate 18) \"10010\")\n    (check-equal? (candidate 7) \"111\")\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (cond\n    [(= n 0) \"\"]\n    [else (string-append (decimal_to_binary (quotient n 2)) (number->string (remainder n 2)))]))\n",
    "  (define (helper n)\n    (cond\n      [(= n 0) '()]\n      [else (cons (remainder n 2) (helper (quotient n 2)))]))\n  (string-join (reverse (helper n)) \"\"))\n",
    "  (if (= n 0)\n      \"\"\n      (string-append (decimal_to_binary (quotient n 2)) (number->string (remainder n 2)))))\n",
    "  (cond [(= n 0) \"\"]\n        [(= n 1) \"1\"]\n        [else (string-append (decimal_to_binary (quotient n 2))\n                             (number->string (remainder n 2)))]))\n",
    "  (cond\n    [(= n 0) \"\"]\n    [(= n 1) \"1\"]\n    [else (string-append (decimal_to_binary (quotient n 2)) (number->string (remainder n 2)))]))\n",
    "  (define (decimal_to_binary_iter n acc)\n    (if (zero? n)\n        acc\n        (decimal_to_binary_iter (quotient n 2) (string-append (number->string (remainder n 2)) acc))))\n  (decimal_to_binary_iter n \"\"))\n",
    "  (define (decimal_to_binary_iter n acc)\n    (cond ((= n 0) acc)\n          ((= (remainder n 2) 0) (decimal_to_binary_iter (/ n 2) (string-append \"0\" acc)))\n          (else (decimal_to_binary_iter (/ n 2) (string-append \"1\" acc)))))\n  (decimal_to_binary_iter n \"\"))\n",
    "  (cond [(zero? n) \"\"]\n        [else (append (decimal_to_binary (quotient n 2))\n                      (number->string (remainder n 2)))]))\n",
    "  (define (helper n)\n    (if (= n 0)\n        \"\"\n        (string-append (helper (quotient n 2)) (number->string (remainder n 2)))))\n  (helper n))\n",
    "  (let loop ([n n] [accumulator \"\"])\n    (cond [(zero? n) accumulator]\n          [else (loop (quotient n 2) (string (remainder n 2) accumulator))])))\n",
    "  (define (helper n)\n    (cond\n      [(= n 0) '()]\n      [else (cons (remainder n 2) (helper (quotient n 2)))]))\n  (string-join (reverse (helper n)) \"\"))\n",
    "  (define (helper n acc)\n    (if (= n 0)\n        acc\n        (helper (quotient n 2) (string (remainder n 2)))))\n  (helper n \"\"))\n",
    "  (cond\n    [(zero? n) \"\"]\n    [else\n     (string-append\n      (decimal_to_binary (quotient n 2))\n      (number->string (remainder n 2)))]))\n",
    "  (define (decimal_to_binary_helper n)\n    (if (= n 0)\n        '()\n        (cons (remainder n 2) (decimal_to_binary_helper (quotient n 2)))))\n  (list->string (reverse (decimal_to_binary_helper n))))\n",
    "  (define (helper n)\n    (cond [(= n 0) '()]\n          [else (cons (remainder n 2) (helper (quotient n 2)))]))\n  (string-join (reverse (helper n)) \"\"))\n",
    "  (define (decimal_to_binary_iter n acc)\n    (if (= n 0)\n        acc\n        (decimal_to_binary_iter (/ n 2) (string-append (number->string (remainder n 2)) acc))))\n  (decimal_to_binary_iter n \"\"))\n",
    "  (define (decimal_to_binary_iter n acc)\n    (if (= n 0)\n        acc\n        (decimal_to_binary_iter (/ n 2) (string-append (number->string (remainder n 2)) acc))))\n  (decimal_to_binary_iter n \"\"))\n",
    "  (define (helper n)\n    (cond\n      [(= n 0) '()]\n      [else (cons (remainder n 2) (helper (quotient n 2)))]))\n  (string-join (reverse (helper n)) \"\"))\n",
    "  (define (helper n)\n    (if (= n 0)\n        '()\n        (cons (remainder n 2) (helper (quotient n 2)))))\n  (apply string (reverse (helper n))))\n",
    "  (define (helper n)\n    (cond\n      [(zero? n) '()]\n      [else (cons (remainder n 2) (helper (quotient n 2)))]))\n  (string-join (reverse (helper n)) \"\"))\n"
  ]
}