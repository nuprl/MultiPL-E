{
  "name": "mbpp_472_check_Consecutive",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Write a python function to check whether the given list contains consecutive numbers or not.\n(define (check_Consecutive l)\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_472_check_Consecutive.py",
  "prompt_terminology": "verbatim",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate check_Consecutive))\n    (check-equal? (candidate (list 1 2 3 4 5)) #t)\n    (check-equal? (candidate (list 1 2 3 5 6)) #f)\n    (check-equal? (candidate (list 1 2 1)) #f)\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (let loop ([l l] [prev (car l)])\n    (cond [(null? l) #t]\n          [(= (car l) (+ prev 1)) (loop (cdr l) (car l))]\n          [else #f])))\n",
    "  (let loop ([l l] [prev (car l)])\n    (if (null? l)\n        #t\n        (if (= (car l) (+ prev 1))\n            (loop (cdr l) (car l))\n            #f))))\n",
    "  (let loop ([l l] [prev (car l)] [res #t])\n    (cond [(empty? l) res]\n          [(= (car l) (+ prev 1)) (loop (cdr l) (car l) res)]\n          [else (loop (cdr l) (car l) #f)])))\n",
    "  (cond\n    [(empty? l) #t]\n    [(= (length l) 1) #t]\n    [(= (length l) 2) (if (= (first l) (second l)) #f #t)]\n    [else (if (= (- (first l) (second l)) (- (second l) (third l))) #f #t)]))\n",
    "  (let loop ([l l] [prev (car l)])\n    (cond\n      [(null? l) #t]\n      [(= (car l) (+ prev 1)) (loop (cdr l) (car l))]\n      [else #f])))\n",
    "  (let loop ([l l] [prev (car l)])\n    (cond [(null? l) #t]\n          [(= prev (car l)) (loop (cdr l) (car l))]\n          [else #f])))\n",
    "  (define (check_Consecutive_helper l)\n    (cond\n      [(empty? l) #t]\n      [(empty? (rest l)) #t]\n      [(= (first l) (- (second l) 1)) (check_Consecutive_helper (rest l))]\n      [else #f]))\n  (check_Consecutive_helper (sort l <)))\n",
    "  (define (check_Consecutive_helper l)\n    (if (null? l)\n        #t\n        (if (= (car l) (cadr l))\n            #f\n            (check_Consecutive_helper (cdr l)))))\n  (check_Consecutive_helper (sort l <)))\n",
    "  (define (check_Consecutive_helper l)\n    (cond ((null? l) #t)\n          ((null? (cdr l)) #t)\n          ((= (car l) (cadr l)) #f)\n          ((= (abs (- (car l) (cadr l))) 1) (check_Consecutive_helper (cdr l)))\n          (else #f)))\n  (check_Consecutive_helper (sort l <)))\n",
    "  (let loop ([l l] [prev (car l)])\n    (if (null? l)\n        #t\n        (if (= (car l) (+ prev 1))\n            (loop (cdr l) (car l))\n            #f))))\n",
    "  (define (check_Consecutive_helper l)\n    (if (null? (cdr l))\n        #t\n        (if (= (abs (- (car l) (cadr l))) 1)\n            (check_Consecutive_helper (cdr l))\n            #f)))\n  (check_Consecutive_helper (sort l <)))\n",
    "  (let loop ((l l) (prev (car l)))\n    (cond ((null? l) #t)\n          ((= (car l) (+ prev 1)) (loop (cdr l) (car l)))\n          (else #f))))\n",
    "  (let ((l (sort l <)))\n    (andmap (lambda (x y) (= (- y x) 1)) l (cdr l))))\n",
    "  (let ((l (sort l <)))\n    (and (= (length l) (length (remove-duplicates l)))\n         (= (length l) (- (car (last l)) (car l) 1)))))\n",
    "  (define (check_Consecutive_helper l)\n    (cond\n      [(empty? l) #t]\n      [(empty? (rest l)) #t]\n      [(= (first l) (first (rest l))) #f]\n      [else (check_Consecutive_helper (rest l))]))\n  (check_Consecutive_helper (sort l <)))\n",
    "  (define (check_Consecutive_helper l)\n    (cond ((null? l) #t)\n          ((null? (cdr l)) #t)\n          ((= (car l) (- (cadr l) 1)) (check_Consecutive_helper (cdr l)))\n          (else #f)))\n  (check_Consecutive_helper (sort l <)))\n",
    "  (define (check_Consecutive_helper l)\n    (cond\n      [(empty? l) #t]\n      [(empty? (rest l)) #t]\n      [(= (first l) (- (second l) 1)) (check_Consecutive_helper (rest l))]\n      [else #f]))\n  (check_Consecutive_helper (sort l <)))\n",
    "  (let loop ([l l] [prev (car l)])\n    (cond [(null? l) #t]\n          [(= (car l) (+ prev 1)) (loop (cdr l) (car l))]\n          [else #f])))\n",
    "  (let loop ([l l] [prev (car l)])\n    (cond [(null? l) #t]\n          [(= (car l) (+ prev 1)) (loop (cdr l) (car l))]\n          [else #f])))\n",
    "  (let loop ([l l] [prev (car l)])\n    (cond [(empty? l) #t]\n          [(= (car l) prev) (loop (cdr l) (car l))]\n          [else #f])))\n"
  ]
}