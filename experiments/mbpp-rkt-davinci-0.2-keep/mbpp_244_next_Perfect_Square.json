{
  "name": "mbpp_244_next_Perfect_Square",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Write a python function to find the next perfect square greater than a given number.\n(define (next_Perfect_Square N)\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_244_next_Perfect_Square.py",
  "prompt_terminology": "verbatim",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate next_Perfect_Square))\n    (check-equal? (candidate 35) 36)\n    (check-equal? (candidate 6) 9)\n    (check-equal? (candidate 9) 16)\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (cond\n    [(= (sqrt N) (floor (sqrt N))) (sqrt (+ N 1))]\n    [else (sqrt (+ N 1))]))\n",
    "  (define (is_Perfect_Square N)\n    (define (is_Perfect_Square_iter N i)\n      (if (= (* i i) N)\n          #t\n          (if (&lt; (* i i) N)\n              (is_Perfect_Square_iter N (+ i 1))\n              #f)))\n    (is_Perfect_Square_iter N 1))\n  (define (next_Perfect_Square_iter N i)\n    (if (is_Perfect_Square N)\n        N\n        (if (is_Perfect_Square (+ N i))\n            (+ N i)\n            (next_Perfect_Square_iter N (+ i 1)))))\n  (next_Perfect_Square_iter N 1))\n</code>\nI am not sure if this is the most efficient way to do this. I am also not sure if I am using the correct style.\n\n\nA:\n\nYour code is very good. I would only suggest a few minor changes.\n\nYou can use <code>let</code> to define local variables.\n<code>(let ([i 1])\n  (if (is_Perfect_Square N)\n      N\n      (if (is_Perfect_Square (+ N i))\n          (+ N i)\n          (next_Perfect_Square_iter N (+ i 1)))))\n</code>\nYou can use <code>and</code> to combine multiple conditions.\n<code>(let ([i 1])\n  (if (and (is_Perfect_Square N)\n           (is_Perfect_Square (+ N i)))\n      (+ N i)\n      (next_Perfect_Square_iter N (+ i 1))))\n</code>\nYou can use <code>cond</code> to combine multiple conditions.\n<code>(let ([i 1])\n  (cond\n    [(is_Perfect_Square N) N]\n    [(is_Perfect_Square (+ N i)) (+ N i)]\n    [else (next_Perfect_Square_iter N (+ i 1))]))\n</code>\nYou can use <code>cond</code> to combine multiple conditions.\n<code>(let ([i 1])\n  (cond\n    [(is_Perfect_Square N) N]\n    [(is_Perfect_Square (+ N i)) (+",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&gt; (* i i) N)\n        (* i i)\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (define (is_Perfect_Square N)\n    (define (is_Perfect_Square_iter N i)\n      (cond\n        [(= i N) #t]\n        [(&gt; i N) #f]\n        [else (is_Perfect_Square_iter N (+ i 1))]))\n    (is_Perfect_Square_iter N 1))\n  (define (next_Perfect_Square_iter N i)\n    (cond\n      [(is_Perfect_Square (+ N i)) (+ N i)]\n      [else (next_Perfect_Square_iter N (+ i 1))]))\n  (next_Perfect_Square_iter N 1))\n",
    "  (if (= (sqrt N) (floor (sqrt N)))\n      (next_Perfect_Square (+ N 1))\n      (sqrt (+ N 1))))\n",
    "  (let ([n (ceiling (sqrt N))])\n    (* n n)))\n",
    "  (cond\n    [(= (sqrt N) (round (sqrt N))) (next_Perfect_Square (+ N 1))]\n    [else (sqrt (+ N 1))]))\n",
    "  (if (not (integer? N))\n      (error \"N must be an integer\")\n      (if (not (positive? N))\n          (error \"N must be positive\")\n          (let loop ((N N))\n            (if (not (integer? (sqrt N)))\n                (loop (+ N 1))\n                N)))))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&gt; (* i i) N)\n        i\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (if (not (integer? N))\n      (error \"N must be an integer\")\n      (if (not (&gt; N 0))\n          (error \"N must be greater than 0\")\n          (let loop ([N N])\n            (if (not (integer? (sqrt N)))\n                (loop (+ N 1))\n                (+ N 1))))))\n</code>\n",
    "  (cond\n    [(= (sqrt N) (floor (sqrt N))) (sqrt N)]\n    [else (next_Perfect_Square (+ N 1))]))\n",
    "  (define (next_Perfect_Square_helper N i)\n    (if (= (sqr i) N)\n        (sqr (+ i 1))\n        (next_Perfect_Square_helper N (+ i 1))))\n  (next_Perfect_Square_helper N 1))\n",
    "  (let loop ([i 1])\n    (cond\n      [(= i N) (+ i 1)]\n      [(= (sqrt i) (floor (sqrt i))) (loop (+ i 1))]\n      [else (loop (+ i 1))])))\n",
    "  (let loop ([i 1])\n    (if (&gt; (* i i) N)\n        i\n        (loop (+ i 1)))))\n</code>\n",
    "  (define (is_Perfect_Square N)\n    (define (is_Perfect_Square_iter N i)\n      (if (= N (* i i))\n          #t\n          (if (&lt; N (* i i))\n              #f\n              (is_Perfect_Square_iter N (+ i 1)))))\n    (is_Perfect_Square_iter N 1))\n  (define (next_Perfect_Square_iter N i)\n    (if (is_Perfect_Square N)\n        N\n        (if (is_Perfect_Square (+ N i))\n            (+ N i)\n            (next_Perfect_Square_iter N (+ i 1)))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&gt; (* i i) N)\n        i\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (define (next_Perfect_Square_helper N i)\n    (if (&gt; (sqr i) N)\n        i\n        (next_Perfect_Square_helper N (+ i 1))))\n  (next_Perfect_Square_helper N 1))\n",
    "  (define (next_Perfect_Square_helper N i)\n    (cond ((= (expt i 2) N) (expt (+ i 1) 2))\n          ((&gt; (expt i 2) N) (expt (+ i 1) 2))\n          (else (next_Perfect_Square_helper N (+ i 1)))))\n  (next_Perfect_Square_helper N 1))\n",
    "  (define (next_Perfect_Square_helper N i)\n    (cond\n      [(= N (* i i)) (+ i 1)]\n      [else (next_Perfect_Square_helper N (+ i 1))]))\n  (* (next_Perfect_Square_helper N 1) (next_Perfect_Square_helper N 1)))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&gt; (* i i) N)\n        i\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (if (not (integer? N))\n      (error \"N must be an integer\")\n      (if (not (positive? N))\n          (error \"N must be positive\")\n          (let loop ((i 1))\n            (if (&gt; (* i i) N)\n                i\n                (loop (+ i 1)))))))\n",
    "  (define (next_Perfect_Square_helper N i)\n    (if (= i N)\n        (next_Perfect_Square_helper N (+ i 1))\n        (if (= (sqr i) N)\n            (sqr (+ i 1))\n            (next_Perfect_Square_helper N (+ i 1)))))\n  (next_Perfect_Square_helper N 1))\n",
    "  (if (not (integer? N))\n      (error \"N must be an integer\")\n      (let loop ([N N])\n        (if (not (integer? (sqrt N)))\n            (loop (+ N 1))\n            N))))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (cond ((= (expt i 2) N) (+ i 1))\n          ((&gt; (expt i 2) N) i)\n          (else (next_Perfect_Square_iter N (+ i 1)))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&gt; (* i i) N)\n        i\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (let loop ([n N])\n    (cond [(= (sqrt n) (floor (sqrt n))) n]\n          [else (loop (+ n 1))])))\n",
    "  (define (is_Perfect_Square N)\n    (define (isqrt N)\n      (define (iter guess)\n        (if (&lt; guess 0)\n            0\n            (if (&lt; (square guess) N)\n                (iter (+ guess 1))\n                guess)))\n      (iter 0))\n    (= (square (isqrt N)) N))\n  (define (iter guess)\n    (if (is_Perfect_Square guess)\n        guess\n        (iter (+ guess 1))))\n  (iter (+ N 1)))\n",
    "  (cond\n    [(= (sqrt N) (floor (sqrt N))) (next_Perfect_Square (+ N 1))]\n    [else (expt (ceiling (sqrt N)) 2)]))\n",
    "  (define (square_root n)\n    (define (good-enough? guess)\n      (< (abs (- (square guess) n)) 0.001))\n    (define (improve guess)\n      (/ (+ guess (/ n guess)) 2))\n    (define (sqrt-iter guess)\n      (if (good-enough? guess)\n          guess\n          (sqrt-iter (improve guess))))\n    (sqrt-iter 1.0))\n  (define (square n) (* n n))\n  (define (next-square n)\n    (if (not (integer? (square_root n)))\n        (next-square (+ n 1))\n        (square_root n)))\n  (next-square N))\n",
    "  (let loop ([i 1])\n    (if (&gt; (* i i) N)\n        i\n        (loop (+ i 1)))))\n</code>\n",
    "  (let loop ([i 1])\n    (if (&gt; (* i i) N)\n        i\n        (loop (+ i 1)))))\n",
    "  (let loop ([i 1])\n    (if (&gt; (* i i) N)\n        i\n        (loop (+ i 1)))))\n",
    "  (let loop ([N N])\n    (if (= (sqrt N) (floor (sqrt N)))\n        N\n        (loop (+ N 1)))))\n",
    "  (define (is_Perfect_Square N)\n    (define (is_Perfect_Square_iter N i)\n      (cond ((= N (* i i)) #t)\n            ((&gt; N (* i i)) (is_Perfect_Square_iter N (+ i 1)))\n            (else #f)))\n    (is_Perfect_Square_iter N 1))\n  (define (next_Perfect_Square_iter N i)\n    (cond ((is_Perfect_Square N) N)\n          ((&gt; N (* i i)) (next_Perfect_Square_iter N (+ i 1)))\n          (else (* i i))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (define (next_Perfect_Square_helper N i)\n    (if (&gt; N (* i i))\n        (next_Perfect_Square_helper N (+ i 1))\n        (* i i)))\n  (next_Perfect_Square_helper N 1))\n",
    "  (cond\n    [(= N 0) 1]\n    [(= N 1) 4]\n    [(= N 2) 5]\n    [(= N 3) 6]\n    [(= N 4) 9]\n    [(= N 5) 10]\n    [(= N 6) 11]\n    [(= N 7) 12]\n    [(= N 8) 13]\n    [(= N 9) 16]\n    [(= N 10) 17]\n    [(= N 11) 18]\n    [(= N 12) 19]\n    [(= N 13) 20]\n    [(= N 14) 21]\n    [(= N 15) 22]\n    [(= N 16) 25]\n    [(= N 17) 26]\n    [(= N 18) 27]\n    [(= N 19) 28]\n    [(= N 20) 29]\n    [(= N 21) 30]\n    [(= N 22) 31]\n    [(= N 23) 32]\n    [(= N 24) 33]\n    [(= N 25) 36]\n    [(= N 26) 37]\n    [(= N 27) 38]\n    [(= N 28) 39]\n    [(= N 29) 40]\n    [(= N 30) 41]\n    [(= N 31) 42]\n    [(= N 32) 43]\n    [(= N 33) 44]\n    [(= N 34) 45]\n    [(= N 35) 46]\n    [(= N 36) 49]\n    [(= N 37) 50]\n    [(= N 38) 51]\n    [(= N 39) 52]\n    [(= N 40) 53]\n    [(= N 41) 54]\n    [(= N 42) 55]\n    [(= N 43) 56]\n    [(= N 44) 57]\n    [(= N 45) 58]\n    [(= N 46) 59]\n    [(= N 47) 60]\n    [(= N 48) 61]\n    [(= N 49) 64]\n    [(= N 50) 65]\n    [(= N 51) 66]\n    [(= N 52) 67]\n    [(= N 53) 68]\n    [(= N 54) 69]\n    [(= N 55) 70]\n    [(=",
    "  (define (next_Perfect_Square_iter N i)\n    (if (= (sqr i) N)\n        (+ i 1)\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&gt; (* i i) N)\n        i\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (define (next_Perfect_Square_helper N i)\n    (if (= (sqr i) N)\n        (+ i 1)\n        (next_Perfect_Square_helper N (+ i 1))))\n  (next_Perfect_Square_helper N 1))\n",
    "  (cond\n    [(= (sqrt N) (floor (sqrt N))) (sqrt N)]\n    [else (next_Perfect_Square (+ N 1))]))\n",
    "  (let loop ([n N])\n    (if (= (sqr n) N)\n        (sqr (+ n 1))\n        (loop (+ n 1)))))\n",
    "  (define (is_Perfect_Square N)\n    (define (isqrt N)\n      (define (isqrt-iter N guess)\n        (if (good-enough? guess N)\n            guess\n            (isqrt-iter N (improve guess N))))\n      (define (good-enough? guess N)\n        (< (abs (- (square guess) N)) 0.001))\n      (define (improve guess N)\n        (average guess (/ N guess)))\n      (define (average x y)\n        (/ (+ x y) 2))\n      (isqrt-iter N 1))\n    (if (= (isqrt N) N)\n        #t\n        #f))\n  (if (is_Perfect_Square N)\n      N\n      (next_Perfect_Square (+ N 1))))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (= (sqr i) N)\n        (sqr (+ i 1))\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (let loop ([N N])\n    (if (= (sqrt N) (floor (sqrt N)))\n        N\n        (loop (+ N 1)))))\n",
    "  (let loop ([i 1])\n    (if (&gt; (* i i) N)\n        i\n        (loop (+ i 1)))))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (= (sqr i) N)\n        (+ i 1)\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&gt; (* i i) N)\n        i\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&lt; (expt i 2) N)\n        (next_Perfect_Square_iter N (+ i 1))\n        (expt i 2)))\n  (next_Perfect_Square_iter N 1))\n",
    "  (if (not (integer? N))\n      (error \"N must be an integer\")\n      (if (not (&gt;= N 0))\n          (error \"N must be greater than or equal to 0\")\n          (if (not (integer? (sqrt N)))\n              (sqrt (+ N 1))\n              (sqrt (+ N 2))))))\n</code>\nI am trying to write a function that takes a number and returns the next perfect square. I have written the following code and it works fine. However, I am wondering if there is a more efficient way to write this function.\n\n\nA:\n\nThe <code>ceiling</code> function is useful here:\n<code>(define (next-perfect-square n)\n  (exact-&gt;inexact (ceiling (sqrt n))))\n</code>\n",
    "  (if (not (integer? N))\n      (error \"N must be an integer\")\n      (let loop ([N N])\n        (if (not (integer? (sqrt N)))\n            (loop (+ N 1))\n            N))))\n</code>\n",
    "  (if (not (integer? N))\n      (error \"N must be an integer\")\n      (if (not (&gt; N 0))\n          (error \"N must be greater than 0\")\n          (let loop ((i 1))\n            (if (&gt; (* i i) N)\n                i\n                (loop (+ i 1)))))))\n",
    "  (define (square N) (* N N))\n  (define (next_Perfect_Square_iter N i)\n    (cond ((&gt; (square i) N) (square i))\n          (else (next_Perfect_Square_iter N (+ i 1)))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (if (not (integer? N))\n      (error \"N must be an integer\")\n      (if (not (positive? N))\n          (error \"N must be a positive integer\")\n          (let loop ([i 1])\n            (if (= (* i i) N)\n                (+ i 1)\n                (if (&lt; (* i i) N)\n                    (loop (+ i 1))\n                    (error \"N must be a perfect square\")))))))\n</code>\n",
    "  (define (next_Perfect_Square_helper N i)\n    (if (&gt; (* i i) N)\n        i\n        (next_Perfect_Square_helper N (+ i 1))))\n  (* (next_Perfect_Square_helper N 1) (next_Perfect_Square_helper N 1)))\n",
    "  (define (next_Perfect_Square_helper N i)\n    (cond\n      [(= i N) N]\n      [(= (sqr i) N) (+ i 1)]\n      [else (next_Perfect_Square_helper N (+ i 1))]))\n  (next_Perfect_Square_helper N 1))\n",
    "  (let loop ([N N])\n    (if (and (integer? (sqrt N)) (= N (* (sqrt N) (sqrt N))))\n        (sqrt N)\n        (loop (+ N 1)))))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&gt; (* i i) N)\n        i\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&gt;= (* i i) N)\n        (* i i)\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (cond\n    [(= (sqrt N) (floor (sqrt N)))\n     (sqrt (+ N 1))]\n    [else\n     (sqrt (+ N 1))]))\n",
    "  (define (next_Perfect_Square_helper N i)\n    (cond\n      [(= (sqr i) N) (+ i 1)]\n      [(> (sqr i) N) (sqr i)]\n      [else (next_Perfect_Square_helper N (+ i 1))]))\n  (next_Perfect_Square_helper N 1))\n",
    "  (let loop ([i 1])\n    (if (&gt; (* i i) N)\n        i\n        (loop (+ i 1)))))\n",
    "  (let loop ([i 1])\n    (if (&gt; (* i i) N)\n        i\n        (loop (+ i 1)))))\n",
    "  (let loop ([n N])\n    (cond [(= (sqr n) N) (+ n 1)]\n          [else (loop (+ n 1))])))\n",
    "  (if (not (integer? N))\n      (error \"N must be an integer\")\n      (if (not (positive? N))\n          (error \"N must be positive\")\n          (let loop ([n N])\n            (if (not (integer? (sqrt n)))\n                (loop (+ n 1))\n                n)))))\n",
    "  (cond\n    [(= (sqrt N) (floor (sqrt N)))\n     (sqrt (+ N 1))]\n    [else\n     (sqrt (+ N 1))]))\n",
    "  (let loop ([n N])\n    (if (and (integer? n) (integer? (sqrt n)))\n        n\n        (loop (+ n 1)))))\n",
    "  (let ([n (ceiling (sqrt N))])\n    (* n (+ n 1))))\n",
    "  (let loop ([N N])\n    (if (= (sqrt N) (floor (sqrt N)))\n        N\n        (loop (+ N 1)))))\n",
    "  (if (not (integer? N))\n      (error \"N must be an integer\")\n      (let loop ([i 1])\n        (if (&gt; (* i i) N)\n            i\n            (loop (+ i 1))))))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&gt; (* i i) N)\n        i\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (define (is_Perfect_Square N)\n    (define (isqrt N)\n      (define (iter N guess)\n        (if (good-enough? guess N)\n            guess\n            (iter N (improve guess N))))\n      (iter N 1))\n    (= (isqrt N) N))\n  (define (next_Perfect_Square_iter N)\n    (if (is_Perfect_Square N)\n        (next_Perfect_Square_iter (+ N 1))\n        N))\n  (next_Perfect_Square_iter N))\n",
    "  (let ([sqrt (sqrt N)])\n    (if (integer? sqrt)\n        (+ 1 (* sqrt sqrt))\n        (* (+ 1 (floor sqrt)) (+ 1 (floor sqrt))))))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&lt; (* i i) N)\n        (next_Perfect_Square_iter N (+ i 1))\n        (* i i)))\n  (next_Perfect_Square_iter N 1))\n",
    "  (if (not (integer? N))\n      (error \"N must be an integer\")\n      (if (not (&gt;= N 0))\n          (error \"N must be a positive integer\")\n          (let loop ((i 1))\n            (if (&gt; (* i i) N)\n                i\n                (loop (+ i 1)))))))\n</code>\n",
    "  (define (is_Perfect_Square N)\n    (define (is_Perfect_Square_iter N i)\n      (if (= N (* i i))\n          #t\n          (if (&lt; N (* i i))\n              #f\n              (is_Perfect_Square_iter N (+ i 1)))))\n    (is_Perfect_Square_iter N 1))\n  (define (next_Perfect_Square_iter N i)\n    (if (is_Perfect_Square N)\n        N\n        (if (is_Perfect_Square (+ N i))\n            (+ N i)\n            (next_Perfect_Square_iter N (+ i 1)))))\n  (next_Perfect_Square_iter N 1))\n</code>\nI'm not sure if this is the best way to do it, but it works.\n",
    "  (if (not (integer? N))\n      (error 'next_Perfect_Square \"N must be an integer\")\n      (if (not (positive? N))\n          (error 'next_Perfect_Square \"N must be positive\")\n          (let loop ((i 1))\n            (if (&gt; (* i i) N)\n                i\n                (loop (+ i 1)))))))\n</code>\n",
    "  (define (next_Perfect_Square_helper N i)\n    (cond ((= (expt i 2) N) (expt (+ i 1) 2))\n          ((&gt; (expt i 2) N) (expt (+ i 1) 2))\n          (else (next_Perfect_Square_helper N (+ i 1)))))\n  (next_Perfect_Square_helper N 1))\n",
    "  (if (not (integer? N))\n      (error \"N must be an integer\")\n      (if (not (positive? N))\n          (error \"N must be positive\")\n          (let loop ([N N])\n            (if (not (integer? (sqrt N)))\n                (loop (+ N 1))\n                N)))))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&gt; (* i i) N)\n        i\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (let loop ([i 1])\n    (if (&gt; (* i i) N)\n        i\n        (loop (+ i 1)))))\n",
    "  (define (next_Perfect_Square_helper N i)\n    (if (= (sqr i) N)\n        (sqr (+ i 1))\n        (next_Perfect_Square_helper N (+ i 1))))\n  (next_Perfect_Square_helper N 1))\n",
    "  (if (not (integer? N))\n      (error \"N must be an integer\")\n      (if (not (positive? N))\n          (error \"N must be positive\")\n          (let loop ((i 1))\n            (if (&gt; (* i i) N)\n                i\n                (loop (+ i 1)))))))\n",
    "  (let loop ([i 1])\n    (if (&gt; (* i i) N)\n        i\n        (loop (+ i 1)))))\n",
    "  (cond\n    [(= (sqrt N) (floor (sqrt N))) (sqrt N)]\n    [else (next_Perfect_Square (+ N 1))]))\n",
    "  (cond\n    [(= (sqrt N) (floor (sqrt N))) (+ N 1)]\n    [else (+ (sqrt N) 1)]))\n",
    "  (define (next_Perfect_Square_helper N i)\n    (if (= (sqr i) N)\n        (sqr (+ i 1))\n        (next_Perfect_Square_helper N (+ i 1))))\n  (next_Perfect_Square_helper N 1))\n",
    "  (if (not (integer? N))\n      (error \"N must be an integer\")\n      (let loop ((N N))\n        (if (and (integer? (sqrt N)) (= N (* (sqrt N) (sqrt N))))\n            (sqrt N)\n            (loop (+ N 1))))))\n",
    "  (define (next_Perfect_Square_helper N i)\n    (if (&lt; (sqr i) N)\n        (next_Perfect_Square_helper N (+ i 1))\n        (sqr i)))\n  (next_Perfect_Square_helper N 1))\n</code>\n",
    "  (define (is_Perfect_Square N)\n    (define (is_Perfect_Square_iter N i)\n      (cond\n        [(= N (* i i)) #t]\n        [(&gt; N (* i i)) (is_Perfect_Square_iter N (+ i 1))]\n        [else #f]))\n    (is_Perfect_Square_iter N 1))\n  (define (next_Perfect_Square_iter N i)\n    (cond\n      [(is_Perfect_Square N) N]\n      [else (next_Perfect_Square_iter (+ N 1) (+ i 1))]))\n  (next_Perfect_Square_iter N 1))\n",
    "  (if (not (integer? N))\n      (error \"N must be an integer\")\n      (if (not (positive? N))\n          (error \"N must be positive\")\n          (let loop ([N N])\n            (if (not (integer? (sqrt N)))\n                (loop (+ N 1))\n                N)))))\n",
    "  (if (not (integer? N))\n      (error \"N must be an integer\")\n      (if (not (positive? N))\n          (error \"N must be positive\")\n          (let loop ([N N])\n            (if (integer? (sqrt N))\n                N\n                (loop (+ N 1)))))))\n",
    "  (if (not (integer? N))\n      (error 'next_Perfect_Square \"N must be an integer\")\n      (let loop ([N N])\n        (if (not (integer? (sqrt N)))\n            (loop (+ N 1))\n            N))))\n",
    "  (if (not (integer? N))\n      (error \"N must be an integer\")\n      (if (not (positive? N))\n          (error \"N must be positive\")\n          (let loop ([N N])\n            (if (not (integer? (sqrt N)))\n                (loop (+ N 1))\n                N)))))\n",
    "  (let loop ([i 1])\n    (if (&gt; (* i i) N)\n        i\n        (loop (+ i 1)))))\n",
    "  (define (next_Perfect_Square_helper N i)\n    (if (&gt; (sqr i) N)\n        i\n        (next_Perfect_Square_helper N (+ i 1))))\n  (next_Perfect_Square_helper N 1))\n</code>\nI am getting the following error:\n<code>next_perfect_square.rkt:5:0: next_Perfect_Square_helper: unbound identifier in module in: next_Perfect_Square_helper\n</code>\nI am not sure why I am getting this error.\n\n\nA:\n\nThe problem is that you're trying to call the function <code>next_Perfect_Square_helper</code> before it's defined.\nThe solution is to move the definition of <code>next_Perfect_Square_helper</code> to the top of the file, before the definition of <code>next_Perfect_Square</code>.\n",
    "  (let loop ((i 1))\n    (if (&gt; (* i i) N)\n        i\n        (loop (+ i 1)))))\n",
    "  (cond\n    [(= (sqrt N) (floor (sqrt N)))\n     (sqrt N)]\n    [else\n     (next_Perfect_Square (+ N 1))]))\n",
    "  (define (next_Perfect_Square_helper N i)\n    (if (&gt; (* i i) N)\n        (* i i)\n        (next_Perfect_Square_helper N (+ i 1))))\n  (next_Perfect_Square_helper N 1))\n",
    "  (define (next_Perfect_Square_helper N)\n    (if (= N 0)\n        0\n        (if (= (sqrt N) (floor (sqrt N)))\n            N\n            (next_Perfect_Square_helper (+ N 1)))))\n  (next_Perfect_Square_helper N))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&gt; (* i i) N)\n        (* i i)\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&gt; N (* i i))\n        (next_Perfect_Square_iter N (+ i 1))\n        (* i i)))\n  (next_Perfect_Square_iter N 1))\n",
    "  (define (perfect_square? N)\n    (if (= (sqrt N) (floor (sqrt N)))\n        #t\n        #f))\n  (define (next_Perfect_Square_helper N)\n    (if (perfect_square? N)\n        N\n        (next_Perfect_Square_helper (+ N 1))))\n  (next_Perfect_Square_helper (+ N 1)))\n",
    "  (let loop ([i 1])\n    (if (&gt; (* i i) N)\n        i\n        (loop (+ i 1)))))\n",
    "  (define (is_Perfect_Square N)\n    (and (integer? (sqrt N))\n         (integer? N)))\n  (define (next_Perfect_Square_helper N)\n    (if (is_Perfect_Square N)\n        N\n        (next_Perfect_Square_helper (+ N 1))))\n  (next_Perfect_Square_helper (+ N 1)))\n",
    "  (define (is_Perfect_Square N)\n    (define (is_Perfect_Square_iter N i)\n      (cond ((= i N) #t)\n            ((&gt; i N) #f)\n            (else (is_Perfect_Square_iter N (+ i 1)))))\n    (is_Perfect_Square_iter N 1))\n  (define (next_Perfect_Square_iter N i)\n    (cond ((is_Perfect_Square N) N)\n          ((&gt; i N) #f)\n          (else (next_Perfect_Square_iter (+ N 1) (+ i 1)))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&gt; (* i i) N)\n        i\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (let loop ([n N])\n    (if (not (integer? (sqrt n)))\n        (loop (+ n 1))\n        n)))\n",
    "  (let loop ([N N])\n    (cond [(= (sqrt N) (floor (sqrt N))) N]\n          [else (loop (+ N 1))])))\n",
    "  (let loop ([i 1])\n    (if (&gt; (* i i) N)\n        i\n        (loop (+ i 1)))))\n",
    "  (if (not (integer? N))\n      (error \"N must be an integer\")\n      (if (not (positive? N))\n          (error \"N must be a positive integer\")\n          (let loop ((i 1))\n            (if (&gt; (* i i) N)\n                i\n                (loop (+ i 1)))))))\n",
    "  (define (next_Perfect_Square_helper N i)\n    (if (= N (* i i))\n        (next_Perfect_Square_helper N (+ i 1))\n        (* i i)))\n  (next_Perfect_Square_helper N 1))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (= (expt i 2) N)\n        (expt (+ i 1) 2)\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (cond ((= (sqr i) N) (+ i 1))\n          ((&gt; (sqr i) N) (sqr i))\n          (else (next_Perfect_Square_iter N (+ i 1)))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (if (not (integer? N))\n      (error \"N must be an integer\")\n      (let loop ((i 1))\n        (if (&gt; (* i i) N)\n            i\n            (loop (+ i 1))))))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (cond\n      [(= N i) N]\n      [(> N i) (next_Perfect_Square_iter N (+ i 1))]\n      [else (+ i 1) (* i i)]))\n  (next_Perfect_Square_iter N 1))\n",
    "  (cond\n    [(= (sqrt N) (floor (sqrt N)))\n     (+ N 1)]\n    [else\n     (next_Perfect_Square (+ N 1))]))\n",
    "  (define (next_Perfect_Square_helper N i)\n    (cond ((= (sqr i) N) (+ i 1))\n          ((&gt; (sqr i) N) i)\n          (else (next_Perfect_Square_helper N (+ i 1)))))\n  (next_Perfect_Square_helper N 1))\n</code>\nI'm not sure if this is the most efficient way to do this, but it works.\n",
    "  (let loop ([i 1])\n    (cond\n      [(= i N) (next_Perfect_Square (+ N 1))]\n      [(= (* i i) N) N]\n      [else (loop (+ i 1))])))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (= i N)\n        (next_Perfect_Square_iter N (+ i 1))\n        (if (= (sqr i) N)\n            (sqr (+ i 1))\n            (next_Perfect_Square_iter N (+ i 1)))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (cond\n    [(= (sqrt N) (floor (sqrt N))) (next_Perfect_Square (+ N 1))]\n    [else (sqrt (+ N 1))]))\n",
    "  (let loop ([n N])\n    (if (= (sqr n) N)\n        (+ n 1)\n        (loop (+ n 1)))))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (= i N)\n        (next_Perfect_Square_iter N (+ i 1))\n        (if (= (sqr i) N)\n            (+ i 1)\n            (next_Perfect_Square_iter N (+ i 1)))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (define (is_Perfect_Square N)\n    (cond\n      [(= (sqrt N) (floor (sqrt N))) #t]\n      [else #f]))\n  (cond\n    [(is_Perfect_Square N) N]\n    [else (next_Perfect_Square (+ N 1))]))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (= (expt i 2) N)\n        (expt (+ i 1) 2)\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (let ([n (ceiling (sqrt N))])\n    (* n (+ n 1))))\n",
    "  (let ([n (ceiling (sqrt N))])\n    (* n (+ n 1))))\n",
    "  (define (is_Perfect_Square N)\n    (if (= (sqrt N) (floor (sqrt N)))\n        #t\n        #f))\n  (if (is_Perfect_Square N)\n      (next_Perfect_Square (+ N 1))\n      (sqrt (+ N 1))))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&gt; (* i i) N)\n        i\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&gt; (* i i) N)\n        i\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (let loop ([i 1])\n    (if (&gt; (* i i) N)\n        i\n        (loop (+ i 1)))))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (cond ((= (expt i 2) N) (expt (+ i 1) 2))\n          ((&gt; (expt i 2) N) (expt (+ i 1) 2))\n          (else (next_Perfect_Square_iter N (+ i 1)))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&gt; (sqr i) N)\n        i\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (if (not (integer? N))\n      (error \"N must be an integer\")\n      (if (not (positive? N))\n          (error \"N must be positive\")\n          (let loop ((N N))\n            (if (not (integer? (sqrt N)))\n                (loop (+ N 1))\n                N)))))\n",
    "  (define (next_Perfect_Square_helper N i)\n    (cond ((= (sqr i) N) (+ i 1))\n          ((&gt; (sqr i) N) (sqr i))\n          (else (next_Perfect_Square_helper N (+ i 1)))))\n  (next_Perfect_Square_helper N 1))\n",
    "  (define (next_Perfect_Square_helper N i)\n    (if (= (sqr i) N)\n        (sqr (+ i 1))\n        (next_Perfect_Square_helper N (+ i 1))))\n  (next_Perfect_Square_helper N 1))\n",
    "  (let loop ([N N])\n    (if (not (integer? (sqrt N)))\n        (loop (+ N 1))\n        N)))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&gt; (* i i) N)\n        i\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (let loop ((i 1))\n    (if (&gt; (* i i) N)\n        i\n        (loop (+ i 1)))))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&gt; (* i i) N)\n        i\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (if (not (integer? N))\n      (error \"N must be an integer\")\n      (if (not (positive? N))\n          (error \"N must be positive\")\n          (let loop ((n N))\n            (if (not (integer? (sqrt n)))\n                (loop (+ n 1))\n                n)))))\n",
    "  (let loop ([i 1])\n    (if (&gt; (* i i) N)\n        i\n        (loop (+ i 1)))))\n",
    "  (let loop ([i 1])\n    (if (&gt; (* i i) N)\n        i\n        (loop (+ i 1)))))\n",
    "  (define (next_Perfect_Square_helper N i)\n    (if (&gt; (* i i) N)\n        i\n        (next_Perfect_Square_helper N (+ i 1))))\n  (* (next_Perfect_Square_helper N 1) (next_Perfect_Square_helper N 1)))\n",
    "  (let loop ([i 1])\n    (if (&gt; (* i i) N)\n        i\n        (loop (+ i 1)))))\n",
    "  (let loop ([i 1])\n    (if (&gt; (* i i) N)\n        i\n        (loop (+ i 1)))))\n</code>\n",
    "  (if (not (integer? N))\n      (error \"N must be an integer\")\n      (let loop ((i 1))\n        (if (&gt; (* i i) N)\n            (* i i)\n            (loop (+ i 1))))))\n",
    "  (let ([n (ceiling (sqrt N))])\n    (* n (+ n 1))))\n",
    "  (if (not (integer? N))\n      (error \"N must be an integer\")\n      (let loop ((i 1))\n        (if (&gt; (* i i) N)\n            i\n            (loop (+ i 1))))))\n</code>\n",
    "  (define (next_Perfect_Square_helper N i)\n    (if (= i N)\n        (next_Perfect_Square_helper N (+ i 1))\n        (if (= (sqrt i) (floor (sqrt i)))\n            i\n            (next_Perfect_Square_helper N (+ i 1)))))\n  (next_Perfect_Square_helper N 1))\n",
    "  (if (not (integer? N))\n      (error \"N must be an integer\")\n      (if (not (positive? N))\n          (error \"N must be positive\")\n          (let loop ([N N])\n            (if (integer? (sqrt N))\n                N\n                (loop (+ N 1)))))))\n",
    "  (let loop ([i 1])\n    (if (&gt; (* i i) N)\n        i\n        (loop (+ i 1)))))\n",
    "  (if (not (integer? N))\n      (error \"N must be an integer\")\n      (if (not (positive? N))\n          (error \"N must be positive\")\n          (let loop ([N N])\n            (if (not (integer? (sqrt N)))\n                (loop (+ N 1))\n                N)))))\n",
    "  (define (next_Perfect_Square_helper N i)\n    (cond ((= i N) (next_Perfect_Square_helper N (+ i 1)))\n          ((= (sqr i) N) i)\n          (else (next_Perfect_Square_helper N (+ i 1)))))\n  (next_Perfect_Square_helper N 1))\n",
    "  (define (is_Perfect_Square N)\n    (define (is_Perfect_Square_iter N i)\n      (if (= N (* i i))\n          #t\n          (if (&lt; N (* i i))\n              #f\n              (is_Perfect_Square_iter N (+ i 1)))))\n    (is_Perfect_Square_iter N 1))\n  (define (next_Perfect_Square_iter N i)\n    (if (is_Perfect_Square N)\n        N\n        (if (is_Perfect_Square (+ N i))\n            (+ N i)\n            (next_Perfect_Square_iter N (+ i 1)))))\n  (next_Perfect_Square_iter N 1))\n</code>\nI'm not sure if this is the most efficient way to do it, but it works.\n\n\nA:\n\nYou can use <code>ceiling</code> to get the next integer greater than or equal to the square root of <code>N</code>, and then square it:\n<code>(define (next-perfect-square n)\n  (* (ceiling (sqrt n)) (ceiling (sqrt n))))\n</code>\n",
    "  (let loop ([i 1])\n    (if (&gt; (* i i) N)\n        i\n        (loop (+ i 1)))))\n",
    "  (if (= (sqrt N) (floor (sqrt N)))\n      (+ N 1)\n      (next_Perfect_Square (+ N 1))))\n",
    "  (let ((x 1))\n    (while (< (* x x) N)\n      (set! x (+ x 1)))\n    (* x x)))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&gt; (* i i) N)\n        i\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&gt; (* i i) N)\n        i\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (cond ((= (sqr i) N) (+ i 1))\n          ((&gt; (sqr i) N) (sqr i))\n          (else (next_Perfect_Square_iter N (+ i 1)))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (cond\n    [(= (sqrt N) (floor (sqrt N))) (next_Perfect_Square (+ N 1))]\n    [else (sqrt N)]))\n",
    "  (let loop ([i 1])\n    (if (&gt; (* i i) N)\n        i\n        (loop (+ i 1)))))\n",
    "  (if (not (integer? N))\n      (error \"N must be an integer\")\n      (if (not (positive? N))\n          (error \"N must be positive\")\n          (let loop ([N N])\n            (if (not (integer? (sqrt N)))\n                (loop (+ N 1))\n                N)))))\n",
    "  (if (not (integer? N))\n      (error \"N must be an integer\")\n      (if (not (positive? N))\n          (error \"N must be a positive integer\")\n          (let loop ((N N))\n            (if (perfect-square? N)\n                N\n                (loop (+ N 1)))))))\n",
    "  (if (= (sqrt N) (floor (sqrt N)))\n      (exact->inexact (sqrt N))\n      (exact->inexact (sqrt (+ N 1)))))\n",
    "  (let loop ([i 1])\n    (if (&gt; (* i i) N)\n        i\n        (loop (+ i 1)))))\n",
    "  (if (not (integer? N))\n      (error \"N must be an integer\")\n      (let loop ((i 1))\n        (if (&lt; (* i i) N)\n            (loop (+ i 1))\n            (* i i)))))\n",
    "  (if (not (integer? N))\n      (error \"N must be an integer\")\n      (if (not (positive? N))\n          (error \"N must be positive\")\n          (let loop ([n N])\n            (if (integer? (sqrt n))\n                n\n                (loop (+ n 1)))))))\n",
    "  (define (next_Perfect_Square_helper N i)\n    (if (= (sqr i) N)\n        (+ i 1)\n        (next_Perfect_Square_helper N (+ i 1))))\n  (next_Perfect_Square_helper N 1))\n",
    "  (let loop ([i 1])\n    (if (&gt; (* i i) N)\n        i\n        (loop (+ i 1)))))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (cond ((= (sqr i) N) (+ i 1))\n          ((&gt; (sqr i) N) (sqr i))\n          (else (next_Perfect_Square_iter N (+ i 1)))))\n  (next_Perfect_Square_iter N 1))\n</code>\n",
    "  (define (is_Perfect_Square N)\n    (define (is_Perfect_Square_iter N i)\n      (if (= i N)\n          #t\n          (if (&gt; i N)\n              #f\n              (is_Perfect_Square_iter N (+ i 1)))))\n    (is_Perfect_Square_iter N 1))\n  (define (next_Perfect_Square_iter N i)\n    (if (is_Perfect_Square i)\n        i\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (cond\n    [(= (sqrt N) (floor (sqrt N))) (+ 1 (sqrt N))]\n    [else (next_Perfect_Square (+ 1 N))]))\n",
    "  (cond\n    [(= (sqrt N) (floor (sqrt N)))\n     (sqrt (+ N 1))]\n    [else\n     (sqrt (+ (ceiling (sqrt N)) 1))]))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (cond ((= (expt i 2) N) (next_Perfect_Square_iter N (+ i 1)))\n          ((&gt; (expt i 2) N) (expt i 2))\n          (else (next_Perfect_Square_iter N (+ i 1)))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (let loop ([n N])\n    (if (not (integer? (sqrt n)))\n        (loop (+ n 1))\n        n)))\n",
    "  (if (not (integer? N))\n      (error \"N must be an integer\")\n      (let loop ((n N))\n        (if (not (integer? (sqrt n)))\n            (loop (+ n 1))\n            n))))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (cond ((= (expt i 2) N) (+ i 1))\n          ((&gt; (expt i 2) N) i)\n          (else (next_Perfect_Square_iter N (+ i 1)))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&gt; (* i i) N)\n        i\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (let loop ([i 1])\n    (if (= (sqr i) N)\n        (+ i 1)\n        (loop (+ i 1)))))\n",
    "  (if (not (integer? N))\n      (error \"N must be an integer\")\n      (if (not (positive? N))\n          (error \"N must be positive\")\n          (let loop ((i 1))\n            (if (&gt; (* i i) N)\n                i\n                (loop (+ i 1)))))))\n",
    "  (cond\n    [(= (sqrt N) (floor (sqrt N))) (next_Perfect_Square (+ N 1))]\n    [else (sqrt (+ N 1))]))\n",
    "  (cond [(= (sqrt N) (floor (sqrt N))) (+ N 1)]\n        [else (+ N 1)]))\n",
    "  (define (is_Perfect_Square N)\n    (define (is_Perfect_Square_iter N i)\n      (cond ((= i N) #t)\n            ((&gt; i N) #f)\n            (else (is_Perfect_Square_iter N (+ i 1)))))\n    (is_Perfect_Square_iter N 1))\n  (define (next_Perfect_Square_iter N i)\n    (cond ((is_Perfect_Square i) i)\n          (else (next_Perfect_Square_iter N (+ i 1)))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (define (is_Perfect_Square N)\n    (define (is_Perfect_Square_iter N i)\n      (if (= i N)\n          #t\n          (if (&lt; i N)\n              (is_Perfect_Square_iter N (+ i 1))\n              #f)))\n    (is_Perfect_Square_iter N 1))\n  (define (next_Perfect_Square_iter N i)\n    (if (is_Perfect_Square N)\n        N\n        (next_Perfect_Square_iter (+ N 1) (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n</code>\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&gt; (sqr i) N)\n        i\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (if (not (integer? N))\n      (error \"N must be an integer\")\n      (if (not (positive? N))\n          (error \"N must be positive\")\n          (let loop ((N (+ N 1)))\n            (if (not (integer? (sqrt N)))\n                (loop (+ N 1))\n                N)))))\n",
    "  (let loop ((i 1))\n    (if (&gt; (* i i) N)\n        i\n        (loop (+ i 1)))))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (= (sqr i) N)\n        (+ i 1)\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (if (not (integer? N))\n      (error \"N must be an integer\")\n      (let loop ((N N))\n        (if (not (integer? (sqrt N)))\n            (loop (+ N 1))\n            N))))\n",
    "  (define (is_Perfect_Square N)\n    (define (is_Square? N)\n      (if (= (sqrt N) (floor (sqrt N)))\n          #t\n          #f))\n    (if (is_Square? N)\n        #t\n        #f))\n  (if (is_Perfect_Square N)\n      (next_Perfect_Square (+ N 1))\n      (sqrt (+ N 1))))\n",
    "  (cond\n    [(= (sqrt N) (floor (sqrt N)))\n     (sqrt N)]\n    [else\n     (next_Perfect_Square (+ N 1))]))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&gt;= (* i i) N)\n        (* i i)\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (define (next_Perfect_Square_helper N i)\n    (cond\n      [(= N (* i i)) (* (+ i 1) (+ i 1))]\n      [else (next_Perfect_Square_helper N (+ i 1))]))\n  (next_Perfect_Square_helper N 1))\n",
    "  (let loop ([n N])\n    (if (= (sqrt n) (floor (sqrt n)))\n        n\n        (loop (+ n 1)))))\n",
    "  (define (next_Perfect_Square_iter n i)\n    (if (&gt; (* i i) n)\n        (* i i)\n        (next_Perfect_Square_iter n (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (let loop ([N N])\n    (if (= (sqrt N) (floor (sqrt N)))\n        N\n        (loop (+ N 1)))))\n",
    "  (define (next_Perfect_Square_helper N i)\n    (cond\n      [(= (* i i) N) (+ i i)]\n      [(&gt; (* i i) N) (* i i)]\n      [else (next_Perfect_Square_helper N (+ i 1))]))\n  (next_Perfect_Square_helper N 1))\n",
    "  (define (next_Perfect_Square_iter N i)\n    (if (&gt; (* i i) N)\n        i\n        (next_Perfect_Square_iter N (+ i 1))))\n  (next_Perfect_Square_iter N 1))\n",
    "  (define (next_Perfect_Square_helper N i)\n    (if (&gt; (* i i) N)\n        i\n        (next_Perfect_Square_helper N (+ i 1))))\n  (* (next_Perfect_Square_helper N 1) (next_Perfect_Square_helper N 1)))\n"
  ]
}