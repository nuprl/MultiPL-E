{
  "name": "mbpp_612_merge",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Write a python function which takes a list of lists, where each sublist has two elements, and returns a list of two lists where the first list has the first element of each sublist and the second one has the second.\n(define (merge lst)\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_612_merge.py",
  "prompt_terminology": "verbatim",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate merge))\n    (check-equal? (candidate (list (list \"x\" \"y\") (list \"a\" \"b\") (list \"m\" \"n\"))) (list (list \"x\" \"a\" \"m\") (list \"y\" \"b\" \"n\")))\n    (check-equal? (candidate (list (list 1 2) (list 3 4) (list 5 6) (list 7 8))) (list (list 1 3 5 7) (list 2 4 6 8)))\n    (check-equal? (candidate (list (list \"x\" \"y\" \"z\") (list \"a\" \"b\" \"c\") (list \"m\" \"n\" \"o\"))) (list (list \"x\" \"a\" \"m\") (list \"y\" \"b\" \"n\") (list \"z\" \"c\" \"o\")))\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (define (merge-helper lst1 lst2)\n    (if (null? lst1)\n        lst2\n        (cons (car lst1) (merge-helper (cdr lst1) lst2))))\n  (merge-helper (map car lst) (map cadr lst)))\n",
    "  (let ([firsts (map first lst)]\n        [seconds (map second lst)])\n    (list firsts seconds)))\n",
    "  (let ([l1 (map car lst)]\n        [l2 (map cadr lst)])\n    (list l1 l2)))\n",
    "  (let loop ([lst lst] [first '()] [second '()])\n    (cond\n      [(empty? lst) (list first second)]\n      [else (loop (rest lst) (cons (first (first lst)) first) (cons (second (first lst)) second))])))\n",
    "  (if (null? lst)\n      '()\n      (cons (map first lst)\n            (cons (map second lst)\n                  '()))))\n",
    "  (let loop ([lst lst] [lst1 '()] [lst2 '()])\n    (cond [(empty? lst) (list lst1 lst2)]\n          [else (loop (rest lst)\n                      (cons (first (first lst)) lst1)\n                      (cons (second (first lst)) lst2))])))\n",
    "  (define (merge-helper lst1 lst2)\n    (if (null? lst1)\n        lst2\n        (cons (car lst1) (merge-helper (cdr lst1) lst2))))\n  (merge-helper (map car lst) (map cadr lst)))\n",
    "  (define (merge-helper lst1 lst2)\n    (if (null? lst1)\n        lst2\n        (cons (car lst1) (merge-helper (cdr lst1) lst2))))\n  (merge-helper (map car lst) (map cadr lst)))\n",
    "  (let ([lst1 (map car lst)]\n        [lst2 (map cadr lst)])\n    (list lst1 lst2)))\n",
    "  (if (empty? lst)\n      (list (list) (list))\n      (let* ([first (first lst)]\n             [rest (merge (rest lst))]\n             [first-list (first rest)]\n             [second-list (second rest)])\n        (list (cons (first first) first-list)\n              (cons (second first) second-list)))))\n",
    "  (let loop ([lst lst] [lst1 '()] [lst2 '()])\n    (cond\n      [(empty? lst) (list lst1 lst2)]\n      [else (loop (rest lst) (cons (first (first lst)) lst1) (cons (second (first lst)) lst2))])))\n",
    "  (let loop ([lst lst] [lst1 '()] [lst2 '()])\n    (cond [(empty? lst) (list lst1 lst2)]\n          [else (loop (rest lst)\n                      (cons (first (first lst)) lst1)\n                      (cons (second (first lst)) lst2))])))\n",
    "  (let loop ([lst lst] [l1 '()] [l2 '()])\n    (cond [(empty? lst) (list l1 l2)]\n          [else (loop (rest lst) (cons (first (first lst)) l1) (cons (second (first lst)) l2))])))\n",
    "  (map list lst))\n",
    "  (apply append (map list (map first lst) (map second lst))))\n",
    "  (let loop ([lst lst]\n             [lst1 '()]\n             [lst2 '()])\n    (cond [(empty? lst) (list lst1 lst2)]\n          [else (loop (rest lst)\n                      (cons (first (first lst)) lst1)\n                      (cons (second (first lst)) lst2))])))\n",
    "  (let loop ((lst lst)\n             (first '())\n             (second '()))\n    (cond ((null? lst) (list first second))\n          (else (loop (cdr lst)\n                      (cons (caar lst) first)\n                      (cons (cadar lst) second))))))\n",
    "  (match lst\n    [(list (list a b) (list c d)) (list (list a c) (list b d))]\n    [(list (list a b) (list c d) (list e f)) (list (list a c e) (list b d f))]\n    [(list (list a b) (list c d) (list e f) (list g h)) (list (list a c e g) (list b d f h))]\n    [(list (list a b) (list c d) (list e f) (list g h) (list i j)) (list (list a c e g i) (list b d f h j))]\n    [(list (list a b) (list c d) (list e f) (list g h) (list i j) (list k l)) (list (list a c e g i k) (list b d f h j l))]\n    [(list (list a b) (list c d) (list e f) (list g h) (list i j) (list k l) (list m n)) (list (list a c e g i k m) (list b d f h j l n))]\n    [(list (list a b) (list c d) (list e f) (list g h) (list i j) (list k l) (list m n) (list o p)) (list (list a c e g i k m o) (list b d f h j l n p))]\n    [(list (list a b) (list c d) (list e f) (list g h) (list i j) (list k l) (list m n) (list o p) (list q r)) (list (list a c e g i k m o q) (list b d f h j l n p r))]\n    [(list (list a b) (list c d) (list e f) (list g h) (list i j) (list k l) (list m n) (list o p) (list q r) (list s t)) (list (list a c e g i k m o q s) (list b d f h j l n p r t))]\n    [(list (list a b) (list",
    "  (if (null? lst)\n      '()\n      (cons (map car lst)\n            (cons (map cadr lst)\n                  '()))))\n",
    "  (if (null? lst)\n      (list '() '())\n      (let* ([first (car lst)]\n             [rest (cdr lst)]\n             [merged (merge rest)]\n             [first-lst (car merged)]\n             [second-lst (cadr merged)])\n        (list (cons (car first) first-lst)\n              (cons (cadr first) second-lst)))))\n"
  ]
}