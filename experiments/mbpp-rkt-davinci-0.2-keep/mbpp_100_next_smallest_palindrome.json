{
  "name": "mbpp_100_next_smallest_palindrome",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n(define (next_smallest_palindrome num)\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_100_next_smallest_palindrome.py",
  "prompt_terminology": "verbatim",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate next_smallest_palindrome))\n    (check-equal? (candidate 99) 101)\n    (check-equal? (candidate 1221) 1331)\n    (check-equal? (candidate 120) 121)\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (define (is_palindrome? num)\n    (define (helper num rev)\n      (if (= num 0)\n          (= rev 0)\n          (helper (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n    (helper num 0))\n  (define (helper num)\n    (if (is_palindrome? num)\n        num\n        (helper (+ num 1))))\n  (helper (+ num 1)))\n",
    "  (let* ([str (number->string num)]\n         [len (string-length str)]\n         [half-len (quotient len 2)]\n         [left (substring str 0 half-len)]\n         [right (substring str (- len half-len))]\n         [left-num (string->number left)]\n         [right-num (string->number right)])\n    (cond [(and (= left-num right-num) (= len 1)) (+ num 1)]\n          [(and (= left-num right-num) (= len 2)) (+ num 11)]\n          [(and (= left-num right-num) (= len 3)) (+ num 101)]\n          [(and (= left-num right-num) (= len 4)) (+ num 1001)]\n          [(and (= left-num right-num) (= len 5)) (+ num 10001)]\n          [(and (= left-num right-num) (= len 6)) (+ num 100001)]\n          [(and (= left-num right-num) (= len 7)) (+ num 1000001)]\n          [(and (= left-num right-num) (= len 8)) (+ num 10000001)]\n          [(and (= left-num right-num) (= len 9)) (+ num 100000001)]\n          [(and (= left-num right-num) (= len 10)) (+ num 1000000001)]\n          [(and (= left-num right-num) (= len 11)) (+ num 10000000001)]\n          [(and (= left-num right-num) (= len 12)) (+ num 100000000001)]\n          [(and (= left-num right-num) (= len 13)) (+ num 1000000000001)]\n          [(and (= left-num right-num) (= len 14)) (+ num 10000000000001)]\n          [(and (= left-num right-num) (= len 15)) (+ num 100000000000001)]\n          [(and (= left-num right-num) (= len 16)) (+ num 1000000000000001)]\n          [(and (= left-num right-num) (= len 17)) (+ num 10000000000000001)]\n          [(and (= left-num right-num) (= len 18)) (+ num 100000000000000001)]\n          [(and (= left-num right-num) (= len 19)) (+ num 10000000000000000001)]\n          [(and (= left-num right-",
    "  (define (is_palindrome? num)\n    (define (reverse-digits num)\n      (define (iter num rev)\n        (if (zero? num)\n            rev\n            (iter (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n      (iter num 0))\n    (= num (reverse-digits num)))\n  (define (next-palindrome num)\n    (if (is_palindrome? num)\n        num\n        (next-palindrome (+ num 1))))\n  (next-palindrome num))\n",
    "  (define (is_palindrome? num)\n    (define (helper num)\n      (if (zero? num)\n          #t\n          (and (even? num)\n               (helper (quotient num 10)))))\n    (helper num))\n  (define (helper num)\n    (if (is_palindrome? num)\n        num\n        (helper (+ num 1))))\n  (helper num))\n",
    "  (let* ([str (number->string num)]\n         [len (string-length str)]\n         [half-len (quotient len 2)]\n         [left (substring str 0 half-len)]\n         [right (substring str (add half-len (if (odd? len) 1 0)) half-len)])\n    (if (string=? left (string-reverse right))\n        (next_smallest_palindrome (add num 1))\n        (string->number (string-append left (string-reverse left))))))\n",
    "  (define (is_palindrome? num)\n    (define (reverse-digits num)\n      (define (reverse-digits-iter num rev)\n        (if (zero? num)\n            rev\n            (reverse-digits-iter (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n      (reverse-digits-iter num 0))\n    (= num (reverse-digits num)))\n  (define (next-palindrome-iter num)\n    (if (is_palindrome? num)\n        num\n        (next-palindrome-iter (+ num 1))))\n  (next-palindrome-iter num))\n",
    "  (let ([str (number->string num)])\n    (string-&gt;number (string-append str (reverse str)))))\n",
    "  (let ([str (number->string num)])\n    (cond\n      [(string=? str (reverse str))\n       (let ([next (add1 num)])\n         (if (string=? (number->string next) (reverse (number->string next)))\n             next\n             (next_smallest_palindrome next)))]\n      [else\n       (let ([len (string-length str)])\n         (let ([mid (quotient len 2)])\n           (let ([left (substring str 0 mid)])\n             (let ([right (reverse left)])\n               (let ([pal (string-append left right)])\n                 (if (&lt;= (string-&gt;number pal) num)\n                     (let ([next (add1 (string-&gt;number pal))])\n                       (next_smallest_palindrome next))\n                     (string-&gt;number pal))))))))])))\n",
    "  (let ([num-str (number->string num)])\n    (if (string=? num-str (string-reverse num-str))\n        num\n        (next_smallest_palindrome (add1 num)))))\n",
    "  (define (is_palindrome? num)\n    (define (reverse-num num)\n      (define (reverse-num-iter num rev)\n        (if (= num 0)\n            rev\n            (reverse-num-iter (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n      (reverse-num-iter num 0))\n    (= num (reverse-num num)))\n  (define (next-palindrome-iter num)\n    (if (is_palindrome? num)\n        num\n        (next-palindrome-iter (+ 1 num))))\n  (next-palindrome-iter num))\n",
    "  (let loop ([num num] [digits (number->string num)] [len (string-length digits)])\n    (cond [(= len 1) (+ num 1)]\n          [(= len 2) (if (= (string-ref digits 0) (string-ref digits 1))\n                        (+ (* num 100) 11)\n                        (+ (* num 100) (+ (string->number (substring digits 1 2)) 1)))]\n          [(= (string-ref digits 0) (string-ref digits (- len 1)))\n           (loop (* num 10) (substring digits 1 (- len 1)) (- len 2))]\n          [else (loop (+ (* num 10) (string->number (substring digits 1 2)))\n                      (substring digits 1 (- len 1))\n                      (- len 2))])))\n",
    "  (let ([str (number->string num)])\n    (cond\n      [(string-&gt;number (string-append str (string-reverse str)))\n       (string-&gt;number (string-append str (string-reverse str)))]\n      [else\n       (next_smallest_palindrome (add1 num))])))\n",
    "  (define (is_palindrome? num)\n    (define (reverse num)\n      (define (reverse-iter num rev)\n        (if (zero? num)\n            rev\n            (reverse-iter (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n      (reverse-iter num 0))\n    (if (= num (reverse num))\n        #t\n        #f))\n  (define (next-iter num)\n    (if (is_palindrome? num)\n        num\n        (next-iter (+ num 1))))\n  (next-iter num))\n",
    "  (define (is_palindrome? num)\n    (define (helper num rev)\n      (if (&lt; num 10)\n          (= num rev)\n          (helper (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n    (helper num 0))\n\n  (define (helper num)\n    (if (is_palindrome? num)\n        num\n        (helper (+ num 1))))\n\n  (helper (+ num 1)))\n</code>\n",
    "  (define (reverse-num num)\n    (define (reverse-num-iter num rev)\n      (if (zero? num)\n          rev\n          (reverse-num-iter (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n    (reverse-num-iter num 0))\n  (define (is-palindrome? num)\n    (if (= num (reverse-num num))\n        #t\n        #f))\n  (define (next-palindrome-iter num)\n    (if (is-palindrome? num)\n        num\n        (next-palindrome-iter (+ num 1))))\n  (next-palindrome-iter num))\n",
    "  (define (is_palindrome? num)\n    (define (helper num rev)\n      (if (zero? num)\n          (= rev 0)\n          (helper (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n    (helper num 0))\n  (define (helper num)\n    (if (is_palindrome? num)\n        num\n        (helper (+ num 1))))\n  (helper (+ num 1)))\n",
    "  (define (is_palindrome? num)\n    (define (helper num rev)\n      (if (&lt; num 10)\n          (= num rev)\n          (helper (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n    (helper num 0))\n  (define (helper num)\n    (if (is_palindrome? num)\n        num\n        (helper (+ num 1))))\n  (helper (+ num 1)))\n",
    "  (define (palindrome? num)\n    (define (reverse num)\n      (define (reverse-iter num rev)\n        (if (zero? num)\n            rev\n            (reverse-iter (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n      (reverse-iter num 0))\n    (if (= num (reverse num))\n        #t\n        #f))\n  (define (next-palindrome-iter num)\n    (if (palindrome? num)\n        num\n        (next-palindrome-iter (+ num 1))))\n  (next-palindrome-iter num))\n",
    "  (let ([str (number->string num)])\n    (if (string-palindrome? str)\n        (next_smallest_palindrome (+ num 1))\n        (string-&gt;number (next-palindrome str)))))\n",
    "  (define (reverse-num num)\n    (define (reverse-num-iter num rev)\n      (if (= num 0)\n          rev\n          (reverse-num-iter (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n    (reverse-num-iter num 0))\n  (define (is-palindrome? num)\n    (= num (reverse-num num)))\n  (define (next-palindrome-iter num)\n    (if (is-palindrome? num)\n        num\n        (next-palindrome-iter (+ num 1))))\n  (next-palindrome-iter num))\n"
  ]
}