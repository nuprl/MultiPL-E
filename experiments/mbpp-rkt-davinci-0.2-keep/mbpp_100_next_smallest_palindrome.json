{
  "name": "mbpp_100_next_smallest_palindrome",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n(define (next_smallest_palindrome num)\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_100_next_smallest_palindrome.py",
  "prompt_terminology": "verbatim",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate next_smallest_palindrome))\n    (check-equal? (candidate 99) 101)\n    (check-equal? (candidate 1221) 1331)\n    (check-equal? (candidate 120) 121)\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (define (is_palindrome? num)\n    (define (helper num rev)\n      (if (= num 0)\n          (= rev 0)\n          (helper (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n    (helper num 0))\n  (define (helper num)\n    (if (is_palindrome? num)\n        num\n        (helper (+ num 1))))\n  (helper (+ num 1)))\n",
    "  (let* ([str (number->string num)]\n         [len (string-length str)]\n         [half-len (quotient len 2)]\n         [left (substring str 0 half-len)]\n         [right (substring str (- len half-len))]\n         [left-num (string->number left)]\n         [right-num (string->number right)])\n    (cond [(and (= left-num right-num) (= len 1)) (+ num 1)]\n          [(and (= left-num right-num) (= len 2)) (+ num 11)]\n          [(and (= left-num right-num) (= len 3)) (+ num 101)]\n          [(and (= left-num right-num) (= len 4)) (+ num 1001)]\n          [(and (= left-num right-num) (= len 5)) (+ num 10001)]\n          [(and (= left-num right-num) (= len 6)) (+ num 100001)]\n          [(and (= left-num right-num) (= len 7)) (+ num 1000001)]\n          [(and (= left-num right-num) (= len 8)) (+ num 10000001)]\n          [(and (= left-num right-num) (= len 9)) (+ num 100000001)]\n          [(and (= left-num right-num) (= len 10)) (+ num 1000000001)]\n          [(and (= left-num right-num) (= len 11)) (+ num 10000000001)]\n          [(and (= left-num right-num) (= len 12)) (+ num 100000000001)]\n          [(and (= left-num right-num) (= len 13)) (+ num 1000000000001)]\n          [(and (= left-num right-num) (= len 14)) (+ num 10000000000001)]\n          [(and (= left-num right-num) (= len 15)) (+ num 100000000000001)]\n          [(and (= left-num right-num) (= len 16)) (+ num 1000000000000001)]\n          [(and (= left-num right-num) (= len 17)) (+ num 10000000000000001)]\n          [(and (= left-num right-num) (= len 18)) (+ num 100000000000000001)]\n          [(and (= left-num right-num) (= len 19)) (+ num 10000000000000000001)]\n          [(and (= left-num right-",
    "  (define (is_palindrome? num)\n    (define (reverse-digits num)\n      (define (iter num rev)\n        (if (zero? num)\n            rev\n            (iter (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n      (iter num 0))\n    (= num (reverse-digits num)))\n  (define (next-palindrome num)\n    (if (is_palindrome? num)\n        num\n        (next-palindrome (+ num 1))))\n  (next-palindrome num))\n",
    "  (define (is_palindrome? num)\n    (define (helper num)\n      (if (zero? num)\n          #t\n          (and (even? num)\n               (helper (quotient num 10)))))\n    (helper num))\n  (define (helper num)\n    (if (is_palindrome? num)\n        num\n        (helper (+ num 1))))\n  (helper num))\n",
    "  (let* ([str (number->string num)]\n         [len (string-length str)]\n         [half-len (quotient len 2)]\n         [left (substring str 0 half-len)]\n         [right (substring str (add half-len (if (odd? len) 1 0)) half-len)])\n    (if (string=? left (string-reverse right))\n        (next_smallest_palindrome (add num 1))\n        (string->number (string-append left (string-reverse left))))))\n",
    "  (define (is_palindrome? num)\n    (define (reverse-digits num)\n      (define (reverse-digits-iter num rev)\n        (if (zero? num)\n            rev\n            (reverse-digits-iter (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n      (reverse-digits-iter num 0))\n    (= num (reverse-digits num)))\n  (define (next-palindrome-iter num)\n    (if (is_palindrome? num)\n        num\n        (next-palindrome-iter (+ num 1))))\n  (next-palindrome-iter num))\n",
    "  (let ([str (number->string num)])\n    (string-&gt;number (string-append str (reverse str)))))\n",
    "  (let ([str (number->string num)])\n    (cond\n      [(string=? str (reverse str))\n       (let ([next (add1 num)])\n         (if (string=? (number->string next) (reverse (number->string next)))\n             next\n             (next_smallest_palindrome next)))]\n      [else\n       (let ([len (string-length str)])\n         (let ([mid (quotient len 2)])\n           (let ([left (substring str 0 mid)])\n             (let ([right (reverse left)])\n               (let ([pal (string-append left right)])\n                 (if (&lt;= (string-&gt;number pal) num)\n                     (let ([next (add1 (string-&gt;number pal))])\n                       (next_smallest_palindrome next))\n                     (string-&gt;number pal))))))))])))\n",
    "  (let ([num-str (number->string num)])\n    (if (string=? num-str (string-reverse num-str))\n        num\n        (next_smallest_palindrome (add1 num)))))\n",
    "  (define (is_palindrome? num)\n    (define (reverse-num num)\n      (define (reverse-num-iter num rev)\n        (if (= num 0)\n            rev\n            (reverse-num-iter (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n      (reverse-num-iter num 0))\n    (= num (reverse-num num)))\n  (define (next-palindrome-iter num)\n    (if (is_palindrome? num)\n        num\n        (next-palindrome-iter (+ 1 num))))\n  (next-palindrome-iter num))\n",
    "  (let loop ([num num] [digits (number->string num)] [len (string-length digits)])\n    (cond [(= len 1) (+ num 1)]\n          [(= len 2) (if (= (string-ref digits 0) (string-ref digits 1))\n                        (+ (* num 100) 11)\n                        (+ (* num 100) (+ (string->number (substring digits 1 2)) 1)))]\n          [(= (string-ref digits 0) (string-ref digits (- len 1)))\n           (loop (* num 10) (substring digits 1 (- len 1)) (- len 2))]\n          [else (loop (+ (* num 10) (string->number (substring digits 1 2)))\n                      (substring digits 1 (- len 1))\n                      (- len 2))])))\n",
    "  (let ([str (number->string num)])\n    (cond\n      [(string-&gt;number (string-append str (string-reverse str)))\n       (string-&gt;number (string-append str (string-reverse str)))]\n      [else\n       (next_smallest_palindrome (add1 num))])))\n",
    "  (define (is_palindrome? num)\n    (define (reverse num)\n      (define (reverse-iter num rev)\n        (if (zero? num)\n            rev\n            (reverse-iter (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n      (reverse-iter num 0))\n    (if (= num (reverse num))\n        #t\n        #f))\n  (define (next-iter num)\n    (if (is_palindrome? num)\n        num\n        (next-iter (+ num 1))))\n  (next-iter num))\n",
    "  (define (is_palindrome? num)\n    (define (helper num rev)\n      (if (&lt; num 10)\n          (= num rev)\n          (helper (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n    (helper num 0))\n\n  (define (helper num)\n    (if (is_palindrome? num)\n        num\n        (helper (+ num 1))))\n\n  (helper (+ num 1)))\n</code>\n",
    "  (define (reverse-num num)\n    (define (reverse-num-iter num rev)\n      (if (zero? num)\n          rev\n          (reverse-num-iter (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n    (reverse-num-iter num 0))\n  (define (is-palindrome? num)\n    (if (= num (reverse-num num))\n        #t\n        #f))\n  (define (next-palindrome-iter num)\n    (if (is-palindrome? num)\n        num\n        (next-palindrome-iter (+ num 1))))\n  (next-palindrome-iter num))\n",
    "  (define (is_palindrome? num)\n    (define (helper num rev)\n      (if (zero? num)\n          (= rev 0)\n          (helper (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n    (helper num 0))\n  (define (helper num)\n    (if (is_palindrome? num)\n        num\n        (helper (+ num 1))))\n  (helper (+ num 1)))\n",
    "  (define (is_palindrome? num)\n    (define (helper num rev)\n      (if (&lt; num 10)\n          (= num rev)\n          (helper (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n    (helper num 0))\n  (define (helper num)\n    (if (is_palindrome? num)\n        num\n        (helper (+ num 1))))\n  (helper (+ num 1)))\n",
    "  (define (palindrome? num)\n    (define (reverse num)\n      (define (reverse-iter num rev)\n        (if (zero? num)\n            rev\n            (reverse-iter (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n      (reverse-iter num 0))\n    (if (= num (reverse num))\n        #t\n        #f))\n  (define (next-palindrome-iter num)\n    (if (palindrome? num)\n        num\n        (next-palindrome-iter (+ num 1))))\n  (next-palindrome-iter num))\n",
    "  (let ([str (number->string num)])\n    (if (string-palindrome? str)\n        (next_smallest_palindrome (+ num 1))\n        (string-&gt;number (next-palindrome str)))))\n",
    "  (define (reverse-num num)\n    (define (reverse-num-iter num rev)\n      (if (= num 0)\n          rev\n          (reverse-num-iter (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n    (reverse-num-iter num 0))\n  (define (is-palindrome? num)\n    (= num (reverse-num num)))\n  (define (next-palindrome-iter num)\n    (if (is-palindrome? num)\n        num\n        (next-palindrome-iter (+ num 1))))\n  (next-palindrome-iter num))\n",
    "  (define (is_palindrome? num)\n    (define (reverse-digits num)\n      (define (reverse-digits-iter num result)\n        (if (zero? num)\n            result\n            (reverse-digits-iter (quotient num 10) (+ (* result 10) (remainder num 10)))))\n      (reverse-digits-iter num 0))\n    (if (= num (reverse-digits num))\n        #t\n        #f))\n  (define (next-palindrome-iter num)\n    (if (is_palindrome? num)\n        num\n        (next-palindrome-iter (+ num 1))))\n  (next-palindrome-iter num))\n",
    "  (let loop ([num num] [num-str (number->string num)] [num-len (string-length num-str)])\n    (cond [(= num-len 1) (+ num 1)]\n          [(= num-len 2) (if (= (string-ref num-str 0) (string-ref num-str 1))\n                            (+ num 11)\n                            (+ num 1))]\n          [else (let ([num-str-len-half (quotient num-len 2)])\n                  (let ([num-str-left (substring num-str 0 num-str-len-half)]\n                        [num-str-right (substring num-str num-str-len-half num-len)])\n                    (let ([num-str-left-rev (reverse num-str-left)])\n                      (if (string=? num-str-left num-str-left-rev)\n                          (let ([num-str-left-rev-int (string->number num-str-left-rev)])\n                            (if (= num-str-left-rev-int 9)\n                                (loop (+ num 100) (number->string (+ num 100)) (+ num-len 2))\n                                (loop (+ num 1) (number->string (+ num 1)) num-len)))\n                          (let ([num-str-left-rev-int (string->number num-str-left-rev)])\n                            (loop (+ num-str-left-rev-int 1) (number->string (+ num-str-left-rev-int 1)) num-len))))))))))\n",
    "  (define (is_palindrome? num)\n    (define (helper num rev)\n      (if (zero? num)\n          (if (= rev 0)\n              #t\n              #f)\n          (helper (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n    (helper num 0))\n  (define (helper num)\n    (if (is_palindrome? num)\n        num\n        (helper (+ num 1))))\n  (helper num))\n",
    "  (define (is_palindrome? num)\n    (define (helper num rev)\n      (if (zero? num)\n          (if (= rev 0)\n              #t\n              #f)\n          (helper (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n    (helper num 0))\n  (define (helper num)\n    (if (is_palindrome? num)\n        num\n        (helper (+ num 1))))\n  (helper num))\n",
    "  (define (is_palindrome? num)\n    (define (reverse num)\n      (define (iter num rev)\n        (if (zero? num)\n            rev\n            (iter (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n      (iter num 0))\n    (if (= num (reverse num))\n        #t\n        #f))\n  (define (iter num)\n    (if (is_palindrome? num)\n        num\n        (iter (+ num 1))))\n  (iter num))\n",
    "  (let ([str (number->string num)])\n    (if (string=? str (string-reverse str))\n        (next_smallest_palindrome (+ num 1))\n        (string->number (string-append str (string-reverse (substring str 0 (quotient (string-length str) 2))))))))\n",
    "  (let ([num-str (number->string num)])\n    (cond [(string-&gt;number (string-append (reverse num-str) num-str)) =&gt; number-&gt;string]\n          [else (next_smallest_palindrome (+ num 1))])))\n</code>\n",
    "  (let loop ([n num])\n    (cond [(= n 0) 0]\n          [(= (modulo n 10) 9) (loop (quotient n 10))]\n          [else (+ (* 10 (next_smallest_palindrome (quotient n 10)))\n                   (modulo n 10))])))\n",
    "  (if (palindrome? num)\n      (next-palindrome-helper num)\n      (next-palindrome-helper (next-palindrome-helper num))))\n",
    "  (define (reverse-string str)\n    (define (reverse-string-helper str result)\n      (if (string-empty? str)\n          result\n          (reverse-string-helper (substring str 1) (string-append result (string (string-ref str 0))))))\n    (reverse-string-helper str \"\"))\n  (define (is-palindrome? str)\n    (string=? str (reverse-string str)))\n  (define (next-palindrome-helper num)\n    (if (is-palindrome? (number->string num))\n        num\n        (next-palindrome-helper (+ num 1))))\n  (next-palindrome-helper (+ num 1)))\n",
    "  (define (reverse-num n)\n    (define (reverse-num-iter n result)\n      (if (= n 0)\n          result\n          (reverse-num-iter (quotient n 10) (+ (* result 10) (remainder n 10)))))\n    (reverse-num-iter n 0))\n\n  (define (is-palindrome? n)\n    (= n (reverse-num n)))\n\n  (define (next-palindrome-iter n)\n    (if (is-palindrome? n)\n        n\n        (next-palindrome-iter (+ n 1))))\n\n  (next-palindrome-iter (+ num 1)))\n",
    "  (let loop ([num num])\n    (if (palindrome? num)\n        num\n        (loop (+ num 1)))))\n",
    "  (define (is_palindrome? num)\n    (define (iter num rev)\n      (if (zero? num)\n          (if (= rev 0)\n              #t\n              #f)\n          (iter (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n    (iter num 0))\n  (define (iter num)\n    (if (is_palindrome? num)\n        num\n        (iter (+ num 1))))\n  (iter num))\n",
    "  (let ([str (number->string num)])\n    (if (string=? str (string-reverse str))\n        (next_smallest_palindrome (+ num 1))\n        (string->number (string-append str (string-reverse (substring str 0 (quotient (string-length str) 2))))))))\n",
    "  (define (reverse-num num)\n    (define (reverse-num-iter num rev)\n      (if (zero? num)\n          rev\n          (reverse-num-iter (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n    (reverse-num-iter num 0))\n  (define (is-palindrome? num)\n    (= num (reverse-num num)))\n  (define (next-palindrome-iter num)\n    (if (is-palindrome? num)\n        num\n        (next-palindrome-iter (+ num 1))))\n  (next-palindrome-iter num))\n",
    "  (define (is_palindrome? num)\n    (equal? (list->string (list->string num)) (list->string (reverse (list->string num)))))\n  (define (next_smallest_palindrome-helper num)\n    (if (is_palindrome? num)\n        num\n        (next_smallest_palindrome-helper (- num 1))))\n  (next_smallest_palindrome-helper num))\n",
    "  (let loop ([n num])\n    (if (palindrome? n)\n        n\n        (loop (+ n 1)))))\n",
    "  (define (is_palindrome? num)\n    (define (reverse-digits num)\n      (define (helper num acc)\n        (if (zero? num)\n            acc\n            (helper (quotient num 10) (+ (* acc 10) (remainder num 10)))))\n      (helper num 0))\n    (if (= num (reverse-digits num))\n        #t\n        #f))\n  (define (next-palindrome num)\n    (if (is_palindrome? num)\n        num\n        (next-palindrome (+ num 1))))\n  (next-palindrome num))\n",
    "  (define (reverse_num num)\n    (define (reverse_num_iter num rev)\n      (if (= num 0)\n          rev\n          (reverse_num_iter (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n    (reverse_num_iter num 0))\n  (define (is_palindrome num)\n    (if (= num (reverse_num num))\n        #t\n        #f))\n  (define (next_smallest_palindrome_iter num)\n    (if (is_palindrome num)\n        num\n        (next_smallest_palindrome_iter (- num 1))))\n  (next_smallest_palindrome_iter num))\n",
    "  (define (is_palindrome? num)\n    (define (reverse-num num)\n      (define (reverse-num-iter num reversed-num)\n        (if (zero? num)\n            reversed-num\n            (reverse-num-iter (quotient num 10) (+ (* reversed-num 10) (remainder num 10)))))\n      (reverse-num-iter num 0))\n    (= num (reverse-num num)))\n  (define (next-palindrome-iter num)\n    (if (is_palindrome? num)\n        num\n        (next-palindrome-iter (+ num 1))))\n  (next-palindrome-iter num))\n",
    "  (let* ([str (number->string num)]\n         [len (string-length str)]\n         [mid (/ len 2)]\n         [left (substring str 0 mid)]\n         [right (substring str mid len)])\n    (cond\n      [(string=? left (string-reverse right))\n       (next_smallest_palindrome (+ num 1))]\n      [(string=? left (string-reverse (substring right 1 len)))\n       (string->number (string-append left (string-reverse left)))]\n      [else\n       (string->number (string-append left (string-reverse left)))])))\n",
    "  (define (reverse-num n)\n    (define (reverse-num-iter n rev)\n      (if (= n 0)\n          rev\n          (reverse-num-iter (quotient n 10) (+ (* rev 10) (remainder n 10)))))\n    (reverse-num-iter n 0))\n  (define (is-palindrome n)\n    (= n (reverse-num n)))\n  (define (next-palindrome n)\n    (if (is-palindrome n)\n        n\n        (next-palindrome (+ n 1))))\n  (next-palindrome num))\n",
    "  (if (palindrome? num)\n      (next-palindrome num)\n      (next-palindrome (next-palindrome num))))\n",
    "  (define (is_palindrome? num)\n    (define (is_palindrome?-iter num rev)\n      (if (= num 0)\n          (= num rev)\n          (is_palindrome?-iter (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n    (is_palindrome?-iter num 0))\n  (define (next-palindrome? num)\n    (if (is_palindrome? num)\n        num\n        (next-palindrome? (+ num 1))))\n  (next-palindrome? (+ num 1)))\n",
    "  (define (reverse-digits num)\n    (define (reverse-digits-iter num rev)\n      (if (zero? num)\n          rev\n          (reverse-digits-iter (/ num 10) (+ (* rev 10) (remainder num 10)))))\n    (reverse-digits-iter num 0))\n  (define (is-palindrome? num)\n    (if (= num (reverse-digits num))\n        #t\n        #f))\n  (define (next-palindrome-iter num)\n    (if (is-palindrome? num)\n        num\n        (next-palindrome-iter (+ num 1))))\n  (next-palindrome-iter num))\n",
    "  (define (is_palindrome? num)\n    (define (helper num rev)\n      (if (= num 0)\n          (= rev 0)\n          (helper (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n    (helper num 0))\n  (define (helper num)\n    (if (is_palindrome? num)\n        num\n        (helper (+ num 1))))\n  (helper (+ num 1)))\n",
    "  (define (is-palindrome? num)\n    (define (reverse-digits num)\n      (define (reverse-digits-iter num acc)\n        (if (zero? num)\n            acc\n            (reverse-digits-iter (quotient num 10) (+ (* acc 10) (remainder num 10)))))\n      (reverse-digits-iter num 0))\n    (= num (reverse-digits num)))\n  (define (next-palindrome num)\n    (if (is-palindrome? num)\n        num\n        (next-palindrome (+ num 1))))\n  (next-palindrome num))\n",
    "  (define (is_palindrome? num)\n    (define (reverse-num num)\n      (define (reverse-num-iter num rev)\n        (if (zero? num)\n            rev\n            (reverse-num-iter (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n      (reverse-num-iter num 0))\n    (if (= num (reverse-num num))\n        #t\n        #f))\n  (define (next-smallest-palindrome-iter num)\n    (if (is_palindrome? num)\n        num\n        (next-smallest-palindrome-iter (- num 1))))\n  (next-smallest-palindrome-iter num))\n",
    "  (let ([str (number->string num)])\n    (if (not (string=? (reverse str) str))\n        (let ([len (string-length str)])\n          (if (even? len)\n              (let ([half-len (/ len 2)])\n                (let ([left (substring str 0 half-len)]\n                      [right (substring str half-len)])\n                  (if (string=? left right)\n                      (string-&gt;number (string-append left (reverse left)))\n                      (string-&gt;number (string-append left (reverse left) (substring str half-len 1)))))\n              (let ([half-len (/ (- len 1) 2)])\n                (let ([left (substring str 0 half-len)]\n                      [right (substring str (+ half-len 1))])\n                  (if (string=? left right)\n                      (string-&gt;number (string-append left (substring str half-len 1) (reverse left)))\n                      (string-&gt;number (string-append left (substring str half-len 1) (reverse left) (substring str half-len 1))))))))\n        num)))\n",
    "  (define (reverse-digits num)\n    (define (reverse-digits-iter num acc)\n      (if (zero? num)\n          acc\n          (reverse-digits-iter (quotient num 10) (+ (* acc 10) (remainder num 10)))))\n    (reverse-digits-iter num 0))\n  (define (is-palindrome? num)\n    (if (= num (reverse-digits num))\n        #t\n        #f))\n  (define (next-palindrome-iter num)\n    (if (is-palindrome? num)\n        num\n        (next-palindrome-iter (+ num 1))))\n  (next-palindrome-iter (+ num 1)))\n",
    "  (let loop ([num num])\n    (if (palindrome? num)\n        num\n        (loop (+ num 1)))))\n",
    "  (let ([num-str (number->string num)])\n    (if (equal? (string-length num-str) 1)\n        (string->number (string-append num-str num-str))\n        (let ([mid (quotient (string-length num-str) 2)])\n          (let ([left (substring num-str 0 mid)])\n            (let ([right (substring num-str mid)])\n              (let ([left-rev (reverse left)])\n                (if (equal? left left-rev)\n                    (let ([left-int (string->number left)])\n                      (let ([left-int-plus-one (+ left-int 1)])\n                        (let ([left-plus-one (number->string left-int-plus-one)])\n                          (let ([left-plus-one-rev (reverse left-plus-one)])\n                            (if (equal? left-plus-one left-plus-one-rev)\n                                (string->number (string-append left-plus-one left-plus-one-rev))\n                                (string->number (string-append left-plus-one left-plus-one-rev)))))\n                          ))))\n                    (string->number (string-append left left-rev))))))))))\n",
    "  (cond\n    [(= num 0) 1]\n    [(= num 1) 2]\n    [(= num 2) 3]\n    [(= num 3) 4]\n    [(= num 4) 5]\n    [(= num 5) 6]\n    [(= num 6) 7]\n    [(= num 7) 8]\n    [(= num 8) 9]\n    [(= num 9) 11]\n    [(= num 10) 11]\n    [(= num 11) 22]\n    [(= num 12) 22]\n    [(= num 13) 22]\n    [(= num 14) 22]\n    [(= num 15) 22]\n    [(= num 16) 22]\n    [(= num 17) 22]\n    [(= num 18) 22]\n    [(= num 19) 22]\n    [(= num 20) 22]\n    [(= num 21) 22]\n    [(= num 22) 33]\n    [(= num 23) 33]\n    [(= num 24) 33]\n    [(= num 25) 33]\n    [(= num 26) 33]\n    [(= num 27) 33]\n    [(= num 28) 33]\n    [(= num 29) 33]\n    [(= num 30) 33]\n    [(= num 31) 33]\n    [(= num 32) 33]\n    [(= num 33) 44]\n    [(= num 34) 44]\n    [(= num 35) 44]\n    [(= num 36) 44]\n    [(= num 37) 44]\n    [(= num 38) 44]\n    [(= num 39) 44]\n    [(= num 40) 44]\n    [(= num 41) 44]\n    [(= num 42) 44]\n    [(= num 43) 44]\n    [(= num 44) 55]\n    [(= num 45) 55]\n    [(= num 46) 55]\n    [(= num 47) 55]\n    [(= num 48) 55]\n    [(= num 49) 55]\n    [(= num 50) 55]\n    [(= num 51) 55]\n    [(= num 52) 55]\n    [(= num 53) 55]\n    [(= num 54) 55]\n    [(= num 55) 66]\n    [(=",
    "  (let loop ([num (+ num 1)])\n    (if (palindrome? (number->string num))\n        num\n        (loop (+ num 1)))))\n",
    "  (let ([str (number->string num)])\n    (if (string=? str (reverse str))\n        (next_smallest_palindrome (+ num 1))\n        (string->number (string-append (reverse (substring str 0 (quotient (string-length str) 2)))\n                                       (reverse (substring str (quotient (string-length str) 2))))))))\n",
    "  (define (is_palindrome? num)\n    (define (reverse-num num)\n      (define (reverse-num-iter num acc)\n        (if (zero? num)\n            acc\n            (reverse-num-iter (quotient num 10) (+ (* acc 10) (remainder num 10)))))\n      (reverse-num-iter num 0))\n    (= num (reverse-num num)))\n  (define (next-palindrome-iter num)\n    (if (is_palindrome? num)\n        num\n        (next-palindrome-iter (+ num 1))))\n  (next-palindrome-iter num))\n",
    "  (define (is_palindrome? num)\n    (define (helper num rev)\n      (if (zero? num)\n          (= rev 0)\n          (helper (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n    (helper num 0))\n  (define (helper num)\n    (if (is_palindrome? num)\n        num\n        (helper (+ 1 num))))\n  (helper num))\n",
    "  (define (is_palindrome? num)\n    (define (reverse-num num)\n      (define (reverse-num-iter num acc)\n        (if (= num 0)\n            acc\n            (reverse-num-iter (/ num 10) (+ (* acc 10) (modulo num 10)))))\n      (reverse-num-iter num 0))\n    (= num (reverse-num num)))\n  (define (next-palindrome-iter num)\n    (if (is_palindrome? num)\n        num\n        (next-palindrome-iter (+ num 1))))\n  (next-palindrome-iter num))\n",
    "  (define (reverse-num num)\n    (if (zero? num)\n        0\n        (+ (* 10 (reverse-num (quotient num 10))) (remainder num 10))))\n  (define (is-palindrome? num)\n    (= num (reverse-num num)))\n  (define (next-palindrome num)\n    (if (is-palindrome? num)\n        num\n        (next-palindrome (+ num 1))))\n  (next-palindrome num))\n",
    "  (let ([str (number->string num)])\n    (if (string=? str (string-reverse str))\n        num\n        (next_smallest_palindrome (add1 num)))))\n",
    "  (define (is_palindrome? num)\n    (define (reverse_num num)\n      (define (iter num rev)\n        (if (zero? num)\n            rev\n            (iter (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n      (iter num 0))\n    (= num (reverse_num num)))\n  (define (iter num)\n    (if (is_palindrome? num)\n        num\n        (iter (+ num 1))))\n  (iter num))\n",
    "  (cond\n    [(= num 0) 1]\n    [(= num 1) 2]\n    [(= num 2) 3]\n    [(= num 3) 4]\n    [(= num 4) 5]\n    [(= num 5) 6]\n    [(= num 6) 7]\n    [(= num 7) 8]\n    [(= num 8) 9]\n    [(= num 9) 11]\n    [else (next_smallest_palindrome (next_smallest_palindrome (quotient num 10)))]))\n",
    "  (define (is_palindrome? num)\n    (let ([str (number->string num)])\n      (equal? str (string-reverse str))))\n  (define (next_palindrome num)\n    (if (is_palindrome? num)\n        num\n        (next_palindrome (+ num 1))))\n  (next_palindrome num))\n",
    "  (define (is_palindrome? num)\n    (define (reverse-num num)\n      (define (reverse-num-iter num reversed)\n        (if (zero? num)\n            reversed\n            (reverse-num-iter (quotient num 10) (+ (* reversed 10) (remainder num 10)))))\n      (reverse-num-iter num 0))\n    (if (= num (reverse-num num))\n        #t\n        #f))\n  (define (next-palindrome-iter num)\n    (if (is_palindrome? num)\n        num\n        (next-palindrome-iter (+ num 1))))\n  (next-palindrome-iter num))\n",
    "  (if (palindrome? num)\n      (next-palindrome num)\n      (next-palindrome (next-palindrome num))))\n",
    "  (define (is_palindrome? num)\n    (define (reverse-num num)\n      (define (reverse-helper num acc)\n        (if (zero? num)\n            acc\n            (reverse-helper (quotient num 10) (+ (* acc 10) (remainder num 10)))))\n      (reverse-helper num 0))\n    (if (= num (reverse-num num))\n        #t\n        #f))\n  (define (next-palindrome-helper num)\n    (if (is_palindrome? num)\n        num\n        (next-palindrome-helper (+ num 1))))\n  (next-palindrome-helper num))\n",
    "  (define (reverse-num num)\n    (define (helper num acc)\n      (if (zero? num)\n          acc\n          (helper (quotient num 10) (+ (* acc 10) (remainder num 10)))))\n    (helper num 0))\n  (define (is-palindrome? num)\n    (if (= num (reverse-num num))\n        #t\n        #f))\n  (define (next-palindrome num)\n    (if (is-palindrome? num)\n        num\n        (next-palindrome (+ num 1))))\n  (next-palindrome (+ num 1)))\n",
    "  (define (reverse-num n)\n    (define (iter n acc)\n      (if (zero? n)\n          acc\n          (iter (quotient n 10) (+ (* acc 10) (remainder n 10)))))\n    (iter n 0))\n  (define (is-palindrome? n)\n    (if (= n (reverse-num n))\n        #t\n        #f))\n  (define (iter n)\n    (if (is-palindrome? n)\n        n\n        (iter (+ n 1))))\n  (iter (+ num 1)))\n",
    "  (define (reverse-num num)\n    (define (reverse-num-iter num rev)\n      (if (zero? num)\n          rev\n          (reverse-num-iter (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n    (reverse-num-iter num 0))\n\n  (define (is-palindrome? num)\n    (= num (reverse-num num)))\n\n  (define (next-palindrome num)\n    (if (is-palindrome? num)\n        num\n        (next-palindrome (+ num 1))))\n\n  (next-palindrome (+ num 1)))\n",
    "  (define (reverse-num num)\n    (define (helper num rev)\n      (if (&lt; num 10)\n          rev\n          (helper (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n    (helper num 0))\n\n  (define (is-palindrome? num)\n    (= num (reverse-num num)))\n\n  (define (find-next-palindrome num)\n    (if (is-palindrome? num)\n        num\n        (find-next-palindrome (+ num 1))))\n\n  (find-next-palindrome num))\n",
    "  (let loop ((num num)\n             (num-str (number->string num)))\n    (cond ((= num 0) (error \"No palindrome found\"))\n          ((palindrome? num-str) num)\n          (else (loop (- num 1) (number->string (- num 1)))))))\n",
    "  (if (palindrome? num)\n      (next-palindrome num)\n      (next-palindrome (next-palindrome num))))\n",
    "  (if (palindrome? num)\n      (next-palindrome num)\n      (next-palindrome (next-palindrome num))))\n",
    "  (let ([num-str (number->string num)])\n    (if (string-&gt;number (string-append (reverse num-str) num-str))\n        (string-&gt;number (string-append (reverse num-str) num-str))\n        (next_smallest_palindrome (+ num 1)))))\n",
    "  (define (is_palindrome? num)\n    (define (helper num rev)\n      (if (zero? num)\n          (= num rev)\n          (helper (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n    (helper num 0))\n  (define (helper num)\n    (if (is_palindrome? num)\n        num\n        (helper (+ num 1))))\n  (helper (+ num 1)))\n",
    "  (let ([num-str (number->string num)])\n    (if (string=? num-str (string-reverse num-str))\n        num\n        (next_smallest_palindrome (add1 num)))))\n",
    "  (define (reverse-num n)\n    (define (iter n acc)\n      (if (= n 0)\n          acc\n          (iter (quotient n 10) (+ (* acc 10) (remainder n 10)))))\n    (iter n 0))\n  (define (is-palindrome? n)\n    (= n (reverse-num n)))\n  (define (next-palindrome n)\n    (if (is-palindrome? n)\n        n\n        (next-palindrome (+ n 1))))\n  (next-palindrome (+ num 1)))\n",
    "  (if (palindrome? num)\n      (next-palindrome num)\n      (next-palindrome (next-palindrome num))))\n",
    "  (define (is_palindrome? num)\n    (define (helper num rev)\n      (if (zero? num)\n          (= rev 0)\n          (helper (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n    (helper num 0))\n  (define (next-palindrome num)\n    (if (is_palindrome? num)\n        (next-palindrome (+ num 1))\n        num))\n  (next-palindrome num))\n",
    "  (let loop ((n num) (i 1))\n    (if (= n 0)\n        (loop num i)\n        (if (palindrome? n)\n            n\n            (loop (+ n i) i)))))\n",
    "  (let ([str (number->string num)])\n    (if (string=? str (reverse str))\n        (next_smallest_palindrome (+ num 1))\n        (string->number (string-append str (reverse (substring str 0 (sub1 (string-length str)))))))))\n",
    "  (define (reverse-num num)\n    (if (= num 0)\n        0\n        (+ (* (reverse-num (quotient num 10)) 10) (remainder num 10))))\n  (define (next-palindrome num)\n    (if (= num 0)\n        0\n        (if (= (remainder num 10) 0)\n            (next-palindrome (quotient num 10))\n            (if (= (remainder num 10) 9)\n                (+ (* (next-palindrome (quotient num 10)) 10) 9)\n                (+ (* (quotient num 10) 10) (remainder num 10))))))\n  (if (= (reverse-num num) num)\n      (next-palindrome num)\n      (next-palindrome (next-palindrome num))))\n",
    "  (define (is_palindrome? num)\n    (define (reverse-num num)\n      (define (reverse-num-iter num rev)\n        (if (= num 0)\n            rev\n            (reverse-num-iter (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n      (reverse-num-iter num 0))\n    (= num (reverse-num num)))\n  (define (next-palindrome-iter num)\n    (if (is_palindrome? num)\n        num\n        (next-palindrome-iter (+ num 1))))\n  (next-palindrome-iter num))\n",
    "  (define (is_palindrome? num)\n    (define (reverse-digits num)\n      (define (helper num rev)\n        (if (zero? num) rev\n            (helper (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n      (helper num 0))\n    (= num (reverse-digits num)))\n  (define (next-palindrome num)\n    (if (is_palindrome? num) num\n        (next-palindrome (+ num 1))))\n  (next-palindrome num))\n",
    "  (define (reverse-num num)\n    (define (reverse-num-iter num rev)\n      (if (= num 0)\n          rev\n          (reverse-num-iter (/ num 10) (+ (* rev 10) (modulo num 10)))))\n    (reverse-num-iter num 0))\n  (define (is-palindrome? num)\n    (= num (reverse-num num)))\n  (define (next-palindrome num)\n    (if (is-palindrome? num)\n        num\n        (next-palindrome (+ num 1))))\n  (next-palindrome num))\n",
    "  (define (is_palindrome? num)\n    (define (reverse-num num)\n      (define (reverse-num-iter num rev-num)\n        (if (zero? num)\n            rev-num\n            (reverse-num-iter (quotient num 10) (+ (* rev-num 10) (remainder num 10)))))\n      (reverse-num-iter num 0))\n    (if (= num (reverse-num num))\n        #t\n        #f))\n  (define (next-palindrome-iter num)\n    (if (is_palindrome? num)\n        num\n        (next-palindrome-iter (+ num 1))))\n  (next-palindrome-iter (+ num 1)))\n",
    "  (define (reverse-num num)\n    (define (reverse-num-helper num rev-num)\n      (if (= num 0)\n          rev-num\n          (reverse-num-helper (quotient num 10) (+ (* rev-num 10) (remainder num 10)))))\n    (reverse-num-helper num 0))\n  (define (is-palindrome? num)\n    (= num (reverse-num num)))\n  (define (next-palindrome-helper num)\n    (if (is-palindrome? num)\n        num\n        (next-palindrome-helper (+ num 1))))\n  (next-palindrome-helper (+ num 1)))\n",
    "  (define (is_palindrome? num)\n    (define (helper num rev)\n      (if (= num 0)\n          (= rev 0)\n          (helper (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n    (helper num 0))\n  (define (helper num)\n    (if (is_palindrome? num)\n        num\n        (helper (+ num 1))))\n  (helper (+ num 1)))\n",
    "  (define (is_palindrome? num)\n    (define (helper num rev)\n      (if (zero? num)\n          (equal? rev num)\n          (helper (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n    (helper num 0))\n  (define (helper num)\n    (if (is_palindrome? num)\n        (helper (+ num 1))\n        num))\n  (helper (+ num 1)))\n",
    "  (let loop ([num num])\n    (if (palindrome? num)\n        num\n        (loop (+ num 1)))))\n",
    "  (define (is_palindrome? num)\n    (define (reverse num)\n      (define (iter num rev)\n        (if (zero? num)\n            rev\n            (iter (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n      (iter num 0))\n    (= num (reverse num)))\n  (define (iter num)\n    (if (is_palindrome? num)\n        num\n        (iter (+ num 1))))\n  (iter num))\n",
    "  (let ([str (number->string num)])\n    (if (not (palindrome? str))\n        (next_smallest_palindrome (add1 num))\n        num)))\n",
    "  (let ([num-str (number->string num)])\n    (cond [(string-palindrome? num-str)\n           (string->number (string-append num-str (reverse num-str)))]\n          [else\n           (let ([num-len (string-length num-str)])\n             (let ([half-len (quotient num-len 2)])\n               (let ([half-str (substring num-str 0 half-len)])\n                 (let ([half-str-rev (reverse half-str)])\n                   (let ([half-str-rev-num (string->number half-str-rev)])\n                     (let ([half-str-num (string->number half-str)])\n                       (let ([half-str-num-plus-1 (+ half-str-num 1)])\n                         (let ([half-str-num-plus-1-str (number->string half-str-num-plus-1)])\n                           (let ([half-str-num-plus-1-str-len (string-length half-str-num-plus-1-str)])\n                             (let ([half-str-num-plus-1-str-rev (reverse half-str-num-plus-1-str)])\n                               (let ([half-str-num-plus-1-str-rev-num (string->number half-str-num-plus-1-str-rev)])\n                                 (let ([half-str-num-plus-1-str-rev-num-plus-1 (+ half-str-num-plus-1-str-rev-num 1)])\n                                   (let ([half-str-num-plus-1-str-rev-num-plus-1-str (number->string half-str-num-plus-1-str-rev-num-plus-1)])\n                                     (let ([half-str-num-plus-1-str-rev-num-plus-1-str-len (string-length half-str-num-plus-1-str-rev-num-plus-1-str)])\n                                       (let ([half-str-num-plus-1-str-rev-num-plus-1-str-",
    "  (define (reverse-num num)\n    (define (reverse-num-iter num rev)\n      (if (zero? num)\n          rev\n          (reverse-num-iter (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n    (reverse-num-iter num 0))\n  (define (is-palindrome? num)\n    (if (= num (reverse-num num))\n        #t\n        #f))\n  (define (next-palindrome num)\n    (if (is-palindrome? num)\n        num\n        (next-palindrome (+ num 1))))\n  (next-palindrome (+ num 1)))\n",
    "  (define (is_palindrome? num)\n    (define (reverse-num num)\n      (define (helper num rev)\n        (if (zero? num)\n            rev\n            (helper (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n      (helper num 0))\n    (= num (reverse-num num)))\n  (define (next-palindrome num)\n    (if (is_palindrome? num)\n        num\n        (next-palindrome (+ num 1))))\n  (next-palindrome num))\n",
    "  (define (is_palindrome? num)\n    (define (helper num rev)\n      (if (zero? num)\n          (if (= rev 0)\n              #t\n              #f)\n          (helper (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n    (helper num 0))\n  (define (helper num)\n    (if (is_palindrome? num)\n        num\n        (helper (+ num 1))))\n  (helper num))\n",
    "  (define (is_palindrome? num)\n    (define (helper num rev)\n      (if (zero? num)\n          (= rev 0)\n          (helper (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n    (helper num 0))\n  (define (helper num)\n    (if (is_palindrome? num)\n        num\n        (helper (+ num 1))))\n  (helper (+ num 1)))\n",
    "  (define (reverse num)\n    (if (zero? num)\n        0\n        (+ (* (remainder num 10) (expt 10 (- (number->string num) 1))) (reverse (quotient num 10)))))\n  (define (is_palindrome num)\n    (if (= num (reverse num))\n        #t\n        #f))\n  (define (next_palindrome num)\n    (if (is_palindrome num)\n        num\n        (next_palindrome (+ num 1))))\n  (next_palindrome num))\n",
    "  (define (is-palindrome? num)\n    (define (helper num rev)\n      (if (zero? num)\n          (if (= rev 0)\n              #t\n              #f)\n          (helper (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n    (helper num 0))\n  (define (helper num)\n    (if (is-palindrome? num)\n        num\n        (helper (+ num 1))))\n  (helper num))\n",
    "  (let* ([str (number->string num)]\n         [len (string-length str)]\n         [mid (quotient len 2)]\n         [left (substring str 0 mid)]\n         [right (substring str mid)])\n    (if (string=? left (string-reverse right))\n        (next_smallest_palindrome (+ num 1))\n        (string->number (string-append left (string-reverse left))))))\n",
    "  (define (reverse-num num)\n    (define (reverse-num-iter num rev)\n      (if (zero? num)\n          rev\n          (reverse-num-iter (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n    (reverse-num-iter num 0))\n  (define (is-palindrome? num)\n    (if (= num (reverse-num num))\n        #t\n        #f))\n  (define (next-palindrome-iter num)\n    (if (is-palindrome? num)\n        num\n        (next-palindrome-iter (+ num 1))))\n  (next-palindrome-iter (+ num 1)))\n",
    "  (define (is_palindrome? num)\n    (define (helper num rev)\n      (if (zero? num)\n          (= rev 0)\n          (helper (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n    (helper num 0))\n  (define (next_palindrome num)\n    (if (is_palindrome? num)\n        (next_palindrome (+ num 1))\n        num))\n  (next_palindrome num))\n",
    "  (define (reverse-num num)\n    (define (reverse-num-iter num reversed)\n      (if (zero? num)\n          reversed\n          (reverse-num-iter (quotient num 10) (+ (* 10 reversed) (remainder num 10)))))\n    (reverse-num-iter num 0))\n  (define (is-palindrome? num)\n    (if (= num (reverse-num num))\n        #t\n        #f))\n  (define (next-palindrome-iter num)\n    (if (is-palindrome? num)\n        num\n        (next-palindrome-iter (+ 1 num))))\n  (next-palindrome-iter num))\n",
    "  (define (reverse-num n)\n    (define (reverse-num-iter n rev)\n      (if (= n 0)\n          rev\n          (reverse-num-iter (quotient n 10) (+ (* rev 10) (remainder n 10)))))\n    (reverse-num-iter n 0))\n  (define (is-palindrome n)\n    (= n (reverse-num n)))\n  (define (next-palindrome-iter n)\n    (if (is-palindrome n)\n        n\n        (next-palindrome-iter (+ n 1))))\n  (next-palindrome-iter (+ num 1)))\n",
    "  (define (is_palindrome? num)\n    (define (reverse-num num)\n      (define (reverse-num-iter num rev)\n        (if (zero? num)\n            rev\n            (reverse-num-iter (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n      (reverse-num-iter num 0))\n    (if (= num (reverse-num num))\n        #t\n        #f))\n  (define (next-palindrome-iter num)\n    (if (is_palindrome? num)\n        num\n        (next-palindrome-iter (+ num 1))))\n  (next-palindrome-iter (+ num 1)))\n",
    "  (define (is_palindrome? num)\n    (define (reverse-num num)\n      (define (reverse-num-iter num rev)\n        (if (= num 0)\n            rev\n            (reverse-num-iter (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n      (reverse-num-iter num 0))\n    (= num (reverse-num num)))\n  (define (next-palindrome-iter num)\n    (if (is_palindrome? num)\n        num\n        (next-palindrome-iter (+ 1 num))))\n  (next-palindrome-iter num))\n",
    "  (define (is_palindrome? num)\n    (define (reverse-num num)\n      (define (iter num rev)\n        (if (zero? num)\n            rev\n            (iter (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n      (iter num 0))\n    (if (= num (reverse-num num))\n        #t\n        #f))\n  (define (iter num)\n    (if (is_palindrome? num)\n        num\n        (iter (+ num 1))))\n  (iter num))\n",
    "  (define (is_palindrome? num)\n    (define (reverse-digits num)\n      (if (zero? num)\n          0\n          (+ (* (remainder num 10) (expt 10 (- (number->string num) 1)))\n             (reverse-digits (quotient num 10)))))\n    (equal? num (reverse-digits num)))\n  (define (next-palindrome num)\n    (if (is_palindrome? num)\n        num\n        (next-palindrome (+ num 1))))\n  (next-palindrome (+ num 1)))\n",
    "  (define (is_palindrome? num)\n    (define (reverse-digits num)\n      (define (iter num rev)\n        (if (zero? num)\n            rev\n            (iter (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n      (iter num 0))\n    (define (is-palindrome? num)\n      (if (= num (reverse-digits num))\n          #t\n          #f))\n    (is-palindrome? num))\n  (define (next-smallest-palindrome num)\n    (if (is_palindrome? num)\n        num\n        (next-smallest-palindrome (- num 1))))\n  (next-smallest-palindrome num))\n",
    "  (define (is_palindrome? num)\n    (define (helper num rev)\n      (if (zero? num)\n          (= rev 0)\n          (helper (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n    (helper num 0))\n  (define (helper num)\n    (if (is_palindrome? num)\n        num\n        (helper (+ num 1))))\n  (helper (+ num 1)))\n",
    "  (define (is_palindrome? num)\n    (define (helper num rev)\n      (if (= num 0)\n          (= rev 0)\n          (helper (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n    (helper num 0))\n  (define (helper num)\n    (if (is_palindrome? num)\n        num\n        (helper (+ num 1))))\n  (helper (+ num 1)))\n",
    "  (define (is_palindrome? num)\n    (define (helper num rev)\n      (if (zero? num)\n          (= rev 0)\n          (helper (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n    (helper num 0))\n  (define (helper num)\n    (if (is_palindrome? num)\n        num\n        (helper (+ num 1))))\n  (helper (+ num 1)))\n",
    "  (let loop ((num num))\n    (if (palindrome? num)\n        num\n        (loop (- num 1)))))\n",
    "  (define (is_palindrome? num)\n    (define (helper num rev)\n      (if (zero? num)\n          (= rev 0)\n          (helper (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n    (helper num 0))\n  (define (helper num)\n    (if (is_palindrome? num)\n        num\n        (helper (+ num 1))))\n  (helper (+ num 1)))\n",
    "  (let loop ([num num])\n    (if (palindrome? num)\n        num\n        (loop (+ num 1)))))\n",
    "  (define (is_palindrome? num)\n    (let ([str (number->string num)])\n      (equal? str (string-reverse str))))\n  (let loop ([num (+ num 1)])\n    (if (is_palindrome? num)\n        num\n        (loop (+ num 1)))))\n",
    "  (define (is_palindrome? num)\n    (define (reverse-num num)\n      (define (reverse-num-helper num acc)\n        (if (= num 0)\n            acc\n            (reverse-num-helper (quotient num 10) (+ (* acc 10) (remainder num 10)))))\n      (reverse-num-helper num 0))\n    (= num (reverse-num num)))\n  (define (next-palindrome-helper num)\n    (if (is_palindrome? num)\n        num\n        (next-palindrome-helper (+ num 1))))\n  (next-palindrome-helper num))\n",
    "  (define (reverse-num num)\n    (define (reverse-num-helper num rev-num)\n      (if (= num 0)\n          rev-num\n          (reverse-num-helper (quotient num 10) (+ (* rev-num 10) (remainder num 10)))))\n    (reverse-num-helper num 0))\n  (define (is-palindrome num)\n    (= num (reverse-num num)))\n  (define (next-palindrome num)\n    (if (is-palindrome num)\n        num\n        (next-palindrome (+ num 1))))\n  (next-palindrome num))\n",
    "  (define (is_palindrome? num)\n    (define (reverse-num num)\n      (define (iter num rev-num)\n        (if (= num 0)\n            rev-num\n            (iter (quotient num 10) (+ (* rev-num 10) (remainder num 10)))))\n      (iter num 0))\n    (= num (reverse-num num)))\n  (define (iter num)\n    (if (is_palindrome? num)\n        num\n        (iter (+ num 1))))\n  (iter (+ num 1)))\n",
    "  (define (is-palindrome? num)\n    (define (helper num rev)\n      (if (&lt; num 10)\n          (= num rev)\n          (helper (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n    (helper num 0))\n  (define (next-palindrome num)\n    (if (is-palindrome? num)\n        (next-palindrome (+ num 1))\n        num))\n  (next-palindrome num))\n",
    "  (let loop ([num (add1 num)])\n    (cond [(palindrome? num) num]\n          [else (loop (add1 num))])))\n",
    "  (define (is_palindrome? num)\n    (define (reverse num)\n      (define (reverse-helper num rev)\n        (if (zero? num)\n            rev\n            (reverse-helper (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n      (reverse-helper num 0))\n    (= num (reverse num)))\n  (define (next-palindrome-helper num)\n    (if (is_palindrome? num)\n        num\n        (next-palindrome-helper (+ num 1))))\n  (next-palindrome-helper num))\n",
    "  (let ([s (number->string num)])\n    (cond\n      [(string=? s (reverse s)) (add1 num)]\n      [else (next_smallest_palindrome (add1 num))])))\n",
    "  (if (palindrome? num)\n      (next-palindrome-helper num 1)\n      (next-palindrome-helper num 0)))\n",
    "  (let ([str (number->string num)]\n        [len (string-length str)])\n    (cond [(= len 1) (+ num 1)]\n          [(= len 2) (if (= (string-ref str 0) (string-ref str 1))\n                         (+ num 11)\n                         (+ num 1))]\n          [else (let ([mid (/ len 2)])\n                  (if (= (string-ref str mid) (string-ref str (- len 1 mid)))\n                      (let ([left (substring str 0 mid)]\n                            [right (substring str (- len 1 mid))])\n                        (if (string=? left right)\n                            (let ([left (string->number left)])\n                              (next_smallest_palindrome (+ left 1)))\n                            (string->number (string-append left right))))\n                      (let ([left (substring str 0 mid)]\n                            [right (substring str (- len 1 mid))])\n                        (string->number (string-append left (reverse right))))))])))\n",
    "  (define (is_palindrome? num)\n    (define (reverse-int num)\n      (define (reverse-int-helper num acc)\n        (if (= num 0)\n            acc\n            (reverse-int-helper (quotient num 10) (+ (* acc 10) (remainder num 10)))))\n      (reverse-int-helper num 0))\n    (= num (reverse-int num)))\n  (define (next-palindrome num)\n    (if (is_palindrome? num)\n        num\n        (next-palindrome (+ num 1))))\n  (next-palindrome num))\n",
    "  (define (is_palindrome? num)\n    (define (reverse_num num)\n      (define (helper num rev)\n        (if (zero? num)\n            rev\n            (helper (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n      (helper num 0))\n    (= num (reverse_num num)))\n  (define (next_palindrome num)\n    (if (is_palindrome? num)\n        num\n        (next_palindrome (+ num 1))))\n  (next_palindrome (+ num 1)))\n",
    "  (let loop ([num (add1 num)])\n    (if (palindrome? num)\n        num\n        (loop (add1 num)))))\n",
    "  (let ([str (number->string num)])\n    (if (string=? str (string-reverse str))\n        (next_smallest_palindrome (+ num 1))\n        (string->number (string-append (string-reverse (substring str 0 (quotient (string-length str) 2)))\n                                       (substring str (quotient (string-length str) 2)))))))\n",
    "  (define (reverse-num num)\n    (define (iter num acc)\n      (if (zero? num)\n          acc\n          (iter (quotient num 10) (+ (* acc 10) (remainder num 10)))))\n    (iter num 0))\n  (define (is-palindrome num)\n    (equal? num (reverse-num num)))\n  (define (next-palindrome num)\n    (if (is-palindrome num)\n        num\n        (next-palindrome (+ num 1))))\n  (next-palindrome (+ num 1)))\n",
    "  (let ([str (number->string num)])\n    (cond\n      [(string-&gt;number (string-append str (reverse str)))\n       (string-&gt;number (string-append str (reverse str)))]\n      [else\n       (next_smallest_palindrome (add1 num))])))\n",
    "  (let ([str (number->string num)])\n    (cond\n      [(string=? str (reverse str))\n       (string->number (reverse str))]\n      [(< (string-length str) 2)\n       (string->number (reverse str))]\n      [else\n       (let ([half-length (quotient (string-length str) 2)])\n         (let ([left (substring str 0 half-length)])\n           (let ([right (substring str half-length)])\n             (let ([left-num (string->number left)])\n               (let ([right-num (string->number right)])\n                 (let ([left-num-plus-1 (+ left-num 1)])\n                   (let ([left-num-plus-1-str (number->string left-num-plus-1)])\n                     (let ([left-num-plus-1-str-len (string-length left-num-plus-1-str)])\n                       (let ([left-num-plus-1-str-len-half (quotient left-num-plus-1-str-len 2)])\n                         (let ([left-num-plus-1-str-len-half-str (substring left-num-plus-1-str 0 left-num-plus-1-str-len-half)])\n                           (let ([left-num-plus-1-str-len-half-str-num (string->number left-num-plus-1-str-len-half-str)])\n                             (let ([left-num-plus-1-str-len-half-str-num-plus-1 (+ left-num-plus-1-str-len-half-str-num 1)])\n                               (let ([left-num-plus-1-str-len-half-str-num-plus-1-str (number->string left-num-plus-1-str-len-half-str-num-plus-1)])\n                                 (let ([left-num-plus-1-str-len-half-str-num-plus-1-str-len (string-length left-num-plus-1-str-len-half-str-num-plus-",
    "  (let ([str (number->string num)])\n    (let ([len (string-length str)])\n      (let ([mid (quotient len 2)])\n        (let ([left (substring str 0 mid)])\n          (let ([right (substring str mid)])\n            (let ([left-rev (reverse left)])\n              (let ([right-rev (reverse right)])\n                (let ([left-rev-num (string->number left-rev)])\n                  (let ([right-rev-num (string->number right-rev)])\n                    (let ([left-rev-num-plus-one (+ left-rev-num 1)])\n                      (let ([left-rev-num-plus-one-str (number->string left-rev-num-plus-one)])\n                        (let ([left-rev-num-plus-one-str-rev (reverse left-rev-num-plus-one-str)])\n                          (let ([left-rev-num-plus-one-str-rev-num (string->number left-rev-num-plus-one-str-rev)])\n                            (let ([left-rev-num-plus-one-str-rev-num-plus-one (+ left-rev-num-plus-one-str-rev-num 1)])\n                              (let ([left-rev-num-plus-one-str-rev-num-plus-one-str (number->string left-rev-num-plus-one-str-rev-num-plus-one)])\n                                (let ([left-rev-num-plus-one-str-rev-num-plus-one-str-rev (reverse left-rev-num-plus-one-str-rev-num-plus-one-str)])\n                                  (let ([left-rev-num-plus-one-str-rev-num-plus-one-str-rev-num (string->number left-rev-num-plus-one-str-rev-num-plus-one-str-rev)])\n                                    (let ([left-rev-num-plus-one-str-rev-num-plus-one-str-rev-num-plus-one (+ left-rev-num-plus-",
    "  (let ([str (number->string num)])\n    (let ([len (string-length str)])\n      (let ([half (quotient len 2)])\n        (let ([left (substring str 0 half)])\n          (let ([right (substring str (- len half))])\n            (let ([left-num (string->number left)])\n              (let ([right-num (string->number right)])\n                (let ([left-num-plus-one (+ left-num 1)])\n                  (let ([left-num-plus-one-str (number->string left-num-plus-one)])\n                    (let ([left-num-plus-one-str-len (string-length left-num-plus-one-str)])\n                      (let ([left-num-plus-one-str-half (quotient left-num-plus-one-str-len 2)])\n                        (let ([left-num-plus-one-str-left (substring left-num-plus-one-str 0 left-num-plus-one-str-half)])\n                          (let ([left-num-plus-one-str-right (substring left-num-plus-one-str (- left-num-plus-one-str-len left-num-plus-one-str-half))])\n                            (let ([left-num-plus-one-str-right-reversed (string-reverse left-num-plus-one-str-right)])\n                              (let ([left-num-plus-one-str-left-reversed (string-reverse left-num-plus-one-str-left)])\n                                (let ([left-num-plus-one-str-right-reversed-num (string->number left-num-plus-one-str-right-reversed)])\n                                  (let ([left-num-plus-one-str-left-reversed-num (string->number left-num-plus-one-str-left-reversed)])\n                                    (let ([left-num-plus-one-str-right-reversed-num-plus-one (+ left-num-plus-one-str-right-revers",
    "  (define (reverse num)\n    (let loop ([num num] [rev 0])\n      (if (zero? num)\n          rev\n          (loop (quotient num 10) (+ (* rev 10) (remainder num 10))))))\n  (define (is-palindrome? num)\n    (equal? num (reverse num)))\n  (define (next-palindrome num)\n    (if (is-palindrome? num)\n        num\n        (next-palindrome (+ num 1))))\n  (next-palindrome (+ num 1)))\n",
    "  (let loop ([num num])\n    (if (palindrome? num)\n        num\n        (loop (+ num 1)))))\n",
    "  (let* ([str (number->string num)]\n         [len (string-length str)]\n         [mid (quotient len 2)]\n         [left (substring str 0 mid)]\n         [right (substring str mid (add mid (remainder len 2)))]\n         [left-rev (reverse left)])\n    (if (equal? left left-rev)\n        (next_smallest_palindrome (add num 1))\n        (string->number (string-append left left-rev)))))\n",
    "  (define (is_palindrome? num)\n    (define (helper num rev)\n      (if (zero? num)\n          (= rev 0)\n          (helper (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n    (helper num 0))\n  (define (helper num)\n    (if (is_palindrome? num)\n        num\n        (helper (+ num 1))))\n  (helper num))\n",
    "  (let loop ([num (+ 1 num)])\n    (cond\n      [(palindrome? num) num]\n      [else (loop (+ 1 num))])))\n",
    "  (define (is_palindrome? num)\n    (define (helper num rev)\n      (if (zero? num)\n          (= num rev)\n          (helper (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n    (helper num 0))\n  (define (helper num)\n    (if (is_palindrome? num)\n        num\n        (helper (+ num 1))))\n  (helper num))\n",
    "  (define (is_palindrome? num)\n    (define (reverse-num num)\n      (define (reverse-num-iter num rev)\n        (if (zero? num)\n            rev\n            (reverse-num-iter (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n      (reverse-num-iter num 0))\n    (= num (reverse-num num)))\n  (define (next-palindrome-iter num)\n    (if (is_palindrome? num)\n        num\n        (next-palindrome-iter (+ num 1))))\n  (next-palindrome-iter num))\n",
    "  (define (is_palindrome? num)\n    (define (reverse-num num)\n      (define (reverse-num-iter num rev-num)\n        (if (= num 0)\n            rev-num\n            (reverse-num-iter (/ num 10) (+ (* rev-num 10) (modulo num 10)))))\n      (reverse-num-iter num 0))\n    (= num (reverse-num num)))\n  (define (next-palindrome-iter num)\n    (if (is_palindrome? num)\n        num\n        (next-palindrome-iter (+ num 1))))\n  (next-palindrome-iter num))\n",
    "  (define (is_palindrome? num)\n    (define (reverse-num num)\n      (define (reverse-num-iter num rev)\n        (if (= num 0)\n            rev\n            (reverse-num-iter (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n      (reverse-num-iter num 0))\n    (if (= num (reverse-num num))\n        #t\n        #f))\n  (define (next-palindrome-iter num)\n    (if (is_palindrome? num)\n        num\n        (next-palindrome-iter (+ num 1))))\n  (next-palindrome-iter (+ num 1)))\n",
    "  (define (is_palindrome? num)\n    (define (reverse-num num)\n      (define (helper num reversed)\n        (if (&lt; num 10)\n            (+ (* reversed 10) num)\n            (helper (quotient num 10) (+ (* reversed 10) (remainder num 10)))))\n      (helper num 0))\n    (if (= num (reverse-num num))\n        #t\n        #f))\n  (define (next-palindrome num)\n    (if (is_palindrome? num)\n        num\n        (next-palindrome (+ num 1))))\n  (next-palindrome num))\n</code>\n",
    "  (let ([str (number->string num)])\n    (string-&gt;number\n     (string-append\n      (substring str 0 (quotient (string-length str) 2))\n      (reverse\n       (substring str (quotient (string-length str) 2) (string-length str)))))))\n</code>\n",
    "  (let ([str (number->string num)])\n    (if (string-&gt;number (string-append (reverse str) str))\n        (next_smallest_palindrome (+ num 1))\n        (string-&gt;number (string-append (reverse str) str)))))\n</code>\n",
    "  (define (is_palindrome? num)\n    (define (helper num rev)\n      (if (zero? num)\n          (equal? num rev)\n          (helper (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n    (helper num 0))\n  (define (helper num)\n    (if (is_palindrome? num)\n        num\n        (helper (+ num 1))))\n  (helper (+ num 1)))\n",
    "  (let loop ([n num])\n    (if (palindrome? n)\n        n\n        (loop (+ n 1)))))\n",
    "  (let loop ([num num])\n    (if (palindrome? num)\n        num\n        (loop (+ num 1)))))\n",
    "  (define (is_palindrome? num)\n    (define (helper num rev)\n      (if (zero? num)\n          (if (= rev 0)\n              #t\n              #f)\n          (helper (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n    (helper num 0))\n  (define (helper num)\n    (if (is_palindrome? num)\n        (helper (+ num 1))\n        num))\n  (helper (+ num 1)))\n",
    "  (let ([num-str (number->string num)])\n    (let ([num-str-len (string-length num-str)])\n      (let ([mid-index (quotient num-str-len 2)])\n        (let ([left-half (substring num-str 0 mid-index)])\n          (let ([right-half (substring num-str (+ mid-index (if (odd? num-str-len) 1 0)) num-str-len)])\n            (let ([left-half-rev (string-reverse left-half)])\n              (let ([left-half-rev-num (string->number left-half-rev)])\n                (let ([right-half-num (string->number right-half)])\n                  (let ([left-half-num (string->number left-half)])\n                    (let ([left-half-rev-num-plus-1 (add1 left-half-rev-num)])\n                      (let ([left-half-rev-num-plus-1-str (number->string left-half-rev-num-plus-1)])\n                        (let ([left-half-rev-num-plus-1-str-len (string-length left-half-rev-num-plus-1-str)])\n                          (let ([left-half-rev-num-plus-1-str-len-minus-1 (sub1 left-half-rev-num-plus-1-str-len)])\n                            (let ([left-half-rev-num-plus-1-str-len-minus-1-str (number->string left-half-rev-num-plus-1-str-len-minus-1)])\n                              (let ([left-half-rev-num-plus-1-str-len-minus-1-str-len (string-length left-half-rev-num-plus-1-str-len-minus-1-str)])\n                                (let ([left-half-rev-num-plus-1-str-len-minus-1-str-len-minus-1 (sub1 left-half-rev-num-plus-1-str-len-minus-1-str-len)])\n                                 ",
    "  (define (reverse-num num)\n    (define (iter num rev)\n      (if (zero? num)\n          rev\n          (iter (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n    (iter num 0))\n  (define (is-palindrome? num)\n    (if (= num (reverse-num num))\n        #t\n        #f))\n  (define (iter num)\n    (if (is-palindrome? num)\n        num\n        (iter (+ num 1))))\n  (iter (+ num 1)))\n",
    "  (define (reverse-num n)\n    (define (reverse-num-iter n rev)\n      (if (= n 0)\n          rev\n          (reverse-num-iter (quotient n 10) (+ (* rev 10) (remainder n 10)))))\n    (reverse-num-iter n 0))\n  (define (is-palindrome? n)\n    (= n (reverse-num n)))\n  (define (next-palindrome-iter n)\n    (if (is-palindrome? n)\n        n\n        (next-palindrome-iter (+ n 1))))\n  (next-palindrome-iter (+ num 1)))\n",
    "  (let loop ((num (+ num 1)))\n    (if (palindrome? num)\n        num\n        (loop (+ num 1)))))\n",
    "  (define (is_palindrome? num)\n    (define (helper num rev)\n      (if (zero? num)\n          (= rev 0)\n          (helper (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n    (helper num 0))\n  (define (helper num)\n    (if (is_palindrome? num)\n        num\n        (helper (+ num 1))))\n  (helper (+ num 1)))\n",
    "  (define (is_palindrome? num)\n    (define (reverse num)\n      (define (iter num rev)\n        (if (zero? num)\n            rev\n            (iter (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n      (iter num 0))\n    (= num (reverse num)))\n  (define (next_palindrome num)\n    (if (is_palindrome? num)\n        (next_palindrome (+ num 1))\n        num))\n  (next_palindrome (+ num 1)))\n",
    "  (define (is_palindrome? num)\n    (define (reverse num)\n      (define (reverse-iter num rev)\n        (if (= num 0)\n            rev\n            (reverse-iter (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n      (reverse-iter num 0))\n    (= num (reverse num)))\n  (define (next-iter num)\n    (if (is_palindrome? num)\n        num\n        (next-iter (+ num 1))))\n  (next-iter num))\n",
    "  (define (is_palindrome? num)\n    (define (helper num rev)\n      (cond\n        [(zero? num) (= num rev)]\n        [else (helper (quotient num 10) (+ (* rev 10) (remainder num 10)))]))\n    (helper num 0))\n  (define (helper num)\n    (if (is_palindrome? num)\n        num\n        (helper (+ num 1))))\n  (helper (+ num 1)))\n",
    "  (define (is_palindrome? num)\n    (define (reverse-num num)\n      (define (helper num rev)\n        (if (zero? num)\n            rev\n            (helper (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n      (helper num 0))\n    (if (= num (reverse-num num))\n        #t\n        #f))\n  (define (helper num)\n    (if (is_palindrome? num)\n        num\n        (helper (+ num 1))))\n  (helper num))\n",
    "  (let loop ((num num)\n             (next-num (+ num 1)))\n    (if (palindrome? next-num)\n        next-num\n        (loop num (+ next-num 1)))))\n",
    "  (define (reverse-int num)\n    (define (reverse-int-helper num acc)\n      (if (= num 0)\n          acc\n          (reverse-int-helper (quotient num 10) (+ (* acc 10) (remainder num 10)))))\n    (reverse-int-helper num 0))\n  (define (is-palindrome? num)\n    (= num (reverse-int num)))\n  (define (next-palindrome num)\n    (if (is-palindrome? num)\n        num\n        (next-palindrome (+ num 1))))\n  (next-palindrome num))\n",
    "  (let* ([str (number->string num)]\n         [len (string-length str)]\n         [half-len (quotient len 2)]\n         [left (substring str 0 half-len)]\n         [right (substring str (- len half-len) len)])\n    (if (string=? left (string-reverse right))\n        (next_smallest_palindrome (add1 num))\n        (string->number (string-append left (string-reverse left))))))\n",
    "  (define (reverse-num num)\n    (define (reverse-num-iter num reversed)\n      (if (zero? num)\n          reversed\n          (reverse-num-iter (quotient num 10) (+ (* reversed 10) (remainder num 10)))))\n    (reverse-num-iter num 0))\n  (define (is-palindrome? num)\n    (define (is-palindrome?-iter num reversed)\n      (if (zero? num)\n          #t\n          (if (= (remainder num 10) (remainder reversed 10))\n              (is-palindrome?-iter (quotient num 10) (quotient reversed 10))\n              #f)))\n    (is-palindrome?-iter num (reverse-num num)))\n  (define (next-palindrome-iter num reversed)\n    (if (is-palindrome? num)\n        num\n        (next-palindrome-iter (+ num 1) (reverse-num num))))\n  (next-palindrome-iter num (reverse-num num)))\n",
    "  (let loop ([num num])\n    (if (palindrome? num)\n        num\n        (loop (+ num 1)))))\n",
    "  (define (reverse-num num)\n    (define (reverse-num-iter num acc)\n      (if (zero? num)\n          acc\n          (reverse-num-iter (quotient num 10) (+ (* acc 10) (remainder num 10)))))\n    (reverse-num-iter num 0))\n  (define (is-palindrome? num)\n    (if (= num (reverse-num num))\n        #t\n        #f))\n  (define (next-palindrome-iter num)\n    (if (is-palindrome? num)\n        num\n        (next-palindrome-iter (+ 1 num))))\n  (next-palindrome-iter num))\n",
    "  (define (reverse-num num)\n    (define (helper num acc)\n      (if (zero? num)\n          acc\n          (helper (quotient num 10) (+ (* acc 10) (remainder num 10)))))\n    (helper num 0))\n  (define (is-palindrome? num)\n    (if (= num (reverse-num num))\n        #t\n        #f))\n  (define (helper num)\n    (if (is-palindrome? num)\n        num\n        (helper (+ num 1))))\n  (helper (+ num 1)))\n",
    "  (let ([num-str (number->string num)]\n        [len (string-length num-str)])\n    (if (even? len)\n        (let ([half-len (/ len 2)])\n          (let ([left-half (substring num-str 0 half-len)]\n                [right-half (substring num-str half-len len)])\n            (let ([left-half-int (string->number left-half)]\n                  [right-half-int (string->number right-half)])\n              (if (< left-half-int right-half-int)\n                  (string->number (string-append left-half left-half))\n                  (string->number (string-append (number->string (add1 left-half-int)) (number->string (add1 left-half-int))))))))\n        (let ([half-len (/ (- len 1) 2)])\n          (let ([left-half (substring num-str 0 half-len)]\n                [right-half (substring num-str (+ half-len 1) len)])\n            (let ([left-half-int (string->number left-half)]\n                  [right-half-int (string->number right-half)])\n              (if (< left-half-int right-half-int)\n                  (string->number (string-append left-half (substring num-str half-len (+ half-len 1)) left-half))\n                  (string->number (string-append (number->string (add1 left-half-int)) (substring num-str half-len (+ half-len 1)) (number->string (add1 left-half-int)))))))))))\n",
    "  (define (is_palindrome? num)\n    (define (helper num rev)\n      (if (zero? num)\n          (= rev 0)\n          (helper (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n    (helper num 0))\n  (define (helper num)\n    (if (is_palindrome? num)\n        num\n        (helper (+ num 1))))\n  (helper num))\n",
    "  (define (is_palindrome? num)\n    (define (reverse-num num)\n      (define (iter num rev)\n        (if (zero? num)\n            rev\n            (iter (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n      (iter num 0))\n    (= num (reverse-num num)))\n  (define (iter num)\n    (if (is_palindrome? num)\n        num\n        (iter (+ num 1))))\n  (iter (+ num 1)))\n",
    "  (define (reverse-num num)\n    (define (reverse-num-iter num rev)\n      (if (zero? num)\n          rev\n          (reverse-num-iter (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n    (reverse-num-iter num 0))\n  (define (is-palindrome? num)\n    (if (= num (reverse-num num))\n        #t\n        #f))\n  (define (next-palindrome-iter num)\n    (if (is-palindrome? num)\n        num\n        (next-palindrome-iter (+ num 1))))\n  (next-palindrome-iter num))\n",
    "  (if (palindrome? num)\n      (next-palindrome-of-palindrome num)\n      (next-palindrome-of-non-palindrome num)))\n",
    "  (define (palindrome? num)\n    (define (helper num rev)\n      (cond\n        [(zero? num) rev]\n        [else (helper (quotient num 10) (+ (* rev 10) (remainder num 10)))]))\n    (equal? num (helper num 0)))\n  (define (helper num)\n    (cond\n      [(palindrome? num) num]\n      [else (helper (+ num 1))]))\n  (helper (+ num 1)))\n",
    "  (define (is_palindrome? num)\n    (define (reverse-num num)\n      (define (iter num rev)\n        (if (&lt; num 10)\n            (+ (* rev 10) num)\n            (iter (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n      (iter num 0))\n    (if (= num (reverse-num num))\n        #t\n        #f))\n  (define (iter num)\n    (if (is_palindrome? num)\n        num\n        (iter (+ num 1))))\n  (iter num))\n",
    "  (define (is_palindrome? num)\n    (define (helper num rev)\n      (if (zero? num)\n          (eq? num rev)\n          (helper (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n    (helper num 0))\n  (define (helper num)\n    (if (is_palindrome? num)\n        (helper (+ num 1))\n        num))\n  (helper (+ num 1)))\n",
    "  (let* ([str (number->string num)]\n         [len (string-length str)]\n         [mid (quotient len 2)]\n         [left (substring str 0 mid)]\n         [right (substring str mid len)])\n    (if (string=? left (string-reverse right))\n        (next_smallest_palindrome (+ num 1))\n        (string-&gt;number (string-append left (string-reverse left))))))\n",
    "  (define (reverse-num num)\n    (define (reverse-num-iter num acc)\n      (if (zero? num)\n          acc\n          (reverse-num-iter (quotient num 10) (+ (* acc 10) (remainder num 10)))))\n    (reverse-num-iter num 0))\n  (define (is-palindrome? num)\n    (if (= num (reverse-num num))\n        #t\n        #f))\n  (define (next-palindrome-iter num)\n    (if (is-palindrome? num)\n        num\n        (next-palindrome-iter (+ num 1))))\n  (next-palindrome-iter (+ num 1)))\n",
    "  (define (is_palindrome? num)\n    (define (reverse-digits num)\n      (define (helper num acc)\n        (if (zero? num)\n            acc\n            (helper (quotient num 10) (+ (* 10 acc) (remainder num 10)))))\n      (helper num 0))\n    (if (= num (reverse-digits num))\n        #t\n        #f))\n  (define (helper num)\n    (if (is_palindrome? num)\n        num\n        (helper (+ num 1))))\n  (helper num))\n",
    "  (let ([str (number->string num)])\n    (if (string=? str (string-reverse str))\n        (next_smallest_palindrome (+ num 1))\n        (string->number (string-append str (string-reverse (substring str 0 (quotient (string-length str) 2))))))))\n",
    "  (define (reverse-int num)\n    (define (reverse-int-iter num acc)\n      (cond ((zero? num) acc)\n            (else (reverse-int-iter (quotient num 10) (+ (* acc 10) (remainder num 10))))))\n    (reverse-int-iter num 0))\n\n  (define (is-palindrome? num)\n    (equal? num (reverse-int num)))\n\n  (define (next-palindrome num)\n    (cond ((is-palindrome? num) num)\n          (else (next-palindrome (+ num 1)))))\n\n  (next-palindrome num))\n",
    "  (define (reverse n)\n    (define (reverse-iter n rev)\n      (if (= n 0)\n          rev\n          (reverse-iter (quotient n 10) (+ (* rev 10) (remainder n 10)))))\n    (reverse-iter n 0))\n  (define (is-palindrome? n)\n    (define (is-palindrome-iter n rev)\n      (if (= n 0)\n          #t\n          (if (= (remainder n 10) (remainder rev 10))\n              (is-palindrome-iter (quotient n 10) (quotient rev 10))\n              #f)))\n    (is-palindrome-iter n (reverse n)))\n  (define (next-palindrome-iter n)\n    (if (is-palindrome? n)\n        n\n        (next-palindrome-iter (+ n 1))))\n  (next-palindrome-iter (+ num 1)))\n",
    "  (let loop ([num num])\n    (if (palindrome? num)\n        num\n        (loop (+ num 1)))))\n",
    "  (let ([str (number->string num)])\n    (if (palindrome? str)\n        (string->number (string-append str (reverse str)))\n        (string->number (string-append str (reverse (substring str 0 (sub1 (string-length str)))))))))\n",
    "  (define (is_palindrome? num)\n    (define (reverse-num num)\n      (define (reverse-num-helper num rev)\n        (if (zero? num)\n            rev\n            (reverse-num-helper (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n      (reverse-num-helper num 0))\n    (if (= num (reverse-num num))\n        #t\n        #f))\n  (define (next-palindrome num)\n    (if (is_palindrome? num)\n        num\n        (next-palindrome (+ num 1))))\n  (next-palindrome num))\n",
    "  (let loop ([num num])\n    (if (palindrome? num)\n        num\n        (loop (+ num 1)))))\n",
    "  (define (is_palindrome? num)\n    (define (helper num rev)\n      (if (zero? num)\n          (= rev 0)\n          (helper (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n    (helper num 0))\n  (define (helper num)\n    (if (is_palindrome? num)\n        num\n        (helper (+ num 1))))\n  (helper (+ num 1)))\n",
    "  (define (reverse-num num)\n    (define (reverse-num-iter num rev-num)\n      (if (zero? num)\n          rev-num\n          (reverse-num-iter (quotient num 10) (+ (* rev-num 10) (remainder num 10)))))\n    (reverse-num-iter num 0))\n  (define (is-palindrome? num)\n    (if (= num (reverse-num num))\n        #t\n        #f))\n  (define (next-palindrome-iter num)\n    (if (is-palindrome? num)\n        num\n        (next-palindrome-iter (+ num 1))))\n  (next-palindrome-iter (+ num 1)))\n",
    "  (let* ([str (number->string num)]\n         [len (string-length str)]\n         [half (quotient len 2)]\n         [left (substring str 0 half)]\n         [right (substring str (- len half))])\n    (if (string=? left (string-reverse right))\n        (next_smallest_palindrome (+ num 1))\n        (string->number (string-append left (string-reverse left))))))\n",
    "  (let loop ((num num) (i 0))\n    (if (palindrome? num)\n        num\n        (loop (+ num (expt 10 i)) (+ i 1)))))\n",
    "  (define (is_palindrome? num)\n    (define (reverse-num num)\n      (define (reverse-num-iter num rev)\n        (if (zero? num)\n            rev\n            (reverse-num-iter (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n      (reverse-num-iter num 0))\n    (= num (reverse-num num)))\n  (define (next-palindrome-iter num)\n    (if (is_palindrome? num)\n        num\n        (next-palindrome-iter (+ num 1))))\n  (next-palindrome-iter (+ num 1)))\n",
    "  (let ([num-str (number->string num)])\n    (cond\n      [(string=? num-str (reverse num-str)) num]\n      [else (next_smallest_palindrome (add1 num))])))\n",
    "  (define (is_palindrome? num)\n    (define (reverse-digits num)\n      (define (reverse-digits-iter num rev)\n        (if (zero? num)\n            rev\n            (reverse-digits-iter (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n      (reverse-digits-iter num 0))\n    (= num (reverse-digits num)))\n  (define (next-palindrome-iter num)\n    (if (is_palindrome? num)\n        num\n        (next-palindrome-iter (+ num 1))))\n  (next-palindrome-iter num))\n",
    "  (define (is_palindrome? num)\n    (define (reverse-num num)\n      (define (iter num acc)\n        (if (zero? num)\n            acc\n            (iter (quotient num 10) (+ (* acc 10) (remainder num 10)))))\n      (iter num 0))\n    (= num (reverse-num num)))\n  (define (iter num)\n    (if (is_palindrome? num)\n        num\n        (iter (+ num 1))))\n  (iter num))\n",
    "  (define (reverse-num num)\n    (define (reverse-num-iter num rev)\n      (if (zero? num)\n          rev\n          (reverse-num-iter (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n    (reverse-num-iter num 0))\n  (define (is-palindrome? num)\n    (if (= num (reverse-num num))\n        #t\n        #f))\n  (define (next-palindrome-iter num)\n    (if (is-palindrome? num)\n        num\n        (next-palindrome-iter (+ num 1))))\n  (next-palindrome-iter (+ num 1)))\n",
    "  (define (is_palindrome? num)\n    (define (reverse-digits num)\n      (define (reverse-digits-iter num rev)\n        (if (zero? num)\n            rev\n            (reverse-digits-iter (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n      (reverse-digits-iter num 0))\n    (if (= num (reverse-digits num))\n        #t\n        #f))\n  (define (next-palindrome-iter num)\n    (if (is_palindrome? num)\n        num\n        (next-palindrome-iter (+ num 1))))\n  (next-palindrome-iter num))\n",
    "  (define (is_palindrome? num)\n    (define (reverse-digits num)\n      (define (helper num rev)\n        (if (zero? num)\n            rev\n            (helper (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n      (helper num 0))\n    (= num (reverse-digits num)))\n  (define (next-palindrome num)\n    (if (is_palindrome? num)\n        (next-palindrome (+ num 1))\n        num))\n  (next-palindrome num))\n",
    "  (define (is_palindrome? num)\n    (define (reverse-digits num)\n      (define (reverse-digits-iter num rev)\n        (if (zero? num)\n            rev\n            (reverse-digits-iter (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n      (reverse-digits-iter num 0))\n    (if (= num (reverse-digits num))\n        #t\n        #f))\n  (define (next-palindrome-iter num)\n    (if (is_palindrome? num)\n        num\n        (next-palindrome-iter (+ 1 num))))\n  (next-palindrome-iter num))\n",
    "  (define (is_palindrome? num)\n    (define (helper num rev)\n      (cond\n        [(zero? num) (= num rev)]\n        [else (helper (quotient num 10) (+ (* rev 10) (remainder num 10)))]))\n    (helper num 0))\n  (define (helper num)\n    (cond\n      [(is_palindrome? num) num]\n      [else (helper (+ num 1))]))\n  (helper (+ num 1)))\n",
    "  (define (is_palindrome? num)\n    (define (helper num rev)\n      (if (zero? num)\n          (= rev 0)\n          (helper (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n    (helper num 0))\n  (define (helper num)\n    (if (is_palindrome? num)\n        num\n        (helper (+ num 1))))\n  (helper (+ num 1)))\n",
    "  (define (is_palindrome? num)\n    (define (reverse-num num)\n      (define (reverse-num-iter num rev)\n        (if (= num 0)\n            rev\n            (reverse-num-iter (quotient num 10) (+ (* rev 10) (remainder num 10)))))\n      (reverse-num-iter num 0))\n    (= num (reverse-num num)))\n  (define (next-palindrome-iter num)\n    (if (is_palindrome? num)\n        num\n        (next-palindrome-iter (+ num 1))))\n  (next-palindrome-iter (+ num 1)))\n",
    "  (define (reverse-int n)\n    (define (reverse-int-helper n acc)\n      (if (zero? n)\n          acc\n          (reverse-int-helper (quotient n 10) (+ (* acc 10) (remainder n 10)))))\n    (reverse-int-helper n 0))\n  (define (is-palindrome? n)\n    (if (= n (reverse-int n))\n        #t\n        #f))\n  (define (next-palindrome-helper n)\n    (if (is-palindrome? n)\n        n\n        (next-palindrome-helper (+ n 1))))\n  (next-palindrome-helper (+ num 1)))\n"
  ]
}