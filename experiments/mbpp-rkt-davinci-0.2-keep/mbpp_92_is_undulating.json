{
  "name": "mbpp_92_is_undulating",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Write a function to check whether the given number is undulating or not.\n(define (is_undulating n)\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_92_is_undulating.py",
  "prompt_terminology": "verbatim",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_undulating))\n    (check-equal? (candidate 1212121) #t)\n    (check-equal? (candidate 1991) #f)\n    (check-equal? (candidate 121) #t)\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (define (is_undulating-iter n1 n2 n3)\n    (cond\n      [(zero? n3) #t]\n      [(and (= n1 (+ n2 1)) (= n2 (- n3 1))) (is_undulating-iter n2 n3 (quotient n3 10))]\n      [(and (= n1 (- n2 1)) (= n2 (+ n3 1))) (is_undulating-iter n2 n3 (quotient n3 10))]\n      [else #f]))\n  (is_undulating-iter (quotient n 10) (remainder n 10) (quotient n 100)))\n",
    "  (define (is_undulating-iter n prev-digit prev-diff)\n    (if (&lt; n 10)\n        #t\n        (let* ([digit (modulo n 10)]\n               [diff (- digit prev-digit)])\n          (if (and (not (= diff 0))\n                   (= diff prev-diff))\n              (is-undulating-iter (quotient n 10) digit diff)\n              #f))))\n  (is-undulating-iter n 0 0))\n",
    "  (define (is-undulating-iter n last-digit)\n    (cond\n      [(zero? n) #t]\n      [(= (remainder n 10) last-digit) #f]\n      [else (is-undulating-iter (quotient n 10) (remainder n 10))]))\n  (is-undulating-iter n (remainder n 10)))\n",
    "  (let loop ([n (number->string n)]\n             [prev-digit (string->number (substring n 0 1))]\n             [i 1])\n    (if (or (zero? i)\n            (= i (sub1 (string-length n))))\n        #t\n        (let ([curr-digit (string->number (substring n i (add1 i)))])\n          (if (= (abs (- prev-digit curr-digit)) 1)\n              (loop n curr-digit (add1 i))\n              #f)))))\n",
    "  (let loop ([n n] [prev-digit 0] [prev-diff 0])\n    (cond [(zero? n) #t]\n          [(zero? (remainder n 10)) #f]\n          [else\n           (let ([curr-digit (remainder n 10)])\n             (if (and (not (zero? prev-digit))\n                      (not (zero? prev-diff))\n                      (not (= (abs prev-diff) (- prev-digit curr-digit))))\n                 #f\n                 (loop (quotient n 10) curr-digit (- prev-digit curr-digit))))])))\n",
    "  (define (is_undulating-iter n prev-digit prev-diff)\n    (cond\n      [(zero? n) #t]\n      [(and (zero? prev-diff) (zero? (modulo n 10)))\n       (is-undulating-iter (quotient n 10) prev-digit prev-diff)]\n      [(and (zero? prev-diff) (zero? prev-digit))\n       (is-undulating-iter (quotient n 10) (modulo n 10) prev-diff)]\n      [(zero? prev-digit)\n       (is-undulating-iter (quotient n 10) (modulo n 10) (modulo n 10))]\n      [(zero? (modulo n 10))\n       (is-undulating-iter (quotient n 10) prev-digit prev-diff)]\n      [(= (abs (- (modulo n 10) prev-digit)) prev-diff)\n       (is-undulating-iter (quotient n 10) (modulo n 10) (abs (- (modulo n 10) prev-digit)))]\n      [else #f]))\n  (is-undulating-iter n 0 0))\n",
    "  (define (helper n)\n    (cond\n      [(zero? n) #f]\n      [(zero? (remainder n 10)) (helper (quotient n 10))]\n      [(zero? (remainder (quotient n 10) 10)) #t]\n      [else (helper (quotient n 10))]))\n  (helper n))\n",
    "  (define (is-undulating-helper n)\n    (cond\n      [(= n 0) #t]\n      [(= (modulo n 10) (modulo (quotient n 10) 10)) #f]\n      [else (is-undulating-helper (quotient n 10))]))\n  (is-undulating-helper n))\n",
    "  (define (is_undulating-iter n prev-digit)\n    (cond ((= n 0) #t)\n          ((= (modulo n 10) prev-digit) #f)\n          (else (is-undulating-iter (quotient n 10) (modulo n 10)))))\n  (is-undulating-iter n (modulo n 10)))\n",
    "  (let loop ([n (number->string n)]\n             [i 0])\n    (cond\n      [(empty? n) #t]\n      [(= i (string-length n)) #t]\n      [(= (string-ref n i) (string-ref n (+ i 2))) (loop (substring n 1) (+ i 1))]\n      [else #f])))\n",
    "  (define (undulating? n)\n    (if (zero? n)\n        #t\n        (let* ([d1 (modulo n 10)]\n               [d2 (modulo (quotient n 10) 10)])\n          (or (and (positive? d1) (negative? d2))\n              (and (negative? d1) (positive? d2))))))\n  (let loop ([n n])\n    (if (zero? n)\n        #t\n        (and (undulating? n)\n             (loop (quotient n 10))))))\n",
    "  (define (is_undulating-iter n1 n2 n3)\n    (cond\n      [(zero? n) #t]\n      [(and (equal? n1 n2) (equal? n2 n3)) #f]\n      [(and (equal? n1 n2) (not (equal? n2 n3))) (is-undulating-iter n2 n3 (modulo (quotient n 10) 10))]\n      [(and (not (equal? n1 n2)) (equal? n2 n3)) (is-undulating-iter n2 n3 (modulo (quotient n 10) 10))]\n      [(and (not (equal? n1 n2)) (not (equal? n2 n3))) (is-undulating-iter n2 n3 (modulo (quotient n 10) 10))]))\n  (is-undulating-iter (modulo (quotient n 100) 10) (modulo (quotient n 10) 10) (modulo n 10)))\n</code>\n",
    "  (define (is_undulating-iter n prev-digit prev-prev-digit)\n    (cond\n      [(zero? n) #t]\n      [(or (and (zero? prev-digit) (zero? prev-prev-digit))\n           (and (zero? prev-digit) (= prev-prev-digit (remainder n 10)))\n           (and (= prev-digit (remainder n 10)) (zero? prev-prev-digit))\n           (and (= prev-digit (remainder n 10)) (= prev-prev-digit (remainder n 10))))\n       #f]\n      [else (is-undulating-iter (quotient n 10) (remainder n 10) prev-digit)]))\n  (is-undulating-iter n 0 0))\n",
    "  (define (undulating? n)\n    (let ([d (string->number (string-ref (number->string n) 0))])\n      (and (not (zero? d))\n           (let loop ([n (string->number (substring (number->string n) 1))]\n                      [prev d])\n             (if (zero? n)\n                 #t\n                 (let ([d (string->number (string-ref (number->string n) 0))])\n                   (if (or (and (= prev d) (= prev (- d 1)))\n                           (and (= prev d) (= prev (+ d 1))))\n                       (loop (string->number (substring (number->string n) 1)) d)\n                       #f)))))))\n  (undulating? n))\n",
    "  (let loop ((n (number->string n))\n             (prev-digit #\\0)\n             (prev-prev-digit #\\0))\n    (cond ((null? n) #t)\n          ((and (= (string-ref n 0) prev-digit)\n                (= (string-ref n 0) prev-prev-digit))\n           #f)\n          (else (loop (string-drop n 1)\n                      (string-ref n 0)\n                      prev-digit)))))\n",
    "  (let loop ([n n] [prev-digit #f] [is-increasing? #t])\n    (if (zero? n)\n        (not is-increasing?)\n        (let ([digit (modulo n 10)])\n          (if prev-digit\n              (if (and (not is-increasing?) (&lt; digit prev-digit))\n                  (loop (quotient n 10) digit #f)\n                  (if (and is-increasing? (&gt; digit prev-digit))\n                      (loop (quotient n 10) digit #t)\n                      #f))\n              (loop (quotient n 10) digit is-increasing?))))))\n",
    "  (define (is_undulating-iter n)\n    (cond\n      [(zero? n) #t]\n      [(zero? (remainder n 10)) #f]\n      [(< (remainder n 10) (remainder (quotient n 10) 10))\n       (is-undulating-iter (quotient n 10))]\n      [else #f]))\n  (is-undulating-iter n))\n",
    "  (define (is_undulating-iter n1 n2 n3)\n    (cond\n      [(zero? n1) #t]\n      [(and (not (zero? n2)) (not (zero? n3)))\n       (and (or (= n1 n2) (= n1 n3))\n            (is-undulating-iter (quotient n1 10) n2 n3))]\n      [(not (zero? n2))\n       (and (= n1 n2) (is-undulating-iter (quotient n1 10) n2 0))]\n      [(not (zero? n3))\n       (and (= n1 n3) (is-undulating-iter (quotient n1 10) 0 n3))]\n      [else (is-undulating-iter (quotient n1 10) 0 0)]))\n  (is-undulating-iter n 0 0))\n",
    "  (let loop ([n (number->string n)]\n             [i 0]\n             [j 1])\n    (cond [(empty? n) #f]\n          [(= (string-ref n i) (string-ref n j))\n           (loop (substring n 1) (+ i 1) (+ j 1))]\n          [else (loop (substring n 1) (+ i 1) (+ j 1))])))\n",
    "  (define (is_undulating-helper n)\n    (if (zero? n)\n        #t\n        (let* ([d1 (modulo n 10)]\n               [n (quotient n 10)]\n               [d2 (modulo n 10)])\n          (if (and (zero? d1) (zero? d2))\n              (is-undulating-helper n)\n              (if (or (and (zero? d1) (not (zero? d2)))\n                      (and (not (zero? d1)) (zero? d2)))\n                  (is-undulating-helper (quotient n 10))\n                  #f)))))\n  (is-undulating-helper n))\n",
    "  (let loop ((n n) (prev #f) (count 0))\n    (cond ((zero? n) (zero? count))\n          ((= (modulo n 10) prev) (loop (quotient n 10) prev count))\n          ((zero? count) (loop (quotient n 10) (modulo n 10) 1))\n          ((= (modulo n 10) (- prev 10)) (loop (quotient n 10) (modulo n 10) (+ count 1)))\n          (else #f))))\n",
    "  (define (is_undulating-iter n prev-digit prev-diff)\n    (cond\n      [(zero? n) #t]\n      [(= prev-digit (modulo n 10)) #f]\n      [(= prev-diff (- (modulo n 10) prev-digit)) #f]\n      [else (is-undulating-iter (quotient n 10) (modulo n 10) (- (modulo n 10) prev-digit))]))\n  (is_undulating-iter n (-1) 0))\n",
    "  (define (is_undulating-iter n digits)\n    (cond\n      [(zero? n) #t]\n      [(= (modulo n 10) (modulo (quotient n 10) 10)) (is-undulating-iter (quotient n 10) digits)]\n      [(= (modulo n 10) (modulo (quotient n 100) 10)) (is-undulating-iter (quotient n 10) digits)]\n      [else #f]))\n  (is-undulating-iter n (number->string n)))\n",
    "  (define (is_undulating-iter n prev-digit prev-diff)\n    (cond\n      [(zero? n) #t]\n      [(and (zero? prev-diff)\n            (zero? (modulo n 10)))\n       (is-undulating-iter (quotient n 10) prev-digit prev-diff)]\n      [(and (zero? prev-diff)\n            (not (zero? (modulo n 10))))\n       (is-undulating-iter (quotient n 10) (modulo n 10) prev-diff)]\n      [(and (not (zero? prev-diff))\n            (zero? (modulo n 10)))\n       (is-undulating-iter (quotient n 10) prev-digit prev-diff)]\n      [(and (not (zero? prev-diff))\n            (not (zero? (modulo n 10))))\n       (if (= (modulo n 10) (- prev-digit prev-diff))\n           (is-undulating-iter (quotient n 10) (modulo n 10) (- prev-digit prev-diff))\n           #f)]))\n  (is-undulating-iter n 0 0))\n",
    "  (let loop ((n (number->string n))\n             (prev-digit (string->number (substring n 0 1)))\n             (i 1)\n             (undulating #t))\n    (cond ((= i (string-length n)) undulating)\n          ((= prev-digit (string->number (substring n i 1))) #f)\n          (else (loop n (string->number (substring n i 1)) (+ i 1) undulating)))))\n",
    "  (let loop ((n n) (prev-digit 0) (is-increasing? #t))\n    (cond ((zero? n) #t)\n          ((= prev-digit (remainder n 10)) #f)\n          ((= prev-digit (- (remainder n 10) 1)) (loop (quotient n 10) (remainder n 10) #t))\n          ((= prev-digit (+ (remainder n 10) 1)) (loop (quotient n 10) (remainder n 10) #f))\n          (else #f))))\n</code>\n",
    "  (define (is_undulating-iter n1 n2 n3)\n    (cond ((= n3 0) #t)\n          ((= (modulo n3 10) (- n2 (modulo n1 10)))\n           (is_undulating-iter n2 n3 (quotient n3 10)))\n          (else #f)))\n  (is_undulating-iter (quotient n 10) (modulo n 10) (quotient n 100)))\n",
    "  (define (is_undulating-helper n)\n    (if (zero? n)\n        #t\n        (let* ([d1 (remainder n 10)]\n               [d2 (remainder (quotient n 10) 10)])\n          (if (or (= d1 d2) (= (abs (- d1 d2)) 2))\n              (is_undulating-helper (quotient n 10))\n              #f))))\n  (is_undulating-helper n))\n",
    "  (let loop ([n n]\n             [prev (modulo n 10)])\n    (cond\n      [(zero? n) #t]\n      [(zero? (modulo n 10)) #f]\n      [(= (modulo n 10) prev) #f]\n      [else (loop (quotient n 10) (modulo n 10))])))\n",
    "  (let loop ((n (number->string n))\n             (prev #\\0)\n             (curr (string-ref n 0))\n             (next (string-ref n 1))\n             (i 2))\n    (cond ((= i (string-length n)) #t)\n          ((or (and (= prev #\\0) (= curr #\\0) (= next #\\0))\n               (and (= prev #\\0) (= curr #\\0) (= next #\\9))\n               (and (= prev #\\0) (= curr #\\9) (= next #\\0))\n               (and (= prev #\\9) (= curr #\\0) (= next #\\0)))\n           #f)\n          ((or (and (= prev #\\0) (= curr #\\0) (= next #\\1))\n               (and (= prev #\\0) (= curr #\\1) (= next #\\0))\n               (and (= prev #\\1) (= curr #\\0) (= next #\\0)))\n           (loop n curr next (string-ref n i) (+ i 1)))\n          ((or (and (= prev #\\0) (= curr #\\0) (= next #\\8))\n               (and (= prev #\\0) (= curr #\\8) (= next #\\0))\n               (and (= prev #\\8) (= curr #\\0) (= next #\\0)))\n           (loop n curr next (string-ref n i) (+ i 1)))\n          ((or (and (= prev #\\0) (= curr #\\0) (= next #\\9))\n               (and (= prev #\\0) (= curr #\\9) (= next #\\0))\n               (and (= prev #\\9) (= curr #\\0) (= next #\\0)))\n           (loop n curr next (string-ref n i) (+ i 1)))\n          ((or (and (= prev #\\0) (= curr #\\1) (= next #\\1))\n               (and (= prev #\\1) (= curr #\\1) (= next #\\0))\n               (and (= prev #\\1) (= curr #\\0) (= next #\\1)))\n           (loop n cur",
    "  (let loop ((n (number->string n))\n             (prev-digit (string->number (string-ref n 0)))\n             (i 1))\n    (cond ((= i (string-length n)) #t)\n          ((= (modulo i 2) 0)\n           (let ((cur-digit (string->number (string-ref n i))))\n             (if (= cur-digit prev-digit)\n                 #f\n                 (loop n cur-digit (+ i 1)))))\n          ((= (modulo i 2) 1)\n           (let ((cur-digit (string->number (string-ref n i))))\n             (if (= cur-digit prev-digit)\n                 #f\n                 (loop n cur-digit (+ i 1))))))))\n",
    "  (define (is_undulating-iter n)\n    (cond\n      [(= n 0) #t]\n      [(= n 1) #f]\n      [(= n 2) #t]\n      [(= n 3) #f]\n      [(= n 4) #t]\n      [(= n 5) #f]\n      [(= n 6) #t]\n      [(= n 7) #f]\n      [(= n 8) #t]\n      [(= n 9) #f]\n      [(= n 10) #t]\n      [(= n 11) #f]\n      [(= n 12) #t]\n      [(= n 13) #f]\n      [(= n 14) #t]\n      [(= n 15) #f]\n      [(= n 16) #t]\n      [(= n 17) #f]\n      [(= n 18) #t]\n      [(= n 19) #f]\n      [(= n 20) #t]\n      [(= n 21) #f]\n      [(= n 22) #t]\n      [(= n 23) #f]\n      [(= n 24) #t]\n      [(= n 25) #f]\n      [(= n 26) #t]\n      [(= n 27) #f]\n      [(= n 28) #t]\n      [(= n 29) #f]\n      [(= n 30) #t]\n      [(= n 31) #f]\n      [(= n 32) #t]\n      [(= n 33) #f]\n      [(= n 34) #t]\n      [(= n 35) #f]\n      [(= n 36) #t]\n      [(= n 37) #f]\n      [(= n 38) #t]\n      [(= n 39) #f]\n      [(= n 40) #t]\n      [(= n 41) #f]\n      [(= n 42) #t]\n      [(= n 43) #f]\n      [(= n 44) #t]\n      [(= n 45) #f]\n      [(= n 46) #t]\n      [(= n 47) #f]\n      [(= n 48) #t]\n      [(= n",
    "  (define (is_undulating-iter n prev-digit prev-diff)\n    (cond\n      [(zero? n) #t]\n      [(= prev-digit (- (modulo n 10) prev-diff))\n       (is_undulating-iter (quotient n 10) (- (modulo n 10) prev-diff) prev-diff)]\n      [else #f]))\n  (is_undulating-iter n (- (modulo n 10) (modulo (quotient n 10) 10)) (modulo (quotient n 10) 10)))\n",
    "  (define (is_undulating-iter n prev-digit)\n    (cond ((zero? n) #t)\n          ((= prev-digit (remainder n 10)) #f)\n          (else (is-undulating-iter (quotient n 10) (remainder n 10)))))\n  (is_undulating-iter n (remainder n 10)))\n",
    "  (define (is_undulating-helper n)\n    (cond\n      [(zero? n) #t]\n      [(zero? (remainder n 10)) #f]\n      [else (is-undulating-helper (quotient n 10))]))\n  (is_undulating-helper n))\n",
    "  (let loop ([n n] [prev -1] [curr -1])\n    (cond [(zero? n) #t]\n          [(= prev curr) #f]\n          [else (loop (quotient n 10) curr (modulo n 10))])))\n",
    "  (let loop ([n n] [prev -1])\n    (cond [(zero? n) #t]\n          [(= prev (modulo n 10)) #f]\n          [else (loop (quotient n 10) (modulo n 10))])))\n",
    "  (define (is_undulating-iter n last-digit)\n    (if (zero? n)\n        #t\n        (let* ([next-digit (modulo n 10)]\n               [is-undulating (or (and (= last-digit 0) (= next-digit 0))\n                                  (and (= last-digit 1) (= next-digit 1))\n                                  (and (= last-digit 2) (= next-digit 2))\n                                  (and (= last-digit 3) (= next-digit 3))\n                                  (and (= last-digit 4) (= next-digit 4))\n                                  (and (= last-digit 5) (= next-digit 5))\n                                  (and (= last-digit 6) (= next-digit 6))\n                                  (and (= last-digit 7) (= next-digit 7))\n                                  (and (= last-digit 8) (= next-digit 8))\n                                  (and (= last-digit 9) (= next-digit 9)))]\n               [new-n (quotient n 10)])\n          (if is-undulating\n              (is-undulating-iter new-n next-digit)\n              #f))))\n  (is-undulating-iter n -1))\n",
    "  (let loop ((n (number->string n))\n             (prev-digit #\\0)\n             (prev-prev-digit #\\0)\n             (prev-prev-prev-digit #\\0)\n             (prev-prev-prev-prev-digit #\\0))\n    (cond ((null? n) #t)\n          ((and (char=? (car n) prev-digit)\n                (char=? (car n) prev-prev-digit)\n                (char=? (car n) prev-prev-prev-digit)\n                (char=? (car n) prev-prev-prev-prev-digit))\n           #f)\n          (else (loop (cdr n)\n                      (car n)\n                      prev-digit\n                      prev-prev-digit\n                      prev-prev-prev-digit)))))\n",
    "  (define (is_undulating-iter n s)\n    (cond\n      [(zero? n) #t]\n      [(= (modulo n 10) (modulo (quotient n 10) 10)) #f]\n      [else (is_undulating-iter (quotient n 10) (+ s 1))]))\n  (is_undulating-iter n 0))\n",
    "  (define (is_undulating-iter n1 n2 n3)\n    (cond ((= n3 0) #t)\n          ((= n1 n2) (is-undulating-iter n2 n3 (modulo n3 10)))\n          (else #f)))\n  (is_undulating-iter (modulo n 100) (modulo n 10) (quotient n 100)))\n",
    "  (define (is-undulating-helper n)\n    (cond\n      [(= n 0) #t]\n      [(= n 1) #t]\n      [(= n 2) #f]\n      [(= n 3) #t]\n      [(= n 4) #f]\n      [(= n 5) #t]\n      [(= n 6) #f]\n      [(= n 7) #t]\n      [(= n 8) #f]\n      [(= n 9) #t]\n      [else (is-undulating-helper (remainder n 10))]))\n  (is-undulating-helper n))\n",
    "  (define (is_undulating-iter n)\n    (if (&lt; n 10)\n        #t\n        (let* ([d1 (modulo n 10)]\n               [d2 (modulo (quotient n 10) 10)]\n               [d3 (modulo (quotient n 100) 10)])\n          (if (or (and (= d1 d2) (= d2 d3))\n                  (and (= d1 (+ d2 1)) (= d2 (+ d3 1)))\n                  (and (= d1 (- d2 1)) (= d2 (- d3 1))))\n              (is_undulating-iter (quotient n 10))\n              #f))))\n  (is_undulating-iter n))\n",
    "  (define (is-undulating-iter n i)\n    (cond ((= i 0) #t)\n          ((= (modulo (quotient n (expt 10 i)) 10)\n              (modulo (quotient n (expt 10 (- i 1))) 10))\n           (is-undulating-iter n (- i 1)))\n          (else #f)))\n  (is-undulating-iter n (- (string-length (number->string n)) 1)))\n",
    "  (let loop ([n (number->string n)] [prev #\\0])\n    (cond [(empty? n) #t]\n          [(= (string-ref n 0) prev) #f]\n          [else (loop (rest n) (string-ref n 0))])))\n",
    "  (let loop ((n (number->string n))\n             (prev-digit #\\0)\n             (prev-prev-digit #\\0)\n             (undulating? #t))\n    (cond ((null? n) undulating?)\n          ((and (char=? (car n) prev-digit)\n                (char=? (car n) prev-prev-digit))\n           (loop (cdr n) prev-digit prev-prev-digit #f))\n          ((char=? (car n) prev-digit)\n           (loop (cdr n) (car n) prev-digit #f))\n          (else (loop (cdr n) (car n) prev-digit undulating?)))))\n",
    "  (define (is_undulating-iter n1 n2)\n    (cond\n      [(empty? n) #t]\n      [(= (first n) n1) (is-undulating-iter n2 (first n))]\n      [(= (first n) n2) (is-undulating-iter n1 (first n))]\n      [else #f]))\n  (is-undulating-iter (first n) (first (rest n))))\n",
    "  (let loop ([n n] [prev -1])\n    (cond [(zero? n) #t]\n          [(= (modulo n 10) prev) #f]\n          [else (loop (quotient n 10) (modulo n 10))])))\n",
    "  (define (is_undulating-iter n i)\n    (cond ((= n 0) #t)\n          ((= i 0) (is_undulating-iter (quotient n 10) 1))\n          ((= (modulo n 10) (modulo (quotient n 100) 10)) #f)\n          (else (is_undulating-iter (quotient n 10) (+ i 1)))))\n  (is_undulating-iter n 0))\n",
    "  (let loop ([n n] [prev-digit -1])\n    (cond\n      [(zero? n) #t]\n      [(zero? (modulo n 10)) (loop (quotient n 10) prev-digit)]\n      [(= (modulo n 10) prev-digit) #f]\n      [else (loop (quotient n 10) (modulo n 10))])))\n",
    "  (define (is_undulating-helper n)\n    (cond\n      [(zero? n) #t]\n      [(zero? (remainder n 10)) #f]\n      [else\n       (let* ([d1 (remainder n 10)]\n              [d2 (remainder (quotient n 10) 10)])\n         (cond\n           [(= d1 d2) #f]\n           [(= (abs (- d1 d2)) 1) (is_undulating-helper (quotient n 10))]\n           [else #f]))]))\n  (is_undulating-helper n))\n",
    "  (let loop ((n (number->string n))\n             (prev-digit (string->number (string-ref n 0)))\n             (i 1))\n    (cond ((= i (string-length n)) #t)\n          ((= (modulo i 2) 0)\n           (let ((cur-digit (string->number (string-ref n i))))\n             (if (= cur-digit prev-digit)\n                 (loop n cur-digit (+ i 1))\n                 #f)))\n          ((= (modulo i 2) 1)\n           (let ((cur-digit (string->number (string-ref n i))))\n             (if (= cur-digit (- prev-digit 1))\n                 (loop n cur-digit (+ i 1))\n                 #f))))))\n",
    "  (let loop ((n (number->string n))\n             (prev-digit #\\0)\n             (prev-prev-digit #\\0))\n    (cond ((null? n) #t)\n          ((and (char=? (car n) prev-digit)\n                (char=? (car n) prev-prev-digit))\n           #f)\n          (else (loop (cdr n) (car n) prev-digit)))))\n",
    "  (let loop ([n (number->string n)]\n             [prev-digit (string->number (string-ref n 0))]\n             [i 1])\n    (cond [(= i (string-length n)) #t]\n          [(= (modulo (string->number (string-ref n i)) 2)\n              (modulo prev-digit 2))\n           (loop n (string->number (string-ref n i)) (+ i 1))]\n          [else #f])))\n",
    "  (define (is_undulating-iter n prev-digit prev-diff)\n    (cond\n      [(zero? n) #t]\n      [(zero? (modulo n 10)) (is_undulating-iter (quotient n 10) prev-digit prev-diff)]\n      [(= prev-digit (modulo n 10)) (is_undulating-iter (quotient n 10) prev-digit prev-diff)]\n      [(= prev-diff (- (modulo n 10) prev-digit)) (is_undulating-iter (quotient n 10) (modulo n 10) (- (modulo n 10) prev-digit))]\n      [else #f]))\n  (is_undulating-iter n -1 -1))\n",
    "  (define (is_undulating-iter n1 n2 n3)\n    (cond\n      [(zero? n1) #t]\n      [(and (not (zero? n2)) (not (zero? n3))\n            (= (modulo n1 10) (modulo n2 10))\n            (= (modulo n2 10) (modulo n3 10)))\n       (is_undulating-iter (quotient n1 10) (quotient n2 10) (quotient n3 10))]\n      [else #f]))\n  (is_undulating-iter n (quotient n 10) (quotient n 100)))\n",
    "  (cond\n    [(= n 0) #f]\n    [(= n 1) #f]\n    [(= n 2) #f]\n    [(= n 3) #f]\n    [(= n 4) #f]\n    [(= n 5) #f]\n    [(= n 6) #f]\n    [(= n 7) #f]\n    [(= n 8) #f]\n    [(= n 9) #f]\n    [else\n     (let ([d1 (modulo n 10)]\n           [d2 (modulo (quotient n 10) 10)]\n           [d3 (modulo (quotient n 100) 10)])\n       (cond\n         [(= d1 d2) #f]\n         [(= d2 d3) #f]\n         [(= d1 (+ d2 d3)) #t]\n         [else #f]))]))\n",
    "  (let loop ([n n] [prev-digit -1])\n    (if (zero? n)\n        #t\n        (let ([curr-digit (remainder n 10)])\n          (if (or (and (positive? prev-digit) (negative? (- curr-digit prev-digit)))\n                  (and (negative? prev-digit) (positive? (- curr-digit prev-digit))))\n              (loop (quotient n 10) curr-digit)\n              #f)))))\n",
    "  (define (is_undulating-iter n i)\n    (cond\n      [(= i 1) #t]\n      [(= (modulo n 10) (modulo (quotient n 10) 10)) (is-undulating-iter (quotient n 10) (- i 1))]\n      [else #f]))\n  (is-undulating-iter n (length (number->string n))))\n",
    "  (define (is_undulating-iter n1 n2 n3)\n    (cond\n      [(= n3 0) #t]\n      [(= (modulo n3 10) (- n2 n1)) (is_undulating-iter n2 (modulo n3 10) (quotient n3 10))]\n      [else #f]))\n  (is_undulating-iter (- (modulo n 10) (quotient n 10)) (modulo n 10) (quotient n 10)))\n",
    "  (let loop ((n n) (prev-digit #f) (prev-prev-digit #f))\n    (cond ((zero? n) #t)\n          ((and (not prev-digit) (not prev-prev-digit))\n           (loop (quotient n 10) (remainder n 10) #f))\n          ((and (not prev-digit) prev-prev-digit)\n           (loop (quotient n 10) (remainder n 10) prev-prev-digit))\n          ((and prev-digit prev-prev-digit)\n           (if (and (= (abs (- prev-digit prev-prev-digit)) 1)\n                    (= (abs (- (remainder n 10) prev-digit)) 1))\n               (loop (quotient n 10) (remainder n 10) prev-digit)\n               #f)))))\n",
    "  (let loop ((n (number->string n))\n             (prev-digit (string->number (substring n 0 1)))\n             (curr-digit (string->number (substring n 1 2)))\n             (next-digit (string->number (substring n 2 3))))\n    (cond ((and (zero? (modulo (sub1 (string-length n)) 3))\n                (zero? (modulo (sub1 (string-length n)) 6)))\n           (and (or (= prev-digit curr-digit)\n                    (= curr-digit next-digit))\n                (loop (substring n 3)\n                      curr-digit\n                      next-digit\n                      (string->number (substring n 3 4)))))\n          ((zero? (modulo (sub1 (string-length n)) 3))\n           (and (or (= prev-digit curr-digit)\n                    (= curr-digit next-digit))\n                (loop (substring n 3)\n                      curr-digit\n                      next-digit\n                      (string->number (substring n 3 4)))))\n          ((zero? (modulo (sub1 (string-length n)) 6))\n           (and (or (= prev-digit curr-digit)\n                    (= curr-digit next-digit))\n                (loop (substring n 3)\n                      curr-digit\n                      next-digit\n                      (string->number (substring n 3 4)))))\n          (else #t))))\n",
    "  (define (is_undulating-iter n prev-digit prev-diff)\n    (cond ((zero? n) #t)\n          ((zero? prev-diff) (is-undulating-iter (quotient n 10) (remainder n 10) 0))\n          ((= (remainder n 10) (+ prev-digit prev-diff)) (is-undulating-iter (quotient n 10) (remainder n 10) prev-diff))\n          ((= (remainder n 10) (- prev-digit prev-diff)) (is-undulating-iter (quotient n 10) (remainder n 10) (- prev-diff)))\n          (else #f)))\n  (is-undulating-iter n 0 0))\n",
    "  (define (is_undulating-iter n prev-digit prev-diff)\n    (cond\n      [(zero? n) #t]\n      [(= prev-digit (remainder n 10)) #f]\n      [(= prev-diff (- (remainder n 10) prev-digit)) #f]\n      [else (is-undulating-iter (quotient n 10) (remainder n 10) (- (remainder n 10) prev-digit))]))\n  (is-undulating-iter n 0 0))\n",
    "  (if (or (zero? n) (negative? n))\n      #f\n      (let loop ([n n] [prev-digit 0] [prev-prev-digit 0] [is-increasing? #t])\n        (cond [(zero? n) (and is-increasing? (not (= prev-digit prev-prev-digit)))]\n              [(= (modulo n 10) prev-digit) #f]\n              [else (loop (quotient n 10) (modulo n 10) prev-digit (not is-increasing?))]))))\n",
    "  (let loop ([n (number->string n)]\n             [prev-digit #\\0]\n             [prev-prev-digit #\\0]\n             [undulating? #t])\n    (cond [(empty? n) undulating?]\n          [(char=? (first n) prev-digit) (loop (rest n) prev-digit prev-prev-digit #f)]\n          [(char=? (first n) prev-prev-digit) (loop (rest n) (first n) prev-digit undulating?)]\n          [else (loop (rest n) (first n) prev-digit undulating?)])))\n",
    "  (define (is_undulating-iter n1 n2 n3)\n    (cond ((or (and (= n1 n2) (= n2 n3))\n               (and (= n1 n3) (= n2 n3)))\n           #f)\n          ((and (= n1 n2) (not (= n2 n3)))\n           (is-undulating-iter n2 n3 (remainder (quotient n3 10) 10)))\n          ((and (not (= n1 n2)) (= n2 n3))\n           (is-undulating-iter n1 n2 (remainder (quotient n2 10) 10)))\n          (else #t)))\n  (is-undulating-iter (remainder (quotient n 100) 10)\n                      (remainder (quotient n 10) 10)\n                      (remainder n 10)))\n",
    "  (define (is_undulating-iter n prev-digit prev-diff)\n    (if (= n 0)\n        #t\n        (let* ((curr-digit (modulo n 10))\n               (curr-diff (- curr-digit prev-digit)))\n          (if (and (= curr-diff prev-diff)\n                   (not (= curr-diff 0)))\n              (is_undulating-iter (quotient n 10) curr-digit curr-diff)\n              #f))))\n  (is_undulating-iter n 0 0))\n",
    "  (let loop ([n (number->string n)]\n             [prev-digit #\\0]\n             [prev-prev-digit #\\0]\n             [undulating? #t])\n    (cond [(empty? n) undulating?]\n          [(and (= (string-ref n 0) prev-digit)\n                (= (string-ref n 0) prev-prev-digit))\n           (loop (rest n) (string-ref n 0) prev-digit #f)]\n          [(and (= (string-ref n 0) prev-digit)\n                (not (= (string-ref n 0) prev-prev-digit)))\n           (loop (rest n) (string-ref n 0) prev-digit undulating?)]\n          [(and (not (= (string-ref n 0) prev-digit))\n                (= (string-ref n 0) prev-prev-digit))\n           (loop (rest n) (string-ref n 0) prev-digit undulating?)]\n          [(and (not (= (string-ref n 0) prev-digit))\n                (not (= (string-ref n 0) prev-prev-digit)))\n           (loop (rest n) (string-ref n 0) prev-digit undulating?)])))\n",
    "  (let loop ((n (number->string n))\n             (prev #\\0)\n             (curr (string-ref n 0))\n             (next (string-ref n 1)))\n    (cond ((null? n) #t)\n          ((and (char=? prev curr) (char=? curr next)) #f)\n          (else (loop (substring n 1) curr next (string-ref n 2))))))\n",
    "  (define (is_undulating-iter n prev-digit prev-diff)\n    (cond\n      [(zero? n) #t]\n      [(and (zero? prev-diff) (zero? (modulo n 10)))\n       (is-undulating-iter (quotient n 10) prev-digit prev-diff)]\n      [(zero? prev-diff)\n       (is-undulating-iter (quotient n 10) (modulo n 10) (sub1 prev-digit))]\n      [(and (= (modulo n 10) (add1 prev-digit))\n            (= (sub1 prev-digit) prev-diff))\n       (is-undulating-iter (quotient n 10) (modulo n 10) (sub1 prev-digit))]\n      [(and (= (modulo n 10) (sub1 prev-digit))\n            (= (add1 prev-digit) prev-diff))\n       (is-undulating-iter (quotient n 10) (modulo n 10) (add1 prev-digit))]\n      [else #f]))\n  (is-undulating-iter n 0 0))\n",
    "  (let loop ([n n] [prev #f])\n    (cond\n      [(zero? n) #t]\n      [(zero? (modulo n 10)) #f]\n      [(and prev (= prev (modulo n 10))) #f]\n      [else (loop (quotient n 10) (modulo n 10))])))\n",
    "  (define (is_undulating-iter n)\n    (cond ((< n 10) #f)\n          ((= (modulo n 10) (modulo (quotient n 10) 10))\n           (is-undulating-iter (quotient n 10)))\n          (else #t)))\n  (is_undulating-iter n))\n",
    "  (let loop ([n n] [prev-digit 0] [prev-prev-digit 0])\n    (cond [(zero? n) #t]\n          [(= prev-digit (- (remainder n 10) 1))\n           (loop (quotient n 10) (remainder n 10) prev-digit)]\n          [(= prev-digit (+ (remainder n 10) 1))\n           (loop (quotient n 10) (remainder n 10) prev-digit)]\n          [(= prev-digit (remainder n 10))\n           (loop (quotient n 10) (remainder n 10) prev-digit)]\n          [else #f])))\n",
    "  (define (is_undulating-iter n1 n2 n3)\n    (cond ((and (zero? n1) (zero? n2) (zero? n3)) #t)\n          ((and (zero? n1) (zero? n2)) #f)\n          ((and (zero? n1) (zero? n3)) #f)\n          ((and (zero? n2) (zero? n3)) #f)\n          ((and (zero? n1) (not (zero? n2)) (not (zero? n3))) #f)\n          ((and (zero? n2) (not (zero? n1)) (not (zero? n3))) #f)\n          ((and (zero? n3) (not (zero? n1)) (not (zero? n2))) #f)\n          ((and (not (zero? n1)) (not (zero? n2)) (not (zero? n3))) #f)\n          (else (is_undulating-iter (modulo n1 10) (modulo n2 10) (modulo n3 10)))))\n  (is_undulating-iter (modulo n 100) (modulo n 10) (quotient n 10)))\n",
    "  (define (is_undulating-iter n prev-diff)\n    (cond [(zero? n) #t]\n          [(zero? (remainder n 10)) (is_undulating-iter (quotient n 10) prev-diff)]\n          [(= (remainder n 10) (remainder (+ n prev-diff) 10)) (is_undulating-iter (quotient n 10) (- prev-diff))]\n          [else #f]))\n  (is_undulating-iter n (- (remainder n 10))))\n",
    "  (let loop ([n (number->string n)]\n             [prev #\\0]\n             [prev-prev #\\0])\n    (cond\n      [(empty? n) #t]\n      [(and (char=? (first n) prev)\n            (char=? (first n) prev-prev))\n       #f]\n      [(char=? (first n) prev)\n       (loop (rest n) (first n) prev)]\n      [else\n       (loop (rest n) (first n) prev-prev)])))\n",
    "  (if (or (zero? n) (zero? (remainder n 10)))\n      #f\n      (let loop ((n n) (prev (remainder n 10)) (cur (remainder (quotient n 10) 10)))\n        (if (zero? cur)\n            #t\n            (if (and (= (abs (- prev cur)) 1) (not (zero? (remainder (quotient n 10) 10))))\n                (loop (quotient n 10) cur (remainder (quotient n 10) 10))\n                #f)))))\n",
    "  (define (is_undulating-iter n prev-digit)\n    (cond\n      [(zero? n) #t]\n      [(= (modulo n 10) prev-digit) #f]\n      [else (is-undulating-iter (quotient n 10) (modulo n 10))]))\n  (is-undulating-iter n (modulo n 10)))\n",
    "  (let loop ((n (number->string n))\n             (prev-digit #\\0)\n             (prev-prev-digit #\\0)\n             (undulating? #t))\n    (cond ((null? n) undulating?)\n          ((and (= (string-ref n 0) prev-digit)\n                (= (string-ref n 0) prev-prev-digit))\n           (loop (cdr n) prev-digit prev-prev-digit #f))\n          ((and (= (string-ref n 0) prev-digit)\n                (not (= (string-ref n 0) prev-prev-digit)))\n           (loop (cdr n) (string-ref n 0) prev-digit #t))\n          (else (loop (cdr n) (string-ref n 0) prev-digit undulating?)))))\n",
    "  (define (is_undulating-iter n i)\n    (cond\n      [(= i 1) #t]\n      [(= (modulo n 10) (modulo (quotient n 10) 10)) (is-undulating-iter (quotient n 10) (- i 1))]\n      [else #f]))\n  (is-undulating-iter n (number->string n)))\n",
    "  (let loop ((n (number->string n))\n             (prev-digit (string->number (substring n 0 1)))\n             (prev-diff 0)\n             (i 1))\n    (cond ((= i (string-length n)) #t)\n          ((= prev-diff 0)\n           (let ((cur-digit (string->number (substring n i (+ i 1)))))\n             (loop n cur-digit (- cur-digit prev-digit) (+ i 1))))\n          ((= prev-diff (- (string->number (substring n i (+ i 1)))\n                           prev-digit))\n           (loop n prev-digit prev-diff (+ i 1)))\n          (else #f))))\n",
    "  (let loop ((n n) (prev -1) (curr -1) (next -1))\n    (cond\n      [(zero? n) #t]\n      [(= prev curr) (loop (quotient n 10) curr next (remainder n 10))]\n      [(= curr next) (loop (quotient n 10) prev curr (remainder n 10))]\n      [else #f])))\n",
    "  (define (is_undulating-iter n prev-digit prev-diff)\n    (if (zero? n)\n        #t\n        (let ((curr-digit (modulo n 10))\n              (curr-diff (- curr-digit prev-digit)))\n          (if (and (not (zero? prev-diff))\n                   (not (= curr-diff prev-diff)))\n              (is-undulating-iter (quotient n 10) curr-digit curr-diff)\n              #f))))\n  (is-undulating-iter n 0 0))\n",
    "  (define (undulating? n)\n    (let loop ([n (number->string n)]\n               [prev-digit #\\0]\n               [prev-prev-digit #\\0])\n      (cond [(empty? n) #t]\n            [(and (char=? (first n) prev-digit)\n                  (char=? (first n) prev-prev-digit)) #f]\n            [(char=? (first n) prev-digit)\n             (loop (rest n) (first n) prev-digit)]\n            [else (loop (rest n) (first n) prev-digit)])))\n  (undulating? n))\n",
    "  (define (is_undulating-iter n1 n2 n3)\n    (cond ((or (zero? n1) (zero? n2) (zero? n3)) #f)\n          ((and (= n1 n2) (= n2 n3)) #f)\n          ((and (= n1 n2) (= n2 n3)) #f)\n          ((and (= n1 n2) (= n3 n2)) #f)\n          ((and (= n1 n2) (= n3 n2)) #f)\n          ((and (= n1 n2) (= n3 n2)) #f)\n          ((and (= n1 n2) (= n3 n2)) #f)\n          ((and (= n1 n2) (= n3 n2)) #f)\n          ((and (= n1 n2) (= n3 n2)) #f)\n          ((and (= n1 n2) (= n3 n2)) #f)\n          ((and (= n1 n2) (= n3 n2)) #f)\n          ((and (= n1 n2) (= n3 n2)) #f)\n          ((and (= n1 n2) (= n3 n2)) #f)\n          ((and (= n1 n2) (= n3 n2)) #f)\n          ((and (= n1 n2) (= n3 n2)) #f)\n          ((and (= n1 n2) (= n3 n2)) #f)\n          ((and (= n1 n2) (= n3 n2)) #f)\n          ((and (= n1 n2) (= n3 n2)) #f)\n          ((and (= n1 n2) (= n3 n2)) #f)\n          ((and (= n1 n2) (= n3 n2)) #f)\n          ((and (= n1 n2) (= n3 n2)) #f)\n          ((and (= n1 n2) (= n3 n2)) #f)\n          ((and (= n1 n2) (= n3 n2)) #f)\n          ((and (= n1 n2) (= n3 n2)) #f)\n          ((and (= n1 n2) (= n3 n2)) #f)\n          ((and (= n1 n2) (=",
    "  (let loop ([n (number->string n)]\n             [prev #\\0]\n             [curr (string-ref n 0)]\n             [next (string-ref n 1)])\n    (cond [(empty? n) #t]\n          [(> (char->integer next) (char->integer curr))\n           (loop (substring n 1) curr next (string-ref n 2))]\n          [(< (char->integer next) (char->integer curr))\n           (loop (substring n 1) curr next (string-ref n 2))]\n          [(= (char->integer next) (char->integer curr))\n           (loop (substring n 1) curr next (string-ref n 2))]\n          [(= (char->integer next) (char->integer prev))\n           (loop (substring n 1) curr next (string-ref n 2))]\n          [else #f])))\n",
    "  (let loop ([n n] [prev -1])\n    (cond\n      [(zero? n) #t]\n      [(= (modulo n 10) prev) #f]\n      [else (loop (quotient n 10) (modulo n 10))])))\n",
    "  (let loop ([n n] [prev #f])\n    (cond [(zero? n) #t]\n          [(and (not prev) (odd? n)) (loop (quotient n 10) #t)]\n          [(and prev (even? n)) (loop (quotient n 10) #f)]\n          [else #f])))\n",
    "  (define (is_undulating-iter n1 n2 n3)\n    (cond\n      [(zero? n1) #t]\n      [(and (equal? n1 n2) (equal? n2 n3)) #f]\n      [(and (equal? n1 n2) (not (equal? n2 n3)))\n       (is-undulating-iter (quotient n1 10) (quotient n2 10) (quotient n3 10))]\n      [(and (not (equal? n1 n2)) (equal? n2 n3))\n       (is-undulating-iter (quotient n1 10) (quotient n2 10) (quotient n3 10))]\n      [(and (not (equal? n1 n2)) (not (equal? n2 n3)))\n       (is-undulating-iter (quotient n1 10) (quotient n2 10) (quotient n3 10))]))\n  (is-undulating-iter (quotient n 100) (quotient n 10) (remainder n 10)))\n",
    "  (define (is_undulating-iter n1 n2 n3)\n    (cond\n      [(zero? n3) #t]\n      [(and (= n1 n2) (= n2 n3)) (is-undulating-iter n2 n3 (remainder n3 10))]\n      [else #f]))\n  (is-undulating-iter (remainder n 100) (remainder n 10) (quotient n 10)))\n",
    "  (let loop ([n (number->string n)]\n             [prev-digit (string->number (substring n 0 1))]\n             [i 1])\n    (cond\n      [(= i (string-length n)) #t]\n      [(= (modulo i 2) 1)\n       (let ([curr-digit (string->number (substring n i (+ i 1)))])\n         (and (= (abs (- prev-digit curr-digit)) 1)\n              (loop n curr-digit (+ i 1))))]\n      [(= (modulo i 2) 0)\n       (let ([curr-digit (string->number (substring n i (+ i 1)))])\n         (and (= prev-digit curr-digit)\n              (loop n curr-digit (+ i 1))))])))\n",
    "  (let loop ((n n) (prev-digit -1) (prev-prev-digit -1) (is-undulating #t))\n    (cond ((zero? n) is-undulating)\n          ((and (not (zero? prev-digit))\n                (not (zero? prev-prev-digit))\n                (or (and (= prev-digit prev-prev-digit)\n                         (= (remainder n 10) prev-digit))\n                    (and (= (remainder n 10) prev-prev-digit)\n                         (= prev-digit prev-prev-digit))))\n           (loop (quotient n 10)\n                 (remainder n 10)\n                 prev-digit\n                 #f))\n          (else (loop (quotient n 10)\n                      (remainder n 10)\n                      prev-digit\n                      is-undulating)))))\n",
    "  (define (is_undulating-iter n last-digit)\n    (cond\n      [(zero? n) #t]\n      [(= last-digit (remainder n 10)) #f]\n      [else (is_undulating-iter (quotient n 10) (remainder n 10))]))\n  (is_undulating-iter n (remainder n 10)))\n",
    "  (let loop ((n (number->string n))\n             (prev #\\0)\n             (curr (string-ref n 0))\n             (next (string-ref n 1)))\n    (cond ((null? n) #t)\n          ((char=? prev curr) #f)\n          ((char=? curr next) #f)\n          (else (loop (substring n 1) curr next (string-ref n 2))))))\n",
    "  (define (is_undulating-iter n i)\n    (cond\n      [(= i 0) #t]\n      [(= (modulo n 10) (modulo (quotient n 10) 10)) (is-undulating-iter (quotient n 10) (- i 1))]\n      [else #f]))\n  (is-undulating-iter n (length (number->string n))))\n",
    "  (let loop ([n (number->string n)]\n             [prev (string-&gt;number (string-ref n 0))])\n    (cond [(empty? n) #t]\n          [(= (string-&gt;number (string-ref n 0)) prev) #f]\n          [else (loop (rest n) (string-&gt;number (string-ref n 0)))])))\n",
    "  (let loop ((n (number->string n))\n             (prev-digit (string-&gt;number (string-ref n 0)))\n             (i 1))\n    (cond ((&gt;= i (string-length n)) #t)\n          ((= (modulo i 2) 0)\n           (let ((cur-digit (string-&gt;number (string-ref n i))))\n             (if (= prev-digit cur-digit)\n                 (loop n prev-digit (+ i 1))\n                 #f)))\n          ((= (modulo i 2) 1)\n           (let ((cur-digit (string-&gt;number (string-ref n i))))\n             (if (= prev-digit cur-digit)\n                 #f\n                 (loop n prev-digit (+ i 1))))))))\n</code>\n",
    "  (define (is_undulating-iter n prev-digit prev-diff)\n    (cond [(zero? n) #t]\n          [(and (zero? prev-diff)\n                (zero? (modulo n 10)))\n           (is-undulating-iter (quotient n 10) (modulo n 10) 0)]\n          [(and (zero? prev-diff)\n                (not (zero? (modulo n 10))))\n           (is-undulating-iter (quotient n 10) (modulo n 10) (modulo n 10))]\n          [(and (not (zero? prev-diff))\n                (zero? (modulo n 10)))\n           (is-undulating-iter (quotient n 10) (modulo n 10) 0)]\n          [(and (not (zero? prev-diff))\n                (not (zero? (modulo n 10))))\n           (is-undulating-iter (quotient n 10) (modulo n 10) (- (modulo n 10) prev-digit))]))\n  (is-undulating-iter n 0 0))\n",
    "  (define (is_undulating-iter n prev-digit curr-digit)\n    (if (zero? n)\n        #t\n        (let ((next-digit (modulo n 10)))\n          (if (and (not (zero? prev-digit))\n                   (not (zero? curr-digit))\n                   (not (zero? next-digit)))\n              (if (and (= prev-digit next-digit)\n                       (not (= curr-digit next-digit)))\n                  (is-undulating-iter (quotient n 10) curr-digit next-digit)\n                  #f)\n              #f))))\n  (is-undulating-iter n -1 -1))\n",
    "  (let loop ((n (number->string n))\n             (prev #f)\n             (next #f))\n    (cond ((null? n) #t)\n          ((and (not prev) (not next))\n           (loop (cdr n) (car n) (cadr n)))\n          ((and (not prev) next)\n           (loop (cdr n) (car n) (cadr n)))\n          ((and prev next)\n           (cond ((= (char->integer prev) (char->integer next))\n                  (loop (cdr n) (car n) (cadr n)))\n                 ((< (char->integer prev) (char->integer next))\n                  (loop (cdr n) (car n) (cadr n)))\n                 ((> (char->integer prev) (char->integer next))\n                  (loop (cdr n) (car n) (cadr n)))))\n          (else #f))))\n",
    "  (let loop ([n n] [prev-digit -1] [prev-diff 0])\n    (cond\n      [(zero? n) #t]\n      [(zero? (remainder n 10)) #f]\n      [else\n       (let ([curr-digit (remainder n 10)])\n         (let ([curr-diff (- curr-digit prev-digit)])\n           (if (and (not (zero? prev-digit))\n                    (not (zero? prev-diff))\n                    (not (= curr-diff prev-diff)))\n               #t\n               (loop (quotient n 10) curr-digit curr-diff))))])))\n",
    "  (define (is_undulating-iter n prev-digit prev-diff)\n    (cond\n      [(zero? n) #t]\n      [(= prev-diff (- (modulo n 10) prev-digit))\n       (is_undulating-iter (quotient n 10) (- (modulo n 10)) (- prev-digit (modulo n 10)))\n      ]\n      [else #f]))\n  (is_undulating-iter n (- (modulo n 10)) (- (modulo n 10))))\n",
    "  (let loop ([n n] [prev-digit -1])\n    (cond [(zero? n) #t]\n          [(= prev-digit (remainder n 10)) #f]\n          [else (loop (quotient n 10) (remainder n 10))])))\n",
    "  (let loop ([n (number->string n)])\n    (cond\n      [(empty? n) #t]\n      [(< (string-&gt;number (substring n 0 2))\n          (string-&gt;number (substring n 1 3)))\n       (loop (substring n 1))]\n      [else #f])))\n</code>\n",
    "  (let loop ((n (number->string n))\n             (prev-digit #\\0)\n             (prev-prev-digit #\\0)\n             (is-increasing? #t))\n    (cond ((null? n) #t)\n          ((and (char=? (car n) prev-digit)\n                (char=? (car n) prev-prev-digit))\n           #f)\n          ((char<? (car n) prev-digit)\n           (if is-increasing? #f (loop (cdr n) (car n) prev-digit #f)))\n          ((char>? (car n) prev-digit)\n           (if is-increasing? (loop (cdr n) (car n) prev-digit #f) #f))\n          (else (loop (cdr n) (car n) prev-digit is-increasing?)))))\n",
    "  (define (is_undulating-iter n)\n    (cond ((< n 10) #f)\n          ((= (modulo n 10) (modulo (quotient n 10) 10))\n           (is-undulating-iter (quotient n 10)))\n          (else #t)))\n  (is-undulating-iter n))\n",
    "  (let loop ([n (number->string n)]\n             [i 0]\n             [j 1])\n    (cond [(empty? n) #t]\n          [(= (string-ref n i) (string-ref n j)) (loop (substring n 1) 0 1)]\n          [else #f])))\n",
    "  (define (is-undulating-helper n)\n    (if (= n 0)\n        #f\n        (let* ([d1 (modulo n 10)]\n               [d2 (modulo (quotient n 10) 10)])\n          (if (= d1 d2)\n              (is-undulating-helper (quotient n 10))\n              (if (and (= d1 (+ d2 1))\n                       (is-undulating-helper (quotient n 10)))\n                  #t\n                  (if (and (= d1 (- d2 1))\n                           (is-undulating-helper (quotient n 10)))\n                      #t\n                      #f))))))\n  (is-undulating-helper n))\n",
    "  (define (helper n)\n    (cond\n      [(zero? n) #t]\n      [(zero? (remainder n 10)) #f]\n      [else (helper (quotient n 10))]))\n  (helper n))\n",
    "  (define (is-undulating-iter n prev-digit prev-diff)\n    (cond\n      [(zero? n) #t]\n      [(= prev-diff (abs (- (modulo n 10) prev-digit)))\n       (is-undulating-iter (quotient n 10) (modulo n 10) prev-diff)]\n      [else #f]))\n  (is-undulating-iter n (- (modulo n 10) (modulo (quotient n 10) 10)) (abs (- (modulo n 10) (modulo (quotient n 10) 10)))))\n",
    "  (define (is_undulating-iter n prev-digit prev-diff)\n    (if (= n 0)\n        #t\n        (let ((cur-digit (modulo n 10))\n              (cur-diff (- prev-digit (modulo n 10))))\n          (if (and (= cur-diff prev-diff)\n                   (= cur-digit prev-digit))\n              #f\n              (is-undulating-iter (quotient n 10) cur-digit cur-diff)))))\n  (is-undulating-iter n 0 0))\n",
    "  (let loop ((n (number->string n))\n             (prev (string-&gt;number (string-ref n 0)))\n             (i 1))\n    (cond ((&gt;= i (string-length n)) #t)\n          ((= prev (string-&gt;number (string-ref n i))) #f)\n          (else (loop (substring n 1)\n                      (string-&gt;number (string-ref n i))\n                      (+ i 1))))))\n",
    "  (let loop ([n n] [prev-digit -1] [prev-diff 0])\n    (cond [(zero? n) #t]\n          [(zero? (modulo n 10)) (loop (quotient n 10) prev-digit prev-diff)]\n          [(= prev-digit -1) (loop (quotient n 10) (modulo n 10) 0)]\n          [(= prev-diff (- (modulo n 10) prev-digit))\n           (loop (quotient n 10) (modulo n 10) (- (modulo n 10) prev-digit))]\n          [else #f])))\n",
    "  (define (is_undulating-helper n)\n    (cond\n      [(zero? n) #t]\n      [(zero? (remainder n 10)) #f]\n      [(zero? (remainder (quotient n 10) 10)) #f]\n      [else (is_undulating-helper (quotient n 10))]))\n  (is_undulating-helper n))\n",
    "  (let loop ([n n]\n             [prev-digit -1]\n             [prev-prev-digit -1])\n    (if (zero? n)\n        #t\n        (let ([cur-digit (modulo n 10)])\n          (if (and (not (equal? prev-digit -1))\n                   (not (equal? prev-prev-digit -1))\n                   (not (equal? (modulo prev-digit 10)\n                                (modulo prev-prev-digit 10))))\n              #f\n              (loop (quotient n 10)\n                    cur-digit\n                    prev-digit))))))\n",
    "  (define (is-undulating-iter n prev-digit prev-diff)\n    (cond ((zero? n) #t)\n          ((and (= prev-diff (modulo (- (quotient n 10) prev-digit) 10))\n                (not (zero? prev-diff)))\n           (is-undulating-iter (quotient n 10) (modulo n 10) prev-diff))\n          ((zero? prev-diff)\n           (is-undulating-iter (quotient n 10) (modulo n 10) (- (modulo n 10) (quotient n 10))))\n          (else #f)))\n  (is-undulating-iter n 0 0))\n",
    "  (define (is_undulating-iter n prev-digit prev-diff)\n    (cond\n      [(zero? n) #t]\n      [(and (zero? prev-diff)\n            (zero? (modulo n 10)))\n       (is-undulating-iter (quotient n 10) prev-digit prev-diff)]\n      [(and (zero? prev-diff)\n            (not (zero? (modulo n 10))))\n       (is-undulating-iter (quotient n 10) (modulo n 10) prev-diff)]\n      [(and (not (zero? prev-diff))\n            (zero? (modulo n 10)))\n       (is-undulating-iter (quotient n 10) prev-digit prev-diff)]\n      [(and (not (zero? prev-diff))\n            (not (zero? (modulo n 10))))\n       (if (= (modulo n 10) (- prev-digit prev-diff))\n           (is-undulating-iter (quotient n 10) (modulo n 10) prev-diff)\n           #f)]))\n  (is-undulating-iter n 0 0))\n",
    "  (let loop ([n (number->string n)]\n             [prev (string-&gt;number (string-ref n 0))]\n             [i 1])\n    (cond [(empty? n) #t]\n          [(= i (string-length n)) #f]\n          [(= (string-&gt;number (string-ref n i)) prev)\n           (loop (substring n i) prev (+ i 1))]\n          [else (loop (substring n i) (string-&gt;number (string-ref n i)) (+ i 1))])))\n",
    "  (define (is_undulating-helper n)\n    (if (< n 10)\n        #f\n        (let ((d1 (modulo n 10))\n              (d2 (modulo (quotient n 10) 10)))\n          (if (and (= d1 d2)\n                   (not (zero? d1)))\n              #t\n              (is_undulating-helper (quotient n 10))))))\n  (is_undulating-helper n))\n",
    "  (let loop ([n n] [prev-digit -1] [prev-prev-digit -1])\n    (cond [(zero? n) #t]\n          [(and (= prev-digit (- (remainder n 10) (remainder (quotient n 10) 10)))\n                (= prev-prev-digit (- (remainder (quotient n 10) 10) (remainder (quotient n 100) 10))))\n           (loop (quotient n 10) (remainder n 10) (remainder (quotient n 10) 10))]\n          [else #f])))\n",
    "  (let loop ((n n) (prev-digit -1) (prev-diff 0) (undulating? #t))\n    (cond\n      [(zero? n) undulating?]\n      [(not (= (abs (- (remainder n 10) prev-digit)) prev-diff))\n       (loop (quotient n 10) (remainder n 10) (- (remainder n 10) prev-digit) #f)]\n      [else (loop (quotient n 10) (remainder n 10) (- (remainder n 10) prev-digit) undulating?)])))\n",
    "  (define (is-undulating-iter n prev-digit prev-diff)\n    (cond\n      [(zero? n) #t]\n      [(= prev-diff (abs (- (modulo n 10) prev-digit)))\n       (is-undulating-iter (quotient n 10) (modulo n 10) prev-diff)]\n      [else #f]))\n  (is-undulating-iter n (modulo n 10) 0))\n",
    "  (cond\n    [(= n 0) #f]\n    [(= n 1) #t]\n    [(= n 2) #t]\n    [else\n     (let ([n (number->string n)])\n       (let loop ([i 0] [j 1])\n         (cond\n           [(= i (- (string-length n) 1)) #t]\n           [(= j (- (string-length n) 1)) #f]\n           [(= (string-ref n i) (string-ref n j)) (loop (+ i 1) (+ j 1))]\n           [(= (string-ref n i) (string-ref n (+ j 1))) (loop (+ i 1) (+ j 2))]\n           [(= (string-ref n (+ i 1)) (string-ref n j)) (loop (+ i 2) (+ j 1))]\n           [(= (string-ref n (+ i 1)) (string-ref n (+ j 1))) (loop (+ i 2) (+ j 2))]\n           [else #f])))))\n",
    "  (let loop ([n n] [prev-digit -1] [prev-diff 0] [is-undulating #t])\n    (cond\n      [(zero? n) is-undulating]\n      [(zero? prev-digit) (loop (quotient n 10) (remainder n 10) 0 is-undulating)]\n      [(zero? prev-diff) (loop (quotient n 10) (remainder n 10) (- (remainder n 10) prev-digit) is-undulating)]\n      [(= (abs (- (remainder n 10) prev-digit)) prev-diff) (loop (quotient n 10) (remainder n 10) (- (remainder n 10) prev-digit) is-undulating)]\n      [else #f])))\n",
    "  (define (is_undulating-helper n)\n    (cond\n      [(zero? n) #t]\n      [(zero? (remainder n 10)) #f]\n      [(zero? (remainder (quotient n 10) 10)) #f]\n      [else (is_undulating-helper (quotient n 10))]))\n  (is_undulating-helper n))\n",
    "  (let loop ([n (number->string n)]\n             [prev #\\0]\n             [curr #\\0]\n             [next #\\0])\n    (cond [(empty? n) #t]\n          [(or (char=? prev curr)\n               (char=? curr next)) #f]\n          [else (loop (rest n) curr (first n) next)])))\n",
    "  (let loop ([n (number->string n)]\n             [prev (string-&gt;number (substring n 0 1))]\n             [i 1])\n    (cond\n      [(empty? n) #t]\n      [(= i (string-length n)) #f]\n      [(= (string-&gt;number (substring n i 1))\n          (+ prev 1))\n       (loop (substring n i)\n             (string-&gt;number (substring n i 1))\n             (+ i 1))]\n      [(= (string-&gt;number (substring n i 1))\n          (- prev 1))\n       (loop (substring n i)\n             (string-&gt;number (substring n i 1))\n             (+ i 1))]\n      [else #f])))\n",
    "  (define (is_undulating-iter n1 n2 n3)\n    (cond\n      [(= n3 0) #f]\n      [(= n1 n2) (is-undulating-iter n2 n3 (remainder n3 10))]\n      [(= n1 (- n2)) (is-undulating-iter n2 n3 (remainder n3 10))]\n      [else #f]))\n  (is-undulating-iter 0 (remainder n 10) (remainder (quotient n 10) 10)))\n",
    "  (define (is_undulating-iter n prev-digit prev-diff)\n    (cond\n      [(zero? n) #t]\n      [(= (modulo n 10) prev-digit) #f]\n      [(= (modulo n 10) (- prev-digit prev-diff))\n       (is-undulating-iter (quotient n 10) (modulo n 10) (- prev-digit (modulo n 10)))]\n      [else (is-undulating-iter (quotient n 10) (modulo n 10) (- (modulo n 10) prev-digit))]))\n  (is-undulating-iter n -1 -1))\n",
    "  (define (is_undulating-iter n i)\n    (cond\n      [(= i 0) #t]\n      [(= (modulo n 10) (modulo (quotient n 10) 10))\n       (is-undulating-iter (quotient n 10) (- i 1))]\n      [else #f]))\n  (is-undulating-iter n (number->string n)))\n",
    "  (let loop ((n (number->string n))\n             (i 0)\n             (j 1))\n    (cond ((null? n) #t)\n          ((null? (cdr n)) #t)\n          ((= (string-&gt;number (substring n i j))\n              (string-&gt;number (substring n j (+ j 1))))\n           #f)\n          (else (loop n (+ i 1) (+ j 1))))))\n",
    "  (define (is_undulating-iter n prev-digit)\n    (cond ((zero? n) #t)\n          ((= prev-digit (remainder n 10)) #f)\n          (else (is-undulating-iter (quotient n 10) (remainder n 10)))))\n  (is-undulating-iter n 0))\n",
    "  (define (is_undulating-helper n)\n    (cond\n      [(zero? n) #t]\n      [(zero? (remainder n 10)) #f]\n      [(zero? (remainder (quotient n 10) 10)) #f]\n      [else (is_undulating-helper (quotient n 10))]))\n  (is_undulating-helper n))\n",
    "  (define (is_undulating-iter n1 n2 n3)\n    (cond\n      [(= n3 0) #f]\n      [(= (modulo n1 10) (modulo n2 10)) (is-undulating-iter n2 n3 (quotient n3 10))]\n      [else #f]))\n  (is-undulating-iter (quotient n 10) (quotient n 100) (quotient n 1000)))\n",
    "  (let loop ((n (number->string n))\n             (prev-digit #\\0)\n             (prev-prev-digit #\\0)\n             (is-increasing? #t))\n    (cond ((null? n) #t)\n          ((= (string-length n) 1) #t)\n          ((= (string-length n) 2)\n           (if (and (char=? (string-ref n 0) prev-digit)\n                    (char=? (string-ref n 1) prev-prev-digit))\n               #t\n               #f))\n          ((char=? (string-ref n 0) prev-digit)\n           (loop (substring n 1)\n                 (string-ref n 1)\n                 prev-digit\n                 (not is-increasing?)))\n          ((if is-increasing?\n               (< (string->number (string (string-ref n 0)))\n                  (string->number (string (string-ref n 1))))\n               (> (string->number (string (string-ref n 0)))\n                  (string->number (string (string-ref n 1)))))\n           (loop (substring n 1)\n                 (string-ref n 0)\n                 prev-digit\n                 is-increasing?))\n          (else #f))))\n",
    "  (let loop ((n n) (prev-digit -1) (prev-diff 0) (prev-prev-diff 0))\n    (cond ((zero? n) #t)\n          ((= prev-prev-diff (- prev-diff (modulo n 10)))\n           (loop (quotient n 10) (- prev-diff (modulo n 10)) prev-diff (- prev-diff (modulo n 10))))\n          (else #f))))\n",
    "  (let loop ([n n] [prev-digit -1])\n    (cond [(zero? n) #t]\n          [(= prev-digit (- (remainder n 10) 1))\n           (loop (quotient n 10) (- (remainder n 10) 1))]\n          [(= prev-digit (+ (remainder n 10) 1))\n           (loop (quotient n 10) (+ (remainder n 10) 1))]\n          [else #f])))\n",
    "  (define (is_undulating-iter n prev-digit)\n    (cond\n      [(zero? n) #t]\n      [(= prev-digit (remainder n 10)) (is_undulating-iter (quotient n 10) prev-digit)]\n      [(= prev-digit (- (remainder n 10) 1)) (is_undulating-iter (quotient n 10) (remainder n 10))]\n      [(= prev-digit (+ (remainder n 10) 1)) (is_undulating-iter (quotient n 10) (remainder n 10))]\n      [else #f]))\n  (is_undulating-iter n (remainder n 10)))\n",
    "  (let loop ([n (number->string n)]\n             [prev-digit #\\0]\n             [prev-prev-digit #\\0])\n    (cond [(empty? n) #t]\n          [(= (string-&gt;number (string-&gt;list (car n)))\n             (string-&gt;number (string-&gt;list (car (cdr n)))))\n           #f]\n          [(= (string-&gt;number (string-&gt;list (car n)))\n             (string-&gt;number (string-&gt;list prev-digit)))\n           #f]\n          [(= (string-&gt;number (string-&gt;list (car n)))\n             (string-&gt;number (string-&gt;list prev-prev-digit)))\n           #f]\n          [else (loop (cdr n) (car n) prev-digit)])))\n",
    "  (define (is_undulating-iter n prev-digit prev-diff)\n    (cond\n      [(zero? n) #t]\n      [(= (modulo n 10) prev-digit) #f]\n      [(= (modulo n 10) (- prev-digit prev-diff)) #f]\n      [else (is-undulating-iter (quotient n 10) (modulo n 10) (- (modulo n 10) prev-digit))]))\n  (is-undulating-iter n -1 -1))\n",
    "  (define (is_undulating-iter n1 n2 n3)\n    (cond\n      [(= n3 0) #f]\n      [(= n1 n2) (is-undulating-iter n2 n3 (modulo n3 10))]\n      [(= n1 (- n2)) (is-undulating-iter n2 n3 (modulo n3 10))]\n      [else #f]))\n  (is-undulating-iter (modulo n 100) (modulo n 10) (quotient n 10)))\n",
    "  (let loop ((n (number->string n))\n             (i 0)\n             (j 1)\n             (k 2))\n    (cond ((or (null? n) (null? (cdr n))) #f)\n          ((= (string-&gt;number (substring n i j))\n              (string-&gt;number (substring n j k)))\n           #f)\n          ((&lt; k (length n))\n           (loop n j k (+ k 1)))\n          (else #t))))\n",
    "  (let loop ([n n] [prev-digit -1] [prev-diff 0] [prev-diff-diff 0])\n    (cond [(zero? n) #t]\n          [(= prev-diff-diff (sub1 prev-diff)) #f]\n          [(= prev-diff-diff (add1 prev-diff)) #f]\n          [else (loop (quotient n 10)\n                      (modulo n 10)\n                      (- (modulo n 10) prev-digit)\n                      (- prev-diff (- (modulo n 10) prev-digit)))])))\n",
    "  (define (undulating? n)\n    (let loop ([n n] [prev-digit -1])\n      (cond\n        [(zero? n) #t]\n        [(= (modulo n 10) prev-digit) #f]\n        [else (loop (quotient n 10) (modulo n 10))])))\n  (undulating? n))\n",
    "  (let ((str (number->string n))\n        (len (string-length str)))\n    (and (not (zero? (modulo len 2)))\n         (let loop ((i 0))\n           (cond ((= i (- len 1)) #t)\n                 ((= (string-ref str i) (string-ref str (+ i 2)))\n                  (loop (+ i 2)))\n                 (else #f))))))\n",
    "  (let loop ([n (number->string n)]\n             [prev-digit (string->number (substring n 0 1))])\n    (cond [(empty? n) #t]\n          [(= (string->number (substring n 0 1)) prev-digit) #f]\n          [else (loop (substring n 1) (string->number (substring n 0 1)))])))\n",
    "  (define (is_undulating-iter n i)\n    (cond\n      [(= i 1) #t]\n      [(= (modulo n 10) (modulo (quotient n 10) 10)) #f]\n      [else (is-undulating-iter (quotient n 10) (- i 1))]))\n  (is_undulating-iter n (number->string n)))\n",
    "  (let loop ((n (number->string n))\n             (prev (string-&gt;number (substring n 0 1)))\n             (i 1))\n    (cond ((&gt;= i (string-length n)) #t)\n          ((= (string-&gt;number (substring n i 1)) prev) #f)\n          (else (loop n (string-&gt;number (substring n i 1)) (+ i 1))))))\n",
    "  (define (is-undulating-iter n prev-digit prev-diff)\n    (cond\n      [(zero? n) #t]\n      [(= prev-digit (modulo n 10)) #f]\n      [(= prev-diff (abs (- prev-digit (modulo n 10))))\n       (is-undulating-iter (quotient n 10) (modulo n 10) prev-diff)]\n      [else #f]))\n  (is-undulating-iter n (modulo n 10) (abs (- (modulo n 10) (modulo (quotient n 10) 10)))))\n",
    "  (let loop ((n (number->string n))\n             (prev (string-&gt;number (substring n 0 1)))\n             (i 1))\n    (cond ((&gt;= i (string-length n)) #t)\n          ((= prev (string-&gt;number (substring n i 1))) #f)\n          (else (loop (substring n 1)\n                      (string-&gt;number (substring n i 1))\n                      (+ i 1))))))\n",
    "  (let loop ([n n] [prev-digit -1] [prev-prev-digit -1])\n    (cond [(zero? n) #t]\n          [(= (modulo n 10) prev-digit) #f]\n          [(= (modulo n 10) prev-prev-digit) #f]\n          [else (loop (quotient n 10) (modulo n 10) prev-digit)])))\n",
    "  (define (is_undulating-iter n)\n    (cond\n      [(zero? n) #t]\n      [(zero? (modulo n 10)) #f]\n      [(zero? (modulo (quotient n 10) 10)) #f]\n      [else (is_undulating-iter (quotient n 10))]))\n  (is_undulating-iter n))\n",
    "  (let loop ((n (number->string n))\n             (prev-digit #\\0)\n             (prev-prev-digit #\\0))\n    (cond ((null? n) #t)\n          ((and (= (string-ref n 0) prev-digit)\n                (= (string-ref n 0) prev-prev-digit))\n           #f)\n          (else (loop (string-drop n 1)\n                      (string-ref n 0)\n                      prev-digit)))))\n",
    "  (let loop ([n (number->string n)]\n             [prev (string-&gt;number (substring n 0 1))]\n             [i 1])\n    (cond\n      [(zero? (modulo i 2))\n       (let ([curr (string-&gt;number (substring n i (+ i 1)))])\n         (if (&gt; curr prev)\n             (loop n curr (+ i 1))\n             #f))]\n      [(zero? (modulo i 2))\n       (let ([curr (string-&gt;number (substring n i (+ i 1)))])\n         (if (&lt; curr prev)\n             (loop n curr (+ i 1))\n             #f))]\n      [else #t])))\n",
    "  (let loop ([n n] [prev-digit -1])\n    (cond [(zero? n) #t]\n          [(= prev-digit (modulo n 10)) #f]\n          [else (loop (quotient n 10) (modulo n 10))])))\n",
    "  (define (undulating? n)\n    (let* ([s (number->string n)]\n           [l (string-length s)])\n      (and (not (zero? l))\n           (let loop ([i 0])\n             (cond\n               [(= i (- l 1)) #t]\n               [(= (string-ref s i) (string-ref s (+ i 1))) (loop (+ i 1))]\n               [else #f])))))\n  (and (not (zero? n))\n       (undulating? n)))\n",
    "  (define (is_undulating-helper n1 n2 n3)\n    (cond\n      [(zero? n1) #t]\n      [(and (not (zero? n2)) (not (zero? n3)))\n       (cond\n         [(= n1 n2) (is-undulating-helper (quotient n1 10) (quotient n2 10) (quotient n3 10))]\n         [(= n2 n3) (is-undulating-helper (quotient n1 10) (quotient n2 10) (quotient n3 10))]\n         [else #f])]\n      [else #f]))\n  (is-undulating-helper n (quotient n 10) (quotient n 100)))\n",
    "  (let loop ([n n] [prev-digit -1] [prev-prev-digit -1])\n    (cond\n      [(zero? n) #t]\n      [(zero? (remainder n 10)) (loop (quotient n 10) prev-digit prev-prev-digit)]\n      [(= (remainder n 10) prev-digit) (loop (quotient n 10) prev-digit prev-prev-digit)]\n      [(= (remainder n 10) prev-prev-digit) (loop (quotient n 10) prev-digit prev-prev-digit)]\n      [else #f])))\n",
    "  (let loop ((n (number->string n))\n             (i 0)\n             (j 1)\n             (k 2))\n    (cond ((= i (string-length n)) #t)\n          ((= j (string-length n)) #f)\n          ((= k (string-length n)) #f)\n          ((= (string-ref n i) (string-ref n j)) #f)\n          ((= (string-ref n i) (string-ref n k)) #f)\n          ((= (string-ref n j) (string-ref n k)) #f)\n          (else (loop n (+ i 1) (+ j 1) (+ k 1))))))\n",
    "  (let loop ([n (number->string n)] [i 0] [j 1])\n    (cond\n      [(and (zero? i) (zero? j)) #t]\n      [(and (zero? i) (not (zero? j))) (loop n j (+ j 1))]\n      [(and (not (zero? i)) (zero? j)) (loop n i (+ i 1))]\n      [(and (not (zero? i)) (not (zero? j)))\n       (if (= (string-ref n i) (string-ref n j))\n           (loop n i (+ j 1))\n           (loop n i (+ i 1)))])))\n",
    "  (let loop ([n (number->string n)]\n             [prev (string-&gt;number (string-ref n 0))]\n             [i 1])\n    (cond [(empty? n) #t]\n          [(= i (string-length n)) #f]\n          [(= (string-&gt;number (string-ref n i)) prev) #f]\n          [else (loop (substring n 1)\n                      (string-&gt;number (string-ref n i))\n                      (+ i 1))])))\n",
    "  (define (is_undulating-iter n prev-digit prev-diff)\n    (cond\n      [(zero? n) #t]\n      [(and (= prev-digit (remainder n 10))\n            (= prev-diff (abs (- prev-digit (remainder (quotient n 10) 10)))))\n       (is-undulating-iter (quotient n 10) prev-digit prev-diff)]\n      [else #f]))\n  (is-undulating-iter n (remainder n 10) (abs (- (remainder n 10) (remainder (quotient n 10) 10)))))\n",
    "  (define (is_undulating-iter n i)\n    (cond\n      [(zero? n) #t]\n      [(zero? (modulo n 10)) #f]\n      [(= (modulo n 10) i) (is-undulating-iter (quotient n 10) i)]\n      [(= (modulo n 10) (- i)) (is-undulating-iter (quotient n 10) (- i))]\n      [else #f]))\n  (is-undulating-iter n (modulo n 10)))\n",
    "  (define (is_undulating-iter n1 n2 n3)\n    (cond\n      [(zero? n1) #t]\n      [(and (equal? n1 n2) (equal? n2 n3)) #f]\n      [(and (equal? n1 n2) (not (equal? n2 n3)))\n       (is-undulating-iter n2 n3 (remainder n3 10))]\n      [(and (not (equal? n1 n2)) (equal? n2 n3))\n       (is-undulating-iter n2 n3 (remainder n3 10))]\n      [(and (not (equal? n1 n2)) (not (equal? n2 n3)))\n       (is-undulating-iter n1 n2 n3)]))\n  (is-undulating-iter (remainder n 10) (remainder (quotient n 10) 10)\n                      (remainder (quotient n 100) 10)))\n",
    "  (let loop ((n (number->string n))\n             (prev #f)\n             (curr (string-&gt;number (string-ref n 0))))\n    (cond ((null? n) #t)\n          ((and prev (not (zero? (modulo (- curr prev) 10)))) #f)\n          (else (loop (cdr n) curr (string-&gt;number (string-ref n 1)))))))\n",
    "  (define (is_undulating-helper n)\n    (if (zero? n)\n        #t\n        (let* ([d1 (modulo n 10)]\n               [n (quotient n 10)]\n               [d2 (modulo n 10)])\n          (if (and (not (zero? d1))\n                   (not (zero? d2))\n                   (not (= d1 d2)))\n              (is_undulating-helper (quotient n 10))\n              #f))))\n  (is_undulating-helper n))\n",
    "  (let loop ([n n] [prev #f])\n    (cond\n      [(zero? n) #t]\n      [(or (not (integer? (remainder n 10)))\n           (and prev (= prev (remainder n 10))))\n       #f]\n      [else (loop (quotient n 10) (remainder n 10))])))\n",
    "  (let loop ([n n] [prev-digit -1])\n    (cond\n      [(zero? n) #t]\n      [(zero? (remainder n 10)) (loop (quotient n 10) prev-digit)]\n      [(and (not (zero? prev-digit))\n            (not (= (remainder n 10) prev-digit))\n            (not (= (remainder n 10) (- prev-digit))))\n       #f]\n      [else (loop (quotient n 10) (remainder n 10))])))\n",
    "  (let loop ([n n] [prev-digit -1] [is-increasing? #t])\n    (cond [(zero? n) is-increasing?]\n          [(zero? (remainder n 10)) (loop (quotient n 10) prev-digit is-increasing?)]\n          [(= prev-digit (remainder n 10)) (loop (quotient n 10) prev-digit is-increasing?)]\n          [(= prev-digit (- (remainder n 10))) (loop (quotient n 10) prev-digit is-increasing?)]\n          [(= prev-digit (+ (remainder n 10))) (loop (quotient n 10) prev-digit is-increasing?)]\n          [(> prev-digit (remainder n 10)) (loop (quotient n 10) (remainder n 10) #f)]\n          [(< prev-digit (remainder n 10)) (loop (quotient n 10) (remainder n 10) #t)])))\n",
    "  (define (is_undulating-iter n)\n    (cond\n      [(zero? n) #t]\n      [(zero? (remainder n 10)) #f]\n      [(zero? (remainder (quotient n 10) 10)) #f]\n      [else (is_undulating-iter (quotient n 10))]))\n  (is_undulating-iter n))\n",
    "  (define (is-undulating-iter n last-digit)\n    (cond\n      [(zero? n) #t]\n      [(= (modulo n 10) last-digit) #f]\n      [else (is-undulating-iter (quotient n 10) (modulo n 10))]))\n  (is-undulating-iter n -1))\n",
    "  (let loop ([n (number->string n)]\n             [prev #\\0]\n             [curr (string-ref n 0)]\n             [next (string-ref n 1)])\n    (cond\n      [(empty? n) #t]\n      [(= (char->integer curr) (char->integer prev)) #f]\n      [(= (char->integer curr) (char->integer next)) #f]\n      [else (loop (rest n) curr next (string-ref n 2))])))\n",
    "  (define (is_undulating-helper n1 n2 n3)\n    (cond ((and (equal? n1 n2) (equal? n2 n3)) #f)\n          ((and (equal? n1 n2) (not (equal? n2 n3))) (is_undulating-helper n2 n3 (modulo (quotient n3 10) 10)))\n          ((and (not (equal? n1 n2)) (equal? n2 n3)) (is_undulating-helper n1 n2 (modulo (quotient n3 10) 10)))\n          ((and (not (equal? n1 n2)) (not (equal? n2 n3))) (is_undulating-helper n1 n2 n3))\n          (else #t)))\n  (is_undulating-helper (modulo (quotient n 100) 10) (modulo (quotient n 10) 10) (modulo n 10)))\n",
    "  (let loop ([n n] [prev #f])\n    (cond [(zero? n) #t]\n          [(and (not prev) (odd? (remainder n 10))) (loop (quotient n 10) #t)]\n          [(and prev (even? (remainder n 10))) (loop (quotient n 10) #f)]\n          [else #f])))\n",
    "  (define (is_undulating-iter n1 n2 n3)\n    (cond ((= n1 n2) #f)\n          ((= n2 n3) #f)\n          ((= n1 n3) #t)\n          (else (is-undulating-iter n2 n3 (modulo (quotient n3 10) 10)))))\n  (is-undulating-iter (modulo (quotient n 10) 10) (modulo n 10) (quotient n 100)))\n",
    "  (define (is_undulating-iter n prev-digit prev-diff)\n    (cond\n      [(zero? n) #t]\n      [(= prev-digit (- (modulo n 10) prev-diff))\n       (is_undulating-iter (quotient n 10) (- (modulo n 10) prev-diff) prev-diff)]\n      [else #f]))\n  (is_undulating-iter n (- (modulo n 10) (modulo (quotient n 10) 10)) (modulo (quotient n 10) 10)))\n",
    "  (let loop ((n n) (prev-digit 0) (prev-diff 0))\n    (cond ((zero? n) #t)\n          ((= prev-diff (- (modulo n 10) prev-digit))\n           (loop (quotient n 10) (modulo n 10) prev-diff))\n          (else #f))))\n",
    "  (let loop ([n n] [prev-digit -1] [prev-prev-digit -1])\n    (cond\n      [(zero? n) #t]\n      [(= (remainder n 10) prev-digit) #f]\n      [(= (remainder n 10) prev-prev-digit) #f]\n      [else (loop (quotient n 10) (remainder n 10) prev-digit)])))\n",
    "  (let loop ([n n] [prev-digit -1] [prev-prev-digit -1])\n    (cond [(zero? n) #t]\n          [(= prev-digit (- (remainder n 10) (remainder (quotient n 10) 10)))\n           (loop (quotient n 10) prev-digit (remainder n 10))]\n          [(= prev-prev-digit (- (remainder n 10) (remainder (quotient n 10) 10)))\n           (loop (quotient n 10) prev-digit (remainder n 10))]\n          [else #f])))\n",
    "  (define (is_undulating-iter n prev-digit prev-diff)\n    (cond ((zero? n) #t)\n          ((zero? (remainder n 10)) (is_undulating-iter (quotient n 10) prev-digit prev-diff))\n          ((= prev-diff (- (remainder n 10) prev-digit)) (is_undulating-iter (quotient n 10) (remainder n 10) prev-diff))\n          ((= prev-diff (+ (remainder n 10) prev-digit)) (is_undulating-iter (quotient n 10) (remainder n 10) prev-diff))\n          (else #f)))\n  (is_undulating-iter n 0 0))\n",
    "  (define (helper n)\n    (cond ((< n 10) (list n))\n          (else (cons (modulo n 10) (helper (quotient n 10))))))\n  (define (is_undulating? lst)\n    (cond ((null? lst) #t)\n          ((null? (cdr lst)) #t)\n          ((= (abs (- (car lst) (cadr lst))) 1) (is_undulating? (cdr lst)))\n          (else #f)))\n  (is_undulating? (helper n)))\n",
    "  (define (is-undulating-helper n i)\n    (cond\n      [(= i 0) #t]\n      [(= (modulo n 10) (modulo (quotient n (expt 10 i)) 10))\n       (is-undulating-helper n (- i 1))]\n      [else #f]))\n  (is-undulating-helper n (- (quotient (expt 10 (quotient (log n) (log 10))) 10) 1)))\n",
    "  (define (is_undulating-helper n)\n    (cond\n      [(zero? n) #t]\n      [(zero? (remainder n 10)) #f]\n      [(zero? (remainder (quotient n 10) 10)) #f]\n      [else (is_undulating-helper (quotient n 10))]))\n  (is_undulating-helper n))\n",
    "  (let loop ([n (number->string n)]\n             [prev (string-&gt;number (string-take n 1))]\n             [i 1])\n    (if (&lt; i (string-length n))\n        (let ([next (string-&gt;number (string-take n i))])\n          (if (or (= prev next)\n                  (= prev (- next 1))\n                  (= prev (+ next 1)))\n              (loop n next (+ i 1))\n              #f))\n        #t)))\n",
    "  (define (is_undulating-iter n prev-digit prev-diff)\n    (cond ((zero? n) #t)\n          ((= (modulo n 10) prev-digit) #f)\n          ((= (modulo n 10) (- prev-digit prev-diff))\n           (is-undulating-iter (quotient n 10) (modulo n 10) (- prev-digit (modulo n 10))))\n          (else (is-undulating-iter (quotient n 10) (modulo n 10) (- (modulo n 10) prev-digit)))))\n  (is-undulating-iter n 0 0))\n</code>\n",
    "  (define (is_undulating-iter n1 n2 n3)\n    (cond\n      [(= n3 0) #f]\n      [(= n1 n2) (is-undulating-iter n2 n3 (remainder n3 10))]\n      [(= n1 (- n2)) (is-undulating-iter n2 n3 (remainder n3 10))]\n      [else #f]))\n  (is_undulating-iter (remainder n 100) (remainder n 10) (quotient n 10)))\n",
    "  (define (undulating? n)\n    (cond ((< n 10) #t)\n          ((= (modulo n 10) (modulo (quotient n 10) 10)) #f)\n          (else (undulating? (quotient n 10)))))\n  (undulating? n))\n",
    "  (let loop ([n (number->string n)]\n             [prev-digit #\\0]\n             [prev-prev-digit #\\0])\n    (cond\n      [(empty? n) #t]\n      [(and (char=? (first n) prev-digit)\n            (char=? (first n) prev-prev-digit))\n       #f]\n      [(char=? (first n) prev-digit)\n       (loop (rest n) (first n) prev-digit)]\n      [else\n       (loop (rest n) (first n) prev-digit)])))\n",
    "  (let loop ([n (number->string n)]\n             [prev #\\0]\n             [curr (string-ref n 0)]\n             [next (string-ref n 1)])\n    (cond [(empty? n) #t]\n          [(and (= prev curr) (= curr next)) #f]\n          [else (loop (rest n) curr next (string-ref n 2))])))\n",
    "  (let loop ([n n] [prev-digit -1] [is-increasing? #t])\n    (cond [(zero? n) is-increasing?]\n          [(= prev-digit (remainder n 10)) (loop (quotient n 10) prev-digit is-increasing?)]\n          [(and is-increasing? (&lt; prev-digit (remainder n 10))) (loop (quotient n 10) (remainder n 10) is-increasing?)]\n          [(and (not is-increasing?) (&gt; prev-digit (remainder n 10))) (loop (quotient n 10) (remainder n 10) is-increasing?)]\n          [else #f])))\n",
    "  (define (is_undulating-iter n last-digit)\n    (cond\n      [(zero? n) #t]\n      [(and (odd? n) (odd? last-digit)) (is-undulating-iter (quotient n 10) (remainder n 10))]\n      [(and (odd? n) (even? last-digit)) (is-undulating-iter (quotient n 10) (remainder n 10))]\n      [(and (even? n) (even? last-digit)) (is-undulating-iter (quotient n 10) (remainder n 10))]\n      [(and (even? n) (odd? last-digit)) (is-undulating-iter (quotient n 10) (remainder n 10))]\n      [else #f]))\n  (is-undulating-iter n (remainder n 10)))\n",
    "  (let loop ((n (number->string n))\n             (i 0)\n             (j 1)\n             (k 2)\n             (undulating? #t))\n    (cond ((null? n) undulating?)\n          ((or (zero? (modulo i 2))\n               (zero? (modulo j 2))\n               (zero? (modulo k 2)))\n           (loop (cdr n) (+ i 1) (+ j 1) (+ k 1) undulating?))\n          ((not (= (string-&gt;number (substring n i j))\n                   (string-&gt;number (substring n j k))))\n           (loop (cdr n) (+ i 1) (+ j 1) (+ k 1) #f))\n          (else (loop (cdr n) (+ i 1) (+ j 1) (+ k 1) undulating?)))))\n</code>\n",
    "  (define (is_undulating-iter n)\n    (cond\n      [(zero? n) #t]\n      [(= (modulo n 10) (modulo (quotient n 10) 10)) (is_undulating-iter (quotient n 10))]\n      [else #f]))\n  (is_undulating-iter n))\n",
    "  (define (is_undulating-iter n1 n2 n3)\n    (cond\n      [(= n3 0) #t]\n      [(= (modulo n3 10) (- n2 (modulo n1 10)))\n       (is_undulating-iter n2 n3 (quotient n3 10))]\n      [else #f]))\n  (is_undulating-iter (quotient n 100) (quotient n 10) (quotient n 10)))\n",
    "  (define (is_undulating-iter n prev-digit prev-diff)\n    (cond\n      [(zero? n) #t]\n      [(= prev-digit (remainder n 10)) #f]\n      [(= prev-diff (- (remainder n 10) prev-digit))\n       (is_undulating-iter (quotient n 10) (remainder n 10) prev-diff)]\n      [else\n       (is_undulating-iter (quotient n 10) (remainder n 10) (- (remainder n 10) prev-digit))]))\n  (is_undulating-iter n 0 0))\n",
    "  (let loop ([n n] [prev-digit -1])\n    (cond\n      [(zero? n) #t]\n      [(zero? (remainder n 10)) (loop (quotient n 10) prev-digit)]\n      [(and (positive? prev-digit) (= prev-digit (remainder n 10)))\n       (loop (quotient n 10) prev-digit)]\n      [(and (negative? prev-digit) (= prev-digit (remainder n 10)))\n       (loop (quotient n 10) prev-digit)]\n      [else (loop (quotient n 10) (remainder n 10))])))\n",
    "  (define (is_undulating-iter n prev-digit prev-diff)\n    (cond\n      [(zero? n) #t]\n      [(= prev-diff (- (modulo n 10) prev-digit))\n       (is_undulating-iter (quotient n 10) (- (modulo n 10) prev-diff) prev-diff)]\n      [else #f]))\n  (is_undulating-iter n 0 0))\n",
    "  (let loop ((n (number->string n))\n             (prev-digit (string->number (substring n 0 1)))\n             (i 1))\n    (cond ((= i (string-length n)) #t)\n          ((= (modulo i 2) 0)\n           (let ((curr-digit (string->number (substring n i (+ i 1)))))\n             (if (= curr-digit prev-digit)\n                 #f\n                 (loop n curr-digit (+ i 1)))))\n          ((= (modulo i 2) 1)\n           (let ((curr-digit (string->number (substring n i (+ i 1)))))\n             (if (= curr-digit (- prev-digit 1))\n                 (loop n curr-digit (+ i 1))\n                 #f))))))\n",
    "  (let loop ((n (number->string n))\n             (prev (string-&gt;number (substring n 0 1)))\n             (i 1))\n    (cond ((&gt;= i (string-length n)) #t)\n          ((= prev (string-&gt;number (substring n i 1))) #f)\n          (else (loop n (string-&gt;number (substring n i 1)) (+ i 1))))))\n"
  ]
}