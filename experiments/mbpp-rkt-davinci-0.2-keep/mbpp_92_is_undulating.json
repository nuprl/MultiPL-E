{
  "name": "mbpp_92_is_undulating",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Write a function to check whether the given number is undulating or not.\n(define (is_undulating n)\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_92_is_undulating.py",
  "prompt_terminology": "verbatim",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_undulating))\n    (check-equal? (candidate 1212121) #t)\n    (check-equal? (candidate 1991) #f)\n    (check-equal? (candidate 121) #t)\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (define (is_undulating-iter n1 n2 n3)\n    (cond\n      [(zero? n3) #t]\n      [(and (= n1 (+ n2 1)) (= n2 (- n3 1))) (is_undulating-iter n2 n3 (quotient n3 10))]\n      [(and (= n1 (- n2 1)) (= n2 (+ n3 1))) (is_undulating-iter n2 n3 (quotient n3 10))]\n      [else #f]))\n  (is_undulating-iter (quotient n 10) (remainder n 10) (quotient n 100)))\n",
    "  (define (is_undulating-iter n prev-digit prev-diff)\n    (if (&lt; n 10)\n        #t\n        (let* ([digit (modulo n 10)]\n               [diff (- digit prev-digit)])\n          (if (and (not (= diff 0))\n                   (= diff prev-diff))\n              (is-undulating-iter (quotient n 10) digit diff)\n              #f))))\n  (is-undulating-iter n 0 0))\n",
    "  (define (is-undulating-iter n last-digit)\n    (cond\n      [(zero? n) #t]\n      [(= (remainder n 10) last-digit) #f]\n      [else (is-undulating-iter (quotient n 10) (remainder n 10))]))\n  (is-undulating-iter n (remainder n 10)))\n",
    "  (let loop ([n (number->string n)]\n             [prev-digit (string->number (substring n 0 1))]\n             [i 1])\n    (if (or (zero? i)\n            (= i (sub1 (string-length n))))\n        #t\n        (let ([curr-digit (string->number (substring n i (add1 i)))])\n          (if (= (abs (- prev-digit curr-digit)) 1)\n              (loop n curr-digit (add1 i))\n              #f)))))\n",
    "  (let loop ([n n] [prev-digit 0] [prev-diff 0])\n    (cond [(zero? n) #t]\n          [(zero? (remainder n 10)) #f]\n          [else\n           (let ([curr-digit (remainder n 10)])\n             (if (and (not (zero? prev-digit))\n                      (not (zero? prev-diff))\n                      (not (= (abs prev-diff) (- prev-digit curr-digit))))\n                 #f\n                 (loop (quotient n 10) curr-digit (- prev-digit curr-digit))))])))\n",
    "  (define (is_undulating-iter n prev-digit prev-diff)\n    (cond\n      [(zero? n) #t]\n      [(and (zero? prev-diff) (zero? (modulo n 10)))\n       (is-undulating-iter (quotient n 10) prev-digit prev-diff)]\n      [(and (zero? prev-diff) (zero? prev-digit))\n       (is-undulating-iter (quotient n 10) (modulo n 10) prev-diff)]\n      [(zero? prev-digit)\n       (is-undulating-iter (quotient n 10) (modulo n 10) (modulo n 10))]\n      [(zero? (modulo n 10))\n       (is-undulating-iter (quotient n 10) prev-digit prev-diff)]\n      [(= (abs (- (modulo n 10) prev-digit)) prev-diff)\n       (is-undulating-iter (quotient n 10) (modulo n 10) (abs (- (modulo n 10) prev-digit)))]\n      [else #f]))\n  (is-undulating-iter n 0 0))\n",
    "  (define (helper n)\n    (cond\n      [(zero? n) #f]\n      [(zero? (remainder n 10)) (helper (quotient n 10))]\n      [(zero? (remainder (quotient n 10) 10)) #t]\n      [else (helper (quotient n 10))]))\n  (helper n))\n",
    "  (define (is-undulating-helper n)\n    (cond\n      [(= n 0) #t]\n      [(= (modulo n 10) (modulo (quotient n 10) 10)) #f]\n      [else (is-undulating-helper (quotient n 10))]))\n  (is-undulating-helper n))\n",
    "  (define (is_undulating-iter n prev-digit)\n    (cond ((= n 0) #t)\n          ((= (modulo n 10) prev-digit) #f)\n          (else (is-undulating-iter (quotient n 10) (modulo n 10)))))\n  (is-undulating-iter n (modulo n 10)))\n",
    "  (let loop ([n (number->string n)]\n             [i 0])\n    (cond\n      [(empty? n) #t]\n      [(= i (string-length n)) #t]\n      [(= (string-ref n i) (string-ref n (+ i 2))) (loop (substring n 1) (+ i 1))]\n      [else #f])))\n",
    "  (define (undulating? n)\n    (if (zero? n)\n        #t\n        (let* ([d1 (modulo n 10)]\n               [d2 (modulo (quotient n 10) 10)])\n          (or (and (positive? d1) (negative? d2))\n              (and (negative? d1) (positive? d2))))))\n  (let loop ([n n])\n    (if (zero? n)\n        #t\n        (and (undulating? n)\n             (loop (quotient n 10))))))\n",
    "  (define (is_undulating-iter n1 n2 n3)\n    (cond\n      [(zero? n) #t]\n      [(and (equal? n1 n2) (equal? n2 n3)) #f]\n      [(and (equal? n1 n2) (not (equal? n2 n3))) (is-undulating-iter n2 n3 (modulo (quotient n 10) 10))]\n      [(and (not (equal? n1 n2)) (equal? n2 n3)) (is-undulating-iter n2 n3 (modulo (quotient n 10) 10))]\n      [(and (not (equal? n1 n2)) (not (equal? n2 n3))) (is-undulating-iter n2 n3 (modulo (quotient n 10) 10))]))\n  (is-undulating-iter (modulo (quotient n 100) 10) (modulo (quotient n 10) 10) (modulo n 10)))\n</code>\n",
    "  (define (is_undulating-iter n prev-digit prev-prev-digit)\n    (cond\n      [(zero? n) #t]\n      [(or (and (zero? prev-digit) (zero? prev-prev-digit))\n           (and (zero? prev-digit) (= prev-prev-digit (remainder n 10)))\n           (and (= prev-digit (remainder n 10)) (zero? prev-prev-digit))\n           (and (= prev-digit (remainder n 10)) (= prev-prev-digit (remainder n 10))))\n       #f]\n      [else (is-undulating-iter (quotient n 10) (remainder n 10) prev-digit)]))\n  (is-undulating-iter n 0 0))\n",
    "  (define (undulating? n)\n    (let ([d (string->number (string-ref (number->string n) 0))])\n      (and (not (zero? d))\n           (let loop ([n (string->number (substring (number->string n) 1))]\n                      [prev d])\n             (if (zero? n)\n                 #t\n                 (let ([d (string->number (string-ref (number->string n) 0))])\n                   (if (or (and (= prev d) (= prev (- d 1)))\n                           (and (= prev d) (= prev (+ d 1))))\n                       (loop (string->number (substring (number->string n) 1)) d)\n                       #f)))))))\n  (undulating? n))\n",
    "  (let loop ((n (number->string n))\n             (prev-digit #\\0)\n             (prev-prev-digit #\\0))\n    (cond ((null? n) #t)\n          ((and (= (string-ref n 0) prev-digit)\n                (= (string-ref n 0) prev-prev-digit))\n           #f)\n          (else (loop (string-drop n 1)\n                      (string-ref n 0)\n                      prev-digit)))))\n",
    "  (let loop ([n n] [prev-digit #f] [is-increasing? #t])\n    (if (zero? n)\n        (not is-increasing?)\n        (let ([digit (modulo n 10)])\n          (if prev-digit\n              (if (and (not is-increasing?) (&lt; digit prev-digit))\n                  (loop (quotient n 10) digit #f)\n                  (if (and is-increasing? (&gt; digit prev-digit))\n                      (loop (quotient n 10) digit #t)\n                      #f))\n              (loop (quotient n 10) digit is-increasing?))))))\n",
    "  (define (is_undulating-iter n)\n    (cond\n      [(zero? n) #t]\n      [(zero? (remainder n 10)) #f]\n      [(< (remainder n 10) (remainder (quotient n 10) 10))\n       (is-undulating-iter (quotient n 10))]\n      [else #f]))\n  (is-undulating-iter n))\n",
    "  (define (is_undulating-iter n1 n2 n3)\n    (cond\n      [(zero? n1) #t]\n      [(and (not (zero? n2)) (not (zero? n3)))\n       (and (or (= n1 n2) (= n1 n3))\n            (is-undulating-iter (quotient n1 10) n2 n3))]\n      [(not (zero? n2))\n       (and (= n1 n2) (is-undulating-iter (quotient n1 10) n2 0))]\n      [(not (zero? n3))\n       (and (= n1 n3) (is-undulating-iter (quotient n1 10) 0 n3))]\n      [else (is-undulating-iter (quotient n1 10) 0 0)]))\n  (is-undulating-iter n 0 0))\n",
    "  (let loop ([n (number->string n)]\n             [i 0]\n             [j 1])\n    (cond [(empty? n) #f]\n          [(= (string-ref n i) (string-ref n j))\n           (loop (substring n 1) (+ i 1) (+ j 1))]\n          [else (loop (substring n 1) (+ i 1) (+ j 1))])))\n",
    "  (define (is_undulating-helper n)\n    (if (zero? n)\n        #t\n        (let* ([d1 (modulo n 10)]\n               [n (quotient n 10)]\n               [d2 (modulo n 10)])\n          (if (and (zero? d1) (zero? d2))\n              (is-undulating-helper n)\n              (if (or (and (zero? d1) (not (zero? d2)))\n                      (and (not (zero? d1)) (zero? d2)))\n                  (is-undulating-helper (quotient n 10))\n                  #f)))))\n  (is-undulating-helper n))\n"
  ]
}