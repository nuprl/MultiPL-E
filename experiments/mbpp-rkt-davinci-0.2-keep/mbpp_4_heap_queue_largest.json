{
  "name": "mbpp_4_heap_queue_largest",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Write a function to find the n largest integers from a given list of numbers, returned in descending order.\n(define (heap_queue_largest nums n)\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_4_heap_queue_largest.py",
  "prompt_terminology": "verbatim",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate heap_queue_largest))\n    (check-equal? (candidate (list 25 35 22 85 14 65 75 22 58) 3) (list 85 75 65))\n    (check-equal? (candidate (list 25 35 22 85 14 65 75 22 58) 2) (list 85 75))\n    (check-equal? (candidate (list 25 35 22 85 14 65 75 22 58) 5) (list 85 75 65 58 35))\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (define (heapify i)\n    (define (swap i j)\n      (define temp (list-ref nums i))\n      (set-car! (list-ref nums i) (list-ref nums j))\n      (set-car! (list-ref nums j) temp))\n    (define (left i)\n      (+ i 1))\n    (define (right i)\n      (+ i 2))\n    (define (parent i)\n      (- i 1))\n    (define (max-heapify i)\n      (define l (left i))\n      (define r (right i))\n      (define largest\n        (cond\n          [(> l (length nums)) i]\n          [(> r (length nums))\n           (cond\n             [(> (list-ref nums l) (list-ref nums i)) l]\n             [else i])]\n          [else\n           (cond\n             [(> (list-ref nums l) (list-ref nums i)) l]\n             [else i])]))\n      (cond\n        [(> (list-ref nums r) (list-ref nums largest))\n         (swap i r)\n         (max-heapify r)]\n        [(> (list-ref nums l) (list-ref nums largest))\n         (swap i l)\n         (max-heapify l)]))\n    (max-heapify i))\n  (define (build-max-heap)\n    (for ([i (in-range (quotient (length nums) 2) -1 -1)])\n      (heapify i)))\n  (define (heap-sort)\n    (build-max-heap)\n    (for ([i (in-range (length nums) 1 -1)])\n      (swap 0 i)\n      (heapify 0)))\n  (define (swap i j)\n    (define temp (list-ref nums i))\n    (set-car! (list-ref nums i) (list-ref nums j))\n    (set-car! (list-ref nums j) temp))\n  (define (left i)",
    "  (define (heapify nums)\n    (define (heapify-helper nums i)\n      (define (swap nums i j)\n        (define (swap-helper nums i j)\n          (if (= i j)\n              nums\n              (begin\n                (define temp (list-ref nums i))\n                (set-car! (list-ref nums i) (list-ref nums j))\n                (set-car! (list-ref nums j) temp)\n                (swap-helper nums (+ i 1) (+ j 1)))))\n      (swap-helper nums i j))\n    (define (heapify-helper-2 nums i)\n      (if (= i 0)\n          nums\n          (begin\n            (define parent (quotient i 2))\n            (if (&gt; (list-ref nums i) (list-ref nums parent))\n                (heapify-helper (swap nums i parent) parent)\n                (heapify-helper nums (- i 1))))))\n    (heapify-helper-2 nums (- (length nums) 1)))\n  (define (heap_queue_largest-helper nums n)\n    (if (= n 0)\n        '()\n        (begin\n          (define temp (list-ref nums 0))\n          (set-car! (list-ref nums 0) (list-ref nums (- (length nums) 1)))\n          (set-car! (list-ref nums (- (length nums) 1)) temp)\n          (cons temp (heap_queue_largest-helper (heapify (sublist nums 0 (- (length nums) 1))) (- n 1))))))\n  (heap_queue_largest-helper (heapify nums) n))\n</code>\n",
    "  (define (heap_queue_largest_helper nums n acc)\n    (if (or (null? nums) (= n 0))\n        acc\n        (heap_queue_largest_helper (cdr nums) (- n 1) (cons (car nums) acc))))\n  (heap_queue_largest_helper nums n '()))\n",
    "  (define (heap_queue_largest-helper nums n result)\n    (if (zero? n)\n        result\n        (heap_queue_largest-helper (remove (max nums) nums) (- n 1) (cons (max nums) result))))\n  (heap_queue_largest-helper nums n '()))\n",
    "  (define (heap_queue_largest-helper nums n)\n    (if (zero? n)\n        '()\n        (let ([max (apply max nums)])\n          (cons max (heap_queue_largest-helper (remove max nums) (- n 1))))))\n  (heap_queue_largest-helper nums n))\n",
    "  (define (heap_queue_largest_helper nums n)\n    (define (heap_queue_largest_helper_helper nums n)\n      (if (= n 0)\n          '()\n          (cons (car nums) (heap_queue_largest_helper_helper (cdr nums) (- n 1)))))\n    (if (= n (length nums))\n        (heap_queue_largest_helper_helper nums n)\n        (heap_queue_largest_helper_helper (heap-sort nums) n)))\n  (heap_queue_largest_helper nums n))\n",
    "  (define (heap_queue_largest_helper nums n result)\n    (cond\n      [(empty? nums) result]\n      [(> (length result) n) (heap_queue_largest_helper (rest nums) n (heap-remove! result))]\n      [else (heap_queue_largest_helper (rest nums) n (heap-add! result (first nums)))]))\n  (heap_queue_largest_helper nums n (make-heap <)))\n",
    "  (define (heap_queue_largest_helper nums n result)\n    (if (zero? n)\n        result\n        (heap_queue_largest_helper (remove-max nums) (- n 1) (cons (max nums) result))))\n  (heap_queue_largest_helper nums n '()))\n",
    "  (define (heapify nums)\n    (define (heapify-helper nums i)\n      (define (swap nums i j)\n        (define (swap-helper nums i j)\n          (define (swap-helper-helper nums i j)\n            (define (swap-helper-helper-helper nums i j)\n              (define (swap-helper-helper-helper-helper nums i j)\n                (define (swap-helper-helper-helper-helper-helper nums i j)\n                  (define (swap-helper-helper-helper-helper-helper-helper nums i j)\n                    (define (swap-helper-helper-helper-helper-helper-helper-helper nums i j)\n                      (define (swap-helper-helper-helper-helper-helper-helper-helper-helper nums i j)\n                        (define (swap-helper-helper-helper-helper-helper-helper-helper-helper-helper nums i j)\n                          (define (swap-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper nums i j)\n                            (define (swap-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper nums i j)\n                              (define (swap-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper nums i j)\n                                (define (swap-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper nums i j)\n                                  (define (swap-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper-helper",
    "  (define (heapify lst)\n    (define (heapify-helper lst)\n      (if (null? lst)\n          '()\n          (let* ([left (heapify-helper (cdr lst))]\n                 [right (heapify-helper (cddr lst))]\n                 [max (if (or (null? left) (null? right))\n                          (if (null? left) right left)\n                          (if (&gt; (car left) (car right)) left right))])\n            (if (&gt; (car max) (car lst))\n                (cons (car lst) (cons (car max) (cdr max)))\n                (cons (car max) (cons (car lst) (cdr max)))))))\n    (heapify-helper lst))\n\n  (define (heap_queue_largest-helper nums n)\n    (if (zero? n)\n        '()\n        (let* ([max (car nums)]\n               [rest (cdr nums)])\n          (cons max (heap_queue_largest-helper rest (- n 1))))))\n\n  (heap_queue_largest-helper (heapify nums) n))\n</code>\n",
    "  (define (heap_queue_largest-helper nums n q)\n    (if (zero? n)\n        (queue-&gt;list q)\n        (if (empty? nums)\n            (queue-&gt;list q)\n            (let ([num (first nums)])\n              (if (&gt; num (peek-min q))\n                  (heap_queue_largest-helper (rest nums) n (enqueue num (dequeue q)))\n                  (heap_queue_largest-helper (rest nums) n q))))))\n  (heap_queue_largest-helper nums n (make-queue)))\n</code>\n",
    "  (define (heap_queue_largest_helper nums n result)\n    (if (or (null? nums) (= n 0))\n        result\n        (heap_queue_largest_helper (cdr nums) (- n 1) (cons (car nums) result))))\n  (heap_queue_largest_helper nums n '()))\n",
    "  (define (heap_queue_largest-helper nums n result)\n    (cond\n      [(empty? nums) result]\n      [(= n 0) result]\n      [else\n       (let* ([num (first nums)]\n              [rest (rest nums)]\n              [result (if (empty? result)\n                          (list num)\n                          (if (< num (first result))\n                              result\n                              (cons num result)))]\n              [result (if (> (length result) n)\n                          (rest result)\n                          result)])\n         (heap_queue_largest-helper rest (- n 1) result))]))\n  (heap_queue_largest-helper nums n '()))\n",
    "  (define (heap_queue_largest-helper nums n result)\n    (if (or (zero? n) (empty? nums))\n        result\n        (heap_queue_largest-helper (rest nums) (- n 1) (cons (max (first nums) (first result)) (rest result)))))\n  (heap_queue_largest-helper nums n (list (first nums))))\n",
    "  (define (heapify lst)\n    (define (heapify-helper lst i)\n      (define (swap lst i j)\n        (define (swap-helper lst i j)\n          (if (= i j)\n              lst\n              (begin\n                (define temp (list-ref lst i))\n                (set-car! (list-ref lst i) (list-ref lst j))\n                (set-car! (list-ref lst j) temp)\n                (swap-helper lst (+ i 1) (+ j 1)))))\n      (if (= i (length lst))\n          lst\n          (begin\n            (define left-child (+ (* 2 i) 1))\n            (define right-child (+ (* 2 i) 2))\n            (if (and (< left-child (length lst))\n                     (< (list-ref lst left-child) (list-ref lst i)))\n                (swap lst i left-child))\n            (if (and (< right-child (length lst))\n                     (< (list-ref lst right-child) (list-ref lst i)))\n                (swap lst i right-child))\n            (heapify-helper lst (+ i 1)))))\n    (heapify-helper lst 0))\n  (define (heap_queue_largest-helper nums n)\n    (if (= n 0)\n        '()\n        (begin\n          (define temp (list-ref nums 0))\n          (set-car! (list-ref nums 0) (list-ref nums (- (length nums) 1)))\n          (set-car! (list-ref nums (- (length nums) 1)) temp)\n          (heapify (list-ref nums 0) (list-ref nums (- (length nums) 1)))\n          (cons (list-ref nums (- (length nums) 1))\n                (heap_queue_largest-helper (list-ref nums 0) (- n 1))))))\n  (heap_queue_largest-helper (heapify nums) n))\n",
    "  (define (heap_queue_largest-helper nums n heap)\n    (if (zero? n)\n        heap\n        (heap_queue_largest-helper (cdr nums) (- n 1) (heap-insert (car nums) heap))))\n  (heap-sort (heap_queue_largest-helper nums n (make-heap)) #:order >))\n",
    "  (define (heap_queue_largest_helper nums n)\n    (if (zero? n)\n        '()\n        (let* ([max (apply max nums)]\n               [rest (filter (lambda (x) (not (= x max))) nums)])\n          (cons max (heap_queue_largest_helper rest (- n 1))))))\n  (heap_queue_largest_helper nums n))\n",
    "  (define (heap_queue_largest_helper nums n)\n    (if (zero? n)\n        '()\n        (let ([max (apply max nums)])\n          (cons max (heap_queue_largest_helper (remove max nums) (- n 1))))))\n  (heap_queue_largest_helper nums n))\n",
    "  (define (heap_queue_largest-helper nums n acc)\n    (cond [(empty? nums) (reverse acc)]\n          [(> (first nums) (first acc)) (heap_queue_largest-helper (rest nums) n (cons (first nums) (rest acc)))]\n          [else (heap_queue_largest-helper (rest nums) n acc)]))\n  (heap_queue_largest-helper nums n (take n (sort > nums))))\n",
    "  (define (heap-queue-largest-helper nums n)\n    (if (= n 0)\n        '()\n        (let ([max-num (apply max nums)])\n          (cons max-num (heap-queue-largest-helper (remove max-num nums) (- n 1))))))\n  (heap-queue-largest-helper nums n))\n"
  ]
}