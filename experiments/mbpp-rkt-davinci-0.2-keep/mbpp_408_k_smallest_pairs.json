{
  "name": "mbpp_408_k_smallest_pairs",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n(define (k_smallest_pairs nums1 nums2 k)\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_408_k_smallest_pairs.py",
  "prompt_terminology": "verbatim",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate k_smallest_pairs))\n    (check-equal? (candidate (list 1 3 7) (list 2 4 6) 2) (list (list 1 2) (list 1 4)))\n    (check-equal? (candidate (list 1 3 7) (list 2 4 6) 1) (list (list 1 2)))\n    (check-equal? (candidate (list 1 3 7) (list 2 4 6) 7) (list (list 1 2) (list 1 4) (list 3 2) (list 1 6) (list 3 4) (list 3 6) (list 7 2)))\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (define (k_smallest_pairs_helper nums1 nums2 k acc)\n    (cond [(empty? nums1) acc]\n          [(empty? nums2) acc]\n          [(= k 0) acc]\n          [else\n           (let* ([min-n1 (min (first nums1) (first nums2))]\n                  [min-n2 (min (first nums2) (first nums1))]\n                  [n1 (if (= min-n1 (first nums1)) (rest nums1) nums1)]\n                  [n2 (if (= min-n2 (first nums2)) (rest nums2) nums2)]\n                  [new-acc (cons (list min-n1 min-n2) acc)])\n             (k_smallest_pairs_helper n1 n2 (- k 1) new-acc))]))\n  (k_smallest_pairs_helper nums1 nums2 k '()))\n",
    "  (define (helper nums1 nums2 k acc)\n    (if (or (null? nums1) (null? nums2))\n        acc\n        (let ([pair (list (car nums1) (car nums2))])\n          (if (&lt; (length acc) k)\n              (helper (cdr nums1) (cdr nums2) k (cons pair acc))\n              (if (&lt; (car pair) (car (last acc)))\n                  (helper (cdr nums1) (cdr nums2) k (cons pair (butlast acc)))\n                  (helper (cdr nums1) (cdr nums2) k acc))))))\n  (reverse (helper nums1 nums2 k '())))\n",
    "  (define (helper n1 n2 k)\n    (cond [(empty? n1) empty]\n          [(empty? n2) empty]\n          [(= k 0) empty]\n          [else (cons (list (first n1) (first n2))\n                      (append (helper (rest n1) (rest n2) (- k 1))\n                              (helper (rest n1) n2 (- k 1))\n                              (helper n1 (rest n2) (- k 1))))]))\n  (helper nums1 nums2 k))\n",
    "  (define (helper nums1 nums2 k)\n    (cond\n      [(empty? nums1) empty]\n      [(empty? nums2) empty]\n      [(zero? k) empty]\n      [else\n       (let ([head1 (first nums1)]\n             [head2 (first nums2)])\n         (cons (list head1 head2)\n               (append (helper nums1 (rest nums2) (- k 1))\n                       (helper (rest nums1) nums2 k))))]))\n  (helper nums1 nums2 k))\n",
    "  (let loop ([nums1 nums1] [nums2 nums2] [k k] [result '()])\n    (cond [(empty? nums1) result]\n          [(empty? nums2) result]\n          [(zero? k) result]\n          [else\n           (let* ([n1 (car nums1)]\n                  [n2 (car nums2)]\n                  [nums1-rest (cdr nums1)]\n                  [nums2-rest (cdr nums2)]\n                  [result-rest (loop nums1-rest nums2-rest (- k 1) result)])\n             (if (< n1 n2)\n                 (loop nums1-rest nums2 (- k 1) (cons (list n1 n2) result-rest))\n                 (loop nums1 nums2-rest (- k 1) (cons (list n1 n2) result-rest))))])))\n",
    "  (define (helper nums1 nums2 k acc)\n    (cond [(empty? nums1) acc]\n          [(empty? nums2) acc]\n          [(= k 0) acc]\n          [else\n           (let* ([head1 (first nums1)]\n                  [head2 (first nums2)]\n                  [tail1 (rest nums1)]\n                  [tail2 (rest nums2)]\n                  [new-acc (cons (list head1 head2) acc)])\n             (if (< head1 head2)\n                 (helper tail1 nums2 (- k 1) new-acc)\n                 (helper nums1 tail2 (- k 1) new-acc)))]))\n  (helper nums1 nums2 k '()))\n",
    "  (define (helper nums1 nums2 k)\n    (if (or (null? nums1) (null? nums2))\n        '()\n        (let ([pair (list (car nums1) (car nums2))])\n          (cons pair (helper (cdr nums1) (cdr nums2) (- k 1))))))\n  (if (or (null? nums1) (null? nums2) (&lt;= k 0))\n      '()\n      (helper nums1 nums2 k)))\n",
    "  (define (helper nums1 nums2 k)\n    (if (or (null? nums1) (null? nums2))\n        '()\n        (let ([smallest-pair (list (car nums1) (car nums2))])\n          (cons smallest-pair (helper (cdr nums1) (cdr nums2) (- k 1))))))\n  (helper nums1 nums2 k))\n",
    "  (define (helper nums1 nums2 k acc)\n    (cond\n      [(empty? nums1) acc]\n      [(empty? nums2) acc]\n      [(zero? k) acc]\n      [else\n       (let ([min-pair (min (car nums1) (car nums2))])\n         (helper (cdr nums1) (cdr nums2) (- k 1) (cons min-pair acc)))]))\n  (reverse (helper nums1 nums2 k '())))\n",
    "  (let ([pairs (for*/list ([x nums1] [y nums2])\n                 (list x y))])\n    (take k (sort pairs (\u03bb (p1 p2) (< (apply + p1) (apply + p2)))))))\n",
    "  (let loop ([nums1 nums1] [nums2 nums2] [k k] [acc '()])\n    (cond [(or (null? nums1) (null? nums2)) (reverse acc)]\n          [(zero? k) (reverse acc)]\n          [else\n           (let ([a (car nums1)]\n                 [b (car nums2)]\n                 [nums1-rest (cdr nums1)]\n                 [nums2-rest (cdr nums2)])\n             (loop (if (&lt; a b) nums1-rest nums1)\n                   (if (&lt; a b) nums2 nums2-rest)\n                   (sub1 k)\n                   (cons (list a b) acc)))])))\n</code>\n",
    "  (define (merge-sort lst)\n    (define (merge lst1 lst2)\n      (cond [(empty? lst1) lst2]\n            [(empty? lst2) lst1]\n            [(< (first lst1) (first lst2))\n             (cons (first lst1) (merge (rest lst1) lst2))]\n            [else\n             (cons (first lst2) (merge lst1 (rest lst2)))]))\n    (define (split lst)\n      (if (empty? lst)\n          (values empty empty)\n          (let ([mid (quotient (length lst) 2)])\n            (values (take lst mid) (drop lst mid)))))\n    (define (merge-sort-helper lst)\n      (if (empty? lst)\n          empty\n          (let-values ([(lst1 lst2) (split lst)])\n            (merge (merge-sort-helper lst1) (merge-sort-helper lst2)))))\n    (merge-sort-helper lst))\n  (define (merge-sort-2d lst)\n    (define (merge-2d lst1 lst2)\n      (cond [(empty? lst1) lst2]\n            [(empty? lst2) lst1]\n            [(< (first (first lst1)) (first (first lst2)))\n             (cons (first lst1) (merge-2d (rest lst1) lst2))]\n            [else\n             (cons (first lst2) (merge-2d lst1 (rest lst2)))]))\n    (define (split lst)\n      (if (empty? lst)\n          (values empty empty)\n          (let ([mid (quotient (length lst) 2)])\n            (values (take lst mid) (drop lst mid)))))\n    (define (merge-sort-helper lst)\n      (if (empty? lst)\n          empty\n          (let-values ([(lst",
    "  (define (helper nums1 nums2 k pairs)\n    (cond [(empty? nums1) pairs]\n          [(empty? nums2) pairs]\n          [(<= k 0) pairs]\n          [else\n           (define (add-pair nums1 nums2 pairs)\n             (define (add-pair-helper nums1 nums2 pairs)\n               (cond [(empty? nums1) pairs]\n                     [(empty? nums2) pairs]\n                     [else (add-pair-helper (rest nums1) (rest nums2) (cons (list (first nums1) (first nums2)) pairs))]))\n             (add-pair-helper nums1 nums2 pairs))\n           (helper (rest nums1) (rest nums2) (- k (length nums2)) (add-pair nums1 nums2 pairs))]))\n  (reverse (helper nums1 nums2 k '())))\n",
    "  (let ([pairs (for*/list ([x nums1] [y nums2])\n                 (list x y))])\n    (take k (sort pairs (\u03bb (x y) (< (apply + x) (apply + y)))))))\n",
    "  (let loop ([nums1 nums1] [nums2 nums2] [k k] [result '()])\n    (cond [(empty? nums1) result]\n          [(empty? nums2) result]\n          [(zero? k) result]\n          [else\n           (let ([n1 (first nums1)]\n                 [n2 (first nums2)]\n                 [nums1 (rest nums1)]\n                 [nums2 (rest nums2)])\n             (loop nums1 nums2 (- k 1) (cons (list n1 n2) result)))])))\n",
    "  (define (helper nums1 nums2 k)\n    (if (or (null? nums1) (null? nums2))\n        '()\n        (let* ([n1 (car nums1)]\n               [n2 (car nums2)]\n               [rest (helper (cdr nums1) (cdr nums2) (- k 1))])\n          (if (or (null? rest)\n                  (> (car (car rest)) (+ n1 n2)))\n              (cons (list (+ n1 n2)) rest)\n              (cons (car rest) (helper nums1 nums2 (- k 1)))))))\n  (helper nums1 nums2 k))\n",
    "  (let ([pairs (for*/list ([n1 nums1] [n2 nums2]) (list n1 n2))])\n    (take k (sort pairs (\u03bb (p1 p2) (< (apply + p1) (apply + p2)))))))\n",
    "  (define (helper n1 n2 k)\n    (if (or (null? n1) (null? n2))\n        '()\n        (let ([pairs (for/list ([x n1] [y n2])\n                       (list x y))])\n          (if (&gt;= k (length pairs))\n              pairs\n              (let ([pairs (sort pairs &lt; #:key car)])\n                (take k pairs))))))\n  (helper nums1 nums2 k))\n",
    "  (let loop ([nums1 nums1] [nums2 nums2] [k k] [acc '()])\n    (cond [(empty? nums1) acc]\n          [(empty? nums2) acc]\n          [(zero? k) acc]\n          [else\n           (let* ([n1 (first nums1)]\n                  [n2 (first nums2)]\n                  [n1-rest (rest nums1)]\n                  [n2-rest (rest nums2)]\n                  [n1-n2 (cons n1 n2)]\n                  [n1-n2-rest (cons n1-n2 acc)])\n             (if (&lt; (first n2) (first n1))\n                 (loop nums1 n2-rest k n1-n2-rest)\n                 (loop n1-rest nums2 k n1-n2-rest)))])))\n",
    "  (define (helper nums1 nums2 k acc)\n    (cond [(empty? nums1) acc]\n          [(empty? nums2) acc]\n          [(zero? k) acc]\n          [else\n           (define (add-pair nums1 nums2 acc)\n             (define (add-pair-helper nums1 nums2 acc)\n               (cond [(empty? nums1) acc]\n                     [(empty? nums2) acc]\n                     [else\n                      (add-pair-helper (rest nums1) (rest nums2) (cons (list (first nums1) (first nums2)) acc))]))\n             (add-pair-helper nums1 nums2 acc))\n           (helper (rest nums1) (rest nums2) (- k (length nums2)) (append (add-pair nums1 nums2 acc) acc))]))\n  (reverse (helper nums1 nums2 k '())))\n"
  ]
}