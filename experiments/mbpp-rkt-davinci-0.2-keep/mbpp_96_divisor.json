{
  "name": "mbpp_96_divisor",
  "language": "rkt",
  "prompt": "#lang racket\n\n;; Write a python function to find the number of divisors of a given integer.\n(define (divisor n)\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_96_divisor.py",
  "prompt_terminology": "verbatim",
  "tests": "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate divisor))\n    (check-equal? (candidate 15) 4)\n    (check-equal? (candidate 12) 6)\n    (check-equal? (candidate 9) 3)\n))\n\n(test-humaneval)",
  "stop_tokens": [
    "\n(define ",
    "\n#|",
    "\n;",
    "\n("
  ],
  "completions": [
    "  (define (divisor-iter i)\n    (if (= i n)\n        0\n        (if (= (modulo n i) 0)\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        0\n        (if (= (remainder n i) 0)\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (for/list ([i (in-range 1 (+ n 1))])\n    (if (zero? (modulo n i)) i)))\n",
    "  (define (divisor-iter i acc)\n    (cond ((= i n) acc)\n          ((= (modulo n i) 0) (divisor-iter (+ i 1) (+ acc 1)))\n          (else (divisor-iter (+ i 1) acc))))\n  (divisor-iter 1 0))\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        0\n        (if (= (modulo n i) 0)\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter n i)\n    (if (= i n)\n        0\n        (if (zero? (modulo n i))\n            (+ 1 (divisor-iter n (+ i 1)))\n            (divisor-iter n (+ i 1)))))\n  (divisor-iter n 1))\n",
    "  (for/list ([i (in-range 1 (+ n 1))])\n    (if (zero? (modulo n i))\n        i)))\n",
    "  (define (divisor-iter i count)\n    (cond ((= i n) count)\n          ((zero? (modulo n i)) (divisor-iter (+ i 1) (+ count 1)))\n          (else (divisor-iter (+ i 1) count))))\n  (divisor-iter 1 0))\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        0\n        (if (= (modulo n i) 0)\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        0\n        (if (= (modulo n i) 0)\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter i n)\n    (if (= i n)\n        0\n        (if (= (modulo n i) 0)\n            (+ 1 (divisor-iter (+ i 1) n))\n            (divisor-iter (+ i 1) n))))\n  (divisor-iter 1 n))\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        0\n        (if (= (modulo n i) 0)\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-helper n divisor-count)\n    (cond\n      [(= n 1) divisor-count]\n      [(= (remainder n divisor-count) 0) (divisor-helper n (+ divisor-count 1))]\n      [else (divisor-helper n (+ divisor-count 1))]))\n  (divisor-helper n 1))\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        0\n        (if (= (modulo n i) 0)\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter i count)\n    (if (= i n)\n        count\n        (if (zero? (modulo n i))\n            (divisor-iter (+ i 1) (+ count 1))\n            (divisor-iter (+ i 1) count))))\n  (divisor-iter 1 0))\n",
    "  (define (divisor-iter i)\n    (if (&gt; i n)\n        0\n        (+ (if (zero? (modulo n i)) 1 0)\n           (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter i)\n    (if (&gt; i n)\n        0\n        (+ (if (zero? (modulo n i)) 1 0)\n           (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter i count)\n    (cond ((= i n) count)\n          ((zero? (modulo n i)) (divisor-iter (+ i 1) (+ count 1)))\n          (else (divisor-iter (+ i 1) count))))\n  (divisor-iter 1 0))\n",
    "  (define (divisor-iter i count)\n    (cond ((= i n) count)\n          ((zero? (modulo n i)) (divisor-iter (+ i 1) (+ count 1)))\n          (else (divisor-iter (+ i 1) count))))\n  (divisor-iter 1 0))\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        0\n        (if (= (remainder n i) 0)\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter n i)\n    (if (= i n)\n        0\n        (if (= (modulo n i) 0)\n            (+ 1 (divisor-iter n (+ i 1)))\n            (divisor-iter n (+ i 1)))))\n  (divisor-iter n 1))\n",
    "  (define (divisor-iter n i)\n    (if (&gt; i n)\n        0\n        (+ (if (zero? (modulo n i)) 1 0)\n           (divisor-iter n (+ i 1)))))\n  (divisor-iter n 1))\n",
    "  (define (divisor-iter i)\n    (if (&lt; i n)\n        (if (zero? (modulo n i))\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))\n        0))\n  (divisor-iter 1))\n",
    "  (for/fold ([sum 0]) ([i (in-range 1 (+ 1 n))])\n    (if (zero? (modulo n i))\n        (+ sum 1)\n        sum)))\n",
    "  (define (divisor-iter i count)\n    (cond\n      [(= i n) count]\n      [(= (modulo n i) 0) (divisor-iter (+ i 1) (+ count 1))]\n      [else (divisor-iter (+ i 1) count)]))\n  (divisor-iter 1 0))\n",
    "  (define (divisor-iter i acc)\n    (cond ((= i 0) acc)\n          ((= (modulo n i) 0) (divisor-iter (- i 1) (+ acc 1)))\n          (else (divisor-iter (- i 1) acc))))\n  (divisor-iter n 0))\n",
    "  (define (divisor-iter i count)\n    (if (= i n)\n        count\n        (if (= (modulo n i) 0)\n            (divisor-iter (+ i 1) (+ count 1))\n            (divisor-iter (+ i 1) count))))\n  (divisor-iter 1 0))\n",
    "  (define (divisor-iter i)\n    (if (&lt; i n)\n        (if (zero? (modulo n i))\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))\n        0))\n  (divisor-iter 1))\n",
    "  (for/fold ([divisors 0]) ([i (in-range 1 (+ 1 n))])\n    (if (zero? (modulo n i))\n        (add1 divisors)\n        divisors)))\n",
    "  (define (divisor-iter n i)\n    (cond ((= i n) 0)\n          ((= (modulo n i) 0) (+ 1 (divisor-iter n (+ i 1))))\n          (else (divisor-iter n (+ i 1)))))\n  (divisor-iter n 1))\n",
    "  (for/list ([i (in-range 1 (+ n 1))])\n    (if (zero? (modulo n i)) i)))\n",
    "  (for/list ([i (in-range 1 (add1 (floor (sqrt n))))])\n    (if (zero? (modulo n i))\n        (list i (quotient n i)))))\n",
    "  (for/fold ([divisors 0]) ([i (in-range 1 (+ n 1))])\n    (if (zero? (modulo n i))\n        (add1 divisors)\n        divisors)))\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        0\n        (if (= (modulo n i) 0)\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (cond [(= n 1) 1]\n        [else (+ 1 (divisor (- n 1)))]))\n",
    "  (define (divisor-iter i n)\n    (if (= i n)\n        0\n        (if (= (remainder n i) 0)\n            (+ 1 (divisor-iter (+ i 1) n))\n            (divisor-iter (+ i 1) n))))\n  (divisor-iter 1 n))\n",
    "  (define (divisor-iter i acc)\n    (cond ((= i 0) acc)\n          ((= (modulo n i) 0) (divisor-iter (- i 1) (+ acc 1)))\n          (else (divisor-iter (- i 1) acc))))\n  (divisor-iter n 0))\n",
    "  (for/list ([i (in-range 1 (+ n 1))])\n    (if (zero? (modulo n i))\n        i)))\n</code>\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        0\n        (if (= (remainder n i) 0)\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter i count)\n    (cond ((&gt; i n) count)\n          ((zero? (modulo n i)) (divisor-iter (+ i 1) (+ count 1)))\n          (else (divisor-iter (+ i 1) count))))\n  (divisor-iter 1 0))\n",
    "  (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n    (if (zero? (modulo n i))\n        i)))\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        0\n        (if (= (modulo n i) 0)\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        0\n        (if (= (modulo n i) 0)\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter i acc)\n    (if (= i n)\n        acc\n        (if (= (modulo n i) 0)\n            (divisor-iter (+ i 1) (+ acc 1))\n            (divisor-iter (+ i 1) acc))))\n  (divisor-iter 1 0))\n",
    "  (for/fold ([divisors '()])\n            ([i (in-range 1 (+ n 1))])\n    (if (zero? (modulo n i))\n        (cons i divisors)\n        divisors)))\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        0\n        (if (= (modulo n i) 0)\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter i count)\n    (cond\n      [(= i n) count]\n      [(= (modulo n i) 0) (divisor-iter (+ i 1) (+ count 1))]\n      [else (divisor-iter (+ i 1) count)]))\n  (divisor-iter 1 0))\n",
    "  (define (divisor-iter n i)\n    (if (= i n)\n        0\n        (if (zero? (modulo n i))\n            (+ 1 (divisor-iter n (+ i 1)))\n            (divisor-iter n (+ i 1)))))\n  (divisor-iter n 1))\n",
    "  (define (divisor-iter i)\n    (cond ((= i n) 0)\n          ((= (modulo n i) 0) (+ 1 (divisor-iter (+ i 1))))\n          (else (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter i)\n    (if (&lt; i n)\n        (if (zero? (modulo n i))\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))\n        0))\n  (divisor-iter 1))\n</code>\nI'm not sure if this is the most efficient way to do it, but it works.\n\n\nA:\n\nI think you're on the right track.  Here's a version that's a little more idiomatic Racket:\n<code>(define (divisor n)\n  (define (divisor-iter i)\n    (if (&lt; i n)\n        (if (zero? (modulo n i))\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))\n        0))\n  (divisor-iter 1))\n</code>\nThe only thing I changed was to use <code>+</code> instead of <code>add1</code>.  <code>+</code> is more general, and it's idiomatic to use it when you're adding numbers.\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        0\n        (if (zero? (modulo n i))\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter i)\n    (if (&gt; i n)\n        0\n        (+ (if (zero? (modulo n i)) 1 0)\n           (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        0\n        (if (zero? (modulo n i))\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n    (if (zero? (modulo n i)) i)))\n",
    "  (define (divisor-iter i count)\n    (if (&gt; i n)\n        count\n        (if (zero? (modulo n i))\n            (divisor-iter (+ i 1) (+ count 1))\n            (divisor-iter (+ i 1) count))))\n  (divisor-iter 1 0))\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        0\n        (if (= (modulo n i) 0)\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter n i)\n    (if (= i n)\n        1\n        (+ (if (= (modulo n i) 0) 1 0)\n           (divisor-iter n (+ i 1)))))\n  (divisor-iter n 1))\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        0\n        (if (= (remainder n i) 0)\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        0\n        (if (zero? (modulo n i))\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        0\n        (if (= (modulo n i) 0)\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter i count)\n    (cond ((= i n) count)\n          ((= (modulo n i) 0) (divisor-iter (+ i 1) (+ count 1)))\n          (else (divisor-iter (+ i 1) count))))\n  (divisor-iter 1 0))\n",
    "  (for/fold ([divisors 0]) ([i (in-range 1 (+ n 1))])\n    (if (zero? (modulo n i))\n        (add1 divisors)\n        divisors)))\n",
    "  (define (divisor-iter i count)\n    (if (&gt; i n)\n        count\n        (if (zero? (modulo n i))\n            (divisor-iter (+ i 1) (+ count 1))\n            (divisor-iter (+ i 1) count))))\n  (divisor-iter 1 0))\n",
    "  (define (divisor-iter i count)\n    (cond ((= i n) count)\n          ((= (modulo n i) 0) (divisor-iter (+ i 1) (+ count 1)))\n          (else (divisor-iter (+ i 1) count))))\n  (divisor-iter 1 0))\n",
    "  (define (divisor-iter i)\n    (cond\n      [(> i n) 0]\n      [(= (modulo n i) 0) (+ 1 (divisor-iter (+ i 1)))]\n      [else (divisor-iter (+ i 1))]))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter i count)\n    (cond ((= i n) count)\n          ((zero? (modulo n i)) (divisor-iter (+ i 1) (+ count 1)))\n          (else (divisor-iter (+ i 1) count))))\n  (divisor-iter 1 0))\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        0\n        (if (= (modulo n i) 0)\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter i count)\n    (if (&gt; i n)\n        count\n        (if (zero? (modulo n i))\n            (divisor-iter (+ i 1) (+ count 1))\n            (divisor-iter (+ i 1) count))))\n  (divisor-iter 1 0))\n</code>\n",
    "  (define (divisor-iter i)\n    (if (&gt; i n)\n        0\n        (+ (if (zero? (modulo n i)) 1 0)\n           (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (cond [(= n 1) 1]\n        [else (+ 1 (divisor (- n 1)))]))\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        0\n        (if (= (modulo n i) 0)\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        0\n        (if (= (modulo n i) 0)\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter count)\n    (if (= count n)\n        0\n        (if (= (remainder n count) 0)\n            (+ 1 (divisor-iter (+ count 1)))\n            (divisor-iter (+ count 1)))))\n  (divisor-iter 1))\n",
    "  (for/fold ([divisors '()]) ([i (in-range 1 (+ 1 n))])\n    (if (zero? (modulo n i))\n        (cons i divisors)\n        divisors)))\n",
    "  (for/list ([i (in-range 1 (+ n 1))])\n    (if (zero? (modulo n i)) i)))\n",
    "  (define (divisor-iter n i)\n    (if (&gt; n i)\n        (if (zero? (modulo n i))\n            (+ 1 (divisor-iter n (+ i 1)))\n            (divisor-iter n (+ i 1)))\n        0))\n  (divisor-iter n 1))\n",
    "  (for/fold ([divisors '()])\n            ([i (in-range 1 (+ n 1))])\n    (if (zero? (modulo n i))\n        (cons i divisors)\n        divisors)))\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        0\n        (if (zero? (modulo n i))\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        0\n        (if (= (modulo n i) 0)\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter i)\n    (cond ((= i n) 1)\n          ((= (modulo n i) 0) (+ 1 (divisor-iter (+ i 1))))\n          (else (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        0\n        (if (= (modulo n i) 0)\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (for/fold ([divisors 0]) ([i (in-range 1 (+ n 1))])\n    (if (zero? (modulo n i))\n        (add1 divisors)\n        divisors)))\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        0\n        (if (= (remainder n i) 0)\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter n i)\n    (if (= i n)\n        1\n        (+ (if (= (modulo n i) 0) 1 0)\n           (divisor-iter n (+ i 1)))))\n  (divisor-iter n 1))\n",
    "  (define (divisor-iter i count)\n    (cond ((= i n) count)\n          ((= (modulo n i) 0) (divisor-iter (+ i 1) (+ count 1)))\n          (else (divisor-iter (+ i 1) count))))\n  (divisor-iter 1 0))\n",
    "  (define (divisor-iter i count)\n    (cond ((= i n) count)\n          ((= (modulo n i) 0) (divisor-iter (+ i 1) (+ count 1)))\n          (else (divisor-iter (+ i 1) count))))\n  (divisor-iter 1 0))\n",
    "  (for/fold ([divisors '()]) ([i (in-range 1 (+ n 1))])\n    (if (zero? (modulo n i))\n        (cons i divisors)\n        divisors)))\n",
    "  (define (divisor-iter n i)\n    (if (= i n)\n        1\n        (+ (if (= (modulo n i) 0) 1 0)\n           (divisor-iter n (+ i 1)))))\n  (divisor-iter n 1))\n",
    "  (define (divisor-iter n i)\n    (if (&lt; i n)\n        (if (zero? (modulo n i))\n            (+ 1 (divisor-iter n (+ i 1)))\n            (divisor-iter n (+ i 1)))\n        0))\n  (divisor-iter n 1))\n",
    "  (define (divisor-iter i count)\n    (if (&gt; i n)\n        count\n        (if (zero? (modulo n i))\n            (divisor-iter (+ i 1) (+ count 1))\n            (divisor-iter (+ i 1) count))))\n  (divisor-iter 1 0))\n",
    "  (define (divisor-iter i count)\n    (cond ((= i n) count)\n          ((= (modulo n i) 0) (divisor-iter (+ i 1) (+ count 1)))\n          (else (divisor-iter (+ i 1) count))))\n  (divisor-iter 1 0))\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        0\n        (+ (if (= (remainder n i) 0) 1 0)\n           (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        0\n        (if (zero? (modulo n i))\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter i count)\n    (cond ((= i n) count)\n          ((zero? (modulo n i)) (divisor-iter (+ i 1) (+ count 1)))\n          (else (divisor-iter (+ i 1) count))))\n  (divisor-iter 1 0))\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        0\n        (if (= (remainder n i) 0)\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        0\n        (if (= (modulo n i) 0)\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        0\n        (if (= (modulo n i) 0)\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter i n)\n    (if (= i n)\n        0\n        (if (= (modulo n i) 0)\n            (+ 1 (divisor-iter (+ i 1) n))\n            (divisor-iter (+ i 1) n))))\n  (divisor-iter 1 n))\n",
    "  (define (divisor-iter i acc)\n    (if (= i n)\n        acc\n        (if (zero? (modulo n i))\n            (divisor-iter (+ i 1) (+ acc 1))\n            (divisor-iter (+ i 1) acc))))\n  (divisor-iter 1 0))\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        0\n        (if (= (modulo n i) 0)\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter i count)\n    (cond ((= i 0) count)\n          ((= (modulo n i) 0) (divisor-iter (- i 1) (+ count 1)))\n          (else (divisor-iter (- i 1) count))))\n  (divisor-iter n 0))\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        0\n        (if (zero? (modulo n i))\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter i)\n    (if (&gt; i n)\n        0\n        (+ (if (zero? (modulo n i)) 1 0)\n           (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter i count)\n    (if (= i n)\n        count\n        (if (zero? (modulo n i))\n            (divisor-iter (+ i 1) (+ count 1))\n            (divisor-iter (+ i 1) count))))\n  (divisor-iter 1 0))\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        0\n        (if (zero? (modulo n i))\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-helper n i)\n    (cond ((&gt; i n) 0)\n          ((= (modulo n i) 0) (+ 1 (divisor-helper n (+ i 1))))\n          (else (divisor-helper n (+ i 1)))))\n  (divisor-helper n 1))\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        0\n        (if (zero? (modulo n i))\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        0\n        (if (= (modulo n i) 0)\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter n i)\n    (if (= n 1)\n        i\n        (if (integer? (/ n i))\n            (divisor-iter (/ n i) (+ i 1))\n            (divisor-iter n (+ i 1)))))\n  (divisor-iter n 1))\n",
    "  (define (divisor-iter i count)\n    (cond ((&gt; i n) count)\n          ((= (modulo n i) 0) (divisor-iter (+ i 1) (+ count 1)))\n          (else (divisor-iter (+ i 1) count))))\n  (divisor-iter 1 0))\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        0\n        (if (= (modulo n i) 0)\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (for/list ([i (in-range 1 (+ n 1))])\n    (if (zero? (modulo n i)) i)))\n",
    "  (for/fold ([divisors (list)]\n             [i 1])\n            ([i (in-range 1 (+ 1 n))])\n    (if (= (modulo n i) 0)\n        (cons i divisors)\n        divisors)))\n",
    "  (cond\n    [(= n 1) 1]\n    [(= n 2) 2]\n    [(= n 3) 2]\n    [(= n 4) 3]\n    [(= n 5) 2]\n    [(= n 6) 4]\n    [(= n 7) 2]\n    [(= n 8) 4]\n    [(= n 9) 3]\n    [(= n 10) 4]\n    [(= n 11) 2]\n    [(= n 12) 6]\n    [(= n 13) 2]\n    [(= n 14) 4]\n    [(= n 15) 4]\n    [(= n 16) 5]\n    [(= n 17) 2]\n    [(= n 18) 6]\n    [(= n 19) 2]\n    [(= n 20) 6]\n    [(= n 21) 4]\n    [(= n 22) 4]\n    [(= n 23) 2]\n    [(= n 24) 8]\n    [(= n 25) 3]\n    [(= n 26) 4]\n    [(= n 27) 4]\n    [(= n 28) 6]\n    [(= n 29) 2]\n    [(= n 30) 8]\n    [(= n 31) 2]\n    [(= n 32) 5]\n    [(= n 33) 4]\n    [(= n 34) 4]\n    [(= n 35) 4]\n    [(= n 36) 9]\n    [(= n 37) 2]\n    [(= n 38) 4]\n    [(= n 39) 4]\n    [(= n 40) 8]\n    [(= n 41) 2]\n    [(= n 42) 6]\n    [(= n 43) 2]\n    [(= n 44) 6]\n    [(= n 45) 6]\n    [(= n 46) 4]\n    [(= n 47) 2]\n    [(= n 48) 12]\n    [(= n 49) 3]\n    [(= n 50) 6]\n    [(= n 51) 4]\n    [(= n 52) 6]\n    [(= n 53) 2]\n    [(= n 54) 8]\n    [(= n 55) 4]\n    [(= n 56) 7]\n    [(=",
    "  (for/fold ([divisors 0]) ([i (in-range 1 (add1 (quotient n 2)))])\n    (if (zero? (modulo n i))\n        (add1 divisors)\n        divisors)))\n",
    "  (define (divisor-iter i count)\n    (cond ((= i n) count)\n          ((= (modulo n i) 0) (divisor-iter (+ i 1) (+ count 1)))\n          (else (divisor-iter (+ i 1) count))))\n  (divisor-iter 1 0))\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        1\n        (if (zero? (modulo n i))\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        0\n        (if (= (modulo n i) 0)\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        0\n        (if (= (remainder n i) 0)\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter i)\n    (if (&lt; i n)\n        (if (zero? (modulo n i))\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))\n        0))\n  (divisor-iter 1))\n",
    "  (for/list ([i (in-range 1 (+ 1 n))])\n    (if (zero? (modulo n i)) i)))\n",
    "  (for/fold ([divisors '()]) ([i (in-range 1 (add1 (quotient n 2)))])\n    (if (zero? (modulo n i))\n        (cons i divisors)\n        divisors)))\n",
    "  (define (divisor-iter i count)\n    (cond ((&gt; i n) count)\n          ((zero? (remainder n i)) (divisor-iter (+ i 1) (+ count 1)))\n          (else (divisor-iter (+ i 1) count))))\n  (divisor-iter 1 0))\n",
    "  (for/fold ([divisors 0]) ([i (in-range 1 (+ n 1))])\n    (if (zero? (modulo n i))\n        (add1 divisors)\n        divisors)))\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        1\n        (if (zero? (modulo n i))\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter i)\n    (if (&gt; i n)\n        0\n        (+ 1 (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        0\n        (if (= (modulo n i) 0)\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter i acc)\n    (cond\n      [(= i 1) acc]\n      [(= (modulo n i) 0) (divisor-iter (- i 1) (+ acc 1))]\n      [else (divisor-iter (- i 1) acc)]))\n  (divisor-iter n 0))\n",
    "  (define (divisor-iter i count)\n    (cond ((> i n) count)\n          ((= (modulo n i) 0) (divisor-iter (+ i 1) (+ count 1)))\n          (else (divisor-iter (+ i 1) count))))\n  (divisor-iter 1 0))\n",
    "  (define (divisor-iter i count)\n    (if (&gt; i n)\n        count\n        (if (zero? (modulo n i))\n            (divisor-iter (+ i 1) (+ count 1))\n            (divisor-iter (+ i 1) count))))\n  (divisor-iter 1 0))\n",
    "  (define (divisor-iter i count)\n    (cond ((&gt; i n) count)\n          ((= (modulo n i) 0) (divisor-iter (+ i 1) (+ count 1)))\n          (else (divisor-iter (+ i 1) count))))\n  (divisor-iter 1 0))\n",
    "  (define (divisor-iter i count)\n    (cond\n      [(= i n) count]\n      [(= (modulo n i) 0) (divisor-iter (+ i 1) (+ count 1))]\n      [else (divisor-iter (+ i 1) count)]))\n  (divisor-iter 1 0))\n",
    "  (define (divisor-iter i)\n    (if (&lt; i n)\n        (if (zero? (modulo n i))\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))\n        0))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter n i)\n    (if (= i n)\n        0\n        (if (= (modulo n i) 0)\n            (+ 1 (divisor-iter n (+ i 1)))\n            (divisor-iter n (+ i 1)))))\n  (divisor-iter n 1))\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        0\n        (if (= (modulo n i) 0)\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter i count)\n    (cond\n      [(= i n) count]\n      [(= (modulo n i) 0) (divisor-iter (+ i 1) (+ count 1))]\n      [else (divisor-iter (+ i 1) count)]))\n  (divisor-iter 1 0))\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        0\n        (if (= (modulo n i) 0)\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter n i)\n    (if (= n i)\n        0\n        (if (= 0 (modulo n i))\n            (+ 1 (divisor-iter n (+ i 1)))\n            (divisor-iter n (+ i 1)))))\n  (divisor-iter n 1))\n",
    "  (define (divisor-iter i count)\n    (if (= i n)\n        count\n        (if (= (modulo n i) 0)\n            (divisor-iter (+ i 1) (+ count 1))\n            (divisor-iter (+ i 1) count))))\n  (divisor-iter 1 0))\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        0\n        (if (= (modulo n i) 0)\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter i)\n    (if (&lt; i n)\n        (if (zero? (modulo n i))\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))\n        0))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter k)\n    (if (= k n)\n        0\n        (if (= (modulo n k) 0)\n            (+ 1 (divisor-iter (+ k 1)))\n            (divisor-iter (+ k 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter i count)\n    (cond ((&gt; i n) count)\n          ((= (modulo n i) 0) (divisor-iter (+ i 1) (+ count 1)))\n          (else (divisor-iter (+ i 1) count))))\n  (divisor-iter 1 0))\n",
    "  (define (divisor-iter i count)\n    (cond ((= i n) count)\n          ((zero? (remainder n i)) (divisor-iter (+ i 1) (+ count 1)))\n          (else (divisor-iter (+ i 1) count))))\n  (divisor-iter 1 0))\n",
    "  (define (iter i)\n    (cond ((= i n) 0)\n          ((= (modulo n i) 0) (+ 1 (iter (+ i 1))))\n          (else (iter (+ i 1)))))\n  (iter 1))\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        0\n        (if (zero? (modulo n i))\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        0\n        (if (= (modulo n i) 0)\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter i count)\n    (cond ((= i n) count)\n          ((zero? (modulo n i)) (divisor-iter (+ i 1) (+ count 1)))\n          (else (divisor-iter (+ i 1) count))))\n  (divisor-iter 1 0))\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        0\n        (if (zero? (modulo n i))\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        0\n        (if (zero? (modulo n i))\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter i n)\n    (if (&gt; i n)\n        0\n        (+ (if (zero? (modulo n i)) 1 0)\n           (divisor-iter (+ i 1) n))))\n  (divisor-iter 1 n))\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        0\n        (if (= (modulo n i) 0)\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        0\n        (if (= (modulo n i) 0)\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n    (if (zero? (modulo n i)) i)))\n",
    "  (define (divisor-iter i n)\n    (if (= i n)\n        0\n        (if (= (modulo n i) 0)\n            (+ 1 (divisor-iter (+ i 1) n))\n            (divisor-iter (+ i 1) n))))\n  (divisor-iter 1 n))\n",
    "  (let loop ([i 1] [count 0])\n    (cond [(= i n) count]\n          [(zero? (modulo n i)) (loop (+ i 1) (+ count 1))]\n          [else (loop (+ i 1) count)])))\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        0\n        (if (zero? (modulo n i))\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter n i)\n    (if (= i n)\n        0\n        (if (= (modulo n i) 0)\n            (+ 1 (divisor-iter n (+ i 1)))\n            (divisor-iter n (+ i 1)))))\n  (divisor-iter n 1))\n",
    "  (for/fold ([divisors '()]) ([i (in-range 1 (add1 (quotient n 2)))])\n    (if (zero? (modulo n i))\n        (cons i divisors)\n        divisors)))\n",
    "  (define (divisor-iter i acc)\n    (cond\n      [(= i 1) acc]\n      [(= (modulo n i) 0) (divisor-iter (- i 1) (+ acc 1))]\n      [else (divisor-iter (- i 1) acc)]))\n  (divisor-iter n 0))\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        0\n        (if (zero? (modulo n i))\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter i acc)\n    (if (= i 0)\n        acc\n        (if (= (remainder n i) 0)\n            (divisor-iter (- i 1) (+ acc 1))\n            (divisor-iter (- i 1) acc))))\n  (divisor-iter n 0))\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        0\n        (if (= (modulo n i) 0)\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        0\n        (if (zero? (modulo n i))\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter i count)\n    (if (= i n)\n        count\n        (if (zero? (modulo n i))\n            (divisor-iter (+ i 1) (+ count 1))\n            (divisor-iter (+ i 1) count))))\n  (divisor-iter 1 0))\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        0\n        (if (= (remainder n i) 0)\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (for/list ([i (in-range 1 n)])\n    (if (zero? (modulo n i))\n        i)))\n",
    "  (for/fold ([count 0]) ([i (in-range 1 (+ n 1))])\n    (if (zero? (modulo n i))\n        (add1 count)\n        count)))\n",
    "  (for/fold ([divisors '()]) ([i (in-range 1 (+ n 1))])\n    (if (zero? (modulo n i))\n        (cons i divisors)\n        divisors)))\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        0\n        (if (zero? (modulo n i))\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        0\n        (if (= (modulo n i) 0)\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        0\n        (if (zero? (modulo n i))\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter n i)\n    (if (= i n)\n        0\n        (if (zero? (modulo n i))\n            (+ 1 (divisor-iter n (+ i 1)))\n            (divisor-iter n (+ i 1)))))\n  (divisor-iter n 1))\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        0\n        (if (= (remainder n i) 0)\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        0\n        (+ (if (zero? (modulo n i)) 1 0)\n           (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        1\n        (if (zero? (modulo n i))\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (for/list ([i (in-range 1 (add1 (quotient n 2)))])\n    (if (zero? (modulo n i))\n        i)))\n",
    "  (define (divisor-iter i acc)\n    (if (= i 1)\n        acc\n        (if (zero? (modulo n i))\n            (divisor-iter (- i 1) (+ acc 1))\n            (divisor-iter (- i 1) acc))))\n  (divisor-iter n 0))\n",
    "  (define (divisor-iter i)\n    (if (&gt; i n)\n        '()\n        (if (zero? (modulo n i))\n            (cons i (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter i count)\n    (if (= i n)\n        count\n        (if (zero? (modulo n i))\n            (divisor-iter (+ i 1) (+ count 1))\n            (divisor-iter (+ i 1) count))))\n  (divisor-iter 1 0))\n",
    "  (define (divisor-iter i count)\n    (cond ((= i n) count)\n          ((= (modulo n i) 0) (divisor-iter (+ i 1) (+ count 1)))\n          (else (divisor-iter (+ i 1) count))))\n  (divisor-iter 1 0))\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        0\n        (if (= (remainder n i) 0)\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        0\n        (if (zero? (modulo n i))\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter i count)\n    (if (&gt; i n)\n        count\n        (if (zero? (modulo n i))\n            (divisor-iter (+ i 1) (+ count 1))\n            (divisor-iter (+ i 1) count))))\n  (divisor-iter 1 0))\n",
    "  (define (divisor-iter i count)\n    (if (= i n)\n        count\n        (if (zero? (modulo n i))\n            (divisor-iter (+ i 1) (+ count 1))\n            (divisor-iter (+ i 1) count))))\n  (divisor-iter 1 0))\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        0\n        (if (= (remainder n i) 0)\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (helper i)\n    (if (= i n)\n        0\n        (if (= (modulo n i) 0)\n            (+ 1 (helper (+ i 1)))\n            (helper (+ i 1)))))\n  (helper 1))\n",
    "  (for/list ([i (in-range 1 (+ n 1))])\n    (if (zero? (modulo n i))\n        i)))\n",
    "  (define (divisor-iter i count)\n    (cond ((= i n) count)\n          ((zero? (modulo n i)) (divisor-iter (+ i 1) (+ count 1)))\n          (else (divisor-iter (+ i 1) count))))\n  (divisor-iter 1 0))\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        0\n        (if (= (modulo n i) 0)\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter i count)\n    (cond ((= i 1) count)\n          ((= (modulo n i) 0) (divisor-iter (- i 1) (+ count 1)))\n          (else (divisor-iter (- i 1) count))))\n  (divisor-iter n 0))\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        0\n        (if (= (modulo n i) 0)\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        0\n        (+ (if (= (modulo n i) 0) 1 0)\n           (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (define (divisor-iter i count)\n    (cond ((= i 0) count)\n          ((= (modulo n i) 0) (divisor-iter (- i 1) (+ count 1)))\n          (else (divisor-iter (- i 1) count))))\n  (divisor-iter n 0))\n",
    "  (for/fold ([divisors 0]) ([i (in-range 1 (+ n 1))])\n    (if (zero? (modulo n i))\n        (add1 divisors)\n        divisors)))\n",
    "  (define (divisor-iter i)\n    (if (= i n)\n        0\n        (if (= (modulo n i) 0)\n            (+ 1 (divisor-iter (+ i 1)))\n            (divisor-iter (+ i 1)))))\n  (divisor-iter 1))\n",
    "  (let loop ([i 1] [count 0])\n    (if (&lt; i n)\n        (if (zero? (modulo n i))\n            (loop (+ i 1) (+ count 1))\n            (loop (+ i 1) count))\n        count)))\n",
    "  (define (divisor-helper n divisor)\n    (if (= n 1)\n        0\n        (if (= (modulo n divisor) 0)\n            (+ 1 (divisor-helper (/ n divisor) divisor))\n            (divisor-helper n (+ divisor 1)))))\n  (divisor-helper n 2))\n",
    "  (define (divisor-iter n i)\n    (if (= i n)\n        0\n        (if (= (remainder n i) 0)\n            (+ 1 (divisor-iter n (+ i 1)))\n            (divisor-iter n (+ i 1)))))\n  (divisor-iter n 1))\n",
    "  (define (divisor-helper i)\n    (if (= i n)\n        0\n        (if (= (modulo n i) 0)\n            (+ 1 (divisor-helper (+ i 1)))\n            (divisor-helper (+ i 1)))))\n  (divisor-helper 1))\n"
  ]
}