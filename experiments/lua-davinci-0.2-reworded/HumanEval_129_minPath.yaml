---
name: HumanEval_129_minPath
language: lua
prompt: "-- Given a grid with N rows and N columns (N >= 2) and a positive integer
  k, \n-- each cell of the grid contains a value. Every integer in the range [1, N
  * N]\n-- inclusive appears exactly once on the cells of the grid.\n-- You have to
  find the minimum path of length k in the grid. You can start\n-- from any cell,
  and in each step you can move to any of the neighbor cells,\n-- in other words,
  you can go to cells which share an edge with you current\n-- cell.\n-- Please note
  that a path of length k means visiting exactly k cells (not\n-- necessarily distinct).\n--
  You CANNOT go off the grid.\n-- A path A (of length k) is considered less than a
  path B (of length k) if\n-- after making the ordered tables of the values on the
  cells that A and B go\n-- through (let's call them lst_A and lst_B), lst_A is lexicographically
  less\n-- than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n--
  such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n-- lst_A[j] =
  lst_B[j].\n-- It is guaranteed that the answer is unique.\n-- Return an ordered
  table of the values on the cells that the minimum path go through.\n-- Examples:
  \   \n-- >>> minPath({{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}, 3)\n-- {1, 2, 1}\n-- >>>
  minPath({{5, 9, 3}, {4, 1, 6}, {7, 8, 2}}, 1)\n-- {1}\nlocal function minPath(grid,
  k)\n"
tests: |-
  lu = require('luaunit')

  function test_humaneval()
  local candidate = minPath
      lu.assertEquals(candidate({{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}, 3), {1, 2, 1})
      lu.assertEquals(candidate({{5, 9, 3}, {4, 1, 6}, {7, 8, 2}}, 1), {1})
      lu.assertEquals(candidate({{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 16}}, 4), {1, 2, 1, 2})
      lu.assertEquals(candidate({{6, 4, 13, 10}, {5, 7, 12, 1}, {3, 16, 11, 15}, {8, 14, 9, 2}}, 7), {1, 10, 1, 10, 1, 10, 1})
      lu.assertEquals(candidate({{8, 14, 9, 2}, {6, 4, 13, 15}, {5, 7, 1, 12}, {3, 10, 11, 16}}, 5), {1, 7, 1, 7, 1})
      lu.assertEquals(candidate({{11, 8, 7, 2}, {5, 16, 14, 4}, {9, 3, 15, 6}, {12, 13, 10, 1}}, 9), {1, 6, 1, 6, 1, 6, 1, 6, 1})
      lu.assertEquals(candidate({{12, 13, 10, 1}, {9, 3, 15, 6}, {5, 16, 14, 4}, {11, 8, 7, 2}}, 12), {1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6})
      lu.assertEquals(candidate({{2, 7, 4}, {3, 1, 5}, {6, 8, 9}}, 8), {1, 3, 1, 3, 1, 3, 1, 3})
      lu.assertEquals(candidate({{6, 1, 5}, {3, 8, 9}, {2, 7, 4}}, 8), {1, 5, 1, 5, 1, 5, 1, 5})
      lu.assertEquals(candidate({{1, 2}, {3, 4}}, 10), {1, 2, 1, 2, 1, 2, 1, 2, 1, 2})
      lu.assertEquals(candidate({{1, 3}, {3, 2}}, 10), {1, 3, 1, 3, 1, 3, 1, 3, 1, 3})
  end

  os.exit(lu.LuaUnit.run())
completions:
- |2-
      local n = #grid
      local function cmp(a, b)
          for i = 1, #a do
              if a[i] < b[i] then
                  return true
              elseif a[i] > b[i] then
                  return false
              end
          end
          return false
      end
      local function dfs(i, j, k, path)
          if k == 0 then
              if not res or cmp(path, res) then
                  res = path
              end
              return
          end
          if i > 1 then
              dfs(i - 1, j, k - 1, {unpack(path), grid[i - 1][j]})
          end
          if i < n then
              dfs(i + 1, j, k - 1, {unpack(path), grid[i + 1][j]})
          end
          if j > 1 then
              dfs(i, j - 1, k - 1, {unpack(path), grid[i][j - 1]})
          end
          if j < n then
              dfs(i, j + 1, k - 1, {unpack(path), grid[i][j + 1]})
          end
      end
      local res
      for i = 1, n do
          for j = 1, n do
              dfs(i, j, k, {grid[i][j]})
          end
      end
      return res
  end
- |2-
      local n = #grid
      local function get_neighbors(i, j)
          local neighbors = {}
          if i > 1 then
              neighbors[#neighbors + 1] = {i = i - 1, j = j}
          end
          if i < n then
              neighbors[#neighbors + 1] = {i = i + 1, j = j}
          end
          if j > 1 then
              neighbors[#neighbors + 1] = {i = i, j = j - 1}
          end
          if j < n then
              neighbors[#neighbors + 1] = {i = i, j = j + 1}
          end
          return neighbors
      end
      local function get_path(i, j, k)
          local path = {}
          local function dfs(i, j, k)
              if k == 0 then
                  return true
              end
              local neighbors = get_neighbors(i, j)
              for _, neighbor in ipairs(neighbors) do
                  if not path[neighbor.i] or not path[neighbor.i][neighbor.j] then
                      path[neighbor.i] = path[neighbor.i] or {}
                      path[neighbor.i][neighbor.j] = true
                      if dfs(neighbor.i, neighbor.j, k - 1) then
                          return true
                      end
                      path[neighbor.i][neighbor.j] = nil
                  end
              end
              return false
          end
          dfs(i, j, k)
          return path
      end
      local function get_path_value(path)
          local value = {}
          for i = 1, n do
              for j = 1, n do
                  if path[i] and path[i][j] then
                      value[#value + 1] = grid[i][j]
                  end
              end
          end
          return value
      end
      local function compare_path(path1, path2)
          local value1 = get_path_value(path1)
          local value2 = get_path_value(
- |2-
      local n = #grid
      local m = {}
      for i = 1, n do
          m[i] = {}
          for j = 1, n do
              m[i][j] = {grid[i][j]}
          end
      end
      for i = 1, k - 1 do
          local t = {}
          for j = 1, n do
              t[j] = {}
              for l = 1, n do
                  t[j][l] = {}
              end
          end
          for j = 1, n do
              for l = 1, n do
                  local x = grid[j][l]
                  local a = j > 1 and grid[j - 1][l] or math.huge
                  local b = j < n and grid[j + 1][l] or math.huge
                  local c = l > 1 and grid[j][l - 1] or math.huge
                  local d = l < n and grid[j][l + 1] or math.huge
                  local min = math.min(a, b, c, d)
                  if min == math.huge then
                      t[j][l] = {x}
                  else
                      local t1 = {}
                      local t2 = {}
                      if min == a then
                          t1 = m[j - 1][l]
                      elseif min == b then
                          t1 = m[j + 1][l]
                      elseif min == c then
                          t1 = m[j][l - 1]
                      else
                          t1 = m[j][l + 1]
                      end
                      for i = 1, #t1 do
                          t2[i] = t1[i]
                      end
                      t2[#t2 + 1] = x
                      t[j][l] = t2
                  end
              end
          end
          m = t
      end
      local min = math.huge
      local ans = {}
      for i = 1, n do
          for j = 1, n do
              local t = m[i][j]
              local x = t[1]
              for k = 2, #t do
                  x = x * n * n + t[k
- |2-
      local n = #grid
      local function get(i, j)
          return grid[i][j]
      end
      local function isValid(i, j)
          return i >= 1 and i <= n and j >= 1 and j <= n
      end
      local function getNeighbors(i, j)
          local neighbors = {}
          if isValid(i - 1, j) then
              neighbors[#neighbors + 1] = {i - 1, j}
          end
          if isValid(i + 1, j) then
              neighbors[#neighbors + 1] = {i + 1, j}
          end
          if isValid(i, j - 1) then
              neighbors[#neighbors + 1] = {i, j - 1}
          end
          if isValid(i, j + 1) then
              neighbors[#neighbors + 1] = {i, j + 1}
          end
          return neighbors
      end
      local function getMinPath(i, j, k)
          local minPath = {}
          local minPathValue = math.huge
          for _, neighbor in ipairs(getNeighbors(i, j)) do
              local neighborI, neighborJ = neighbor[1], neighbor[2]
              local neighborValue = get(neighborI, neighborJ)
              if k == 1 then
                  if neighborValue < minPathValue then
                      minPath = {neighborValue}
                      minPathValue = neighborValue
                  end
              else
                  local path = getMinPath(neighborI, neighborJ, k - 1)
                  local pathValue = get(neighborI, neighborJ)
                  for _, value in ipairs(path) do
                      pathValue = pathValue * n + value
                  end
                  if pathValue < minPathValue then
                      minPath = {neighborValue}
                      for _, value in ipairs(path) do
                          minPath[#minPath + 1] = value
                      end
                      minPathValue = pathValue
                  end
              end
          end
          return minPath
      end
      local minPath = {}
      local minPathValue = math.huge
      for i =
- |2-
      local n = #grid
      local function get(x, y)
          return grid[x][y]
      end
      local function get_neighbors(x, y)
          local neighbors = {}
          if x > 1 then
              neighbors[#neighbors + 1] = {x - 1, y}
          end
          if x < n then
              neighbors[#neighbors + 1] = {x + 1, y}
          end
          if y > 1 then
              neighbors[#neighbors + 1] = {x, y - 1}
          end
          if y < n then
              neighbors[#neighbors + 1] = {x, y + 1}
          end
          return neighbors
      end
      local function compare(a, b)
          for i = 1, k do
              if a[i] < b[i] then
                  return true
              elseif a[i] > b[i] then
                  return false
              end
          end
          return false
      end
      local function get_min_path(x, y, k)
          if k == 1 then
              return {get(x, y)}
          end
          local min_path = nil
          for _, neighbor in ipairs(get_neighbors(x, y)) do
              local path = get_min_path(neighbor[1], neighbor[2], k - 1)
              if min_path == nil or compare(path, min_path) then
                  min_path = path
              end
          end
          min_path[#min_path + 1] = get(x, y)
          return min_path
      end
      local min_path = nil
      for i = 1, n do
          for j = 1, n do
              local path = get_min_path(i, j, k)
              if min_path == nil or compare(path, min_path) then
                  min_path = path
              end
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local function get(x, y)
          if x < 1 or x > n or y < 1 or y > n then
              return nil
          end
          return grid[x][y]
      end
      local function get_neighbors(x, y)
          local neighbors = {}
          local function add(x, y)
              local value = get(x, y)
              if value then
                  neighbors[#neighbors + 1] = {x, y, value}
              end
          end
          add(x - 1, y)
          add(x + 1, y)
          add(x, y - 1)
          add(x, y + 1)
          return neighbors
      end
      local function compare(a, b)
          for i = 1, k do
              if a[i] < b[i] then
                  return true
              elseif a[i] > b[i] then
                  return false
              end
          end
          return false
      end
      local function dfs(x, y, k, path)
          if k == 0 then
              return path
          end
          local neighbors = get_neighbors(x, y)
          table.sort(neighbors, function(a, b) return a[3] < b[3] end)
          for _, neighbor in ipairs(neighbors) do
              local new_path = dfs(neighbor[1], neighbor[2], k - 1, path)
              if new_path and (not path or compare(new_path, path)) then
                  path = new_path
              end
          end
          return path
      end
      local path = nil
      for i = 1, n do
          for j = 1, n do
              local new_path = dfs(i, j, k, {grid[i][j]})
              if new_path and (not path or compare(new_path, path)) then
                  path = new_path
              end
          end
      end
      return path
  end
- |2-
      local N = #grid
      local function get(x, y)
          return grid[x][y]
      end
      local function get_neighbors(x, y)
          local neighbors = {}
          if x > 1 then
              neighbors[#neighbors + 1] = {x - 1, y}
          end
          if x < N then
              neighbors[#neighbors + 1] = {x + 1, y}
          end
          if y > 1 then
              neighbors[#neighbors + 1] = {x, y - 1}
          end
          if y < N then
              neighbors[#neighbors + 1] = {x, y + 1}
          end
          return neighbors
      end
      local function get_path(x, y, k)
          if k == 0 then
              return {}
          end
          local min_path = nil
          for _, neighbor in ipairs(get_neighbors(x, y)) do
              local path = get_path(neighbor[1], neighbor[2], k - 1)
              if path then
                  path[#path + 1] = get(x, y)
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
          return min_path
      end
      local min_path = nil
      for i = 1, N do
          for j = 1, N do
              local path = get_path(i, j, k)
              if path then
                  path[#path + 1] = get(i, j)
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local function get(x, y)
          return grid[x][y]
      end
      local function get_neighbors(x, y)
          local neighbors = {}
          if x > 1 then
              neighbors[#neighbors + 1] = {x - 1, y}
          end
          if x < n then
              neighbors[#neighbors + 1] = {x + 1, y}
          end
          if y > 1 then
              neighbors[#neighbors + 1] = {x, y - 1}
          end
          if y < n then
              neighbors[#neighbors + 1] = {x, y + 1}
          end
          return neighbors
      end
      local function get_path(x, y, k)
          if k == 0 then
              return {}
          end
          local min_path = nil
          for _, neighbor in ipairs(get_neighbors(x, y)) do
              local path = get_path(neighbor[1], neighbor[2], k - 1)
              if path then
                  path[#path + 1] = get(x, y)
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
          return min_path
      end
      local min_path = nil
      for i = 1, n do
          for j = 1, n do
              local path = get_path(i, j, k)
              if path then
                  path[#path + 1] = get(i, j)
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local function get(x, y)
          return grid[x][y]
      end
      local function get_neighbors(x, y)
          local neighbors = {}
          if x > 1 then
              neighbors[#neighbors + 1] = {x - 1, y}
          end
          if x < n then
              neighbors[#neighbors + 1] = {x + 1, y}
          end
          if y > 1 then
              neighbors[#neighbors + 1] = {x, y - 1}
          end
          if y < n then
              neighbors[#neighbors + 1] = {x, y + 1}
          end
          return neighbors
      end
      local function get_path(x, y, k)
          if k == 0 then
              return {}
          end
          local min_path = nil
          for _, neighbor in ipairs(get_neighbors(x, y)) do
              local path = get_path(neighbor[1], neighbor[2], k - 1)
              if path then
                  path[#path + 1] = get(x, y)
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
          return min_path
      end
      local min_path = nil
      for i = 1, n do
          for j = 1, n do
              local path = get_path(i, j, k)
              if path then
                  path[#path + 1] = get(i, j)
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local function get(x, y)
          return grid[x][y]
      end
      local function get_neighbors(x, y)
          local neighbors = {}
          if x > 1 then
              neighbors[#neighbors + 1] = {x - 1, y}
          end
          if x < n then
              neighbors[#neighbors + 1] = {x + 1, y}
          end
          if y > 1 then
              neighbors[#neighbors + 1] = {x, y - 1}
          end
          if y < n then
              neighbors[#neighbors + 1] = {x, y + 1}
          end
          return neighbors
      end
      local function get_path(x, y, k)
          if k == 0 then
              return {}
          end
          local min_path = nil
          for _, neighbor in ipairs(get_neighbors(x, y)) do
              local path = get_path(neighbor[1], neighbor[2], k - 1)
              if path then
                  path[#path + 1] = get(x, y)
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
          return min_path
      end
      local min_path = nil
      for i = 1, n do
          for j = 1, n do
              local path = get_path(i, j, k)
              if path then
                  path[#path + 1] = get(i, j)
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local function get(x, y)
          if x < 1 or x > n or y < 1 or y > n then
              return nil
          end
          return grid[x][y]
      end
      local function get_neighbors(x, y)
          local neighbors = {}
          local n = get(x - 1, y)
          if n then
              neighbors[#neighbors + 1] = n
          end
          n = get(x + 1, y)
          if n then
              neighbors[#neighbors + 1] = n
          end
          n = get(x, y - 1)
          if n then
              neighbors[#neighbors + 1] = n
          end
          n = get(x, y + 1)
          if n then
              neighbors[#neighbors + 1] = n
          end
          return neighbors
      end
      local function get_min_neighbor(x, y)
          local neighbors = get_neighbors(x, y)
          local min_neighbor = neighbors[1]
          for i = 2, #neighbors do
              if neighbors[i] < min_neighbor then
                  min_neighbor = neighbors[i]
              end
          end
          return min_neighbor
      end
      local function get_min_path(x, y, k)
          if k == 1 then
              return {grid[x][y]}
          end
          local min_neighbor = get_min_neighbor(x, y)
          local min_path
          for i = 1, n do
              for j = 1, n do
                  if grid[i][j] == min_neighbor then
                      local path = get_min_path(i, j, k - 1)
                      if not min_path or path < min_path then
                          min_path = path
                      end
                  end
              end
          end
          min_path[#min_path + 1] = grid[x][y]
          return min_path
      end
      local min_path
      for i = 1, n do
          for j =
- |2-
      local n = #grid
      local function get_value(i, j)
          return grid[i][j]
      end
      local function get_neighbors(i, j)
          local neighbors = {}
          if i > 1 then
              neighbors[#neighbors + 1] = {i - 1, j}
          end
          if i < n then
              neighbors[#neighbors + 1] = {i + 1, j}
          end
          if j > 1 then
              neighbors[#neighbors + 1] = {i, j - 1}
          end
          if j < n then
              neighbors[#neighbors + 1] = {i, j + 1}
          end
          return neighbors
      end
      local function get_path(i, j, k)
          if k == 0 then
              return {}
          end
          local min_path = nil
          for _, neighbor in ipairs(get_neighbors(i, j)) do
              local path = get_path(neighbor[1], neighbor[2], k - 1)
              path[#path + 1] = get_value(i, j)
              if min_path == nil or path < min_path then
                  min_path = path
              end
          end
          return min_path
      end
      local min_path = nil
      for i = 1, n do
          for j = 1, n do
              local path = get_path(i, j, k)
              path[#path + 1] = get_value(i, j)
              if min_path == nil or path < min_path then
                  min_path = path
              end
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local function get(x, y)
          return grid[x][y]
      end
      local function get_neighbors(x, y)
          local neighbors = {}
          if x > 1 then
              neighbors[#neighbors + 1] = {x - 1, y}
          end
          if x < n then
              neighbors[#neighbors + 1] = {x + 1, y}
          end
          if y > 1 then
              neighbors[#neighbors + 1] = {x, y - 1}
          end
          if y < n then
              neighbors[#neighbors + 1] = {x, y + 1}
          end
          return neighbors
      end
      local function get_path(x, y, k)
          if k == 0 then
              return {}
          end
          local min_path = nil
          for _, neighbor in ipairs(get_neighbors(x, y)) do
              local path = get_path(neighbor[1], neighbor[2], k - 1)
              if path then
                  path[#path + 1] = get(x, y)
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
          return min_path
      end
      local min_path = nil
      for i = 1, n do
          for j = 1, n do
              local path = get_path(i, j, k)
              if path then
                  path[#path + 1] = get(i, j)
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local function get(x, y)
          return grid[x][y]
      end
      local function get_neighbors(x, y)
          local neighbors = {}
          if x > 1 then
              neighbors[#neighbors + 1] = {x - 1, y}
          end
          if x < n then
              neighbors[#neighbors + 1] = {x + 1, y}
          end
          if y > 1 then
              neighbors[#neighbors + 1] = {x, y - 1}
          end
          if y < n then
              neighbors[#neighbors + 1] = {x, y + 1}
          end
          return neighbors
      end
      local function compare(a, b)
          for i = 1, k do
              if a[i] < b[i] then
                  return true
              elseif a[i] > b[i] then
                  return false
              end
          end
          return false
      end
      local function get_path(x, y, k)
          local path = {get(x, y)}
          local neighbors = get_neighbors(x, y)
          for i = 1, #neighbors do
              local nx, ny = neighbors[i][1], neighbors[i][2]
              local npath = get_path(nx, ny, k - 1)
              if compare(path, npath) then
                  path = npath
              end
          end
          return path
      end
      local min_path = get_path(1, 1, k)
      for i = 1, n do
          for j = 1, n do
              local path = get_path(i, j, k)
              if compare(path, min_path) then
                  min_path = path
              end
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local function get(x, y)
          return grid[x][y]
      end
      local function isValid(x, y)
          return x >= 1 and x <= n and y >= 1 and y <= n
      end
      local function getNeighbors(x, y)
          local neighbors = {}
          if isValid(x - 1, y) then
              neighbors[#neighbors + 1] = {x - 1, y}
          end
          if isValid(x + 1, y) then
              neighbors[#neighbors + 1] = {x + 1, y}
          end
          if isValid(x, y - 1) then
              neighbors[#neighbors + 1] = {x, y - 1}
          end
          if isValid(x, y + 1) then
              neighbors[#neighbors + 1] = {x, y + 1}
          end
          return neighbors
      end
      local function getPaths(x, y, k)
          if k == 0 then
              return {{}}
          end
          local paths = {}
          for _, neighbor in ipairs(getNeighbors(x, y)) do
              local x1, y1 = neighbor[1], neighbor[2]
              for _, path in ipairs(getPaths(x1, y1, k - 1)) do
                  path[#path + 1] = get(x, y)
                  paths[#paths + 1] = path
              end
          end
          return paths
      end
      local function getMinPath(paths)
          local minPath = paths[1]
          for i = 2, #paths do
              local path = paths[i]
              if path < minPath then
                  minPath = path
              end
          end
          return minPath
      end
      local paths = {}
      for i = 1, n do
          for j = 1, n do
              local path = getMinPath(getPaths(i, j, k))
              paths[#paths + 1] = path
          end
      end
      return getMinPath(paths)
  end
- |2-
      local n = #grid
      local function get(x, y)
          return grid[x][y]
      end
      local function set(x, y, v)
          grid[x][y] = v
      end
      local function isValid(x, y)
          return x >= 1 and x <= n and y >= 1 and y <= n
      end
      local function getNeighbors(x, y)
          local neighbors = {}
          if isValid(x - 1, y) then
              neighbors[#neighbors + 1] = {x - 1, y}
          end
          if isValid(x + 1, y) then
              neighbors[#neighbors + 1] = {x + 1, y}
          end
          if isValid(x, y - 1) then
              neighbors[#neighbors + 1] = {x, y - 1}
          end
          if isValid(x, y + 1) then
              neighbors[#neighbors + 1] = {x, y + 1}
          end
          return neighbors
      end
      local function compare(a, b)
          return a[1] < b[1] or (a[1] == b[1] and a[2] < b[2])
      end
      local function getMin(a, b)
          return compare(a, b) and a or b
      end
      local function getMinPath(x, y, k)
          if k == 0 then
              return {}
          end
          local minPath = nil
          for _, neighbor in ipairs(getNeighbors(x, y)) do
              local path = getMinPath(neighbor[1], neighbor[2], k - 1)
              if path then
                  path[#path + 1] = get(x, y)
                  minPath = getMin(minPath or path, path)
              end
          end
          return minPath
      end
      local minPath = nil
      for i = 1, n do
          for j = 1, n do
              local path = getMinPath(i, j, k)
              if path then
                  path[#path + 1] = get(i, j)
- |2-
      local n = #grid
      local function get(x, y)
          return grid[x][y]
      end
      local function get_neighbors(x, y)
          local neighbors = {}
          if x > 1 then
              neighbors[#neighbors + 1] = {x - 1, y}
          end
          if x < n then
              neighbors[#neighbors + 1] = {x + 1, y}
          end
          if y > 1 then
              neighbors[#neighbors + 1] = {x, y - 1}
          end
          if y < n then
              neighbors[#neighbors + 1] = {x, y + 1}
          end
          return neighbors
      end
      local function get_path(x, y, k)
          if k == 0 then
              return {}
          end
          local neighbors = get_neighbors(x, y)
          local min_path = nil
          for _, neighbor in ipairs(neighbors) do
              local path = get_path(neighbor[1], neighbor[2], k - 1)
              if path then
                  path[#path + 1] = get(x, y)
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
          return min_path
      end
      local min_path = nil
      for i = 1, n do
          for j = 1, n do
              local path = get_path(i, j, k)
              if path then
                  path[#path + 1] = get(i, j)
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local function get(i, j)
          return grid[i][j]
      end
      local function get_neighbors(i, j)
          local res = {}
          if i > 1 then
              table.insert(res, {i - 1, j})
          end
          if i < n then
              table.insert(res, {i + 1, j})
          end
          if j > 1 then
              table.insert(res, {i, j - 1})
          end
          if j < n then
              table.insert(res, {i, j + 1})
          end
          return res
      end
      local function get_neighbors_values(i, j)
          local res = {}
          for _, n in ipairs(get_neighbors(i, j)) do
              table.insert(res, get(n[1], n[2]))
          end
          return res
      end
      local function get_min_neighbor(i, j)
          local min_val = math.huge
          local min_i, min_j
          for _, n in ipairs(get_neighbors(i, j)) do
              local val = get(n[1], n[2])
              if val < min_val then
                  min_val = val
                  min_i, min_j = n[1], n[2]
              end
          end
          return min_i, min_j
      end
      local function get_min_path(i, j, k)
          if k == 1 then
              return {get(i, j)}
          end
          local min_i, min_j = get_min_neighbor(i, j)
          local min_path = get_min_path(min_i, min_j, k - 1)
          table.insert(min_path, 1, get(i, j))
          return min_path
      end
      local min_val = math.huge
      local min_i, min_j
      for i = 1, n do
          for j = 1, n do
              local val = get(i, j
- |2-
      local n = #grid
      local function get(i, j)
          return grid[i][j]
      end
      local function get_neighbors(i, j)
          local neighbors = {}
          if i > 1 then
              neighbors[#neighbors + 1] = {i - 1, j}
          end
          if i < n then
              neighbors[#neighbors + 1] = {i + 1, j}
          end
          if j > 1 then
              neighbors[#neighbors + 1] = {i, j - 1}
          end
          if j < n then
              neighbors[#neighbors + 1] = {i, j + 1}
          end
          return neighbors
      end
      local function compare(a, b)
          for i = 1, k do
              if a[i] < b[i] then
                  return true
              elseif a[i] > b[i] then
                  return false
              end
          end
          return false
      end
      local function dfs(i, j, path, visited)
          if #path == k then
              return path
          end
          visited[i][j] = true
          local min_path = nil
          for _, neighbor in ipairs(get_neighbors(i, j)) do
              local ni, nj = neighbor[1], neighbor[2]
              if not visited[ni][nj] then
                  local new_path = dfs(ni, nj, {unpack(path), get(ni, nj)}, visited)
                  if min_path == nil or compare(new_path, min_path) then
                      min_path = new_path
                  end
              end
          end
          visited[i][j] = false
          return min_path
      end
      local visited = {}
      for i = 1, n do
          visited[i] = {}
      end
      local min_path = nil
      for i = 1, n do
          for j = 1, n do
              local new_path = dfs(i, j, {get(i, j)}, visited)
              if min_path == nil or compare(new
- |2-
      local n = #grid
      local function get_neighbors(i, j)
          local neighbors = {}
          if i > 1 then
              neighbors[#neighbors + 1] = {i - 1, j}
          end
          if i < n then
              neighbors[#neighbors + 1] = {i + 1, j}
          end
          if j > 1 then
              neighbors[#neighbors + 1] = {i, j - 1}
          end
          if j < n then
              neighbors[#neighbors + 1] = {i, j + 1}
          end
          return neighbors
      end
      local function get_min_path(i, j, k)
          if k == 0 then
              return {}
          end
          local min_path = nil
          for _, neighbor in ipairs(get_neighbors(i, j)) do
              local path = get_min_path(neighbor[1], neighbor[2], k - 1)
              if path then
                  path[#path + 1] = grid[i][j]
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
          return min_path
      end
      local min_path = nil
      for i = 1, n do
          for j = 1, n do
              local path = get_min_path(i, j, k)
              if path then
                  path[#path + 1] = grid[i][j]
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local function get_neighbors(i, j)
          local neighbors = {}
          if i > 1 then
              neighbors[#neighbors + 1] = {i - 1, j}
          end
          if i < n then
              neighbors[#neighbors + 1] = {i + 1, j}
          end
          if j > 1 then
              neighbors[#neighbors + 1] = {i, j - 1}
          end
          if j < n then
              neighbors[#neighbors + 1] = {i, j + 1}
          end
          return neighbors
      end
      local function get_path(i, j, k)
          local path = {{i, j}}
          local value = grid[i][j]
          local visited = {}
          visited[i] = {}
          visited[i][j] = true
          while k > 1 do
              local neighbors = get_neighbors(i, j)
              local min_value = math.huge
              local min_i, min_j
              for _, neighbor in ipairs(neighbors) do
                  local i, j = neighbor[1], neighbor[2]
                  if not visited[i] or not visited[i][j] then
                      local value = grid[i][j]
                      if value < min_value then
                          min_value = value
                          min_i, min_j = i, j
                      end
                  end
              end
              if min_i then
                  i, j = min_i, min_j
                  path[#path + 1] = {i, j}
                  if not visited[i] then
                      visited[i] = {}
                  end
                  visited[i][j] = true
                  k = k - 1
              else
                  break
              end
          end
          return path
      end
      local min_path
      local min_values
      for i = 1, n do
          for j = 1, n do
              local path = get_path(i, j, k)
              local values = {}
              for _, cell in ipairs(path) do
                  values[#values + 1] =
- |2-
      local n = #grid
      local visited = {}
      local function dfs(i, j, k, path)
          if k == 0 then
              return path
          end
          if i < 1 or i > n or j < 1 or j > n or visited[i][j] then
              return nil
          end
          visited[i][j] = true
          local res = nil
          for _, d in ipairs({{0, 1}, {0, -1}, {1, 0}, {-1, 0}}) do
              local path_ = dfs(i + d[1], j + d[2], k - 1, {grid[i][j]})
              if path_ then
                  path_ = table.concat(path_, "")
                  if not res or path_ < res then
                      res = path_
                  end
              end
          end
          visited[i][j] = false
          return res and string.toTable(res)
      end
      for i = 1, n do
          visited[i] = {}
      end
      local res = nil
      for i = 1, n do
          for j = 1, n do
              local path = dfs(i, j, k, {})
              if path then
                  path = table.concat(path, "")
                  if not res or path < res then
                      res = path
                  end
              end
          end
      end
      return res and string.toTable(res)
  end
- |2-
      -- Write your code here
      return {}
  end
- |2-
      local n = #grid
      local function get_neighbors(i, j)
          local neighbors = {}
          if i > 1 then
              neighbors[#neighbors + 1] = {i - 1, j}
          end
          if i < n then
              neighbors[#neighbors + 1] = {i + 1, j}
          end
          if j > 1 then
              neighbors[#neighbors + 1] = {i, j - 1}
          end
          if j < n then
              neighbors[#neighbors + 1] = {i, j + 1}
          end
          return neighbors
      end
      local function get_path(i, j, k)
          local path = {}
          local function dfs(i, j, k)
              if k == 0 then
                  return true
              end
              for _, neighbor in ipairs(get_neighbors(i, j)) do
                  local i1, j1 = neighbor[1], neighbor[2]
                  if not path[i1] or not path[i1][j1] then
                      path[i1] = path[i1] or {}
                      path[i1][j1] = true
                      if dfs(i1, j1, k - 1) then
                          return true
                      end
                      path[i1][j1] = nil
                  end
              end
              return false
          end
          dfs(i, j, k)
          local result = {}
          for i = 1, n do
              for j = 1, n do
                  if path[i] and path[i][j] then
                      result[#result + 1] = grid[i][j]
                  end
              end
          end
          return result
      end
      local min_path = nil
      for i = 1, n do
          for j = 1, n do
              local path = get_path(i, j, k)
              if not min_path or path < min_path then
                  min_path = path
              end
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local function get(i, j)
          return grid[i][j]
      end
      local function set(i, j, v)
          grid[i][j] = v
      end
      local function get_neighbors(i, j)
          local neighbors = {}
          if i > 1 then
              neighbors[#neighbors + 1] = {i - 1, j}
          end
          if i < n then
              neighbors[#neighbors + 1] = {i + 1, j}
          end
          if j > 1 then
              neighbors[#neighbors + 1] = {i, j - 1}
          end
          if j < n then
              neighbors[#neighbors + 1] = {i, j + 1}
          end
          return neighbors
      end
      local function get_min_path(i, j, k)
          if k == 0 then
              return {}
          end
          local min_path = nil
          for _, neighbor in ipairs(get_neighbors(i, j)) do
              local ni, nj = neighbor[1], neighbor[2]
              local path = get_min_path(ni, nj, k - 1)
              if path then
                  path[#path + 1] = get(ni, nj)
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
          return min_path
      end
      local min_path = nil
      for i = 1, n do
          for j = 1, n do
              local path = get_min_path(i, j, k)
              if path then
                  path[#path + 1] = get(i, j)
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
      end
      return min_path
  end
- |2-
      local N = #grid
      local function get(x, y)
          return grid[x][y]
      end
      local function get_neighbors(x, y)
          local neighbors = {}
          if x > 1 then
              neighbors[#neighbors + 1] = {x - 1, y}
          end
          if x < N then
              neighbors[#neighbors + 1] = {x + 1, y}
          end
          if y > 1 then
              neighbors[#neighbors + 1] = {x, y - 1}
          end
          if y < N then
              neighbors[#neighbors + 1] = {x, y + 1}
          end
          return neighbors
      end
      local function get_path_value(path)
          local value = {}
          for _, cell in ipairs(path) do
              value[#value + 1] = get(cell[1], cell[2])
          end
          return value
      end
      local function get_path_length(path)
          return #path
      end
      local function is_path_valid(path)
          return get_path_length(path) == k
      end
      local function is_path_less(path1, path2)
          local value1 = get_path_value(path1)
          local value2 = get_path_value(path2)
          for i = 1, k do
              if value1[i] < value2[i] then
                  return true
              elseif value1[i] > value2[i] then
                  return false
              end
          end
          return false
      end
      local function is_path_greater(path1, path2)
          return not is_path_less(path1, path2)
      end
      local function is_path_equal(path1, path2)
          return not is_path_less(path1, path2) and not is_path_less(path2, path1)
      end
      local function get_path_last_cell(path)
          return path[#path]
      end
      local function get_path_neighbors(path)
- |2-
      local n = #grid
      local function get(x, y)
          return grid[x][y]
      end
      local function cmp(a, b)
          return a[1] < b[1]
      end
      local function get_neighbors(x, y)
          local neighbors = {}
          if x > 1 then
              neighbors[#neighbors + 1] = {get(x - 1, y), x - 1, y}
          end
          if x < n then
              neighbors[#neighbors + 1] = {get(x + 1, y), x + 1, y}
          end
          if y > 1 then
              neighbors[#neighbors + 1] = {get(x, y - 1), x, y - 1}
          end
          if y < n then
              neighbors[#neighbors + 1] = {get(x, y + 1), x, y + 1}
          end
          table.sort(neighbors, cmp)
          return neighbors
      end
      local function get_min_path(x, y, k)
          if k == 1 then
              return {get(x, y)}
          end
          local min_path = nil
          for _, neighbor in ipairs(get_neighbors(x, y)) do
              local path = get_min_path(neighbor[2], neighbor[3], k - 1)
              if not min_path or path < min_path then
                  min_path = path
              end
          end
          min_path[#min_path + 1] = get(x, y)
          return min_path
      end
      return get_min_path(1, 1, k)
  end
- |2-
      local n = #grid
      local function get(x, y)
          if x < 1 or x > n or y < 1 or y > n then
              return math.huge
          end
          return grid[x][y]
      end
      local function get_min(x, y)
          return math.min(get(x - 1, y), get(x + 1, y), get(x, y - 1), get(x, y + 1))
      end
      local function get_min_path(x, y, k)
          if k == 0 then
              return {}
          end
          local min = get_min(x, y)
          if min == math.huge then
              return nil
          end
          local path
          if get(x - 1, y) == min then
              path = get_min_path(x - 1, y, k - 1)
          elseif get(x + 1, y) == min then
              path = get_min_path(x + 1, y, k - 1)
          elseif get(x, y - 1) == min then
              path = get_min_path(x, y - 1, k - 1)
          else
              path = get_min_path(x, y + 1, k - 1)
          end
          if path then
              table.insert(path, 1, min)
              return path
          end
      end
      local min_path
      for i = 1, n do
          for j = 1, n do
              local path = get_min_path(i, j, k)
              if path then
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local function get(x, y)
          return grid[x][y]
      end
      local function get_neighbors(x, y)
          local neighbors = {}
          if x > 1 then
              neighbors[#neighbors + 1] = {x - 1, y}
          end
          if x < n then
              neighbors[#neighbors + 1] = {x + 1, y}
          end
          if y > 1 then
              neighbors[#neighbors + 1] = {x, y - 1}
          end
          if y < n then
              neighbors[#neighbors + 1] = {x, y + 1}
          end
          return neighbors
      end
      local function compare(a, b)
          for i = 1, k do
              if a[i] < b[i] then
                  return true
              elseif a[i] > b[i] then
                  return false
              end
          end
          return false
      end
      local function dfs(x, y, path)
          if #path == k then
              return path
          end
          local neighbors = get_neighbors(x, y)
          local min_path = nil
          for _, neighbor in ipairs(neighbors) do
              local new_path = dfs(neighbor[1], neighbor[2], {unpack(path)})
              if min_path == nil or compare(new_path, min_path) then
                  min_path = new_path
              end
          end
          min_path[#min_path + 1] = get(x, y)
          return min_path
      end
      local min_path = nil
      for i = 1, n do
          for j = 1, n do
              local new_path = dfs(i, j, {})
              if min_path == nil or compare(new_path, min_path) then
                  min_path = new_path
              end
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local function get(x, y)
          return grid[x][y]
      end
      local function isValid(x, y)
          return x >= 1 and x <= n and y >= 1 and y <= n
      end
      local function getNeighbors(x, y)
          local neighbors = {}
          for i = -1, 1 do
              for j = -1, 1 do
                  if i ~= 0 or j ~= 0 then
                      local nx, ny = x + i, y + j
                      if isValid(nx, ny) then
                          table.insert(neighbors, {nx, ny})
                      end
                  end
              end
          end
          return neighbors
      end
      local function compare(a, b)
          for i = 1, #a do
              if a[i] < b[i] then
                  return true
              elseif a[i] > b[i] then
                  return false
              end
          end
          return false
      end
      local function getPath(x, y, k)
          local path = {{x, y}}
          local value = get(x, y)
          local min = {value}
          while k > 1 do
              local neighbors = getNeighbors(x, y)
              local minNeighbor = nil
              for _, neighbor in ipairs(neighbors) do
                  local nx, ny = neighbor[1], neighbor[2]
                  local nValue = get(nx, ny)
                  if not minNeighbor or compare({nValue}, minNeighbor) then
                      minNeighbor = {nValue}
                  end
              end
              table.insert(min, minNeighbor[1])
              x, y = neighbors[1][1], neighbors[1][2]
              k = k - 1
          end
          return min
      end
      local min = nil
      for i = 1, n do
          for j = 1, n do
              local path = getPath(i, j, k)
              if not min or compare(path, min) then
                  min = path
              end
          end
      end
      return
- |2-
      local n = #grid
      local function get(x, y)
          return grid[x][y]
      end
      local function get_path(x, y, k)
          if k == 0 then
              return {}
          end
          local paths = {}
          if x > 1 then
              local path = get_path(x - 1, y, k - 1)
              table.insert(path, get(x, y))
              table.insert(paths, path)
          end
          if x < n then
              local path = get_path(x + 1, y, k - 1)
              table.insert(path, get(x, y))
              table.insert(paths, path)
          end
          if y > 1 then
              local path = get_path(x, y - 1, k - 1)
              table.insert(path, get(x, y))
              table.insert(paths, path)
          end
          if y < n then
              local path = get_path(x, y + 1, k - 1)
              table.insert(path, get(x, y))
              table.insert(paths, path)
          end
          local min_path = paths[1]
          for i = 2, #paths do
              if paths[i] < min_path then
                  min_path = paths[i]
              end
          end
          return min_path
      end
      local min_path = get_path(1, 1, k)
      for i = 1, n do
          for j = 1, n do
              local path = get_path(i, j, k)
              if path < min_path then
                  min_path = path
              end
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local function get_neighbors(i, j)
          local neighbors = {}
          if i > 1 then
              neighbors[#neighbors + 1] = {i - 1, j}
          end
          if i < n then
              neighbors[#neighbors + 1] = {i + 1, j}
          end
          if j > 1 then
              neighbors[#neighbors + 1] = {i, j - 1}
          end
          if j < n then
              neighbors[#neighbors + 1] = {i, j + 1}
          end
          return neighbors
      end
      local function get_path(i, j, k)
          local path = {}
          local function dfs(i, j, k)
              if k == 0 then
                  return true
              end
              local neighbors = get_neighbors(i, j)
              for _, neighbor in ipairs(neighbors) do
                  local ni, nj = neighbor[1], neighbor[2]
                  if grid[ni][nj] < grid[i][j] then
                      path[#path + 1] = grid[ni][nj]
                      if dfs(ni, nj, k - 1) then
                          return true
                      end
                      path[#path] = nil
                  end
              end
              return false
          end
          path[#path + 1] = grid[i][j]
          dfs(i, j, k - 1)
          return path
      end
      local min_path = {}
      for i = 1, n do
          for j = 1, n do
              local path = get_path(i, j, k)
              if #min_path == 0 or path < min_path then
                  min_path = path
              end
          end
      end
      return min_path
  end
- |2-
      local N = #grid
      local function get(i, j)
          return grid[i][j]
      end
      local function set(i, j, v)
          grid[i][j] = v
      end
      local function get_neighbors(i, j)
          local neighbors = {}
          if i > 1 then
              neighbors[#neighbors + 1] = {i - 1, j}
          end
          if i < N then
              neighbors[#neighbors + 1] = {i + 1, j}
          end
          if j > 1 then
              neighbors[#neighbors + 1] = {i, j - 1}
          end
          if j < N then
              neighbors[#neighbors + 1] = {i, j + 1}
          end
          return neighbors
      end
      local function get_paths(i, j, k)
          if k == 0 then
              return {{get(i, j)}}
          end
          local paths = {}
          for _, neighbor in ipairs(get_neighbors(i, j)) do
              local ni, nj = neighbor[1], neighbor[2]
              for _, path in ipairs(get_paths(ni, nj, k - 1)) do
                  paths[#paths + 1] = {get(i, j)}
                  for _, v in ipairs(path) do
                      paths[#paths][#paths[#paths] + 1] = v
                  end
              end
          end
          return paths
      end
      local min_path
      for i = 1, N do
          for j = 1, N do
              for _, path in ipairs(get_paths(i, j, k)) do
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local dp = {}
      for i = 1, n do
          dp[i] = {}
          for j = 1, n do
              dp[i][j] = {}
          end
      end
      for i = 1, n do
          for j = 1, n do
              dp[i][j][1] = {grid[i][j]}
          end
      end
      for l = 2, k do
          for i = 1, n do
              for j = 1, n do
                  local min = nil
                  if i > 1 then
                      local t = {}
                      for _, v in ipairs(dp[i - 1][j][l - 1]) do
                          table.insert(t, v)
                      end
                      table.insert(t, grid[i][j])
                      if not min or t < min then
                          min = t
                      end
                  end
                  if i < n then
                      local t = {}
                      for _, v in ipairs(dp[i + 1][j][l - 1]) do
                          table.insert(t, v)
                      end
                      table.insert(t, grid[i][j])
                      if not min or t < min then
                          min = t
                      end
                  end
                  if j > 1 then
                      local t = {}
                      for _, v in ipairs(dp[i][j - 1][l - 1]) do
                          table.insert(t, v)
                      end
                      table.insert(t, grid[i][j])
                      if not min or t < min then
                          min = t
                      end
                  end
                  if j < n then
                      local t = {}
                      for _, v in ipairs(dp[i][j + 1][l - 1]) do
                          table.insert(t, v)
                      end
                      table.insert(t, grid[i][j])
                      if not min or t < min then
                          min = t
                      end
                  end
                  dp[i][j][l] = min
              end
          end
      end
      local min = nil
      for i = 1, n do
          for j =
- |2-
      local n = #grid
      local function get(x, y)
          return grid[x][y]
      end
      local function get_neighbors(x, y)
          local neighbors = {}
          if x > 1 then
              neighbors[#neighbors + 1] = {x - 1, y}
          end
          if x < n then
              neighbors[#neighbors + 1] = {x + 1, y}
          end
          if y > 1 then
              neighbors[#neighbors + 1] = {x, y - 1}
          end
          if y < n then
              neighbors[#neighbors + 1] = {x, y + 1}
          end
          return neighbors
      end
      local function compare(a, b)
          for i = 1, k do
              if a[i] < b[i] then
                  return true
              elseif a[i] > b[i] then
                  return false
              end
          end
          return false
      end
      local function dfs(x, y, path, visited)
          if #path == k then
              if not min_path or compare(path, min_path) then
                  min_path = path
              end
              return
          end
          for _, neighbor in ipairs(get_neighbors(x, y)) do
              local x, y = neighbor[1], neighbor[2]
              if not visited[x][y] then
                  visited[x][y] = true
                  path[#path + 1] = get(x, y)
                  dfs(x, y, path, visited)
                  path[#path] = nil
                  visited[x][y] = false
              end
          end
      end
      local min_path
      for i = 1, n do
          for j = 1, n do
              local visited = {}
              for i = 1, n do
                  visited[i] = {}
              end
              visited[i][j] = true
              dfs(i, j, {get(i, j)}, visited)
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local function get(x, y)
          return grid[x][y]
      end
      local function get_neighbors(x, y)
          local neighbors = {}
          if x > 1 then
              neighbors[#neighbors + 1] = {x - 1, y}
          end
          if x < n then
              neighbors[#neighbors + 1] = {x + 1, y}
          end
          if y > 1 then
              neighbors[#neighbors + 1] = {x, y - 1}
          end
          if y < n then
              neighbors[#neighbors + 1] = {x, y + 1}
          end
          return neighbors
      end
      local function compare(a, b)
          for i = 1, k do
              if a[i] < b[i] then
                  return true
              elseif a[i] > b[i] then
                  return false
              end
          end
          return false
      end
      local function get_min_path(x, y, k)
          if k == 1 then
              return {get(x, y)}
          end
          local min_path = nil
          for _, neighbor in ipairs(get_neighbors(x, y)) do
              local path = get_min_path(neighbor[1], neighbor[2], k - 1)
              if min_path == nil or compare(path, min_path) then
                  min_path = path
              end
          end
          min_path[#min_path + 1] = get(x, y)
          return min_path
      end
      return get_min_path(1, 1, k)
  end
- |2
      local n = #grid
      local function get(x, y)
          return grid[x][y]
      end
      local function get_neighbors(x, y)
          local neighbors = {}
          if x > 1 then
              neighbors[#neighbors + 1] = {x - 1, y}
          end
          if x < n then
              neighbors[#neighbors + 1] = {x + 1, y}
          end
          if y > 1 then
              neighbors[#neighbors + 1] = {x, y - 1}
          end
          if y < n then
              neighbors[#neighbors + 1] = {x, y + 1}
          end
          return neighbors
      end
      local function get_path(x, y, k)
          local path = {}
          local function dfs(x, y, k)
              if k == 0 then
                  return true
              end
              for _, neighbor in ipairs(get_neighbors(x, y)) do
                  local nx, ny = neighbor[1], neighbor[2]
                  if not path[nx] or not path[nx][ny] then
                      path[nx] = path[nx] or {}
                      path[nx][ny] = true
                      if dfs(nx, ny, k - 1) then
                          return true
                      end
                      path[nx][ny] = nil
                  end
              end
              return false
          end
          dfs(x, y, k)
          return path
      end
      local function get_path_values(path)
          local values = {}
          for x, row in ipairs(path) do
              for y, _ in pairs(row) do
                  values[#values + 1] = get(x, y)
              end
          end
          return values
      end
      local function compare_paths(path1, path2)
          local values1 = get_path_values(path1)
          local values2 = get_path_values(path2)
          for i = 1, #values1 do
              if values1[i] < values2[i] then
- |2-
      local N = #grid
      local function get(i, j)
          return grid[i][j]
      end
      local function get_path(i, j, k)
          if k == 0 then
              return {}
          end
          local min_path = nil
          local min_val = nil
          local function update(path, val)
              if min_path == nil or val < min_val then
                  min_path = path
                  min_val = val
              end
          end
          if i > 1 then
              local path = get_path(i - 1, j, k - 1)
              path[#path + 1] = get(i, j)
              update(path, get(i, j))
          end
          if i < N then
              local path = get_path(i + 1, j, k - 1)
              path[#path + 1] = get(i, j)
              update(path, get(i, j))
          end
          if j > 1 then
              local path = get_path(i, j - 1, k - 1)
              path[#path + 1] = get(i, j)
              update(path, get(i, j))
          end
          if j < N then
              local path = get_path(i, j + 1, k - 1)
              path[#path + 1] = get(i, j)
              update(path, get(i, j))
          end
          return min_path
      end
      local min_path = nil
      local min_val = nil
      for i = 1, N do
          for j = 1, N do
              local path = get_path(i, j, k)
              path[#path + 1] = get(i, j)
              if min_path == nil or get(i, j) < min_val then
                  min_path = path
                  min_val = get(i, j)
              end
          end
      end
      return min_path
  end
- |2
      local n = #grid
      local function isValid(x, y)
          return x >= 1 and x <= n and y >= 1 and y <= n
      end
      local function getValue(x, y)
          return grid[x][y]
      end
      local function getNeighbors(x, y)
          local neighbors = {}
          if isValid(x - 1, y) then
              neighbors[#neighbors + 1] = {x - 1, y}
          end
          if isValid(x + 1, y) then
              neighbors[#neighbors + 1] = {x + 1, y}
          end
          if isValid(x, y - 1) then
              neighbors[#neighbors + 1] = {x, y - 1}
          end
          if isValid(x, y + 1) then
              neighbors[#neighbors + 1] = {x, y + 1}
          end
          return neighbors
      end
      local function getPaths(x, y, k)
          if k == 0 then
              return {{}}
          end
          local paths = {}
          for _, neighbor in ipairs(getNeighbors(x, y)) do
              local nx, ny = neighbor[1], neighbor[2]
              for _, path in ipairs(getPaths(nx, ny, k - 1)) do
                  path[#path + 1] = {nx, ny}
                  paths[#paths + 1] = path
              end
          end
          return paths
      end
      local function getPathValues(path)
          local values = {}
          for _, cell in ipairs(path) do
              values[#values + 1] = getValue(cell[1], cell[2])
          end
          return values
      end
      local function comparePaths(path1, path2)
          local values1 = getPathValues(path1)
          local values2 = getPathValues(path2)
          for i = 1, #values1 do
              if values1[i] < values2[i] then
                  return true
              elseif values1[i] > values2[i] then
- |2
      local n = #grid
      local function get_neighbors(i, j)
          local neighbors = {}
          if i > 1 then
              neighbors[#neighbors + 1] = {i - 1, j}
          end
          if i < n then
              neighbors[#neighbors + 1] = {i + 1, j}
          end
          if j > 1 then
              neighbors[#neighbors + 1] = {i, j - 1}
          end
          if j < n then
              neighbors[#neighbors + 1] = {i, j + 1}
          end
          return neighbors
      end
      local function get_path(i, j, k)
          local path = {}
          local function dfs(i, j, k)
              if k == 0 then
                  return true
              end
              for _, neighbor in ipairs(get_neighbors(i, j)) do
                  local ni, nj = neighbor[1], neighbor[2]
                  if not path[ni] or not path[ni][nj] then
                      path[ni] = path[ni] or {}
                      path[ni][nj] = true
                      if dfs(ni, nj, k - 1) then
                          return true
                      end
                      path[ni][nj] = nil
                  end
              end
              return false
          end
          dfs(i, j, k)
          return path
      end
      local function get_path_value(path)
          local value = {}
          for i, row in ipairs(path) do
              for j, _ in pairs(row) do
                  value[#value + 1] = grid[i][j]
              end
          end
          return value
      end
      local function compare_path(path1, path2)
          local value1 = get_path_value(path1)
          local value2 = get_path_value(path2)
          for i = 1, k do
              if value1[i] < value2[i] then
                  return true
              elseif value1[i] > value2[i] then
                  return false
              end
          end
- |2-
      local n = #grid
      local visited = {}
      local function dfs(i, j, k, path)
          if k == 0 then
              return path
          end
          if i < 1 or i > n or j < 1 or j > n or visited[i] and visited[i][j] then
              return nil
          end
          visited[i] = visited[i] or {}
          visited[i][j] = true
          local min = nil
          local function update(path)
              if not min or path < min then
                  min = path
              end
          end
          update(dfs(i - 1, j, k - 1, {grid[i][j], unpack(path)}))
          update(dfs(i + 1, j, k - 1, {grid[i][j], unpack(path)}))
          update(dfs(i, j - 1, k - 1, {grid[i][j], unpack(path)}))
          update(dfs(i, j + 1, k - 1, {grid[i][j], unpack(path)}))
          visited[i][j] = false
          return min
      end
      local min = nil
      for i = 1, n do
          for j = 1, n do
              local path = dfs(i, j, k, {})
              if not min or path < min then
                  min = path
              end
          end
      end
      return min
  end
- |2-
      local n = #grid
      local function get(x, y)
          return grid[x][y]
      end
      local function set(x, y, v)
          grid[x][y] = v
      end
      local function get_neighbors(x, y)
          local neighbors = {}
          if x > 1 then
              neighbors[#neighbors + 1] = {x - 1, y}
          end
          if x < n then
              neighbors[#neighbors + 1] = {x + 1, y}
          end
          if y > 1 then
              neighbors[#neighbors + 1] = {x, y - 1}
          end
          if y < n then
              neighbors[#neighbors + 1] = {x, y + 1}
          end
          return neighbors
      end
      local function get_path(x, y)
          local path = {}
          local function dfs(x, y)
              if set(x, y, -1) == -1 then
                  return
              end
              path[#path + 1] = get(x, y)
              for _, neighbor in ipairs(get_neighbors(x, y)) do
                  dfs(unpack(neighbor))
              end
          end
          dfs(x, y)
          return path
      end
      local function compare(path1, path2)
          for i = 1, k do
              if path1[i] < path2[i] then
                  return true
              elseif path1[i] > path2[i] then
                  return false
              end
          end
          return false
      end
      local min_path
      for i = 1, n do
          for j = 1, n do
              local path = get_path(i, j)
              if #path == k then
                  if not min_path or compare(path, min_path) then
                      min_path = path
                  end
              end
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local visited = {}
      local function dfs(i, j, k, path)
          if k == 0 then
              return path
          end
          visited[i] = visited[i] or {}
          visited[i][j] = true
          local min_path
          if i > 1 and not visited[i - 1][j] then
              local new_path = dfs(i - 1, j, k - 1, {grid[i][j]})
              if not min_path or new_path < min_path then
                  min_path = new_path
              end
          end
          if i < n and not visited[i + 1][j] then
              local new_path = dfs(i + 1, j, k - 1, {grid[i][j]})
              if not min_path or new_path < min_path then
                  min_path = new_path
              end
          end
          if j > 1 and not visited[i][j - 1] then
              local new_path = dfs(i, j - 1, k - 1, {grid[i][j]})
              if not min_path or new_path < min_path then
                  min_path = new_path
              end
          end
          if j < n and not visited[i][j + 1] then
              local new_path = dfs(i, j + 1, k - 1, {grid[i][j]})
              if not min_path or new_path < min_path then
                  min_path = new_path
              end
          end
          visited[i][j] = false
          return min_path
      end
      local min_path
      for i = 1, n do
          visited[i] = {}
          for j = 1, n do
              local new_path = dfs(i, j, k, {})
              if not min_path or new_path < min_path then
                  min_path = new_path
              end
          end
      end
      return min_path
  end
- "    local n = #grid\n    local m = {}\n    for i = 1, n do\n        m[i] = {}\n
  \       for j = 1, n do\n            m[i][j] = {grid[i][j]}\n        end\n    end\n
  \   for i = 1, k - 1 do\n        local t = {}\n        for j = 1, n do\n            t[j]
  = {}\n            for l = 1, n do\n                t[j][l] = {}\n            end\n
  \       end\n        for j = 1, n do\n            for l = 1, n do\n                if
  j > 1 then\n                    if l > 1 then\n                        local a =
  m[j - 1][l - 1]\n                        local b = m[j][l]\n                        local
  c = {}\n                        for x = 1, #a do\n                            c[x]
  = a[x]\n                        end\n                        for x = 1, #b do\n
  \                           c[#c + 1] = b[x]\n                        end\n                        table.sort(c)\n
  \                       if #t[j][l] == 0 or c[1] < t[j][l][1] then\n                            t[j][l]
  = c\n                        end\n                    end\n                    local
  a = m[j - 1][l]\n                    local b = m[j][l]\n                    local
  c = {}\n                    for x = 1, #a do\n                        c[x] = a[x]\n
  \                   end\n                    for x = 1, #b do\n                        c[#c
  + 1] = b[x]\n                    end\n                    table.sort(c)\n                    if
  #t[j][l] == 0 or c[1] < t[j][l][1] then\n                        t[j][l] = c\n                    end\n
  \                   if l < n then\n                        local a = m[j - 1][l
  + 1]\n                        local b = m[j][l]\n                        local c
  = {}\n                        for x = 1, #a do\n                            c[x]
  = a[x]\n                        end\n                        for x = 1, #b do\n
  \                           c[#c + 1] = b[x]\n                        end\n                       "
- |2-
      local n = #grid
      local function get(i, j)
          if i < 1 or i > n or j < 1 or j > n then
              return nil
          end
          return grid[i][j]
      end
      local function get_path(i, j, k)
          if k == 0 then
              return {}, 0
          end
          local min_path, min_sum = nil, math.huge
          local function update(path, sum)
              if sum < min_sum then
                  min_path, min_sum = path, sum
              elseif sum == min_sum then
                  local lst_path, lst_min_path = {}, {}
                  for _, v in ipairs(path) do
                      lst_path[#lst_path + 1] = v
                  end
                  for _, v in ipairs(min_path) do
                      lst_min_path[#lst_min_path + 1] = v
                  end
                  table.sort(lst_path)
                  table.sort(lst_min_path)
                  if lst_path < lst_min_path then
                      min_path = path
                  end
              end
          end
          local path, sum = get_path(i - 1, j, k - 1)
          if path then
              path[#path + 1] = get(i, j)
              sum = sum + get(i, j)
              update(path, sum)
          end
          path, sum = get_path(i + 1, j, k - 1)
          if path then
              path[#path + 1] = get(i, j)
              sum = sum + get(i, j)
              update(path, sum)
          end
          path, sum = get_path(i, j - 1, k - 1)
          if path then
              path[#path + 1] = get(i, j)
              sum = sum + get(i, j)
              update(path, sum)
          end
          path, sum = get_path(i, j + 1, k - 1)
          if path then
              path[#path
- |2-
      local n = #grid
      local function get(x, y)
          return grid[x][y]
      end
      local function get_neighbors(x, y)
          local neighbors = {}
          if x > 1 then
              neighbors[#neighbors + 1] = {x - 1, y}
          end
          if x < n then
              neighbors[#neighbors + 1] = {x + 1, y}
          end
          if y > 1 then
              neighbors[#neighbors + 1] = {x, y - 1}
          end
          if y < n then
              neighbors[#neighbors + 1] = {x, y + 1}
          end
          return neighbors
      end
      local function get_path(x, y, k)
          local path = {}
          for i = 1, k do
              path[i] = get(x, y)
              local neighbors = get_neighbors(x, y)
              local min_neighbor = neighbors[1]
              for _, neighbor in ipairs(neighbors) do
                  if get(neighbor[1], neighbor[2]) < get(min_neighbor[1], min_neighbor[2]) then
                      min_neighbor = neighbor
                  end
              end
              x, y = min_neighbor[1], min_neighbor[2]
          end
          return path
      end
      local min_path = get_path(1, 1, k)
      for i = 1, n do
          for j = 1, n do
              local path = get_path(i, j, k)
              if path < min_path then
                  min_path = path
              end
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local function get(x, y)
          return grid[x][y]
      end
      local function cmp(a, b)
          for i = 1, k do
              if a[i] ~= b[i] then
                  return a[i] < b[i]
              end
          end
          return false
      end
      local function get_neighbors(x, y)
          local res = {}
          if x > 1 then
              res[#res + 1] = {x - 1, y}
          end
          if x < n then
              res[#res + 1] = {x + 1, y}
          end
          if y > 1 then
              res[#res + 1] = {x, y - 1}
          end
          if y < n then
              res[#res + 1] = {x, y + 1}
          end
          return res
      end
      local function get_path(x, y, k)
          if k == 0 then
              return {}
          end
          local res = {}
          for _, n in ipairs(get_neighbors(x, y)) do
              local p = get_path(n[1], n[2], k - 1)
              if #p > 0 then
                  p[#p + 1] = get(x, y)
                  if #res == 0 or cmp(p, res) then
                      res = p
                  end
              end
          end
          return res
      end
      local res = {}
      for i = 1, n do
          for j = 1, n do
              local p = get_path(i, j, k)
              if #p > 0 then
                  p[#p + 1] = get(i, j)
                  if #res == 0 or cmp(p, res) then
                      res = p
                  end
              end
          end
      end
      return res
  end
- |2-
      local n = #grid
      local function get(x, y)
          return grid[x][y]
      end
      local function set(x, y, v)
          grid[x][y] = v
      end
      local function get_neighbors(x, y)
          local neighbors = {}
          if x > 1 then
              neighbors[#neighbors + 1] = {x - 1, y}
          end
          if x < n then
              neighbors[#neighbors + 1] = {x + 1, y}
          end
          if y > 1 then
              neighbors[#neighbors + 1] = {x, y - 1}
          end
          if y < n then
              neighbors[#neighbors + 1] = {x, y + 1}
          end
          return neighbors
      end
      local function get_path(x, y)
          local path = {}
          local function get_path_rec(x, y)
              local v = get(x, y)
              if v == -1 then
                  return
              end
              path[#path + 1] = v
              for _, neighbor in ipairs(get_neighbors(x, y)) do
                  local nx, ny = neighbor[1], neighbor[2]
                  if get(nx, ny) == v - 1 then
                      get_path_rec(nx, ny)
                      break
                  end
              end
          end
          get_path_rec(x, y)
          return path
      end
      local function get_min_path(x, y)
          local min_path = {}
          local function get_min_path_rec(x, y, k)
              if k == 0 then
                  return
              end
              local v = get(x, y)
              min_path[#min_path + 1] = v
              local min_neighbor = nil
              for _, neighbor in ipairs(get_neighbors(x, y)) do
                  local nx, ny = neighbor[1], neighbor[2]
                  local nv = get(nx, ny)
                  if nv == v
- "    local n = #grid\n    local function get(i, j)\n        return grid[i][j]\n
  \   end\n    local function get_neighbors(i, j)\n        local neighbors = {}\n
  \       if i > 1 then\n            neighbors[#neighbors + 1] = {i - 1, j}\n        end\n
  \       if i < n then\n            neighbors[#neighbors + 1] = {i + 1, j}\n        end\n
  \       if j > 1 then\n            neighbors[#neighbors + 1] = {i, j - 1}\n        end\n
  \       if j < n then\n            neighbors[#neighbors + 1] = {i, j + 1}\n        end\n
  \       return neighbors\n    end\n    local function get_path(i, j, k)\n        local
  path = {{i, j}}\n        local visited = {}\n        visited[i] = {}\n        visited[i][j]
  = true\n        while #path < k do\n            local last = path[#path]\n            local
  neighbors = get_neighbors(last[1], last[2])\n            local min_neighbor = nil\n
  \           for _, neighbor in ipairs(neighbors) do\n                if not visited[neighbor[1]]
  or not visited[neighbor[1]][neighbor[2]] then\n                    if not min_neighbor
  or get(neighbor[1], neighbor[2]) < get(min_neighbor[1], min_neighbor[2]) then\n
  \                       min_neighbor = neighbor\n                    end\n                end\n
  \           end\n            if not min_neighbor then\n                return nil\n
  \           end\n            path[#path + 1] = min_neighbor\n            if not
  visited[min_neighbor[1]] then\n                visited[min_neighbor[1]] = {}\n            end\n
  \           visited[min_neighbor[1]][min_neighbor[2]] = true\n        end\n        return
  path\n    end\n    local min_path = nil\n    for i = 1, n do\n        for j = 1,
  n do\n            local path = get_path(i, j, k)\n           "
- |2-
      local n = #grid
      local function get(i, j)
          return grid[i][j]
      end
      local function get_neighbors(i, j)
          local neighbors = {}
          if i > 1 then
              neighbors[#neighbors + 1] = {i - 1, j}
          end
          if i < n then
              neighbors[#neighbors + 1] = {i + 1, j}
          end
          if j > 1 then
              neighbors[#neighbors + 1] = {i, j - 1}
          end
          if j < n then
              neighbors[#neighbors + 1] = {i, j + 1}
          end
          return neighbors
      end
      local function get_min_path(i, j, k)
          if k == 1 then
              return {get(i, j)}
          end
          local min_path = nil
          for _, neighbor in ipairs(get_neighbors(i, j)) do
              local path = get_min_path(neighbor[1], neighbor[2], k - 1)
              if min_path == nil or path < min_path then
                  min_path = path
              end
          end
          min_path[#min_path + 1] = get(i, j)
          return min_path
      end
      local min_path = nil
      for i = 1, n do
          for j = 1, n do
              local path = get_min_path(i, j, k)
              if min_path == nil or path < min_path then
                  min_path = path
              end
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local function get_neighbors(i, j)
          local neighbors = {}
          if i > 1 then
              neighbors[#neighbors + 1] = {i - 1, j}
          end
          if i < n then
              neighbors[#neighbors + 1] = {i + 1, j}
          end
          if j > 1 then
              neighbors[#neighbors + 1] = {i, j - 1}
          end
          if j < n then
              neighbors[#neighbors + 1] = {i, j + 1}
          end
          return neighbors
      end
      local function get_path(i, j, k)
          local path = {}
          local function get_path_rec(i, j, k)
              if k == 0 then
                  return
              end
              path[#path + 1] = grid[i][j]
              local neighbors = get_neighbors(i, j)
              for _, neighbor in ipairs(neighbors) do
                  local i1, j1 = neighbor[1], neighbor[2]
                  local path1 = get_path(i1, j1, k - 1)
                  if #path1 > 0 then
                      for _, value in ipairs(path1) do
                          path[#path + 1] = value
                      end
                      return
                  end
              end
              path[#path + 1] = nil
          end
          get_path_rec(i, j, k)
          return path
      end
      local min_path
      for i = 1, n do
          for j = 1, n do
              local path = get_path(i, j, k)
              if #path > 0 then
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local function get(i, j)
          return grid[i][j]
      end
      local function get_neighbors(i, j)
          local neighbors = {}
          if i > 1 then
              neighbors[#neighbors + 1] = {i - 1, j}
          end
          if i < n then
              neighbors[#neighbors + 1] = {i + 1, j}
          end
          if j > 1 then
              neighbors[#neighbors + 1] = {i, j - 1}
          end
          if j < n then
              neighbors[#neighbors + 1] = {i, j + 1}
          end
          return neighbors
      end
      local function get_path(i, j, k)
          local path = {}
          local function dfs(i, j, k)
              if k == 0 then
                  return true
              end
              for _, neighbor in ipairs(get_neighbors(i, j)) do
                  local ni, nj = neighbor[1], neighbor[2]
                  if not path[ni] or not path[ni][nj] then
                      path[ni] = path[ni] or {}
                      path[ni][nj] = true
                      if dfs(ni, nj, k - 1) then
                          return true
                      end
                      path[ni][nj] = nil
                  end
              end
              return false
          end
          if dfs(i, j, k) then
              return path
          end
      end
      local function get_path_value(path)
          local value = {}
          for i = 1, n do
              for j = 1, n do
                  if path[i] and path[i][j] then
                      value[#value + 1] = get(i, j)
                  end
              end
          end
          return value
      end
      local function compare(a, b)
          for i = 1, #a do
              if a[i] < b[i] then
                  return true
              elseif a[i] > b[i] then
                  return false
              end
          end
- |2-
      local n = #grid
      local function get(i, j)
          return grid[i][j]
      end
      local function get_neighbors(i, j)
          local neighbors = {}
          if i > 1 then
              neighbors[#neighbors + 1] = {i - 1, j}
          end
          if i < n then
              neighbors[#neighbors + 1] = {i + 1, j}
          end
          if j > 1 then
              neighbors[#neighbors + 1] = {i, j - 1}
          end
          if j < n then
              neighbors[#neighbors + 1] = {i, j + 1}
          end
          return neighbors
      end
      local function get_path(i, j, k)
          if k == 0 then
              return {}
          end
          local min_path = nil
          for _, neighbor in ipairs(get_neighbors(i, j)) do
              local path = get_path(neighbor[1], neighbor[2], k - 1)
              if path then
                  path[#path + 1] = get(i, j)
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
          return min_path
      end
      local min_path = nil
      for i = 1, n do
          for j = 1, n do
              local path = get_path(i, j, k)
              if path then
                  path[#path + 1] = get(i, j)
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local function get(x, y)
          return grid[x][y]
      end
      local function get_neighbors(x, y)
          local neighbors = {}
          if x > 1 then
              neighbors[#neighbors + 1] = {x - 1, y}
          end
          if x < n then
              neighbors[#neighbors + 1] = {x + 1, y}
          end
          if y > 1 then
              neighbors[#neighbors + 1] = {x, y - 1}
          end
          if y < n then
              neighbors[#neighbors + 1] = {x, y + 1}
          end
          return neighbors
      end
      local function compare(a, b)
          for i = 1, k do
              if a[i] < b[i] then
                  return true
              elseif a[i] > b[i] then
                  return false
              end
          end
          return false
      end
      local function get_min_path(x, y, k)
          local min_path = {get(x, y)}
          if k == 1 then
              return min_path
          end
          local neighbors = get_neighbors(x, y)
          for i = 1, #neighbors do
              local neighbor = neighbors[i]
              local path = get_min_path(neighbor[1], neighbor[2], k - 1)
              path[#path + 1] = get(x, y)
              if compare(path, min_path) then
                  min_path = path
              end
          end
          return min_path
      end
      local min_path = get_min_path(1, 1, k)
      for i = 1, n do
          for j = 1, n do
              local path = get_min_path(i, j, k)
              if compare(path, min_path) then
                  min_path = path
              end
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local function get_neighbors(i, j)
          local neighbors = {}
          if i > 1 then
              neighbors[#neighbors + 1] = {i - 1, j}
          end
          if i < n then
              neighbors[#neighbors + 1] = {i + 1, j}
          end
          if j > 1 then
              neighbors[#neighbors + 1] = {i, j - 1}
          end
          if j < n then
              neighbors[#neighbors + 1] = {i, j + 1}
          end
          return neighbors
      end
      local function get_path(i, j, k)
          local path = {{i, j}}
          local min_path
          local min_value
          for _, neighbor in ipairs(get_neighbors(i, j)) do
              local neighbor_path = get_path(neighbor[1], neighbor[2], k - 1)
              if neighbor_path then
                  local neighbor_value = grid[neighbor[1]][neighbor[2]]
                  if not min_value or neighbor_value < min_value then
                      min_value = neighbor_value
                      min_path = neighbor_path
                  end
              end
          end
          if min_path then
              for _, cell in ipairs(min_path) do
                  path[#path + 1] = cell
              end
          elseif k == 1 then
              return path
          end
          return path
      end
      local min_path
      local min_value
      for i = 1, n do
          for j = 1, n do
              local path = get_path(i, j, k)
              if path then
                  local value = grid[i][j]
                  if not min_value or value < min_value then
                      min_value = value
                      min_path = path
                  end
              end
          end
      end
      local result = {}
      for _, cell in ipairs(min_path) do
          result[#result + 1] = grid[cell[1]][cell[2]]
      end
      return result
- |2-
      local n = #grid
      local function get(i, j)
          return grid[i][j]
      end
      local function set(i, j, v)
          grid[i][j] = v
      end
      local function get_neighbors(i, j)
          local neighbors = {}
          if i > 1 then
              neighbors[#neighbors + 1] = {i - 1, j}
          end
          if i < n then
              neighbors[#neighbors + 1] = {i + 1, j}
          end
          if j > 1 then
              neighbors[#neighbors + 1] = {i, j - 1}
          end
          if j < n then
              neighbors[#neighbors + 1] = {i, j + 1}
          end
          return neighbors
      end
      local function get_neighbors_values(i, j)
          local neighbors = get_neighbors(i, j)
          local values = {}
          for _, neighbor in ipairs(neighbors) do
              values[#values + 1] = get(unpack(neighbor))
          end
          return values
      end
      local function compare(a, b)
          return a < b
      end
      local function compare_paths(path_a, path_b)
          for i = 1, k do
              local a = get(unpack(path_a[i]))
              local b = get(unpack(path_b[i]))
              if a ~= b then
                  return compare(a, b)
              end
          end
          return false
      end
      local function get_min_path(i, j)
          local min_path = {{i, j}}
          local min_path_values = {get(i, j)}
          local min_path_value = min_path_values[1]
          local neighbors = get_neighbors(i, j)
          for _, neighbor in ipairs(neighbors) do
              local path = get_min_path(unpack(neighbor))
              local path_values = {}
              for _, cell in ipairs(
- |2-
      local n = #grid
      local function get(x, y)
          return grid[x][y]
      end
      local function get_neighbors(x, y)
          local neighbors = {}
          if x > 1 then
              neighbors[#neighbors + 1] = {x - 1, y}
          end
          if x < n then
              neighbors[#neighbors + 1] = {x + 1, y}
          end
          if y > 1 then
              neighbors[#neighbors + 1] = {x, y - 1}
          end
          if y < n then
              neighbors[#neighbors + 1] = {x, y + 1}
          end
          return neighbors
      end
      local function compare(a, b)
          for i = 1, k do
              if a[i] < b[i] then
                  return true
              elseif a[i] > b[i] then
                  return false
              end
          end
          return false
      end
      local function get_min_path(x, y, k)
          if k == 1 then
              return {get(x, y)}
          end
          local min_path = nil
          for _, neighbor in ipairs(get_neighbors(x, y)) do
              local path = get_min_path(neighbor[1], neighbor[2], k - 1)
              if not min_path or compare(path, min_path) then
                  min_path = path
              end
          end
          min_path[#min_path + 1] = get(x, y)
          return min_path
      end
      return get_min_path(1, 1, k)
  end
- |2-
      local n = #grid
      local dp = {}
      for i = 1, n do
          dp[i] = {}
          for j = 1, n do
              dp[i][j] = {}
          end
      end
      for i = 1, n do
          for j = 1, n do
              dp[i][j][1] = {grid[i][j]}
          end
      end
      for l = 2, k do
          for i = 1, n do
              for j = 1, n do
                  local min = nil
                  for di = -1, 1 do
                      for dj = -1, 1 do
                          if math.abs(di) + math.abs(dj) == 1 then
                              local ni = i + di
                              local nj = j + dj
                              if ni >= 1 and ni <= n and nj >= 1 and nj <= n then
                                  local path = dp[ni][nj][l - 1]
                                  if path then
                                      local newPath = {grid[i][j]}
                                      for _, v in ipairs(path) do
                                          table.insert(newPath, v)
                                      end
                                      if not min or newPath < min then
                                          min = newPath
                                      end
                                  end
                              end
                          end
                      end
                  end
                  dp[i][j][l] = min
              end
          end
      end
      local min = nil
      for i = 1, n do
          for j = 1, n do
              local path = dp[i][j][k]
              if path then
                  if not min or path < min then
                      min = path
                  end
              end
          end
      end
      return min
  end
- |2-
      local n = #grid
      local function get_neighbors(x, y)
          local neighbors = {}
          if x > 1 then
              neighbors[#neighbors + 1] = {x - 1, y}
          end
          if x < n then
              neighbors[#neighbors + 1] = {x + 1, y}
          end
          if y > 1 then
              neighbors[#neighbors + 1] = {x, y - 1}
          end
          if y < n then
              neighbors[#neighbors + 1] = {x, y + 1}
          end
          return neighbors
      end
      local function get_path(path, x, y)
          local path = path or {}
          path[#path + 1] = grid[x][y]
          if #path == k then
              return path
          end
          local neighbors = get_neighbors(x, y)
          local min_path = nil
          for _, neighbor in ipairs(neighbors) do
              local path = get_path(path, neighbor[1], neighbor[2])
              if path then
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
          return min_path
      end
      local min_path = nil
      for i = 1, n do
          for j = 1, n do
              local path = get_path(nil, i, j)
              if path then
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local function dfs(i, j, k, path)
          if k == 0 then
              return path
          end
          local min_path = nil
          local min_path_val = nil
          local function update_min_path(path)
              local path_val = table.concat(path, "")
              if min_path_val == nil or path_val < min_path_val then
                  min_path = path
                  min_path_val = path_val
              end
          end
          if i > 1 then
              update_min_path(dfs(i - 1, j, k - 1, {grid[i][j], unpack(path)}))
          end
          if i < n then
              update_min_path(dfs(i + 1, j, k - 1, {grid[i][j], unpack(path)}))
          end
          if j > 1 then
              update_min_path(dfs(i, j - 1, k - 1, {grid[i][j], unpack(path)}))
          end
          if j < n then
              update_min_path(dfs(i, j + 1, k - 1, {grid[i][j], unpack(path)}))
          end
          return min_path
      end
      local min_path = nil
      local min_path_val = nil
      for i = 1, n do
          for j = 1, n do
              local path = dfs(i, j, k, {})
              local path_val = table.concat(path, "")
              if min_path_val == nil or path_val < min_path_val then
                  min_path = path
                  min_path_val = path_val
              end
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local function get(i, j)
          return grid[i][j]
      end
      local function get_neighbors(i, j)
          local neighbors = {}
          if i > 1 then
              neighbors[#neighbors + 1] = {i - 1, j}
          end
          if i < n then
              neighbors[#neighbors + 1] = {i + 1, j}
          end
          if j > 1 then
              neighbors[#neighbors + 1] = {i, j - 1}
          end
          if j < n then
              neighbors[#neighbors + 1] = {i, j + 1}
          end
          return neighbors
      end
      local function compare(a, b)
          for i = 1, #a do
              if a[i] < b[i] then
                  return true
              elseif a[i] > b[i] then
                  return false
              end
          end
          return false
      end
      local function get_path(i, j, k)
          local path = {}
          local function dfs(i, j, k)
              if k == 0 then
                  return true
              end
              local neighbors = get_neighbors(i, j)
              for _, neighbor in ipairs(neighbors) do
                  local ni, nj = neighbor[1], neighbor[2]
                  if dfs(ni, nj, k - 1) then
                      path[#path + 1] = get(ni, nj)
                      return true
                  end
              end
              return false
          end
          dfs(i, j, k)
          return path
      end
      local min_path
      for i = 1, n do
          for j = 1, n do
              local path = get_path(i, j, k)
              if not min_path or compare(path, min_path) then
                  min_path = path
              end
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local function get_neighbors(i, j)
          local neighbors = {}
          if i > 1 then
              neighbors[#neighbors + 1] = {i - 1, j}
          end
          if i < n then
              neighbors[#neighbors + 1] = {i + 1, j}
          end
          if j > 1 then
              neighbors[#neighbors + 1] = {i, j - 1}
          end
          if j < n then
              neighbors[#neighbors + 1] = {i, j + 1}
          end
          return neighbors
      end
      local function get_min_path(i, j, k)
          if k == 1 then
              return {grid[i][j]}
          end
          local min_path = nil
          for _, neighbor in ipairs(get_neighbors(i, j)) do
              local path = get_min_path(neighbor[1], neighbor[2], k - 1)
              if min_path == nil or path < min_path then
                  min_path = path
              end
          end
          return {grid[i][j]} .. min_path
      end
      local min_path = nil
      for i = 1, n do
          for j = 1, n do
              local path = get_min_path(i, j, k)
              if min_path == nil or path < min_path then
                  min_path = path
              end
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local function get_neighbors(x, y)
          local neighbors = {}
          if x > 1 then
              neighbors[#neighbors + 1] = {x - 1, y}
          end
          if x < n then
              neighbors[#neighbors + 1] = {x + 1, y}
          end
          if y > 1 then
              neighbors[#neighbors + 1] = {x, y - 1}
          end
          if y < n then
              neighbors[#neighbors + 1] = {x, y + 1}
          end
          return neighbors
      end
      local function compare(a, b)
          for i = 1, #a do
              if a[i] < b[i] then
                  return true
              elseif a[i] > b[i] then
                  return false
              end
          end
          return false
      end
      local function dfs(x, y, path)
          if #path == k then
              if not min_path or compare(path, min_path) then
                  min_path = path
              end
              return
          end
          for _, neighbor in ipairs(get_neighbors(x, y)) do
              local nx, ny = neighbor[1], neighbor[2]
              if not visited[nx][ny] then
                  visited[nx][ny] = true
                  dfs(nx, ny, {unpack(path), grid[nx][ny]})
                  visited[nx][ny] = false
              end
          end
      end
      local visited = {}
      for i = 1, n do
          visited[i] = {}
      end
      local min_path
      for i = 1, n do
          for j = 1, n do
              visited[i][j] = true
              dfs(i, j, {grid[i][j]})
              visited[i][j] = false
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local function get_neighbors(i, j)
          local res = {}
          if i > 1 then
              table.insert(res, {i - 1, j})
          end
          if i < n then
              table.insert(res, {i + 1, j})
          end
          if j > 1 then
              table.insert(res, {i, j - 1})
          end
          if j < n then
              table.insert(res, {i, j + 1})
          end
          return res
      end
      local function dfs(i, j, k, path)
          if k == 0 then
              return path
          end
          local neighbors = get_neighbors(i, j)
          local min_path = nil
          for _, neighbor in ipairs(neighbors) do
              local ni, nj = neighbor[1], neighbor[2]
              local new_path = dfs(ni, nj, k - 1, path .. grid[ni][nj])
              if min_path == nil or new_path < min_path then
                  min_path = new_path
              end
          end
          return min_path
      end
      local min_path = nil
      for i = 1, n do
          for j = 1, n do
              local path = dfs(i, j, k - 1, grid[i][j])
              if min_path == nil or path < min_path then
                  min_path = path
              end
          end
      end
      local res = {}
      for i = 1, k do
          table.insert(res, tonumber(min_path:sub(i, i)))
      end
      return res
  end
- |2-
      local n = #grid
      local function get_neighbors(x, y)
          local res = {}
          if x > 1 then
              table.insert(res, {x - 1, y})
          end
          if x < n then
              table.insert(res, {x + 1, y})
          end
          if y > 1 then
              table.insert(res, {x, y - 1})
          end
          if y < n then
              table.insert(res, {x, y + 1})
          end
          return res
      end
      local function get_path(x, y, k)
          if k == 0 then
              return {}
          end
          local res = {}
          for _, n in ipairs(get_neighbors(x, y)) do
              local x1, y1 = unpack(n)
              local path = get_path(x1, y1, k - 1)
              if path then
                  table.insert(path, 1, grid[x][y])
                  table.insert(res, path)
              end
          end
          if #res == 0 then
              return nil
          end
          table.sort(res, function(a, b)
              for i = 1, k do
                  if a[i] < b[i] then
                      return true
                  elseif a[i] > b[i] then
                      return false
                  end
              end
              return false
          end)
          return res[1]
      end
      local res = {}
      for i = 1, n do
          for j = 1, n do
              local path = get_path(i, j, k)
              if path then
                  table.insert(res, path)
              end
          end
      end
      table.sort(res, function(a, b)
          for i = 1, k do
              if a[i] < b[i] then
                  return true
              elseif a[i] > b[i] then
                  return false
              end
          end
          return false
      end)
      return res[1]
  end
- |2-
      local n = #grid
      local m = #grid[1]
      local function get(x, y)
          return grid[x][y]
      end
      local function get_neighbors(x, y)
          local neighbors = {}
          if x > 1 then
              neighbors[#neighbors + 1] = {x - 1, y}
          end
          if x < n then
              neighbors[#neighbors + 1] = {x + 1, y}
          end
          if y > 1 then
              neighbors[#neighbors + 1] = {x, y - 1}
          end
          if y < m then
              neighbors[#neighbors + 1] = {x, y + 1}
          end
          return neighbors
      end
      local function get_path(x, y, k)
          if k == 0 then
              return {}
          end
          local neighbors = get_neighbors(x, y)
          local min_path = nil
          for _, neighbor in ipairs(neighbors) do
              local path = get_path(neighbor[1], neighbor[2], k - 1)
              if path then
                  path[#path + 1] = get(x, y)
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
          return min_path
      end
      local min_path = nil
      for i = 1, n do
          for j = 1, m do
              local path = get_path(i, j, k)
              if path then
                  path[#path + 1] = get(i, j)
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local function cmp(a, b)
          for i = 1, k do
              if a[i] < b[i] then
                  return true
              elseif a[i] > b[i] then
                  return false
              end
          end
          return false
      end
      local function dfs(i, j, k, path)
          if k == 0 then
              return path
          end
          local res = {}
          if i > 1 then
              res[#res + 1] = dfs(i - 1, j, k - 1, {grid[i - 1][j], unpack(path)})
          end
          if i < n then
              res[#res + 1] = dfs(i + 1, j, k - 1, {grid[i + 1][j], unpack(path)})
          end
          if j > 1 then
              res[#res + 1] = dfs(i, j - 1, k - 1, {grid[i][j - 1], unpack(path)})
          end
          if j < n then
              res[#res + 1] = dfs(i, j + 1, k - 1, {grid[i][j + 1], unpack(path)})
          end
          table.sort(res, cmp)
          return res[1]
      end
      local res = {}
      for i = 1, n do
          for j = 1, n do
              res[#res + 1] = dfs(i, j, k, {grid[i][j]})
          end
      end
      table.sort(res, cmp)
      return res[1]
  end
- |2-
      local n = #grid
      local function get(x, y)
          return grid[x][y]
      end
      local function get_neighbors(x, y)
          local neighbors = {}
          if x > 1 then
              neighbors[#neighbors + 1] = {x - 1, y}
          end
          if x < n then
              neighbors[#neighbors + 1] = {x + 1, y}
          end
          if y > 1 then
              neighbors[#neighbors + 1] = {x, y - 1}
          end
          if y < n then
              neighbors[#neighbors + 1] = {x, y + 1}
          end
          return neighbors
      end
      local function get_paths(x, y, k)
          local paths = {}
          if k == 1 then
              paths[#paths + 1] = {get(x, y)}
          else
              for _, neighbor in ipairs(get_neighbors(x, y)) do
                  for _, path in ipairs(get_paths(neighbor[1], neighbor[2], k - 1)) do
                      paths[#paths + 1] = {get(x, y)}
                      for _, value in ipairs(path) do
                          paths[#paths][#paths[#paths] + 1] = value
                      end
                  end
              end
          end
          return paths
      end
      local min_path = nil
      for i = 1, n do
          for j = 1, n do
              for _, path in ipairs(get_paths(i, j, k)) do
                  if min_path == nil or path < min_path then
                      min_path = path
                  end
              end
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local m = {}
      for i = 1, n do
          m[i] = {}
          for j = 1, n do
              m[i][j] = {grid[i][j]}
          end
      end
      for i = 1, k - 1 do
          local new_m = {}
          for j = 1, n do
              new_m[j] = {}
              for k = 1, n do
                  new_m[j][k] = {}
              end
          end
          for j = 1, n do
              for k = 1, n do
                  local v = m[j][k]
                  if j > 1 then
                      local u = m[j - 1][k]
                      if #u < #v or (#u == #v and u < v) then
                          v = u
                      end
                  end
                  if j < n then
                      local u = m[j + 1][k]
                      if #u < #v or (#u == #v and u < v) then
                          v = u
                      end
                  end
                  if k > 1 then
                      local u = m[j][k - 1]
                      if #u < #v or (#u == #v and u < v) then
                          v = u
                      end
                  end
                  if k < n then
                      local u = m[j][k + 1]
                      if #u < #v or (#u == #v and u < v) then
                          v = u
                      end
                  end
                  new_m[j][k] = v
              end
          end
          m = new_m
      end
      local v = m[1][1]
      for i = 1, n do
          for j = 1, n do
              local u = m[i][j]
              if #u < #v or (#u == #v and u < v) then
                  v = u
              end
          end
      end
      return v
  end
- |2-
      local n = #grid
      local m = #grid[1]
      local dp = {}
      local function get(i, j)
          if i < 1 or i > n or j < 1 or j > m then
              return math.huge
          end
          return dp[i][j]
      end
      for i = 1, n do
          dp[i] = {}
          for j = 1, m do
              dp[i][j] = math.huge
          end
      end
      for i = 1, n do
          for j = 1, m do
              if i == 1 and j == 1 then
                  dp[i][j] = grid[i][j]
              else
                  dp[i][j] = math.min(get(i - 1, j), get(i, j - 1), get(i - 1, j - 1)) + grid[i][j]
              end
          end
      end
      local function get_path(i, j, k)
          if k == 0 then
              return {}
          end
          local a = get(i - 1, j)
          local b = get(i, j - 1)
          local c = get(i - 1, j - 1)
          if a < b and a < c then
              return {grid[i][j]} .. get_path(i - 1, j, k - 1)
          elseif b < a and b < c then
              return {grid[i][j]} .. get_path(i, j - 1, k - 1)
          else
              return {grid[i][j]} .. get_path(i - 1, j - 1, k - 1)
          end
      end
      return get_path(n, m, k)
  end
- |2-
      local n = #grid
      local function get_neighbors(x, y)
          local neighbors = {}
          if x > 1 then
              neighbors[#neighbors + 1] = {x - 1, y}
          end
          if x < n then
              neighbors[#neighbors + 1] = {x + 1, y}
          end
          if y > 1 then
              neighbors[#neighbors + 1] = {x, y - 1}
          end
          if y < n then
              neighbors[#neighbors + 1] = {x, y + 1}
          end
          return neighbors
      end
      local function get_path(x, y, k)
          if k == 0 then
              return {}
          end
          local min_path = nil
          for _, neighbor in ipairs(get_neighbors(x, y)) do
              local path = get_path(neighbor[1], neighbor[2], k - 1)
              if path then
                  path[#path + 1] = grid[x][y]
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
          return min_path
      end
      local min_path = nil
      for i = 1, n do
          for j = 1, n do
              local path = get_path(i, j, k)
              if path then
                  path[#path + 1] = grid[i][y]
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local function get(i, j)
          return grid[i][j]
      end
      local function get_neighbors(i, j)
          local result = {}
          if i > 1 then
              table.insert(result, {i - 1, j})
          end
          if i < n then
              table.insert(result, {i + 1, j})
          end
          if j > 1 then
              table.insert(result, {i, j - 1})
          end
          if j < n then
              table.insert(result, {i, j + 1})
          end
          return result
      end
      local function get_paths(i, j, k)
          if k == 0 then
              return {{get(i, j)}}
          end
          local result = {}
          for _, neighbor in ipairs(get_neighbors(i, j)) do
              local ni, nj = neighbor[1], neighbor[2]
              for _, path in ipairs(get_paths(ni, nj, k - 1)) do
                  table.insert(result, {get(i, j)} .. path)
              end
          end
          return result
      end
      local result = {}
      for i = 1, n do
          for j = 1, n do
              for _, path in ipairs(get_paths(i, j, k - 1)) do
                  table.insert(result, {get(i, j)} .. path)
              end
          end
      end
      table.sort(result)
      return result[1]
  end
- |2-
      local n = #grid
      local function get(x, y)
          return grid[x][y]
      end
      local function get_neighbors(x, y)
          local neighbors = {}
          if x > 1 then
              neighbors[#neighbors + 1] = {x - 1, y}
          end
          if x < n then
              neighbors[#neighbors + 1] = {x + 1, y}
          end
          if y > 1 then
              neighbors[#neighbors + 1] = {x, y - 1}
          end
          if y < n then
              neighbors[#neighbors + 1] = {x, y + 1}
          end
          return neighbors
      end
      local function compare(a, b)
          for i = 1, k do
              if a[i] < b[i] then
                  return true
              elseif a[i] > b[i] then
                  return false
              end
          end
          return false
      end
      local function get_path(x, y, k)
          local path = {}
          for i = 1, k do
              path[i] = get(x, y)
              local neighbors = get_neighbors(x, y)
              local min_neighbor = neighbors[1]
              for j = 2, #neighbors do
                  if compare(get_path(neighbors[j][1], neighbors[j][2], k - i),
                             get_path(min_neighbor[1], min_neighbor[2], k - i)) then
                      min_neighbor = neighbors[j]
                  end
              end
              x, y = min_neighbor[1], min_neighbor[2]
          end
          return path
      end
      return get_path(1, 1, k)
  end
- |2-
      local n = #grid
      local m = #grid[1]
      local dp = {}
      local dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}
      local function get(i, j)
          if i < 1 or i > n or j < 1 or j > m then
              return math.huge
          end
          return grid[i][j]
      end
      for i = 1, n do
          dp[i] = {}
          for j = 1, m do
              dp[i][j] = {}
              for len = 1, k do
                  dp[i][j][len] = math.huge
              end
          end
      end
      for i = 1, n do
          for j = 1, m do
              dp[i][j][1] = grid[i][j]
          end
      end
      for len = 2, k do
          for i = 1, n do
              for j = 1, m do
                  for _, dir in ipairs(dirs) do
                      local ni, nj = i + dir[1], j + dir[2]
                      dp[i][j][len] = math.min(dp[i][j][len], dp[ni][nj][len - 1] + get(i, j))
                  end
              end
          end
      end
      local ans = math.huge
      local ans_i, ans_j
      for i = 1, n do
          for j = 1, m do
              if dp[i][j][k] < ans then
                  ans = dp[i][j][k]
                  ans_i, ans_j = i, j
              end
          end
      end
      local res = {}
      for len = k, 1, -1 do
          table.insert(res, 1, grid[ans_i][ans_j])
          for _, dir in ipairs(dirs) do
              local ni, nj = ans_i + dir[1], ans_j + dir[2]
              if dp[ni][nj][len - 1] + get(ans
- |2-
      local N = #grid
      local function get_neighbors(i, j)
          local neighbors = {}
          if i > 1 then
              neighbors[#neighbors + 1] = {i - 1, j}
          end
          if i < N then
              neighbors[#neighbors + 1] = {i + 1, j}
          end
          if j > 1 then
              neighbors[#neighbors + 1] = {i, j - 1}
          end
          if j < N then
              neighbors[#neighbors + 1] = {i, j + 1}
          end
          return neighbors
      end
      local function get_path(i, j, k)
          if k == 0 then
              return {}
          end
          local min_path = nil
          for _, neighbor in ipairs(get_neighbors(i, j)) do
              local path = get_path(neighbor[1], neighbor[2], k - 1)
              if path then
                  path[#path + 1] = grid[i][j]
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
          return min_path
      end
      local min_path = nil
      for i = 1, N do
          for j = 1, N do
              local path = get_path(i, j, k)
              if path then
                  path[#path + 1] = grid[i][j]
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local function get(x, y)
          if x < 1 or x > n or y < 1 or y > n then
              return math.huge
          end
          return grid[x][y]
      end
      local function get_path(x, y, k)
          if k == 0 then
              return {get(x, y)}
          end
          local path = {}
          local min_path = nil
          local min_value = math.huge
          for dx = -1, 1 do
              for dy = -1, 1 do
                  if dx ~= 0 or dy ~= 0 then
                      local p = get_path(x + dx, y + dy, k - 1)
                      if p[1] < min_value then
                          min_value = p[1]
                          min_path = p
                      end
                  end
              end
          end
          table.insert(path, get(x, y))
          for i = 1, #min_path do
              table.insert(path, min_path[i])
          end
          return path
      end
      local min_path = nil
      local min_value = math.huge
      for x = 1, n do
          for y = 1, n do
              local p = get_path(x, y, k - 1)
              if p[1] < min_value then
                  min_value = p[1]
                  min_path = p
              end
          end
      end
      return min_path
  end
- |2-
      local function get_neighbors(i, j)
          local neighbors = {}
          if i > 1 then
              neighbors[#neighbors + 1] = {i - 1, j}
          end
          if i < #grid then
              neighbors[#neighbors + 1] = {i + 1, j}
          end
          if j > 1 then
              neighbors[#neighbors + 1] = {i, j - 1}
          end
          if j < #grid then
              neighbors[#neighbors + 1] = {i, j + 1}
          end
          return neighbors
      end
      local function get_paths(i, j, k)
          local paths = {}
          if k == 1 then
              paths[#paths + 1] = {grid[i][j]}
          else
              for _, neighbor in ipairs(get_neighbors(i, j)) do
                  local i_neighbor, j_neighbor = neighbor[1], neighbor[2]
                  for _, path in ipairs(get_paths(i_neighbor, j_neighbor, k - 1)) do
                      paths[#paths + 1] = {grid[i][j]}
                      for _, value in ipairs(path) do
                          paths[#paths][#paths[#paths] + 1] = value
                      end
                  end
              end
          end
          return paths
      end
      local min_path = nil
      for i = 1, #grid do
          for j = 1, #grid do
              for _, path in ipairs(get_paths(i, j, k)) do
                  if min_path == nil or path < min_path then
                      min_path = path
                  end
              end
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local function isValid(x, y)
          return x >= 1 and x <= n and y >= 1 and y <= n
      end
      local function getValue(x, y)
          return grid[x][y]
      end
      local function getNeighbors(x, y)
          local neighbors = {}
          if isValid(x - 1, y) then
              neighbors[#neighbors + 1] = {x - 1, y}
          end
          if isValid(x + 1, y) then
              neighbors[#neighbors + 1] = {x + 1, y}
          end
          if isValid(x, y - 1) then
              neighbors[#neighbors + 1] = {x, y - 1}
          end
          if isValid(x, y + 1) then
              neighbors[#neighbors + 1] = {x, y + 1}
          end
          return neighbors
      end
      local function compare(a, b)
          for i = 1, #a do
              if a[i] < b[i] then
                  return true
              elseif a[i] > b[i] then
                  return false
              end
          end
          return false
      end
      local function getPath(x, y, k)
          local path = {{x, y}}
          local value = getValue(x, y)
          local minPath = {value}
          while #path > 0 do
              local cur = path[#path]
              path[#path] = nil
              local neighbors = getNeighbors(cur[1], cur[2])
              for _, neighbor in ipairs(neighbors) do
                  local x, y = neighbor[1], neighbor[2]
                  if not visited[x][y] then
                      visited[x][y] = true
                      local value = getValue(x, y)
                      local newPath = {unpack(minPath)}
                      newPath[#newPath + 1] = value
                      if #newPath == k then
                          if compare(newPath, minPath) then
                              minPath = newPath
                          end
                      else
                          path[#
- |2-
    local n = #grid
    local function get_neighbors(i, j)
      local neighbors = {}
      if i > 1 then
        neighbors[#neighbors + 1] = {i - 1, j}
      end
      if i < n then
        neighbors[#neighbors + 1] = {i + 1, j}
      end
      if j > 1 then
        neighbors[#neighbors + 1] = {i, j - 1}
      end
      if j < n then
        neighbors[#neighbors + 1] = {i, j + 1}
      end
      return neighbors
    end
    local function compare(a, b)
      for i = 1, #a do
        if a[i] < b[i] then
          return true
        elseif a[i] > b[i] then
          return false
        end
      end
      return false
    end
    local function dfs(i, j, path, visited)
      if #path == k then
        if not min_path or compare(path, min_path) then
          min_path = path
        end
        return
      end
      for _, neighbor in ipairs(get_neighbors(i, j)) do
        local ni, nj = neighbor[1], neighbor[2]
        if not visited[ni][nj] then
          visited[ni][nj] = true
          dfs(ni, nj, {unpack(path), grid[ni][nj]}, visited)
          visited[ni][nj] = false
        end
      end
    end
    local min_path
    for i = 1, n do
      for j = 1, n do
        dfs(i, j, {grid[i][j]}, {})
      end
    end
    return min_path
  end
- |2-
      local n = #grid
      local function get(x, y)
          return grid[x][y]
      end
      local function get_neighbors(x, y)
          local neighbors = {}
          if x > 1 then
              neighbors[#neighbors + 1] = {x - 1, y}
          end
          if x < n then
              neighbors[#neighbors + 1] = {x + 1, y}
          end
          if y > 1 then
              neighbors[#neighbors + 1] = {x, y - 1}
          end
          if y < n then
              neighbors[#neighbors + 1] = {x, y + 1}
          end
          return neighbors
      end
      local function get_path(x, y, k)
          local path = {}
          local function dfs(x, y, k)
              if k == 0 then
                  return true
              end
              for _, neighbor in ipairs(get_neighbors(x, y)) do
                  local nx, ny = neighbor[1], neighbor[2]
                  if not path[nx] or not path[nx][ny] then
                      path[nx] = path[nx] or {}
                      path[nx][ny] = true
                      if dfs(nx, ny, k - 1) then
                          return true
                      end
                      path[nx][ny] = nil
                  end
              end
              return false
          end
          if dfs(x, y, k) then
              local result = {}
              for x, row in pairs(path) do
                  for y, _ in pairs(row) do
                      result[#result + 1] = get(x, y)
                  end
              end
              return result
          end
      end
      local min_path = nil
      for x = 1, n do
          for y = 1, n do
              local path = get_path(x, y, k)
              if path then
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
      end
      return min_path
  end
- |2
      local n = #grid
      local function get(i, j)
          return grid[i][j]
      end
      local function get_neighbors(i, j)
          local neighbors = {}
          if i > 1 then
              neighbors[#neighbors + 1] = {i - 1, j}
          end
          if i < n then
              neighbors[#neighbors + 1] = {i + 1, j}
          end
          if j > 1 then
              neighbors[#neighbors + 1] = {i, j - 1}
          end
          if j < n then
              neighbors[#neighbors + 1] = {i, j + 1}
          end
          return neighbors
      end
      local function compare(a, b)
          for i = 1, k do
              if a[i] < b[i] then
                  return true
              elseif a[i] > b[i] then
                  return false
              end
          end
          return false
      end
      local function dfs(i, j, path, visited)
          if #path == k then
              return path
          end
          local min_path = nil
          for _, neighbor in ipairs(get_neighbors(i, j)) do
              local ni, nj = neighbor[1], neighbor[2]
              if not visited[ni][nj] then
                  visited[ni][nj] = true
                  local new_path = dfs(ni, nj, {unpack(path), get(ni, nj)}, visited)
                  if not min_path or compare(new_path, min_path) then
                      min_path = new_path
                  end
                  visited[ni][nj] = false
              end
          end
          return min_path
      end
      local min_path = nil
      for i = 1, n do
          for j = 1, n do
              local visited = {}
              for i = 1, n do
                  visited[i] = {}
              end
              visited[i][j] = true
              local new_path = dfs(i, j, {get(i, j)}, visited)
- |2-
      local n = #grid
      local function get_value(x, y)
          return grid[x][y]
      end
      local function get_neighbors(x, y)
          local neighbors = {}
          if x > 1 then
              neighbors[#neighbors + 1] = {x - 1, y}
          end
          if x < n then
              neighbors[#neighbors + 1] = {x + 1, y}
          end
          if y > 1 then
              neighbors[#neighbors + 1] = {x, y - 1}
          end
          if y < n then
              neighbors[#neighbors + 1] = {x, y + 1}
          end
          return neighbors
      end
      local function get_path(x, y, k)
          local path = {}
          local function dfs(x, y, k)
              if k == 0 then
                  return true
              end
              for _, neighbor in ipairs(get_neighbors(x, y)) do
                  local nx, ny = neighbor[1], neighbor[2]
                  if not path[nx] or not path[nx][ny] then
                      path[nx] = path[nx] or {}
                      path[nx][ny] = true
                      if dfs(nx, ny, k - 1) then
                          return true
                      end
                      path[nx][ny] = nil
                  end
              end
              return false
          end
          dfs(x, y, k)
          return path
      end
      local function get_path_values(path)
          local values = {}
          for x, row in ipairs(path) do
              for y, _ in pairs(row) do
                  values[#values + 1] = get_value(x, y)
              end
          end
          return values
      end
      local min_path, min_path_values
      for x = 1, n do
          for y = 1, n do
              local path = get_path(x, y, k)
              local path_values = get_path_values(path)
              if not min_path_
- |2-
      local n = #grid
      local function get(x, y)
          return grid[x][y]
      end
      local function set(x, y, v)
          grid[x][y] = v
      end
      local function cmp(a, b)
          return a[1] < b[1] or (a[1] == b[1] and a[2] < b[2])
      end
      local function get_neighbors(x, y)
          local neighbors = {}
          if x > 1 then
              neighbors[#neighbors + 1] = {x - 1, y}
          end
          if x < n then
              neighbors[#neighbors + 1] = {x + 1, y}
          end
          if y > 1 then
              neighbors[#neighbors + 1] = {x, y - 1}
          end
          if y < n then
              neighbors[#neighbors + 1] = {x, y + 1}
          end
          table.sort(neighbors, cmp)
          return neighbors
      end
      local function get_path(x, y, k)
          local path = {}
          local v = get(x, y)
          path[#path + 1] = v
          if k == 1 then
              return path
          end
          local neighbors = get_neighbors(x, y)
          local min_path = nil
          for _, neighbor in ipairs(neighbors) do
              local nx, ny = neighbor[1], neighbor[2]
              local nv = get(nx, ny)
              if nv < v then
                  local npath = get_path(nx, ny, k - 1)
                  if not min_path or npath < min_path then
                      min_path = npath
                  end
              end
          end
          if min_path then
              for _, v in ipairs(min_path) do
                  path[#path + 1] = v
              end
          end
          return path
      end
      local min_path = nil
      for i = 1, n do
          for j = 1,
- |2-
      local n = #grid
      local function get(x, y)
          return grid[x][y]
      end
      local function get_neighbors(x, y)
          local neighbors = {}
          if x > 1 then
              neighbors[#neighbors + 1] = {x - 1, y}
          end
          if x < n then
              neighbors[#neighbors + 1] = {x + 1, y}
          end
          if y > 1 then
              neighbors[#neighbors + 1] = {x, y - 1}
          end
          if y < n then
              neighbors[#neighbors + 1] = {x, y + 1}
          end
          return neighbors
      end
      local function get_paths(x, y, k)
          local paths = {}
          if k == 1 then
              paths[#paths + 1] = {{x, y}}
          else
              for _, neighbor in ipairs(get_neighbors(x, y)) do
                  for _, path in ipairs(get_paths(neighbor[1], neighbor[2], k - 1)) do
                      paths[#paths + 1] = {{x, y}}
                      for _, cell in ipairs(path) do
                          paths[#paths][#paths[#paths] + 1] = cell
                      end
                  end
              end
          end
          return paths
      end
      local function compare_paths(path1, path2)
          for i = 1, k do
              if get(path1[i][1], path1[i][2]) < get(path2[i][1], path2[i][2]) then
                  return true
              elseif get(path1[i][1], path1[i][2]) > get(path2[i][1], path2[i][2]) then
                  return false
              end
          end
          return false
      end
      local min_path
      for i = 1, n do
          for j = 1, n do
              for _, path in ipairs(get_paths(i, j, k)) do
                  if not min_path
- |2
      local n = #grid
      local function get(x, y)
          if x < 1 or x > n or y < 1 or y > n then
              return nil
          end
          return grid[x][y]
      end
      local function get_neighbors(x, y)
          local neighbors = {}
          local function add(x, y)
              local v = get(x, y)
              if v then
                  neighbors[#neighbors + 1] = {v, x, y}
              end
          end
          add(x - 1, y)
          add(x + 1, y)
          add(x, y - 1)
          add(x, y + 1)
          return neighbors
      end
      local function compare(a, b)
          for i = 1, k do
              if a[i] < b[i] then
                  return true
              elseif a[i] > b[i] then
                  return false
              end
          end
          return false
      end
      local function dfs(x, y, path, visited)
          if #path == k then
              return path
          end
          local neighbors = get_neighbors(x, y)
          table.sort(neighbors, function(a, b) return a[1] < b[1] end)
          for _, neighbor in ipairs(neighbors) do
              local v, nx, ny = neighbor[1], neighbor[2], neighbor[3]
              if not visited[nx][ny] then
                  visited[nx][ny] = true
                  local new_path = dfs(nx, ny, {unpack(path), v}, visited)
                  if new_path then
                      if not min_path or compare(new_path, min_path) then
                          min_path = new_path
                      end
                  end
                  visited[nx][ny] = false
              end
          end
      end
      local min_path
      for i = 1, n do
          for j = 1, n do
              local visited = {}
              for i = 1, n do
                  visited[i] = {}
              end
- |2-
      local N = #grid
      local function get(x, y)
          if x < 1 or x > N or y < 1 or y > N then
              return 0
          end
          return grid[x][y]
      end
      local function get_neighbors(x, y)
          local neighbors = {}
          for i = -1, 1 do
              for j = -1, 1 do
                  if i ~= 0 or j ~= 0 then
                      local nx, ny = x + i, y + j
                      if get(nx, ny) ~= 0 then
                          neighbors[#neighbors + 1] = {nx, ny}
                      end
                  end
              end
          end
          return neighbors
      end
      local function get_path(x, y, k)
          if k == 0 then
              return {}
          end
          local neighbors = get_neighbors(x, y)
          local min_path = nil
          for _, neighbor in ipairs(neighbors) do
              local nx, ny = neighbor[1], neighbor[2]
              local path = get_path(nx, ny, k - 1)
              if path then
                  path[#path + 1] = get(x, y)
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
          return min_path
      end
      local min_path = nil
      for i = 1, N do
          for j = 1, N do
              local path = get_path(i, j, k)
              if path then
                  path[#path + 1] = get(i, j)
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local function get(x, y)
          return grid[x][y]
      end
      local function get_neighbors(x, y)
          local neighbors = {}
          if x > 1 then
              neighbors[#neighbors + 1] = {x - 1, y}
          end
          if x < n then
              neighbors[#neighbors + 1] = {x + 1, y}
          end
          if y > 1 then
              neighbors[#neighbors + 1] = {x, y - 1}
          end
          if y < n then
              neighbors[#neighbors + 1] = {x, y + 1}
          end
          return neighbors
      end
      local function get_path(x, y, k)
          if k == 0 then
              return {}
          end
          local min_path = nil
          for _, neighbor in ipairs(get_neighbors(x, y)) do
              local path = {get(x, y)}
              for _, value in ipairs(get_path(neighbor[1], neighbor[2], k - 1)) do
                  path[#path + 1] = value
              end
              if min_path == nil or path < min_path then
                  min_path = path
              end
          end
          return min_path
      end
      local min_path = nil
      for i = 1, n do
          for j = 1, n do
              local path = get_path(i, j, k)
              if min_path == nil or path < min_path then
                  min_path = path
              end
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local function get(i, j)
          return grid[i][j]
      end
      local function get_neighbors(i, j)
          local neighbors = {}
          if i > 1 then
              neighbors[#neighbors + 1] = {i - 1, j}
          end
          if i < n then
              neighbors[#neighbors + 1] = {i + 1, j}
          end
          if j > 1 then
              neighbors[#neighbors + 1] = {i, j - 1}
          end
          if j < n then
              neighbors[#neighbors + 1] = {i, j + 1}
          end
          return neighbors
      end
      local function get_key(i, j)
          return i * n + j
      end
      local function get_value(i, j)
          return get(i, j)
      end
      local function get_path_key(path)
          local key = ''
          for _, v in ipairs(path) do
              key = key .. get_key(v[1], v[2])
          end
          return key
      end
      local function get_path_value(path)
          local value = {}
          for _, v in ipairs(path) do
              value[#value + 1] = get_value(v[1], v[2])
          end
          return value
      end
      local function get_path_length(path)
          return #path
      end
      local function compare_paths(path1, path2)
          local value1 = get_path_value(path1)
          local value2 = get_path_value(path2)
          for i = 1, #value1 do
              if value1[i] < value2[i] then
                  return -1
              elseif value1[i] > value2[i] then
                  return 1
              end
          end
          return 0
      end
      local function get_paths(i, j, k)
          local paths = {}
          local function get_paths_rec(path)
              local path_length = get
- |2-
      local n = #grid
      local m = #grid[1]
      local function get(i, j)
          if i < 1 or i > n or j < 1 or j > m then
              return nil
          end
          return grid[i][j]
      end
      local function get_neighbors(i, j)
          local neighbors = {}
          local function add(i, j)
              local val = get(i, j)
              if val then
                  neighbors[val] = {i, j}
              end
          end
          add(i - 1, j)
          add(i + 1, j)
          add(i, j - 1)
          add(i, j + 1)
          return neighbors
      end
      local function get_min_path(i, j, k)
          local val = get(i, j)
          if k == 1 then
              return {val}
          end
          local neighbors = get_neighbors(i, j)
          local min_path = nil
          for _, v in pairs(neighbors) do
              local path = get_min_path(v[1], v[2], k - 1)
              if not min_path or path < min_path then
                  min_path = path
              end
          end
          table.insert(min_path, 1, val)
          return min_path
      end
      local min_path = nil
      for i = 1, n do
          for j = 1, m do
              local path = get_min_path(i, j, k)
              if not min_path or path < min_path then
                  min_path = path
              end
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local function cmp(a, b)
          for i = 1, k do
              if a[i] < b[i] then
                  return true
              elseif a[i] > b[i] then
                  return false
              end
          end
          return false
      end
      local function dfs(i, j, k, path)
          if k == 0 then
              return path
          end
          local min_path = nil
          for di = -1, 1 do
              for dj = -1, 1 do
                  if math.abs(di) + math.abs(dj) == 1 then
                      local ni, nj = i + di, j + dj
                      if ni >= 1 and ni <= n and nj >= 1 and nj <= n then
                          local new_path = dfs(ni, nj, k - 1, {grid[ni][nj]})
                          if new_path then
                              if not min_path or cmp(new_path, min_path) then
                                  min_path = new_path
                              end
                          end
                      end
                  end
              end
          end
          if min_path then
              table.insert(path, 1, grid[i][j])
              return path
          end
      end
      for i = 1, n do
          for j = 1, n do
              local path = dfs(i, j, k, {})
              if path then
                  return path
              end
          end
      end
  end
- |2-
      local n = #grid
      local function get_neighbors(x, y)
          local neighbors = {}
          if x > 1 then
              neighbors[#neighbors + 1] = {x - 1, y}
          end
          if x < n then
              neighbors[#neighbors + 1] = {x + 1, y}
          end
          if y > 1 then
              neighbors[#neighbors + 1] = {x, y - 1}
          end
          if y < n then
              neighbors[#neighbors + 1] = {x, y + 1}
          end
          return neighbors
      end
      local function get_value(x, y)
          return grid[x][y]
      end
      local function get_path(x, y, k)
          if k == 0 then
              return {}
          end
          local neighbors = get_neighbors(x, y)
          local min_path = nil
          for _, neighbor in ipairs(neighbors) do
              local path = get_path(neighbor[1], neighbor[2], k - 1)
              if path then
                  path[#path + 1] = get_value(x, y)
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
          return min_path
      end
      local min_path = nil
      for i = 1, n do
          for j = 1, n do
              local path = get_path(i, j, k)
              if path then
                  path[#path + 1] = get_value(i, j)
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
      end
      return min_path
  end
- |2-
      local N = #grid
      local function get_neighbors(i, j)
          local neighbors = {}
          if i > 1 then
              neighbors[#neighbors + 1] = {i - 1, j}
          end
          if i < N then
              neighbors[#neighbors + 1] = {i + 1, j}
          end
          if j > 1 then
              neighbors[#neighbors + 1] = {i, j - 1}
          end
          if j < N then
              neighbors[#neighbors + 1] = {i, j + 1}
          end
          return neighbors
      end
      local function get_path(i, j, k)
          if k == 0 then
              return {}
          end
          local min_path = nil
          for _, neighbor in ipairs(get_neighbors(i, j)) do
              local path = get_path(neighbor[1], neighbor[2], k - 1)
              if path then
                  path[#path + 1] = grid[i][j]
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
          return min_path
      end
      local min_path = nil
      for i = 1, N do
          for j = 1, N do
              local path = get_path(i, j, k)
              if path then
                  path[#path + 1] = grid[i][j]
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local function get_value(i, j)
          return grid[i][j]
      end
      local function get_neighbors(i, j)
          local neighbors = {}
          if i > 1 then
              neighbors[#neighbors + 1] = {i - 1, j}
          end
          if i < n then
              neighbors[#neighbors + 1] = {i + 1, j}
          end
          if j > 1 then
              neighbors[#neighbors + 1] = {i, j - 1}
          end
          if j < n then
              neighbors[#neighbors + 1] = {i, j + 1}
          end
          return neighbors
      end
      local function get_path(i, j, k)
          if k == 0 then
              return {}
          end
          local min_path = nil
          for _, neighbor in ipairs(get_neighbors(i, j)) do
              local path = get_path(neighbor[1], neighbor[2], k - 1)
              if path then
                  path[#path + 1] = get_value(i, j)
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
          return min_path
      end
      local min_path = nil
      for i = 1, n do
          for j = 1, n do
              local path = get_path(i, j, k)
              if path then
                  path[#path + 1] = get_value(i, j)
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local function get_neighbors(i, j)
          local neighbors = {}
          if i > 1 then
              neighbors[#neighbors + 1] = {i - 1, j}
          end
          if i < n then
              neighbors[#neighbors + 1] = {i + 1, j}
          end
          if j > 1 then
              neighbors[#neighbors + 1] = {i, j - 1}
          end
          if j < n then
              neighbors[#neighbors + 1] = {i, j + 1}
          end
          return neighbors
      end
      local function get_path(i, j, k)
          local path = {}
          local function dfs(i, j, k)
              if k == 0 then
                  return true
              end
              local neighbors = get_neighbors(i, j)
              for _, neighbor in ipairs(neighbors) do
                  local i, j = neighbor[1], neighbor[2]
                  if not visited[i][j] then
                      visited[i][j] = true
                      path[#path + 1] = grid[i][j]
                      if dfs(i, j, k - 1) then
                          return true
                      end
                      path[#path] = nil
                      visited[i][j] = false
                  end
              end
              return false
          end
          dfs(i, j, k)
          return path
      end
      local visited = {}
      for i = 1, n do
          visited[i] = {}
      end
      local min_path = {}
      for i = 1, n do
          for j = 1, n do
              visited[i][j] = true
              local path = {grid[i][j]}
              local path_ = get_path(i, j, k - 1)
              if path_ then
                  for _, v in ipairs(path_) do
                      path[#path + 1] = v
                  end
              end
              if #min_path == 0 or path < min_path then
                  min_path = path
              end
              visited[i][
- |2-
      local n = #grid
      local function get(x, y)
          return grid[x][y]
      end
      local function get_neighbors(x, y)
          local neighbors = {}
          if x > 1 then
              neighbors[#neighbors + 1] = {x = x - 1, y = y}
          end
          if x < n then
              neighbors[#neighbors + 1] = {x = x + 1, y = y}
          end
          if y > 1 then
              neighbors[#neighbors + 1] = {x = x, y = y - 1}
          end
          if y < n then
              neighbors[#neighbors + 1] = {x = x, y = y + 1}
          end
          return neighbors
      end
      local function get_path(x, y, k)
          if k == 0 then
              return {}
          end
          local min_path = nil
          for _, neighbor in ipairs(get_neighbors(x, y)) do
              local path = get_path(neighbor.x, neighbor.y, k - 1)
              if path then
                  path[#path + 1] = get(x, y)
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
          return min_path
      end
      local min_path = nil
      for i = 1, n do
          for j = 1, n do
              local path = get_path(i, j, k)
              if path then
                  path[#path + 1] = get(i, j)
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local function get(x, y)
          return grid[x][y]
      end
      local function get_neighbors(x, y)
          local neighbors = {}
          if x > 1 then
              neighbors[#neighbors + 1] = {x - 1, y}
          end
          if x < n then
              neighbors[#neighbors + 1] = {x + 1, y}
          end
          if y > 1 then
              neighbors[#neighbors + 1] = {x, y - 1}
          end
          if y < n then
              neighbors[#neighbors + 1] = {x, y + 1}
          end
          return neighbors
      end
      local function get_path(x, y, k)
          if k == 0 then
              return {}
          end
          local min_path = nil
          for _, neighbor in ipairs(get_neighbors(x, y)) do
              local path = get_path(neighbor[1], neighbor[2], k - 1)
              if path then
                  path[#path + 1] = get(x, y)
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
          return min_path
      end
      local min_path = nil
      for i = 1, n do
          for j = 1, n do
              local path = get_path(i, j, k)
              if path then
                  path[#path + 1] = get(i, j)
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local min = {}
      local min_sum = math.huge
      local min_path = {}
      local function dfs(i, j, path, sum)
          if i < 1 or i > n or j < 1 or j > n then
              return
          end
          if #path == k then
              if sum < min_sum then
                  min_sum = sum
                  min_path = path
              elseif sum == min_sum then
                  for i = 1, k do
                      if path[i] < min_path[i] then
                          min_path = path
                          break
                      elseif path[i] > min_path[i] then
                          break
                      end
                  end
              end
              return
          end
          dfs(i - 1, j, {path[1], grid[i - 1][j]}, sum + grid[i - 1][j])
          dfs(i + 1, j, {path[1], grid[i + 1][j]}, sum + grid[i + 1][j])
          dfs(i, j - 1, {path[1], grid[i][j - 1]}, sum + grid[i][j - 1])
          dfs(i, j + 1, {path[1], grid[i][j + 1]}, sum + grid[i][j + 1])
      end
      for i = 1, n do
          for j = 1, n do
              dfs(i, j, {grid[i][j]}, grid[i][j])
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local function get(i, j)
          return grid[i][j]
      end
      local function get_neighbors(i, j)
          local t = {}
          if i > 1 then
              t[#t + 1] = {i - 1, j}
          end
          if i < n then
              t[#t + 1] = {i + 1, j}
          end
          if j > 1 then
              t[#t + 1] = {i, j - 1}
          end
          if j < n then
              t[#t + 1] = {i, j + 1}
          end
          return t
      end
      local function get_path(i, j, k)
          if k == 0 then
              return {}
          end
          local t = {}
          for _, v in ipairs(get_neighbors(i, j)) do
              local i1, j1 = v[1], v[2]
              local path = get_path(i1, j1, k - 1)
              if #path > 0 then
                  t[#t + 1] = {get(i, j), path}
              end
          end
          table.sort(t, function(a, b)
              local a1, a2 = a[1], a[2]
              local b1, b2 = b[1], b[2]
              if a1 < b1 then
                  return true
              elseif a1 > b1 then
                  return false
              else
                  return a2 < b2
              end
          end)
          return t[1] and t[1][2] or {}
      end
      local t = {}
      for i = 1, n do
          for j = 1, n do
              local path = get_path(i, j, k)
              if #path > 0 then
                  t[#t + 1] = {get(i, j), path}
              end
          end
      end
      table.sort(t, function(a, b)
          local a1, a2 = a[1], a[2]
          local b1,
- |2-
      local n = #grid
      local function get(x, y)
          return grid[x][y]
      end
      local function get_neighbors(x, y)
          local neighbors = {}
          if x > 1 then
              neighbors[#neighbors + 1] = {x - 1, y}
          end
          if x < n then
              neighbors[#neighbors + 1] = {x + 1, y}
          end
          if y > 1 then
              neighbors[#neighbors + 1] = {x, y - 1}
          end
          if y < n then
              neighbors[#neighbors + 1] = {x, y + 1}
          end
          return neighbors
      end
      local function get_path(x, y, k)
          if k == 0 then
              return {}
          end
          local min_path = nil
          for _, neighbor in ipairs(get_neighbors(x, y)) do
              local path = get_path(neighbor[1], neighbor[2], k - 1)
              if path then
                  path[#path + 1] = get(x, y)
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
          return min_path
      end
      local min_path = nil
      for i = 1, n do
          for j = 1, n do
              local path = get_path(i, j, k)
              if path then
                  path[#path + 1] = get(i, j)
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local function get(x, y)
          return grid[x][y]
      end
      local function get_neighbors(x, y)
          local neighbors = {}
          if x > 1 then
              neighbors[#neighbors + 1] = {x - 1, y}
          end
          if x < n then
              neighbors[#neighbors + 1] = {x + 1, y}
          end
          if y > 1 then
              neighbors[#neighbors + 1] = {x, y - 1}
          end
          if y < n then
              neighbors[#neighbors + 1] = {x, y + 1}
          end
          return neighbors
      end
      local function get_path(x, y, k)
          local path = {}
          for i = 1, k do
              path[i] = get(x, y)
              local neighbors = get_neighbors(x, y)
              local min_neighbor = neighbors[1]
              for _, neighbor in ipairs(neighbors) do
                  if get(neighbor[1], neighbor[2]) < get(min_neighbor[1], min_neighbor[2]) then
                      min_neighbor = neighbor
                  end
              end
              x, y = min_neighbor[1], min_neighbor[2]
          end
          return path
      end
      local min_path = get_path(1, 1, k)
      for i = 1, n do
          for j = 1, n do
              local path = get_path(i, j, k)
              if path < min_path then
                  min_path = path
              end
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local function get(i, j)
          if i < 1 or i > n or j < 1 or j > n then
              return nil
          end
          return grid[i][j]
      end
      local function get_neighbors(i, j)
          local neighbors = {}
          for _, d in ipairs({{1, 0}, {-1, 0}, {0, 1}, {0, -1}}) do
              local x, y = i + d[1], j + d[2]
              local v = get(x, y)
              if v then
                  neighbors[v] = {x, y}
              end
          end
          return neighbors
      end
      local function get_path(i, j, k)
          local v = get(i, j)
          if k == 1 then
              return {v}
          end
          local neighbors = get_neighbors(i, j)
          local min_path = nil
          for _, n in pairs(neighbors) do
              local path = get_path(n[1], n[2], k - 1)
              if not min_path or path < min_path then
                  min_path = path
              end
          end
          table.insert(min_path, 1, v)
          return min_path
      end
      local min_path = nil
      for i = 1, n do
          for j = 1, n do
              local path = get_path(i, j, k)
              if not min_path or path < min_path then
                  min_path = path
              end
          end
      end
      return min_path
  end
- |2-
      -- your code here
  end
- |2-
      local n = #grid
      local function get(x, y)
          return grid[x][y]
      end
      local function get_neighbors(x, y)
          local neighbors = {}
          if x > 1 then
              neighbors[#neighbors + 1] = {x - 1, y}
          end
          if x < n then
              neighbors[#neighbors + 1] = {x + 1, y}
          end
          if y > 1 then
              neighbors[#neighbors + 1] = {x, y - 1}
          end
          if y < n then
              neighbors[#neighbors + 1] = {x, y + 1}
          end
          return neighbors
      end
      local function compare(a, b)
          for i = 1, k do
              if a[i] < b[i] then
                  return true
              elseif a[i] > b[i] then
                  return false
              end
          end
          return false
      end
      local function dfs(x, y, path, visited)
          if #path == k then
              return path
          end
          visited[x][y] = true
          local min_path = nil
          for _, neighbor in ipairs(get_neighbors(x, y)) do
              local nx, ny = neighbor[1], neighbor[2]
              if not visited[nx][ny] then
                  local new_path = dfs(nx, ny, {unpack(path), get(nx, ny)}, visited)
                  if min_path == nil or compare(new_path, min_path) then
                      min_path = new_path
                  end
              end
          end
          visited[x][y] = false
          return min_path
      end
      local visited = {}
      for i = 1, n do
          visited[i] = {}
      end
      local min_path = nil
      for i = 1, n do
          for j = 1, n do
              local new_path = dfs(i, j, {get(i, j)}, visited)
              if min_path == nil or
- |2-
      local n = #grid
      local function get(x, y)
          return grid[x][y]
      end
      local function get_neighbors(x, y)
          local neighbors = {}
          if x > 1 then
              neighbors[#neighbors + 1] = {x - 1, y}
          end
          if x < n then
              neighbors[#neighbors + 1] = {x + 1, y}
          end
          if y > 1 then
              neighbors[#neighbors + 1] = {x, y - 1}
          end
          if y < n then
              neighbors[#neighbors + 1] = {x, y + 1}
          end
          return neighbors
      end
      local function compare(a, b)
          for i = 1, k do
              if a[i] < b[i] then
                  return true
              elseif a[i] > b[i] then
                  return false
              end
          end
          return false
      end
      local function get_min_path(x, y, k)
          local min_path = {}
          for i = 1, k do
              min_path[i] = get(x, y)
          end
          local neighbors = get_neighbors(x, y)
          for _, neighbor in ipairs(neighbors) do
              local path = get_min_path(neighbor[1], neighbor[2], k - 1)
              if compare(path, min_path) then
                  min_path = path
              end
          end
          return min_path
      end
      local min_path = {}
      for i = 1, n do
          for j = 1, n do
              local path = get_min_path(i, j, k)
              if compare(path, min_path) then
                  min_path = path
              end
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local function get(x, y)
          return grid[x][y]
      end
      local function get_neighbors(x, y)
          local neighbors = {}
          if x > 1 then
              neighbors[#neighbors + 1] = {x - 1, y}
          end
          if x < n then
              neighbors[#neighbors + 1] = {x + 1, y}
          end
          if y > 1 then
              neighbors[#neighbors + 1] = {x, y - 1}
          end
          if y < n then
              neighbors[#neighbors + 1] = {x, y + 1}
          end
          return neighbors
      end
      local function get_paths(x, y, k)
          if k == 0 then
              return {{}}
          end
          local paths = {}
          for _, neighbor in ipairs(get_neighbors(x, y)) do
              local neighbor_x, neighbor_y = neighbor[1], neighbor[2]
              for _, path in ipairs(get_paths(neighbor_x, neighbor_y, k - 1)) do
                  paths[#paths + 1] = {get(x, y)}
                  for _, value in ipairs(path) do
                      paths[#paths][#paths[#paths] + 1] = value
                  end
              end
          end
          return paths
      end
      local function compare_paths(path1, path2)
          for i = 1, #path1 do
              if path1[i] < path2[i] then
                  return true
              elseif path1[i] > path2[i] then
                  return false
              end
          end
          return false
      end
      local min_path = nil
      for i = 1, n do
          for j = 1, n do
              for _, path in ipairs(get_paths(i, j, k)) do
                  if min_path == nil or compare_paths(path, min_path) then
                      min_path = path
                  end
              end
          end
      end
- |2-
      local n = #grid
      local m = {}
      for i = 1, n do
          m[i] = {}
          for j = 1, n do
              m[i][j] = {grid[i][j]}
          end
      end
      for i = 2, k do
          for j = 1, n do
              for l = 1, n do
                  local t = {}
                  if j > 1 then
                      for _, v in ipairs(m[j - 1][l]) do
                          table.insert(t, v)
                      end
                  end
                  if j < n then
                      for _, v in ipairs(m[j + 1][l]) do
                          table.insert(t, v)
                      end
                  end
                  if l > 1 then
                      for _, v in ipairs(m[j][l - 1]) do
                          table.insert(t, v)
                      end
                  end
                  if l < n then
                      for _, v in ipairs(m[j][l + 1]) do
                          table.insert(t, v)
                      end
                  end
                  table.sort(t)
                  m[j][l] = t
              end
          end
      end
      local res = {}
      for i = 1, n do
          for j = 1, n do
              if #res == 0 or res[1] > m[i][j][1] then
                  res = m[i][j]
              end
          end
      end
      return res
  end
- |2-
      local n = #grid
      local function get_neighbors(i, j)
          local res = {}
          if i > 1 then
              table.insert(res, {i - 1, j})
          end
          if i < n then
              table.insert(res, {i + 1, j})
          end
          if j > 1 then
              table.insert(res, {i, j - 1})
          end
          if j < n then
              table.insert(res, {i, j + 1})
          end
          return res
      end
      local function get_path(i, j, k)
          if k == 0 then
              return {}
          end
          local res = {}
          for _, n in ipairs(get_neighbors(i, j)) do
              local path = get_path(n[1], n[2], k - 1)
              table.insert(path, 1, grid[i][j])
              if #res == 0 or path < res then
                  res = path
              end
          end
          return res
      end
      local res = {}
      for i = 1, n do
          for j = 1, n do
              local path = get_path(i, j, k)
              if #res == 0 or path < res then
                  res = path
              end
          end
      end
      return res
  end
- |2-
      local n = #grid
      local function get_neighbors(i, j)
          local neighbors = {}
          if i > 1 then
              neighbors[#neighbors + 1] = {i - 1, j}
          end
          if i < n then
              neighbors[#neighbors + 1] = {i + 1, j}
          end
          if j > 1 then
              neighbors[#neighbors + 1] = {i, j - 1}
          end
          if j < n then
              neighbors[#neighbors + 1] = {i, j + 1}
          end
          return neighbors
      end
      local function get_path(i, j, k)
          local path = {}
          local function dfs(i, j, k)
              if k == 0 then
                  return true
              end
              for _, neighbor in ipairs(get_neighbors(i, j)) do
                  local ni, nj = neighbor[1], neighbor[2]
                  if not visited[ni][nj] then
                      visited[ni][nj] = true
                      path[#path + 1] = grid[ni][nj]
                      if dfs(ni, nj, k - 1) then
                          return true
                      end
                      path[#path] = nil
                      visited[ni][nj] = false
                  end
              end
              return false
          end
          dfs(i, j, k)
          return path
      end
      local visited = {}
      for i = 1, n do
          visited[i] = {}
      end
      local min_path = {}
      for i = 1, n do
          for j = 1, n do
              visited[i][j] = true
              local path = {grid[i][j]}
              local path_len = 1
              while path_len < k do
                  local new_path = get_path(i, j, k - path_len)
                  if #new_path == 0 then
                      break
                  end
                  path_len = path_len + #new_path
                  for _, val in ipairs(new_path) do
                      path[#path +
- |2-
      local n = #grid
      local function get(x, y)
          return grid[x][y]
      end
      local function set(x, y, v)
          grid[x][y] = v
      end
      local function get_neighbors(x, y)
          local neighbors = {}
          if x > 1 then
              neighbors[#neighbors + 1] = {x - 1, y}
          end
          if x < n then
              neighbors[#neighbors + 1] = {x + 1, y}
          end
          if y > 1 then
              neighbors[#neighbors + 1] = {x, y - 1}
          end
          if y < n then
              neighbors[#neighbors + 1] = {x, y + 1}
          end
          return neighbors
      end
      local function compare(a, b)
          local a_val = get(a[1], a[2])
          local b_val = get(b[1], b[2])
          if a_val < b_val then
              return true
          elseif a_val > b_val then
              return false
          else
              return a[1] < b[1] or (a[1] == b[1] and a[2] < b[2])
          end
      end
      local function get_min_neighbor(x, y)
          local neighbors = get_neighbors(x, y)
          local min_neighbor = neighbors[1]
          for i = 2, #neighbors do
              if compare(neighbors[i], min_neighbor) then
                  min_neighbor = neighbors[i]
              end
          end
          return min_neighbor
      end
      local function get_min_path(x, y, k)
          if k == 1 then
              return {get(x, y)}
          end
          local min_neighbor = get_min_neighbor(x, y)
          local min_path = get_min_path(min_neighbor[1], min_neighbor[2], k - 1)
          min_path
- |2-
      local n = #grid
      local function get(x, y)
          return grid[x][y]
      end
      local function get_neighbors(x, y)
          local neighbors = {}
          if x > 1 then
              neighbors[#neighbors + 1] = {x - 1, y}
          end
          if x < n then
              neighbors[#neighbors + 1] = {x + 1, y}
          end
          if y > 1 then
              neighbors[#neighbors + 1] = {x, y - 1}
          end
          if y < n then
              neighbors[#neighbors + 1] = {x, y + 1}
          end
          return neighbors
      end
      local function less(a, b)
          for i = 1, k do
              if a[i] < b[i] then
                  return true
              elseif a[i] > b[i] then
                  return false
              end
          end
          return false
      end
      local function get_min_path(x, y, k)
          local min_path = {}
          local min_path_value = get(x, y)
          for _, neighbor in ipairs(get_neighbors(x, y)) do
              local neighbor_x, neighbor_y = neighbor[1], neighbor[2]
              local neighbor_path = get_min_path(neighbor_x, neighbor_y, k - 1)
              local neighbor_path_value = get(neighbor_x, neighbor_y)
              if less({neighbor_path_value, unpack(neighbor_path)}, {min_path_value, unpack(min_path)}) then
                  min_path = neighbor_path
                  min_path_value = neighbor_path_value
              end
          end
          return {min_path_value, unpack(min_path)}
      end
      local min_path = get_min_path(1, 1, k)
      return {unpack(min_path, 2, #min_path)}
  end
- |2-
      local n = #grid
      local function rec(i, j, k, path)
          if k == 0 then
              return path
          end
          local min_path
          if i > 1 then
              local path_ = rec(i - 1, j, k - 1, {grid[i][j]})
              if not min_path or path_ < min_path then
                  min_path = path_
              end
          end
          if i < n then
              local path_ = rec(i + 1, j, k - 1, {grid[i][j]})
              if not min_path or path_ < min_path then
                  min_path = path_
              end
          end
          if j > 1 then
              local path_ = rec(i, j - 1, k - 1, {grid[i][j]})
              if not min_path or path_ < min_path then
                  min_path = path_
              end
          end
          if j < n then
              local path_ = rec(i, j + 1, k - 1, {grid[i][j]})
              if not min_path or path_ < min_path then
                  min_path = path_
              end
          end
          if min_path then
              table.insert(min_path, 1, grid[i][j])
          end
          return min_path
      end
      local min_path
      for i = 1, n do
          for j = 1, n do
              local path = rec(i, j, k, {})
              if not min_path or path < min_path then
                  min_path = path
              end
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local function get(i, j)
          return grid[i][j]
      end
      local function get_neighbors(i, j)
          local neighbors = {}
          if i > 1 then
              neighbors[#neighbors + 1] = {i - 1, j}
          end
          if i < n then
              neighbors[#neighbors + 1] = {i + 1, j}
          end
          if j > 1 then
              neighbors[#neighbors + 1] = {i, j - 1}
          end
          if j < n then
              neighbors[#neighbors + 1] = {i, j + 1}
          end
          return neighbors
      end
      local function get_path(i, j, k)
          local path = {}
          local function dfs(i, j, k)
              if k == 0 then
                  return true
              end
              for _, neighbor in ipairs(get_neighbors(i, j)) do
                  local ni, nj = neighbor[1], neighbor[2]
                  if not path[ni] or not path[ni][nj] then
                      path[ni] = path[ni] or {}
                      path[ni][nj] = true
                      if dfs(ni, nj, k - 1) then
                          return true
                      end
                      path[ni][nj] = nil
                  end
              end
              return false
          end
          dfs(i, j, k)
          return path
      end
      local function get_path_value(path)
          local lst = {}
          for i = 1, n do
              for j = 1, n do
                  if path[i] and path[i][j] then
                      lst[#lst + 1] = get(i, j)
                  end
              end
          end
          return lst
      end
      local function get_min_path_value(k)
          local min_path_value
          for i = 1, n do
              for j = 1, n do
                  local path = get_path(i, j, k)
                  local path_value =
- |2-
      -- your code here
      local n = #grid
      local function get(x, y)
          return grid[x][y]
      end
      local function get_neighbors(x, y)
          local neighbors = {}
          if x > 1 then
              table.insert(neighbors, {x - 1, y})
          end
          if x < n then
              table.insert(neighbors, {x + 1, y})
          end
          if y > 1 then
              table.insert(neighbors, {x, y - 1})
          end
          if y < n then
              table.insert(neighbors, {x, y + 1})
          end
          return neighbors
      end
      local function compare(a, b)
          for i = 1, #a do
              if a[i] < b[i] then
                  return true
              elseif a[i] > b[i] then
                  return false
              end
          end
          return false
      end
      local function get_path(x, y, k)
          local path = {}
          local function dfs(x, y, k)
              if k == 0 then
                  return true
              end
              local neighbors = get_neighbors(x, y)
              table.insert(path, get(x, y))
              for _, neighbor in ipairs(neighbors) do
                  if dfs(neighbor[1], neighbor[2], k - 1) then
                      return true
                  end
              end
              table.remove(path)
              return false
          end
          dfs(x, y, k)
          return path
      end
      local min_path = {}
      for i = 1, n do
          for j = 1, n do
              local path = get_path(i, j, k)
              if #min_path == 0 or compare(path, min_path) then
                  min_path = path
              end
          end
      end
      return min_path
  end
- |2-
      local function get_neighbors(x, y)
          local neighbors = {}
          if x > 1 then
              table.insert(neighbors, {x - 1, y})
          end
          if x < #grid then
              table.insert(neighbors, {x + 1, y})
          end
          if y > 1 then
              table.insert(neighbors, {x, y - 1})
          end
          if y < #grid then
              table.insert(neighbors, {x, y + 1})
          end
          return neighbors
      end
      local function get_paths(x, y, k)
          local paths = {}
          if k == 1 then
              table.insert(paths, {grid[x][y]})
          else
              for _, neighbor in ipairs(get_neighbors(x, y)) do
                  for _, path in ipairs(get_paths(neighbor[1], neighbor[2], k - 1)) do
                      table.insert(paths, {grid[x][y]})
                      table.insert(paths[#paths], path)
                  end
              end
          end
          return paths
      end
      local min_path = {}
      for i = 1, #grid do
          for j = 1, #grid do
              for _, path in ipairs(get_paths(i, j, k)) do
                  if #min_path == 0 or path < min_path then
                      min_path = path
                  end
              end
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local function get(x, y)
          return grid[x][y]
      end
      local function get_neighbors(x, y)
          local neighbors = {}
          if x > 1 then
              neighbors[#neighbors + 1] = {x - 1, y}
          end
          if x < n then
              neighbors[#neighbors + 1] = {x + 1, y}
          end
          if y > 1 then
              neighbors[#neighbors + 1] = {x, y - 1}
          end
          if y < n then
              neighbors[#neighbors + 1] = {x, y + 1}
          end
          return neighbors
      end
      local function compare(a, b)
          for i = 1, k do
              if a[i] < b[i] then
                  return true
              elseif a[i] > b[i] then
                  return false
              end
          end
          return false
      end
      local function dfs(x, y, path, visited)
          if #path == k then
              if not min_path or compare(path, min_path) then
                  min_path = path
              end
              return
          end
          for _, neighbor in ipairs(get_neighbors(x, y)) do
              local nx, ny = neighbor[1], neighbor[2]
              if not visited[nx][ny] then
                  visited[nx][ny] = true
                  dfs(nx, ny, {unpack(path), get(nx, ny)}, visited)
                  visited[nx][ny] = false
              end
          end
      end
      local min_path
      for i = 1, n do
          for j = 1, n do
              dfs(i, j, {get(i, j)}, {})
          end
      end
      return min_path
  end
- |2
      local function get_neighbors(i, j)
          local neighbors = {}
          if i > 1 then
              neighbors[#neighbors + 1] = {i - 1, j}
          end
          if i < #grid then
              neighbors[#neighbors + 1] = {i + 1, j}
          end
          if j > 1 then
              neighbors[#neighbors + 1] = {i, j - 1}
          end
          if j < #grid then
              neighbors[#neighbors + 1] = {i, j + 1}
          end
          return neighbors
      end
      local function get_path(i, j, k)
          local path = {}
          local min_path = {}
          local min_value = math.huge
          local function dfs(i, j, k)
              if k == 0 then
                  local value = 0
                  for _, v in ipairs(path) do
                      value = value * 10 + grid[v[1]][v[2]]
                  end
                  if value < min_value then
                      min_value = value
                      min_path = {}
                      for _, v in ipairs(path) do
                          min_path[#min_path + 1] = grid[v[1]][v[2]]
                      end
                  end
                  return
              end
              for _, v in ipairs(get_neighbors(i, j)) do
                  path[#path + 1] = v
                  dfs(v[1], v[2], k - 1)
                  path[#path] = nil
              end
          end
          dfs(i, j, k)
          return min_path
      end
      local min_path = {}
      local min_value = math.huge
      for i = 1, #grid do
          for j = 1, #grid do
              local path = get_path(i, j, k)
              local value = 0
              for _, v in ipairs(path) do
                  value = value * 10 + v
              end
              if value < min_value then
                  min_value = value
                  min_path = path
              end
- |2-
      local n = #grid
      local m = #grid[1]
      local function get(x, y)
          return grid[x][y]
      end
      local function get_neighbors(x, y)
          local res = {}
          if x > 1 then
              res[#res + 1] = {x - 1, y}
          end
          if x < n then
              res[#res + 1] = {x + 1, y}
          end
          if y > 1 then
              res[#res + 1] = {x, y - 1}
          end
          if y < m then
              res[#res + 1] = {x, y + 1}
          end
          return res
      end
      local function get_path(x, y, k)
          if k == 0 then
              return {}
          end
          local res = {}
          for _, n in ipairs(get_neighbors(x, y)) do
              local x1, y1 = n[1], n[2]
              local path = get_path(x1, y1, k - 1)
              if #path > 0 then
                  path[#path + 1] = get(x, y)
                  res[#res + 1] = path
              end
          end
          table.sort(res, function(a, b)
              for i = 1, k do
                  if a[i] < b[i] then
                      return true
                  elseif a[i] > b[i] then
                      return false
                  end
              end
              return false
          end)
          return res[1] or {}
      end
      local res = {}
      for i = 1, n do
          for j = 1, m do
              local path = get_path(i, j, k)
              if #path > 0 then
                  path[#path + 1] = get(i, j)
                  res[#res + 1] = path
              end
          end
      end
      table.sort(res, function(a, b)
          for i = 1, k do
              if a[i] < b[i] then
                  return
- |2-
      local n = #grid
      local function get(i, j)
          return grid[i][j]
      end
      local function get_neighbors(i, j)
          local neighbors = {}
          if i > 1 then
              neighbors[#neighbors + 1] = {i - 1, j}
          end
          if i < n then
              neighbors[#neighbors + 1] = {i + 1, j}
          end
          if j > 1 then
              neighbors[#neighbors + 1] = {i, j - 1}
          end
          if j < n then
              neighbors[#neighbors + 1] = {i, j + 1}
          end
          return neighbors
      end
      local function get_paths(i, j, k)
          local paths = {}
          if k == 1 then
              paths[#paths + 1] = {get(i, j)}
          else
              for _, neighbor in ipairs(get_neighbors(i, j)) do
                  local ni, nj = neighbor[1], neighbor[2]
                  for _, path in ipairs(get_paths(ni, nj, k - 1)) do
                      paths[#paths + 1] = {get(i, j)}
                      for _, value in ipairs(path) do
                          paths[#paths][#paths[#paths] + 1] = value
                      end
                  end
              end
          end
          return paths
      end
      local min_path = nil
      for i = 1, n do
          for j = 1, n do
              for _, path in ipairs(get_paths(i, j, k)) do
                  if min_path == nil or path < min_path then
                      min_path = path
                  end
              end
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local function get(x, y)
          return grid[x][y]
      end
      local function get_neighbors(x, y)
          local res = {}
          if x > 1 then
              res[#res + 1] = {x - 1, y}
          end
          if x < n then
              res[#res + 1] = {x + 1, y}
          end
          if y > 1 then
              res[#res + 1] = {x, y - 1}
          end
          if y < n then
              res[#res + 1] = {x, y + 1}
          end
          return res
      end
      local function is_less(a, b)
          for i = 1, k do
              if a[i] < b[i] then
                  return true
              elseif a[i] > b[i] then
                  return false
              end
          end
          return false
      end
      local function get_min(x, y, k)
          local res = {get(x, y)}
          local min = res
          for _, n in ipairs(get_neighbors(x, y)) do
              local m = get_min(n[1], n[2], k - 1)
              if is_less(m, min) then
                  min = m
              end
          end
          for i = 1, k - 1 do
              res[i + 1] = min[i]
          end
          return res
      end
      local res = {get(1, 1)}
      for i = 1, n do
          for j = 1, n do
              local m = get_min(i, j, k - 1)
              if is_less(m, res) then
                  res = m
              end
          end
      end
      return res
  end
- |2-
      local n = #grid
      local function get(i, j)
          return grid[i][j]
      end
      local function get_neighbors(i, j)
          local neighbors = {}
          if i > 1 then
              neighbors[#neighbors + 1] = {i - 1, j}
          end
          if i < n then
              neighbors[#neighbors + 1] = {i + 1, j}
          end
          if j > 1 then
              neighbors[#neighbors + 1] = {i, j - 1}
          end
          if j < n then
              neighbors[#neighbors + 1] = {i, j + 1}
          end
          return neighbors
      end
      local function get_path(i, j, k)
          if k == 0 then
              return {}
          end
          local min_path = nil
          for _, neighbor in ipairs(get_neighbors(i, j)) do
              local path = get_path(neighbor[1], neighbor[2], k - 1)
              if path then
                  path[#path + 1] = get(i, j)
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
          return min_path
      end
      local min_path = nil
      for i = 1, n do
          for j = 1, n do
              local path = get_path(i, j, k)
              if path then
                  path[#path + 1] = get(i, j)
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local function get(x, y)
          return grid[x][y]
      end
      local function get_neighbors(x, y)
          local neighbors = {}
          if x > 1 then
              neighbors[#neighbors + 1] = {x - 1, y}
          end
          if x < n then
              neighbors[#neighbors + 1] = {x + 1, y}
          end
          if y > 1 then
              neighbors[#neighbors + 1] = {x, y - 1}
          end
          if y < n then
              neighbors[#neighbors + 1] = {x, y + 1}
          end
          return neighbors
      end
      local function get_path(x, y, k)
          if k == 0 then
              return {}
          end
          local min_path = nil
          for _, neighbor in ipairs(get_neighbors(x, y)) do
              local path = get_path(neighbor[1], neighbor[2], k - 1)
              if path then
                  path[#path + 1] = get(x, y)
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
          return min_path
      end
      local min_path = nil
      for i = 1, n do
          for j = 1, n do
              local path = get_path(i, j, k)
              if path then
                  path[#path + 1] = get(i, j)
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local function get(x, y)
          return grid[x][y]
      end
      local function get_neighbors(x, y)
          local neighbors = {}
          if x > 1 then
              neighbors[#neighbors + 1] = {x - 1, y}
          end
          if x < n then
              neighbors[#neighbors + 1] = {x + 1, y}
          end
          if y > 1 then
              neighbors[#neighbors + 1] = {x, y - 1}
          end
          if y < n then
              neighbors[#neighbors + 1] = {x, y + 1}
          end
          return neighbors
      end
      local function get_path(x, y, k)
          if k == 0 then
              return {}
          end
          local min_path = nil
          for _, neighbor in ipairs(get_neighbors(x, y)) do
              local path = get_path(neighbor[1], neighbor[2], k - 1)
              if path then
                  path[#path + 1] = get(x, y)
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
          return min_path
      end
      local min_path = nil
      for i = 1, n do
          for j = 1, n do
              local path = get_path(i, j, k)
              if path then
                  path[#path + 1] = get(i, j)
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local function get(i, j)
          return grid[i][j]
      end
      local function get_next(i, j)
          local next = {}
          if i > 1 then
              next[#next + 1] = {i - 1, j}
          end
          if i < n then
              next[#next + 1] = {i + 1, j}
          end
          if j > 1 then
              next[#next + 1] = {i, j - 1}
          end
          if j < n then
              next[#next + 1] = {i, j + 1}
          end
          return next
      end
      local function get_path(i, j, k)
          local path = {}
          local function dfs(i, j, k)
              if k == 0 then
                  return true
              end
              local next = get_next(i, j)
              for _, v in ipairs(next) do
                  local i, j = v[1], v[2]
                  if not path[i] or not path[i][j] then
                      path[i] = path[i] or {}
                      path[i][j] = true
                      if dfs(i, j, k - 1) then
                          return true
                      end
                      path[i][j] = nil
                  end
              end
              return false
          end
          dfs(i, j, k)
          return path
      end
      local function get_value(path)
          local value = {}
          for i, v in ipairs(path) do
              local i, j = v[1], v[2]
              value[#value + 1] = get(i, j)
          end
          return value
      end
      local function less(a, b)
          for i = 1, #a do
              if a[i] < b[i] then
                  return true
              elseif a[i] > b[i] then
                  return false
              end
          end
          return false
      end
      local min_value = nil
      for i = 1, n do
          for j
- |2-
      -- Write your code here
      return {}
  end
- |2-
      local function get_neighbors(x, y)
          local neighbors = {}
          if x > 1 then
              table.insert(neighbors, {x - 1, y})
          end
          if x < #grid then
              table.insert(neighbors, {x + 1, y})
          end
          if y > 1 then
              table.insert(neighbors, {x, y - 1})
          end
          if y < #grid then
              table.insert(neighbors, {x, y + 1})
          end
          return neighbors
      end
      local function get_paths(x, y, k)
          local paths = {}
          if k == 1 then
              table.insert(paths, {grid[x][y]})
          else
              for _, neighbor in ipairs(get_neighbors(x, y)) do
                  for _, path in ipairs(get_paths(neighbor[1], neighbor[2], k - 1)) do
                      table.insert(paths, {grid[x][y]})
                      table.insert(paths[#paths], path)
                  end
              end
          end
          return paths
      end
      local min_path = nil
      for i = 1, #grid do
          for j = 1, #grid do
              for _, path in ipairs(get_paths(i, j, k)) do
                  if min_path == nil or path < min_path then
                      min_path = path
                  end
              end
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local m = {}
      for i = 1, n do
          m[i] = {}
          for j = 1, n do
              m[i][j] = {}
          end
      end
      for i = 1, n do
          for j = 1, n do
              m[i][j][1] = grid[i][j]
          end
      end
      for l = 2, k do
          for i = 1, n do
              for j = 1, n do
                  local min_val = math.huge
                  local min_path = {}
                  if i > 1 then
                      if m[i - 1][j][l - 1] < min_val then
                          min_val = m[i - 1][j][l - 1]
                          min_path = {unpack(m[i - 1][j])}
                      elseif m[i - 1][j][l - 1] == min_val then
                          local t = {unpack(m[i - 1][j])}
                          for k = 1, l - 1 do
                              if t[k] < min_path[k] then
                                  break
                              elseif t[k] > min_path[k] then
                                  min_path = t
                                  break
                              end
                          end
                      end
                  end
                  if i < n then
                      if m[i + 1][j][l - 1] < min_val then
                          min_val = m[i + 1][j][l - 1]
                          min_path = {unpack(m[i + 1][j])}
                      elseif m[i + 1][j][l - 1] == min_val then
                          local t = {unpack(m[i + 1][j])}
                          for k = 1, l - 1 do
                              if t[k] < min_path[k] then
                                  break
                              elseif t[k] > min_path[k] then
                                  min_path = t
                                  break
                              end
                          end
                      end
                  end
                  if j > 1 then
                      if m[i][j - 1][l
- |2
      local n = #grid
      local function get(x, y)
          return grid[x][y]
      end
      local function get_neighbors(x, y)
          local neighbors = {}
          if x > 1 then
              neighbors[#neighbors + 1] = {x - 1, y}
          end
          if x < n then
              neighbors[#neighbors + 1] = {x + 1, y}
          end
          if y > 1 then
              neighbors[#neighbors + 1] = {x, y - 1}
          end
          if y < n then
              neighbors[#neighbors + 1] = {x, y + 1}
          end
          return neighbors
      end
      local function get_path(x, y, k)
          local path = {}
          local function dfs(x, y, k)
              if k == 0 then
                  return true
              end
              for _, n in ipairs(get_neighbors(x, y)) do
                  local nx, ny = n[1], n[2]
                  if not path[nx] or not path[nx][ny] then
                      path[nx] = path[nx] or {}
                      path[nx][ny] = true
                      if dfs(nx, ny, k - 1) then
                          return true
                      end
                      path[nx][ny] = nil
                  end
              end
              return false
          end
          dfs(x, y, k)
          return path
      end
      local function get_path_values(path)
          local values = {}
          for x, row in ipairs(path) do
              for y, _ in pairs(row) do
                  values[#values + 1] = get(x, y)
              end
          end
          return values
      end
      local function compare_paths(path1, path2)
          local values1 = get_path_values(path1)
          local values2 = get_path_values(path2)
          for i = 1, #values1 do
              if values1[i] < values2[i] then
- |2
      local n = #grid
      local function get(i, j)
          return grid[i][j]
      end
      local function get_neighbors(i, j)
          local neighbors = {}
          if i > 1 then
              neighbors[#neighbors + 1] = {i - 1, j}
          end
          if i < n then
              neighbors[#neighbors + 1] = {i + 1, j}
          end
          if j > 1 then
              neighbors[#neighbors + 1] = {i, j - 1}
          end
          if j < n then
              neighbors[#neighbors + 1] = {i, j + 1}
          end
          return neighbors
      end
      local function compare(a, b)
          for i = 1, k do
              if a[i] < b[i] then
                  return true
              elseif a[i] > b[i] then
                  return false
              end
          end
          return false
      end
      local function dfs(i, j, path, visited)
          if #path == k then
              return path
          end
          local min_path = nil
          for _, neighbor in ipairs(get_neighbors(i, j)) do
              local ni, nj = neighbor[1], neighbor[2]
              if not visited[ni][nj] then
                  visited[ni][nj] = true
                  local new_path = dfs(ni, nj, {unpack(path), get(ni, nj)}, visited)
                  if not min_path or compare(new_path, min_path) then
                      min_path = new_path
                  end
                  visited[ni][nj] = false
              end
          end
          return min_path
      end
      local min_path = nil
      for i = 1, n do
          for j = 1, n do
              local visited = {}
              for i = 1, n do
                  visited[i] = {}
              end
              visited[i][j] = true
              local new_path = dfs(i, j, {get(i, j)}, visited)
- |2-
      -- Write your code here
      return {}
  end
- |2-
      local N = #grid
      local function get(x, y)
          return grid[x][y]
      end
      local function get_neighbors(x, y)
          local neighbors = {}
          if x > 1 then
              neighbors[#neighbors + 1] = {x - 1, y}
          end
          if x < N then
              neighbors[#neighbors + 1] = {x + 1, y}
          end
          if y > 1 then
              neighbors[#neighbors + 1] = {x, y - 1}
          end
          if y < N then
              neighbors[#neighbors + 1] = {x, y + 1}
          end
          return neighbors
      end
      local function get_path(x, y, k)
          local path = {}
          for i = 1, k do
              path[i] = get(x, y)
              local neighbors = get_neighbors(x, y)
              local min_neighbor = neighbors[1]
              for j = 2, #neighbors do
                  local neighbor = neighbors[j]
                  if get(neighbor[1], neighbor[2]) < get(min_neighbor[1], min_neighbor[2]) then
                      min_neighbor = neighbor
                  end
              end
              x, y = min_neighbor[1], min_neighbor[2]
          end
          return path
      end
      local min_path = get_path(1, 1, k)
      for i = 1, N do
          for j = 1, N do
              local path = get_path(i, j, k)
              if path < min_path then
                  min_path = path
              end
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local function get(x, y)
          return grid[x][y]
      end
      local function get_neighbors(x, y)
          local neighbors = {}
          if x > 1 then
              neighbors[#neighbors + 1] = {x - 1, y}
          end
          if x < n then
              neighbors[#neighbors + 1] = {x + 1, y}
          end
          if y > 1 then
              neighbors[#neighbors + 1] = {x, y - 1}
          end
          if y < n then
              neighbors[#neighbors + 1] = {x, y + 1}
          end
          return neighbors
      end
      local function get_path(x, y, k)
          local path = {}
          local function dfs(x, y, k)
              if k == 0 then
                  return true
              end
              for _, neighbor in ipairs(get_neighbors(x, y)) do
                  local nx, ny = neighbor[1], neighbor[2]
                  if not path[nx] or not path[nx][ny] then
                      path[nx] = path[nx] or {}
                      path[nx][ny] = true
                      if dfs(nx, ny, k - 1) then
                          return true
                      end
                      path[nx][ny] = nil
                  end
              end
              return false
          end
          if dfs(x, y, k) then
              local result = {}
              for x, row in pairs(path) do
                  for y, _ in pairs(row) do
                      result[#result + 1] = get(x, y)
                  end
              end
              return result
          end
      end
      local min_path = nil
      for x = 1, n do
          for y = 1, n do
              local path = get_path(x, y, k)
              if path then
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local function dfs(i, j, k, path)
          if k == 0 then
              return path
          end
          local minPath = nil
          for _, d in ipairs({{0, 1}, {0, -1}, {1, 0}, {-1, 0}}) do
              local x, y = i + d[1], j + d[2]
              if x >= 1 and x <= n and y >= 1 and y <= n then
                  local newPath = dfs(x, y, k - 1, {grid[x][y]})
                  if minPath == nil or newPath < minPath then
                      minPath = newPath
                  end
              end
          end
          return {grid[i][j]}:merge(minPath)
      end
      local minPath = nil
      for i = 1, n do
          for j = 1, n do
              local newPath = dfs(i, j, k - 1, {grid[i][j]})
              if minPath == nil or newPath < minPath then
                  minPath = newPath
              end
          end
      end
      return minPath
  end
- |2
      local N = #grid
      local function get_neighbors(i, j)
          local neighbors = {}
          if i > 1 then
              neighbors[#neighbors + 1] = {i - 1, j}
          end
          if i < N then
              neighbors[#neighbors + 1] = {i + 1, j}
          end
          if j > 1 then
              neighbors[#neighbors + 1] = {i, j - 1}
          end
          if j < N then
              neighbors[#neighbors + 1] = {i, j + 1}
          end
          return neighbors
      end
      local function get_value(i, j)
          return grid[i][j]
      end
      local function compare(path1, path2)
          for i = 1, k do
              local v1 = get_value(path1[i][1], path1[i][2])
              local v2 = get_value(path2[i][1], path2[i][2])
              if v1 < v2 then
                  return true
              elseif v1 > v2 then
                  return false
              end
          end
          return false
      end
      local function get_path(path)
          local result = {}
          for i = 1, k do
              result[i] = get_value(path[i][1], path[i][2])
          end
          return result
      end
      local function get_min_path(i, j, path)
          if #path == k then
              return path
          end
          local neighbors = get_neighbors(i, j)
          local min_path = nil
          for _, neighbor in ipairs(neighbors) do
              local new_path = {unpack(path)}
              new_path[#new_path + 1] = neighbor
              local path = get_min_path(neighbor[1], neighbor[2], new_path)
              if min_path == nil or compare(path, min_path) then
                  min_path = path
              end
          end
          return min_path
      end
      local min_path = nil
- |2-
      local n = #grid
      local dp = {}
      for i = 1, n do
          dp[i] = {}
          for j = 1, n do
              dp[i][j] = {}
          end
      end
      for i = 1, n do
          for j = 1, n do
              dp[i][j][1] = {grid[i][j]}
          end
      end
      for i = 1, n do
          for j = 1, n do
              for l = 2, k do
                  local min = nil
                  if i > 1 then
                      local t = dp[i - 1][j][l - 1]
                      if not min or t < min then
                          min = t
                      end
                  end
                  if i < n then
                      local t = dp[i + 1][j][l - 1]
                      if not min or t < min then
                          min = t
                      end
                  end
                  if j > 1 then
                      local t = dp[i][j - 1][l - 1]
                      if not min or t < min then
                          min = t
                      end
                  end
                  if j < n then
                      local t = dp[i][j + 1][l - 1]
                      if not min or t < min then
                          min = t
                      end
                  end
                  if min then
                      dp[i][j][l] = {grid[i][j]}
                      for _, v in ipairs(min) do
                          table.insert(dp[i][j][l], v)
                      end
                  end
              end
          end
      end
      local min = nil
      for i = 1, n do
          for j = 1, n do
              local t = dp[i][j][k]
              if t and (not min or t < min) then
                  min = t
              end
          end
      end
      return min
  end
- |2-
      local N = #grid
      local function get_neighbors(i, j)
          local res = {}
          if i > 1 then
              table.insert(res, {i - 1, j})
          end
          if i < N then
              table.insert(res, {i + 1, j})
          end
          if j > 1 then
              table.insert(res, {i, j - 1})
          end
          if j < N then
              table.insert(res, {i, j + 1})
          end
          return res
      end
      local function get_path(i, j, k)
          if k == 0 then
              return {}
          end
          local res = {}
          for _, n in ipairs(get_neighbors(i, j)) do
              local ni, nj = n[1], n[2]
              local path = get_path(ni, nj, k - 1)
              table.insert(path, 1, grid[ni][nj])
              table.insert(res, path)
          end
          table.sort(res, function(a, b)
              for i = 1, k do
                  if a[i] < b[i] then
                      return true
                  elseif a[i] > b[i] then
                      return false
                  end
              end
              return false
          end)
          return res[1]
      end
      local res = {}
      for i = 1, N do
          for j = 1, N do
              local path = get_path(i, j, k)
              table.insert(path, 1, grid[i][j])
              table.insert(res, path)
          end
      end
      table.sort(res, function(a, b)
          for i = 1, k + 1 do
              if a[i] < b[i] then
                  return true
              elseif a[i] > b[i] then
                  return false
              end
          end
          return false
      end)
      return res[1]
  end
- |2-
      local n = #grid
      local function get(x, y)
          return grid[x][y]
      end
      local function get_neighbors(x, y)
          local neighbors = {}
          if x > 1 then
              neighbors[#neighbors + 1] = {x - 1, y}
          end
          if x < n then
              neighbors[#neighbors + 1] = {x + 1, y}
          end
          if y > 1 then
              neighbors[#neighbors + 1] = {x, y - 1}
          end
          if y < n then
              neighbors[#neighbors + 1] = {x, y + 1}
          end
          return neighbors
      end
      local function get_path(x, y, k)
          if k == 0 then
              return {}
          end
          local min_path = nil
          for _, neighbor in ipairs(get_neighbors(x, y)) do
              local path = get_path(neighbor[1], neighbor[2], k - 1)
              if path then
                  path[#path + 1] = get(x, y)
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
          return min_path
      end
      local min_path = nil
      for i = 1, n do
          for j = 1, n do
              local path = get_path(i, j, k)
              if path then
                  path[#path + 1] = get(i, j)
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
      end
      return min_path
  end
- |2
      local n = #grid
      local dp = {}
      for i = 1, n do
          dp[i] = {}
          for j = 1, n do
              dp[i][j] = {}
          end
      end
      for i = 1, n do
          for j = 1, n do
              dp[i][j][1] = {grid[i][j]}
          end
      end
      for l = 2, k do
          for i = 1, n do
              for j = 1, n do
                  local min = nil
                  if i > 1 then
                      local t = {}
                      for _, v in ipairs(dp[i - 1][j][l - 1]) do
                          table.insert(t, v)
                      end
                      table.insert(t, grid[i][j])
                      if min == nil or t < min then
                          min = t
                      end
                  end
                  if i < n then
                      local t = {}
                      for _, v in ipairs(dp[i + 1][j][l - 1]) do
                          table.insert(t, v)
                      end
                      table.insert(t, grid[i][j])
                      if min == nil or t < min then
                          min = t
                      end
                  end
                  if j > 1 then
                      local t = {}
                      for _, v in ipairs(dp[i][j - 1][l - 1]) do
                          table.insert(t, v)
                      end
                      table.insert(t, grid[i][j])
                      if min == nil or t < min then
                          min = t
                      end
                  end
                  if j < n then
                      local t = {}
                      for _, v in ipairs(dp[i][j + 1][l - 1]) do
                          table.insert(t, v)
                      end
                      table.insert(t, grid[i][j])
                      if min == nil or t < min then
                          min = t
                      end
                  end
                  dp[i][j][l] = min
              end
          end
      end
      local min = nil
      for i = 1, n do
- |2-
      local n = #grid
      local function get(i, j)
          if i < 1 or i > n or j < 1 or j > n then
              return nil
          end
          return grid[i][j]
      end
      local function get_neighbors(i, j)
          local neighbors = {}
          for _, p in ipairs({{-1, 0}, {1, 0}, {0, -1}, {0, 1}}) do
              local x, y = i + p[1], j + p[2]
              local v = get(x, y)
              if v then
                  neighbors[v] = {x, y}
              end
          end
          return neighbors
      end
      local function get_min_path(i, j, k)
          if k == 0 then
              return {}
          end
          local neighbors = get_neighbors(i, j)
          local min_path = nil
          for v, p in pairs(neighbors) do
              local path = get_min_path(p[1], p[2], k - 1)
              if path then
                  table.insert(path, 1, v)
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
          return min_path
      end
      local min_path = nil
      for i = 1, n do
          for j = 1, n do
              local path = get_min_path(i, j, k)
              if path then
                  table.insert(path, 1, grid[i][j])
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
      end
      return min_path
  end
- |2-
      local N = #grid
      local dp = {}
      for i = 1, N do
          dp[i] = {}
          for j = 1, N do
              dp[i][j] = {}
          end
      end
      for i = 1, N do
          for j = 1, N do
              dp[i][j][1] = {grid[i][j]}
          end
      end
      for l = 2, k do
          for i = 1, N do
              for j = 1, N do
                  local min_path = nil
                  for _, dir in ipairs({{-1, 0}, {1, 0}, {0, -1}, {0, 1}}) do
                      local i1, j1 = i + dir[1], j + dir[2]
                      if i1 >= 1 and i1 <= N and j1 >= 1 and j1 <= N then
                          local path = dp[i1][j1][l - 1]
                          if not min_path or path < min_path then
                              min_path = path
                          end
                      end
                  end
                  if min_path then
                      dp[i][j][l] = {grid[i][j]}
                      for _, v in ipairs(min_path) do
                          table.insert(dp[i][j][l], v)
                      end
                  end
              end
          end
      end
      local min_path = nil
      for i = 1, N do
          for j = 1, N do
              local path = dp[i][j][k]
              if path and (not min_path or path < min_path) then
                  min_path = path
              end
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local function get_value(x, y)
          return grid[x][y]
      end
      local function get_neighbors(x, y)
          local neighbors = {}
          if x > 1 then
              neighbors[#neighbors + 1] = {x - 1, y}
          end
          if x < n then
              neighbors[#neighbors + 1] = {x + 1, y}
          end
          if y > 1 then
              neighbors[#neighbors + 1] = {x, y - 1}
          end
          if y < n then
              neighbors[#neighbors + 1] = {x, y + 1}
          end
          return neighbors
      end
      local function compare(a, b)
          for i = 1, k do
              if a[i] < b[i] then
                  return true
              elseif a[i] > b[i] then
                  return false
              end
          end
          return false
      end
      local function get_path(x, y, k)
          local path = {}
          for i = 1, k do
              path[i] = get_value(x, y)
              local neighbors = get_neighbors(x, y)
              local min_neighbor = neighbors[1]
              for j = 2, #neighbors do
                  if compare(neighbors[j], min_neighbor) then
                      min_neighbor = neighbors[j]
                  end
              end
              x, y = min_neighbor[1], min_neighbor[2]
          end
          return path
      end
      local min_path = get_path(1, 1, k)
      for i = 1, n do
          for j = 1, n do
              local path = get_path(i, j, k)
              if compare(path, min_path) then
                  min_path = path
              end
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local function get(i, j)
          if i < 1 or i > n or j < 1 or j > n then
              return nil
          end
          return grid[i][j]
      end
      local function get_min(i, j)
          local a = get(i - 1, j)
          local b = get(i + 1, j)
          local c = get(i, j - 1)
          local d = get(i, j + 1)
          if a == nil then
              a = math.huge
          end
          if b == nil then
              b = math.huge
          end
          if c == nil then
              c = math.huge
          end
          if d == nil then
              d = math.huge
          end
          return math.min(a, b, c, d)
      end
      local function get_min_path(i, j, k)
          if k == 0 then
              return {}
          end
          local a = get(i - 1, j)
          local b = get(i + 1, j)
          local c = get(i, j - 1)
          local d = get(i, j + 1)
          local min = get_min(i, j)
          if a == min then
              return {grid[i][j]} .. get_min_path(i - 1, j, k - 1)
          elseif b == min then
              return {grid[i][j]} .. get_min_path(i + 1, j, k - 1)
          elseif c == min then
              return {grid[i][j]} .. get_min_path(i, j - 1, k - 1)
          elseif d == min then
              return {grid[i][j]} .. get_min_path(i, j + 1, k - 1)
          end
      end
      local function get_min_path_from(i, j)
          local min = math.huge
          local path
          for k = 1, n * n do
              local p = get_min_path(i, j, k)
              if #p == k then
                  if
- |2-
      local n = #grid
      local function get(i, j)
          return grid[i][j]
      end
      local function get_neighbors(i, j)
          local neighbors = {}
          if i > 1 then
              neighbors[#neighbors + 1] = {i - 1, j}
          end
          if i < n then
              neighbors[#neighbors + 1] = {i + 1, j}
          end
          if j > 1 then
              neighbors[#neighbors + 1] = {i, j - 1}
          end
          if j < n then
              neighbors[#neighbors + 1] = {i, j + 1}
          end
          return neighbors
      end
      local function get_neighbors_values(i, j)
          local neighbors = get_neighbors(i, j)
          local values = {}
          for _, neighbor in ipairs(neighbors) do
              values[#values + 1] = get(neighbor[1], neighbor[2])
          end
          return values
      end
      local function get_min_neighbor(i, j)
          local neighbors = get_neighbors(i, j)
          local min_value = math.huge
          local min_neighbor = nil
          for _, neighbor in ipairs(neighbors) do
              local value = get(neighbor[1], neighbor[2])
              if value < min_value then
                  min_value = value
                  min_neighbor = neighbor
              end
          end
          return min_neighbor
      end
      local function get_min_path(i, j, k)
          if k == 1 then
              return {get(i, j)}
          end
          local min_neighbor = get_min_neighbor(i, j)
          local min_path = get_min_path(min_neighbor[1], min_neighbor[2], k - 1)
          min_path[#min_path + 1] = get(i, j)
          return min_path
      end
      local min_path = nil
      for i
- |2
      local n = #grid
      local visited = {}
      local function dfs(i, j, k, path)
          if k == 0 then
              return path
          end
          if i < 1 or i > n or j < 1 or j > n or visited[i][j] then
              return nil
          end
          visited[i][j] = true
          local min_path = nil
          local min_path_len = math.huge
          local path_len = #path
          for _, dir in ipairs({{0, 1}, {0, -1}, {1, 0}, {-1, 0}}) do
              local new_path = dfs(i + dir[1], j + dir[2], k - 1, path)
              if new_path then
                  local new_path_len = #new_path
                  if new_path_len < min_path_len then
                      min_path = new_path
                      min_path_len = new_path_len
                  elseif new_path_len == min_path_len then
                      for i = 1, new_path_len do
                          if new_path[i] < min_path[i] then
                              min_path = new_path
                              break
                          elseif new_path[i] > min_path[i] then
                              break
                          end
                      end
                  end
              end
          end
          visited[i][j] = false
          if min_path then
              min_path[path_len + 1] = grid[i][j]
          end
          return min_path
      end
      for i = 1, n do
          visited[i] = {}
      end
      local min_path = nil
      local min_path_len = math.huge
      for i = 1, n do
          for j = 1, n do
              local path = dfs(i, j, k, {})
              if path then
                  local path_len = #path
                  if path_len < min_path_len then
                      min_path = path
                      min_path_len = path_len
                  elseif path_len == min_path_len then
- |2-
      local n = #grid
      local function get(x, y)
          return grid[x][y]
      end
      local function get_neighbors(x, y)
          local neighbors = {}
          if x > 1 then
              neighbors[#neighbors + 1] = {x - 1, y}
          end
          if x < n then
              neighbors[#neighbors + 1] = {x + 1, y}
          end
          if y > 1 then
              neighbors[#neighbors + 1] = {x, y - 1}
          end
          if y < n then
              neighbors[#neighbors + 1] = {x, y + 1}
          end
          return neighbors
      end
      local function get_path(x, y, k)
          local path = {}
          for i = 1, k do
              path[i] = get(x, y)
              local neighbors = get_neighbors(x, y)
              local min_neighbor = neighbors[1]
              for _, neighbor in ipairs(neighbors) do
                  if get(neighbor[1], neighbor[2]) < get(min_neighbor[1], min_neighbor[2]) then
                      min_neighbor = neighbor
                  end
              end
              x, y = min_neighbor[1], min_neighbor[2]
          end
          return path
      end
      local min_path = get_path(1, 1, k)
      for i = 1, n do
          for j = 1, n do
              local path = get_path(i, j, k)
              if path < min_path then
                  min_path = path
              end
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local function get(i, j)
          return grid[i][j]
      end
      local function get_neighbors(i, j)
          local neighbors = {}
          if i > 1 then
              neighbors[#neighbors + 1] = {i - 1, j}
          end
          if i < n then
              neighbors[#neighbors + 1] = {i + 1, j}
          end
          if j > 1 then
              neighbors[#neighbors + 1] = {i, j - 1}
          end
          if j < n then
              neighbors[#neighbors + 1] = {i, j + 1}
          end
          return neighbors
      end
      local function get_path(i, j, k)
          local path = {}
          local function dfs(i, j, k)
              if k == 0 then
                  return true
              end
              for _, neighbor in ipairs(get_neighbors(i, j)) do
                  local ni, nj = neighbor[1], neighbor[2]
                  if not path[ni] or not path[ni][nj] then
                      path[ni] = path[ni] or {}
                      path[ni][nj] = true
                      if dfs(ni, nj, k - 1) then
                          return true
                      end
                      path[ni][nj] = nil
                  end
              end
              return false
          end
          dfs(i, j, k)
          return path
      end
      local function get_path_value(path)
          local value = {}
          for i = 1, n do
              for j = 1, n do
                  if path[i] and path[i][j] then
                      value[#value + 1] = get(i, j)
                  end
              end
          end
          return value
      end
      local min_path = nil
      for i = 1, n do
          for j = 1, n do
              local path = get_path(i, j, k)
              local value = get_path_value(path)
              if not min_path or value < min_
- |2
      local n = #grid
      local function get_neighbors(i, j)
          local neighbors = {}
          if i > 1 then
              neighbors[#neighbors + 1] = {i - 1, j}
          end
          if i < n then
              neighbors[#neighbors + 1] = {i + 1, j}
          end
          if j > 1 then
              neighbors[#neighbors + 1] = {i, j - 1}
          end
          if j < n then
              neighbors[#neighbors + 1] = {i, j + 1}
          end
          return neighbors
      end
      local function get_path(i, j, k)
          local path = {}
          local function dfs(i, j, k)
              if k == 0 then
                  return true
              end
              local neighbors = get_neighbors(i, j)
              for _, neighbor in ipairs(neighbors) do
                  local ni, nj = neighbor[1], neighbor[2]
                  if not visited[ni][nj] then
                      visited[ni][nj] = true
                      path[#path + 1] = grid[ni][nj]
                      if dfs(ni, nj, k - 1) then
                          return true
                      end
                      visited[ni][nj] = false
                      path[#path] = nil
                  end
              end
              return false
          end
          dfs(i, j, k)
          return path
      end
      local min_path = {}
      local visited = {}
      for i = 1, n do
          visited[i] = {}
      end
      for i = 1, n do
          for j = 1, n do
              visited[i][j] = true
              local path = get_path(i, j, k - 1)
              if #path > 0 then
                  path[#path + 1] = grid[i][j]
                  if #min_path == 0 or path < min_path then
                      min_path = path
                  end
              end
              visited[i][j] = false
          end
      end
      return min_path
- |2-
      local function get_neighbors(grid, i, j)
          local neighbors = {}
          if i > 1 then
              table.insert(neighbors, {i - 1, j})
          end
          if i < #grid then
              table.insert(neighbors, {i + 1, j})
          end
          if j > 1 then
              table.insert(neighbors, {i, j - 1})
          end
          if j < #grid then
              table.insert(neighbors, {i, j + 1})
          end
          return neighbors
      end
      local function get_paths(grid, i, j, k)
          local paths = {}
          if k == 1 then
              table.insert(paths, {grid[i][j]})
          else
              for _, neighbor in ipairs(get_neighbors(grid, i, j)) do
                  local i_neighbor, j_neighbor = neighbor[1], neighbor[2]
                  for _, path in ipairs(get_paths(grid, i_neighbor, j_neighbor, k - 1)) do
                      table.insert(paths, {grid[i][j]})
                      table.insert(paths[#paths], path)
                  end
              end
          end
          return paths
      end
      local function compare_paths(path_a, path_b)
          for i = 1, #path_a do
              if path_a[i] < path_b[i] then
                  return true
              elseif path_a[i] > path_b[i] then
                  return false
              end
          end
          return false
      end
      local min_path = {}
      for i = 1, #grid do
          for j = 1, #grid do
              for _, path in ipairs(get_paths(grid, i, j, k)) do
                  if #min_path == 0 or compare_paths(path, min_path) then
                      min_path = path
                  end
              end
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local function get(x, y)
          return grid[x][y]
      end
      local function get_neighbors(x, y)
          local neighbors = {}
          if x > 1 then
              neighbors[#neighbors + 1] = {x = x - 1, y = y}
          end
          if x < n then
              neighbors[#neighbors + 1] = {x = x + 1, y = y}
          end
          if y > 1 then
              neighbors[#neighbors + 1] = {x = x, y = y - 1}
          end
          if y < n then
              neighbors[#neighbors + 1] = {x = x, y = y + 1}
          end
          return neighbors
      end
      local function get_path(x, y, k)
          if k == 0 then
              return {}
          end
          local neighbors = get_neighbors(x, y)
          local min_path = nil
          for _, neighbor in ipairs(neighbors) do
              local path = get_path(neighbor.x, neighbor.y, k - 1)
              if path then
                  path[#path + 1] = get(x, y)
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
          return min_path
      end
      local min_path = nil
      for i = 1, n do
          for j = 1, n do
              local path = get_path(i, j, k)
              if path then
                  path[#path + 1] = get(i, j)
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local m = {}
      for i = 1, n do
          m[i] = {}
          for j = 1, n do
              m[i][j] = {}
          end
      end
      for i = 1, n do
          for j = 1, n do
              m[i][j][1] = {grid[i][j]}
          end
      end
      for l = 2, k do
          for i = 1, n do
              for j = 1, n do
                  local t = {}
                  if i > 1 then
                      table.insert(t, m[i - 1][j][l - 1])
                  end
                  if i < n then
                      table.insert(t, m[i + 1][j][l - 1])
                  end
                  if j > 1 then
                      table.insert(t, m[i][j - 1][l - 1])
                  end
                  if j < n then
                      table.insert(t, m[i][j + 1][l - 1])
                  end
                  table.sort(t, function(a, b)
                      for i = 1, #a do
                          if a[i] < b[i] then
                              return true
                          elseif a[i] > b[i] then
                              return false
                          end
                      end
                      return false
                  end)
                  m[i][j][l] = t[1]
              end
          end
      end
      return m[1][1][k]
  end
- |2-
      local n = #grid
      local dp = {}
      for i = 1, n do
          dp[i] = {}
          for j = 1, n do
              dp[i][j] = {}
          end
      end
      for i = 1, n do
          for j = 1, n do
              dp[i][j][1] = {grid[i][j]}
          end
      end
      for l = 2, k do
          for i = 1, n do
              for j = 1, n do
                  local min_path = nil
                  if i > 1 then
                      local path = dp[i - 1][j][l - 1]
                      if not min_path or path < min_path then
                          min_path = path
                      end
                  end
                  if i < n then
                      local path = dp[i + 1][j][l - 1]
                      if not min_path or path < min_path then
                          min_path = path
                      end
                  end
                  if j > 1 then
                      local path = dp[i][j - 1][l - 1]
                      if not min_path or path < min_path then
                          min_path = path
                      end
                  end
                  if j < n then
                      local path = dp[i][j + 1][l - 1]
                      if not min_path or path < min_path then
                          min_path = path
                      end
                  end
                  dp[i][j][l] = {grid[i][j]}
                  for _, v in ipairs(min_path) do
                      table.insert(dp[i][j][l], v)
                  end
              end
          end
      end
      local min_path = nil
      for i = 1, n do
          for j = 1, n do
              local path = dp[i][j][k]
              if not min_path or path < min_path then
                  min_path = path
              end
          end
      end
      return min_path
  end
- |2-
      -- your code here
      return {}
  end
- |2-
      local n = #grid
      local function get(i, j)
          return grid[i][j]
      end
      local function get_neighbors(i, j)
          local neighbors = {}
          if i > 1 then
              neighbors[#neighbors + 1] = {i - 1, j}
          end
          if i < n then
              neighbors[#neighbors + 1] = {i + 1, j}
          end
          if j > 1 then
              neighbors[#neighbors + 1] = {i, j - 1}
          end
          if j < n then
              neighbors[#neighbors + 1] = {i, j + 1}
          end
          return neighbors
      end
      local function get_path(i, j, k)
          if k == 0 then
              return {get(i, j)}
          end
          local min_path = nil
          for _, neighbor in ipairs(get_neighbors(i, j)) do
              local path = get_path(neighbor[1], neighbor[2], k - 1)
              if min_path == nil or path < min_path then
                  min_path = path
              end
          end
          return {get(i, j)} .. min_path
      end
      local min_path = nil
      for i = 1, n do
          for j = 1, n do
              local path = get_path(i, j, k)
              if min_path == nil or path < min_path then
                  min_path = path
              end
          end
      end
      return min_path
  end
- |2
      local n = #grid
      local function get(x, y)
          return grid[x][y]
      end
      local function get_neighbors(x, y)
          local res = {}
          if x > 1 then
              res[#res + 1] = {x - 1, y}
          end
          if x < n then
              res[#res + 1] = {x + 1, y}
          end
          if y > 1 then
              res[#res + 1] = {x, y - 1}
          end
          if y < n then
              res[#res + 1] = {x, y + 1}
          end
          return res
      end
      local function get_path(x, y, k)
          local res = {}
          local function dfs(x, y, k)
              if k == 0 then
                  return true
              end
              for _, n in ipairs(get_neighbors(x, y)) do
                  local nx, ny = n[1], n[2]
                  if not visited[nx][ny] then
                      visited[nx][ny] = true
                      res[#res + 1] = get(nx, ny)
                      if dfs(nx, ny, k - 1) then
                          return true
                      end
                      visited[nx][ny] = false
                      res[#res] = nil
                  end
              end
              return false
          end
          dfs(x, y, k)
          return res
      end
      local visited = {}
      for i = 1, n do
          visited[i] = {}
      end
      local res = {}
      for i = 1, n do
          for j = 1, n do
              visited[i][j] = true
              local path = get_path(i, j, k - 1)
              if #path > 0 then
                  path[#path + 1] = get(i, j)
                  if #res == 0 or path < res then
                      res = path
                  end
              end
              visited[i][j] = false
          end
      end
      return res
  end
- |2-
      local n = #grid
      local function get(x, y)
          return grid[x][y]
      end
      local function get_neighbors(x, y)
          local neighbors = {}
          if x > 1 then
              neighbors[#neighbors + 1] = {x - 1, y}
          end
          if x < n then
              neighbors[#neighbors + 1] = {x + 1, y}
          end
          if y > 1 then
              neighbors[#neighbors + 1] = {x, y - 1}
          end
          if y < n then
              neighbors[#neighbors + 1] = {x, y + 1}
          end
          return neighbors
      end
      local function compare(a, b)
          for i = 1, k do
              if a[i] < b[i] then
                  return true
              elseif a[i] > b[i] then
                  return false
              end
          end
          return false
      end
      local function get_min_path(x, y, k)
          if k == 1 then
              return {get(x, y)}
          end
          local min_path = nil
          for _, neighbor in ipairs(get_neighbors(x, y)) do
              local path = get_min_path(neighbor[1], neighbor[2], k - 1)
              path[#path + 1] = get(x, y)
              if min_path == nil or compare(path, min_path) then
                  min_path = path
              end
          end
          return min_path
      end
      return get_min_path(1, 1, k)
  end
- |2-
      local n = #grid
      local function isValid(x, y)
          return x >= 1 and x <= n and y >= 1 and y <= n
      end
      local function getValue(x, y)
          return grid[x][y]
      end
      local function getNeighbors(x, y)
          local neighbors = {}
          if isValid(x - 1, y) then
              neighbors[#neighbors + 1] = {x - 1, y}
          end
          if isValid(x + 1, y) then
              neighbors[#neighbors + 1] = {x + 1, y}
          end
          if isValid(x, y - 1) then
              neighbors[#neighbors + 1] = {x, y - 1}
          end
          if isValid(x, y + 1) then
              neighbors[#neighbors + 1] = {x, y + 1}
          end
          return neighbors
      end
      local function compare(path1, path2)
          for i = 1, k do
              if path1[i] < path2[i] then
                  return true
              elseif path1[i] > path2[i] then
                  return false
              end
          end
          return false
      end
      local function dfs(x, y, path, visited)
          if #path == k then
              return path
          end
          local neighbors = getNeighbors(x, y)
          local minPath = nil
          for _, neighbor in ipairs(neighbors) do
              local nx, ny = neighbor[1], neighbor[2]
              if not visited[nx][ny] then
                  visited[nx][ny] = true
                  local newPath = dfs(nx, ny, {unpack(path), getValue(nx, ny)}, visited)
                  if not minPath or compare(newPath, minPath) then
                      minPath = newPath
                  end
                  visited[nx][ny] = false
              end
          end
          return minPath
      end
      local minPath = nil
      for i = 1, n do
          for j = 1,
- |2-
      local n = #grid
      local m = #grid[1]
      local dp = {}
      for i = 1, n do
          dp[i] = {}
          for j = 1, m do
              dp[i][j] = {}
          end
      end
      for i = 1, n do
          for j = 1, m do
              dp[i][j][1] = {grid[i][j]}
          end
      end
      for l = 2, k do
          for i = 1, n do
              for j = 1, m do
                  local min = {}
                  if i > 1 then
                      min = dp[i - 1][j][l - 1]
                  end
                  if j > 1 and #dp[i][j - 1][l - 1] < #min then
                      min = dp[i][j - 1][l - 1]
                  end
                  if i < n and #dp[i + 1][j][l - 1] < #min then
                      min = dp[i + 1][j][l - 1]
                  end
                  if j < m and #dp[i][j + 1][l - 1] < #min then
                      min = dp[i][j + 1][l - 1]
                  end
                  dp[i][j][l] = {grid[i][j]}
                  for _, v in ipairs(min) do
                      table.insert(dp[i][j][l], v)
                  end
              end
          end
      end
      local min = dp[1][1][k]
      for i = 1, n do
          for j = 1, m do
              if #dp[i][j][k] < #min then
                  min = dp[i][j][k]
              end
          end
      end
      return min
  end
- |2-
      local n = #grid
      local function get(x, y)
          return grid[x][y]
      end
      local function set(x, y, v)
          grid[x][y] = v
      end
      local function get_neighbors(x, y)
          local neighbors = {}
          if x > 1 then
              neighbors[#neighbors + 1] = {x - 1, y}
          end
          if x < n then
              neighbors[#neighbors + 1] = {x + 1, y}
          end
          if y > 1 then
              neighbors[#neighbors + 1] = {x, y - 1}
          end
          if y < n then
              neighbors[#neighbors + 1] = {x, y + 1}
          end
          return neighbors
      end
      local function get_neighbors_values(x, y)
          local neighbors = get_neighbors(x, y)
          local values = {}
          for _, v in ipairs(neighbors) do
              values[#values + 1] = get(v[1], v[2])
          end
          return values
      end
      local function get_min_neighbor(x, y)
          local neighbors = get_neighbors(x, y)
          local min_value = math.huge
          local min_neighbor = nil
          for _, v in ipairs(neighbors) do
              local value = get(v[1], v[2])
              if value < min_value then
                  min_value = value
                  min_neighbor = v
              end
          end
          return min_neighbor
      end
      local function get_min_neighbor_value(x, y)
          local min_neighbor = get_min_neighbor(x, y)
          return get(min_neighbor[1], min_neighbor[2])
      end
      local function get_min_neighbor_values(x, y)
          local neighbors = get_neighbors(x, y)
          local min_value = math.huge
          local min
- |2-
      local n = #grid
      local function get(x, y)
          return grid[x][y]
      end
      local function set(x, y, v)
          grid[x][y] = v
      end
      local function get_neighbors(x, y)
          local neighbors = {}
          if x > 1 then
              neighbors[#neighbors + 1] = {x - 1, y}
          end
          if x < n then
              neighbors[#neighbors + 1] = {x + 1, y}
          end
          if y > 1 then
              neighbors[#neighbors + 1] = {x, y - 1}
          end
          if y < n then
              neighbors[#neighbors + 1] = {x, y + 1}
          end
          return neighbors
      end
      local function get_path(x, y)
          local path = {}
          while x ~= nil do
              path[#path + 1] = get(x, y)
              x, y = get(x, y + n)
          end
          return path
      end
      local function set_path(x, y, path)
          for i = 1, #path do
              set(x, y, path[i])
              set(x, y + n, x)
              x, y = get(x, y + n)
          end
      end
      local function get_min_path(x, y)
          local min_path = get_path(x, y)
          for _, neighbor in ipairs(get_neighbors(x, y)) do
              local path = get_path(neighbor[1], neighbor[2])
              if #path < #min_path then
                  min_path = path
              elseif #path == #min_path then
                  for i = 1, #path do
                      if path[i] < min_path[i] then
                          min_path = path
                          break
                      elseif path[i] > min_path[i] then
                          break
                      end
                  end
              end
          end
          return min_path
      end
      local function set_min
- |2-
      local N = #grid
      local function get(x, y)
          if x < 1 or x > N or y < 1 or y > N then
              return nil
          end
          return grid[x][y]
      end
      local function getNeighbors(x, y)
          local neighbors = {}
          for i = -1, 1 do
              for j = -1, 1 do
                  if i ~= 0 or j ~= 0 then
                      local neighbor = get(x + i, y + j)
                      if neighbor then
                          table.insert(neighbors, neighbor)
                      end
                  end
              end
          end
          return neighbors
      end
      local function getMinPath(x, y, k)
          local minPath = {}
          local minPathValue = math.huge
          local function dfs(x, y, k, path, pathValue)
              if k == 0 then
                  if pathValue < minPathValue then
                      minPath = path
                      minPathValue = pathValue
                  end
                  return
              end
              for _, neighbor in ipairs(getNeighbors(x, y)) do
                  local newPath = table.copy(path)
                  table.insert(newPath, neighbor)
                  local newPathValue = pathValue * 10 + neighbor
                  dfs(x, y, k - 1, newPath, newPathValue)
              end
          end
          dfs(x, y, k, {}, 0)
          return minPath
      end
      local minPath = {}
      local minPathValue = math.huge
      for i = 1, N do
          for j = 1, N do
              local path = getMinPath(i, j, k)
              local pathValue = 0
              for _, value in ipairs(path) do
                  pathValue = pathValue * 10 + value
              end
              if pathValue < minPathValue then
                  minPath = path
                  minPathValue = pathValue
              end
          end
      end
      return minPath
  end
- |2-
      local n = #grid
      local function get(x, y)
          return grid[x][y]
      end
      local function get_neighbors(x, y)
          local neighbors = {}
          if x > 1 then
              neighbors[#neighbors + 1] = {x - 1, y}
          end
          if x < n then
              neighbors[#neighbors + 1] = {x + 1, y}
          end
          if y > 1 then
              neighbors[#neighbors + 1] = {x, y - 1}
          end
          if y < n then
              neighbors[#neighbors + 1] = {x, y + 1}
          end
          return neighbors
      end
      local function compare(a, b)
          for i = 1, k do
              if a[i] < b[i] then
                  return true
              elseif a[i] > b[i] then
                  return false
              end
          end
          return false
      end
      local function dfs(x, y, k, path)
          if k == 0 then
              return path
          end
          local neighbors = get_neighbors(x, y)
          local min_path = nil
          for _, neighbor in ipairs(neighbors) do
              local new_path = dfs(neighbor[1], neighbor[2], k - 1, path)
              if min_path == nil or compare(new_path, min_path) then
                  min_path = new_path
              end
          end
          return min_path
      end
      local min_path = nil
      for i = 1, n do
          for j = 1, n do
              local path = dfs(i, j, k, {get(i, j)})
              if min_path == nil or compare(path, min_path) then
                  min_path = path
              end
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local function get_neighbors(i, j)
          local neighbors = {}
          if i > 1 then
              neighbors[#neighbors + 1] = {i - 1, j}
          end
          if i < n then
              neighbors[#neighbors + 1] = {i + 1, j}
          end
          if j > 1 then
              neighbors[#neighbors + 1] = {i, j - 1}
          end
          if j < n then
              neighbors[#neighbors + 1] = {i, j + 1}
          end
          return neighbors
      end
      local function get_path(i, j, k)
          if k == 0 then
              return {}
          end
          local min_path = nil
          for _, neighbor in ipairs(get_neighbors(i, j)) do
              local path = get_path(neighbor[1], neighbor[2], k - 1)
              if path then
                  path[#path + 1] = grid[i][j]
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
          return min_path
      end
      local min_path = nil
      for i = 1, n do
          for j = 1, n do
              local path = get_path(i, j, k)
              if path then
                  path[#path + 1] = grid[i][j]
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
      end
      return min_path
  end
- |2-
    local n = #grid
    local function get(x, y)
      if x < 1 or x > n or y < 1 or y > n then
        return nil
      end
      return grid[x][y]
    end
    local function get_min(x, y, k)
      if k == 0 then
        return {}, 0
      end
      local min_path, min_val = nil, math.huge
      for i = -1, 1 do
        for j = -1, 1 do
          if i ~= 0 or j ~= 0 then
            local val = get(x + i, y + j)
            if val then
              local path, val = get_min(x + i, y + j, k - 1)
              if val < min_val then
                min_path, min_val = {val, unpack(path)}, val
              end
            end
          end
        end
      end
      return min_path, min_val
    end
    local min_path, min_val = nil, math.huge
    for i = 1, n do
      for j = 1, n do
        local path, val = get_min(i, j, k)
        if val < min_val then
          min_path, min_val = {get(i, j), unpack(path)}, val
        end
      end
    end
    return min_path
  end
- |2-
      local N = #grid
      local function get_neighbors(x, y)
          local neighbors = {}
          if x > 1 then
              neighbors[#neighbors + 1] = {x - 1, y}
          end
          if x < N then
              neighbors[#neighbors + 1] = {x + 1, y}
          end
          if y > 1 then
              neighbors[#neighbors + 1] = {x, y - 1}
          end
          if y < N then
              neighbors[#neighbors + 1] = {x, y + 1}
          end
          return neighbors
      end
      local function get_path(x, y, k)
          if k == 0 then
              return {}
          end
          local neighbors = get_neighbors(x, y)
          local min_path = nil
          for _, neighbor in ipairs(neighbors) do
              local path = get_path(neighbor[1], neighbor[2], k - 1)
              if path then
                  path[#path + 1] = grid[x][y]
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
          return min_path
      end
      local min_path = nil
      for i = 1, N do
          for j = 1, N do
              local path = get_path(i, j, k)
              if path then
                  path[#path + 1] = grid[i][y]
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local function get_neighbors(i, j)
          local neighbors = {}
          if i > 1 then
              neighbors[#neighbors + 1] = {i - 1, j}
          end
          if i < n then
              neighbors[#neighbors + 1] = {i + 1, j}
          end
          if j > 1 then
              neighbors[#neighbors + 1] = {i, j - 1}
          end
          if j < n then
              neighbors[#neighbors + 1] = {i, j + 1}
          end
          return neighbors
      end
      local function get_path(i, j, k)
          local path = {}
          local function dfs(i, j, k)
              if k == 0 then
                  return true
              end
              for _, neighbor in ipairs(get_neighbors(i, j)) do
                  local ni, nj = neighbor[1], neighbor[2]
                  if not path[ni] or not path[ni][nj] then
                      path[ni] = path[ni] or {}
                      path[ni][nj] = true
                      if dfs(ni, nj, k - 1) then
                          return true
                      end
                      path[ni][nj] = nil
                  end
              end
              return false
          end
          path[i] = {}
          path[i][j] = true
          dfs(i, j, k - 1)
          return path
      end
      local function get_path_values(path)
          local values = {}
          for i, row in ipairs(path) do
              for j, _ in pairs(row) do
                  values[#values + 1] = grid[i][j]
              end
          end
          return values
      end
      local function compare_paths(path1, path2)
          local values1 = get_path_values(path1)
          local values2 = get_path_values(path2)
          for i = 1, #values1 do
              if values1[i] < values2[i] then
                  return true
              elseif
- |2-
      local n = #grid
      local function get_cell(i, j)
          return grid[i][j]
      end
      local function get_neighbors(i, j)
          local neighbors = {}
          if i > 1 then
              neighbors[#neighbors + 1] = {i - 1, j}
          end
          if i < n then
              neighbors[#neighbors + 1] = {i + 1, j}
          end
          if j > 1 then
              neighbors[#neighbors + 1] = {i, j - 1}
          end
          if j < n then
              neighbors[#neighbors + 1] = {i, j + 1}
          end
          return neighbors
      end
      local function get_path(i, j, k)
          if k == 0 then
              return {}
          end
          local min_path = nil
          for _, neighbor in ipairs(get_neighbors(i, j)) do
              local path = {get_cell(i, j)}
              for _, value in ipairs(get_path(unpack(neighbor), k - 1)) do
                  path[#path + 1] = value
              end
              if min_path == nil or path < min_path then
                  min_path = path
              end
          end
          return min_path
      end
      local min_path = nil
      for i = 1, n do
          for j = 1, n do
              local path = {get_cell(i, j)}
              for _, value in ipairs(get_path(i, j, k - 1)) do
                  path[#path + 1] = value
              end
              if min_path == nil or path < min_path then
                  min_path = path
              end
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local function get_neighbors(x, y)
          local neighbors = {}
          if x > 1 then
              neighbors[#neighbors + 1] = {x - 1, y}
          end
          if x < n then
              neighbors[#neighbors + 1] = {x + 1, y}
          end
          if y > 1 then
              neighbors[#neighbors + 1] = {x, y - 1}
          end
          if y < n then
              neighbors[#neighbors + 1] = {x, y + 1}
          end
          return neighbors
      end
      local function get_path(x, y, k)
          if k == 0 then
              return {}
          end
          local min_path = nil
          for _, neighbor in ipairs(get_neighbors(x, y)) do
              local path = get_path(neighbor[1], neighbor[2], k - 1)
              if path then
                  path[#path + 1] = grid[x][y]
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
          return min_path
      end
      local min_path = nil
      for i = 1, n do
          for j = 1, n do
              local path = get_path(i, j, k)
              if path then
                  path[#path + 1] = grid[i][y]
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
      end
      return min_path
  end
- |2-
    local n = #grid
    local function get(x, y)
      return grid[x][y]
    end
    local function get_neighbors(x, y)
      local neighbors = {}
      if x > 1 then
        neighbors[#neighbors + 1] = {x - 1, y}
      end
      if x < n then
        neighbors[#neighbors + 1] = {x + 1, y}
      end
      if y > 1 then
        neighbors[#neighbors + 1] = {x, y - 1}
      end
      if y < n then
        neighbors[#neighbors + 1] = {x, y + 1}
      end
      return neighbors
    end
    local function compare(a, b)
      for i = 1, k do
        if a[i] < b[i] then
          return true
        elseif a[i] > b[i] then
          return false
        end
      end
      return false
    end
    local function dfs(x, y, k, path)
      if k == 0 then
        return path
      end
      local min_path = nil
      for _, neighbor in ipairs(get_neighbors(x, y)) do
        local new_path = dfs(neighbor[1], neighbor[2], k - 1, path)
        if not min_path or compare(new_path, min_path) then
          min_path = new_path
        end
      end
      return min_path
    end
    local min_path = nil
    for i = 1, n do
      for j = 1, n do
        local new_path = dfs(i, j, k, {get(i, j)})
        if not min_path or compare(new_path, min_path) then
          min_path = new_path
        end
      end
    end
    return min_path
  end
- |2-
      local n = #grid
      local function get(i, j)
          if i < 1 or i > n or j < 1 or j > n then
              return math.huge
          end
          return grid[i][j]
      end
      local function get_path(i, j, k)
          if k == 0 then
              return {}
          end
          local v = get(i, j)
          local l = get_path(i - 1, j, k - 1)
          local r = get_path(i + 1, j, k - 1)
          local u = get_path(i, j - 1, k - 1)
          local d = get_path(i, j + 1, k - 1)
          local min_path
          local min_value = math.huge
          for _, path in ipairs({l, r, u, d}) do
              local value = v
              for _, x in ipairs(path) do
                  value = value * 10 + x
              end
              if value < min_value then
                  min_value = value
                  min_path = path
              end
          end
          return {v, unpack(min_path)}
      end
      return get_path(1, 1, k)
  end
- |2-
      local n = #grid
      local function get_val(i, j)
          return grid[i][j]
      end
      local function get_neighbors(i, j)
          local neighbors = {}
          if i > 1 then
              neighbors[#neighbors + 1] = {i - 1, j}
          end
          if i < n then
              neighbors[#neighbors + 1] = {i + 1, j}
          end
          if j > 1 then
              neighbors[#neighbors + 1] = {i, j - 1}
          end
          if j < n then
              neighbors[#neighbors + 1] = {i, j + 1}
          end
          return neighbors
      end
      local function get_path(i, j, k)
          if k == 0 then
              return {}
          end
          local min_path = nil
          for _, neighbor in ipairs(get_neighbors(i, j)) do
              local path = get_path(neighbor[1], neighbor[2], k - 1)
              if path then
                  path[#path + 1] = get_val(i, j)
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
          return min_path
      end
      local min_path = nil
      for i = 1, n do
          for j = 1, n do
              local path = get_path(i, j, k)
              if path then
                  path[#path + 1] = get_val(i, j)
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local function get(x, y)
          return grid[x][y]
      end
      local function set(x, y, value)
          grid[x][y] = value
      end
      local function get_neighbors(x, y)
          local neighbors = {}
          if x > 1 then
              neighbors[#neighbors + 1] = {x - 1, y}
          end
          if x < n then
              neighbors[#neighbors + 1] = {x + 1, y}
          end
          if y > 1 then
              neighbors[#neighbors + 1] = {x, y - 1}
          end
          if y < n then
              neighbors[#neighbors + 1] = {x, y + 1}
          end
          return neighbors
      end
      local function get_path(x, y)
          local path = {}
          local function dfs(x, y)
              path[#path + 1] = get(x, y)
              if #path == k then
                  return
              end
              for _, neighbor in ipairs(get_neighbors(x, y)) do
                  local nx, ny = unpack(neighbor)
                  if get(nx, ny) < get(x, y) then
                      dfs(nx, ny)
                      if #path == k then
                          return
                      end
                  end
              end
              path[#path] = nil
          end
          dfs(x, y)
          return path
      end
      local function get_min_path()
          local min_path = {}
          for i = 1, n do
              for j = 1, n do
                  local path = get_path(i, j)
                  if #path > 0 then
                      if #min_path == 0 or path < min_path then
                          min_path = path
                      end
                  end
              end
          end
          return min_path
      end
      return get_min_path()
  end
- |2-
      local n = #grid
      local m = #grid[1]
      local function get(x, y)
          if x < 1 or x > n or y < 1 or y > m then
              return math.huge
          end
          return grid[x][y]
      end
      local function get_neighbors(x, y)
          return {
              {x - 1, y},
              {x + 1, y},
              {x, y - 1},
              {x, y + 1}
          }
      end
      local function cmp(a, b)
          for i = 1, k do
              if a[i] < b[i] then
                  return true
              elseif a[i] > b[i] then
                  return false
              end
          end
          return false
      end
      local function get_path(x, y, k)
          local path = {get(x, y)}
          local min_path = path
          for _ = 1, k - 1 do
              local min_val = math.huge
              local min_x, min_y
              for _, neighbor in ipairs(get_neighbors(x, y)) do
                  local nx, ny = neighbor[1], neighbor[2]
                  local val = get(nx, ny)
                  if val < min_val then
                      min_val = val
                      min_x, min_y = nx, ny
                  end
              end
              x, y = min_x, min_y
              path[#path + 1] = min_val
              if cmp(path, min_path) then
                  min_path = path
              end
          end
          return min_path
      end
      local min_path = get_path(1, 1, k)
      for i = 1, n do
          for j = 1, m do
              local path = get_path(i, j, k)
              if cmp(path, min_path) then
                  min_path = path
              end
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local m = #grid[1]
      local dp = {}
      for i = 1, n do
          dp[i] = {}
          for j = 1, m do
              dp[i][j] = {}
          end
      end
      local function get(i, j, l)
          if i < 1 or i > n or j < 1 or j > m then
              return nil
          end
          if l == 1 then
              return {grid[i][j]}
          end
          if dp[i][j][l] then
              return dp[i][j][l]
          end
          local res = nil
          local t = get(i - 1, j, l - 1)
          if t and (not res or t < res) then
              res = t
          end
          t = get(i + 1, j, l - 1)
          if t and (not res or t < res) then
              res = t
          end
          t = get(i, j - 1, l - 1)
          if t and (not res or t < res) then
              res = t
          end
          t = get(i, j + 1, l - 1)
          if t and (not res or t < res) then
              res = t
          end
          if res then
              res = {grid[i][j]} .. res
          end
          dp[i][j][l] = res
          return res
      end
      return get(1, 1, k)
  end
- |2-
      -- your code here
  end
- |2-
      local n = #grid
      local function get(x, y)
          if x < 1 or x > n or y < 1 or y > n then
              return math.huge
          end
          return grid[x][y]
      end
      local function cmp(a, b)
          return a[1] < b[1]
      end
      local function dfs(x, y, k, path)
          if k == 0 then
              table.insert(path, get(x, y))
              table.sort(path, cmp)
              return path
          end
          local min_path = nil
          for _, d in ipairs({{-1, 0}, {1, 0}, {0, -1}, {0, 1}}) do
              local nx, ny = x + d[1], y + d[2]
              local path = dfs(nx, ny, k - 1, {get(x, y)})
              if min_path == nil or cmp(path, min_path) then
                  min_path = path
              end
          end
          return min_path
      end
      return dfs(1, 1, k, {})
  end
- |2-
      local n = #grid
      local function get(x, y)
          return grid[x][y]
      end
      local function get_neighbors(x, y)
          local neighbors = {}
          if x > 1 then
              neighbors[#neighbors + 1] = {x - 1, y}
          end
          if x < n then
              neighbors[#neighbors + 1] = {x + 1, y}
          end
          if y > 1 then
              neighbors[#neighbors + 1] = {x, y - 1}
          end
          if y < n then
              neighbors[#neighbors + 1] = {x, y + 1}
          end
          return neighbors
      end
      local function get_path(x, y, k)
          local path = {}
          local function dfs(x, y, k)
              if k == 0 then
                  return true
              end
              for _, neighbor in ipairs(get_neighbors(x, y)) do
                  local nx, ny = neighbor[1], neighbor[2]
                  if not path[nx] or not path[nx][ny] then
                      path[nx] = path[nx] or {}
                      path[nx][ny] = true
                      if dfs(nx, ny, k - 1) then
                          return true
                      end
                      path[nx][ny] = nil
                  end
              end
              return false
          end
          if dfs(x, y, k) then
              local lst = {}
              for x, row in pairs(path) do
                  for y in pairs(row) do
                      lst[#lst + 1] = get(x, y)
                  end
              end
              return lst
          end
      end
      local min_path = nil
      for x = 1, n do
          for y = 1, n do
              local path = get_path(x, y, k)
              if path then
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
      end
      return min_path
- |2-
      local n = #grid
      local function get_neighbors(i, j)
          local res = {}
          if i > 1 then
              table.insert(res, {i - 1, j})
          end
          if i < n then
              table.insert(res, {i + 1, j})
          end
          if j > 1 then
              table.insert(res, {i, j - 1})
          end
          if j < n then
              table.insert(res, {i, j + 1})
          end
          return res
      end
      local function get_path(i, j, k)
          if k == 0 then
              return {}
          end
          local res = {}
          for _, n in ipairs(get_neighbors(i, j)) do
              local path = get_path(n[1], n[2], k - 1)
              if #path == k - 1 then
                  table.insert(path, 1, grid[i][j])
                  if #res == 0 or path < res then
                      res = path
                  end
              end
          end
          return res
      end
      local res = {}
      for i = 1, n do
          for j = 1, n do
              local path = get_path(i, j, k)
              if #path == k then
                  if #res == 0 or path < res then
                      res = path
                  end
              end
          end
      end
      return res
  end
- |2-
      local n = #grid
      local function get(x, y)
          return grid[x][y]
      end
      local function get_neighbors(x, y)
          local neighbors = {}
          if x > 1 then
              neighbors[#neighbors + 1] = {x - 1, y}
          end
          if x < n then
              neighbors[#neighbors + 1] = {x + 1, y}
          end
          if y > 1 then
              neighbors[#neighbors + 1] = {x, y - 1}
          end
          if y < n then
              neighbors[#neighbors + 1] = {x, y + 1}
          end
          return neighbors
      end
      local function get_path(x, y, k)
          local path = {}
          local function dfs(x, y, k)
              if k == 0 then
                  return true
              end
              for _, neighbor in ipairs(get_neighbors(x, y)) do
                  local nx, ny = neighbor[1], neighbor[2]
                  if not path[nx] or not path[nx][ny] then
                      path[nx] = path[nx] or {}
                      path[nx][ny] = true
                      if dfs(nx, ny, k - 1) then
                          return true
                      end
                      path[nx][ny] = nil
                  end
              end
              return false
          end
          if dfs(x, y, k) then
              local result = {}
              for x, row in pairs(path) do
                  for y, _ in pairs(row) do
                      result[#result + 1] = get(x, y)
                  end
              end
              return result
          end
      end
      local min_path
      for x = 1, n do
          for y = 1, n do
              local path = get_path(x, y, k)
              if path then
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local function get(x, y)
          if x < 1 or x > n or y < 1 or y > n then
              return math.huge
          end
          return grid[x][y]
      end
      local function get_path(x, y, k)
          if k == 0 then
              return {}, get(x, y)
          end
          local paths = {}
          for _, dir in ipairs({{1, 0}, {0, 1}, {-1, 0}, {0, -1}}) do
              local path, val = get_path(x + dir[1], y + dir[2], k - 1)
              table.insert(path, val)
              table.insert(paths, path)
          end
          table.sort(paths, function(a, b)
              for i = 1, k do
                  if a[i] < b[i] then
                      return true
                  elseif a[i] > b[i] then
                      return false
                  end
              end
              return false
          end)
          return paths[1], get(x, y)
      end
      return get_path(1, 1, k)
  end
- |2-
      local n = #grid
      local function get_neighbors(i, j)
          local neighbors = {}
          if i > 1 then
              neighbors[#neighbors + 1] = {i - 1, j}
          end
          if i < n then
              neighbors[#neighbors + 1] = {i + 1, j}
          end
          if j > 1 then
              neighbors[#neighbors + 1] = {i, j - 1}
          end
          if j < n then
              neighbors[#neighbors + 1] = {i, j + 1}
          end
          return neighbors
      end
      local function get_path(i, j, k)
          local path = {}
          local function dfs(i, j, k)
              if k == 0 then
                  return true
              end
              for _, neighbor in ipairs(get_neighbors(i, j)) do
                  local ni, nj = neighbor[1], neighbor[2]
                  if not path[ni] or not path[ni][nj] then
                      path[ni] = path[ni] or {}
                      path[ni][nj] = true
                      if dfs(ni, nj, k - 1) then
                          return true
                      end
                      path[ni][nj] = nil
                  end
              end
              return false
          end
          if dfs(i, j, k) then
              local lst = {}
              for i = 1, n do
                  for j = 1, n do
                      if path[i] and path[i][j] then
                          lst[#lst + 1] = grid[i][j]
                      end
                  end
              end
              return lst
          end
      end
      local min_path = nil
      for i = 1, n do
          for j = 1, n do
              local path = get_path(i, j, k)
              if path then
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local m = #grid[1]
      local function get(x, y)
          if x < 1 or x > n or y < 1 or y > m then
              return math.huge
          end
          return grid[x][y]
      end
      local function get_neighbors(x, y)
          return {
              {x - 1, y},
              {x + 1, y},
              {x, y - 1},
              {x, y + 1}
          }
      end
      local function get_paths(x, y, k)
          if k == 0 then
              return {{get(x, y)}}
          end
          local paths = {}
          for _, n in ipairs(get_neighbors(x, y)) do
              local nx, ny = n[1], n[2]
              for _, path in ipairs(get_paths(nx, ny, k - 1)) do
                  table.insert(paths, {get(x, y), unpack(path)})
              end
          end
          return paths
      end
      local paths = {}
      for i = 1, n do
          for j = 1, m do
              for _, path in ipairs(get_paths(i, j, k - 1)) do
                  table.insert(paths, path)
              end
          end
      end
      table.sort(paths, function(a, b)
          for i = 1, k do
              if a[i] < b[i] then
                  return true
              elseif a[i] > b[i] then
                  return false
              end
          end
          return false
      end)
      return paths[1]
  end
- |2-
      local n = #grid
      local function get_neighbors(i, j)
          local neighbors = {}
          if i > 1 then
              neighbors[#neighbors + 1] = {i - 1, j}
          end
          if i < n then
              neighbors[#neighbors + 1] = {i + 1, j}
          end
          if j > 1 then
              neighbors[#neighbors + 1] = {i, j - 1}
          end
          if j < n then
              neighbors[#neighbors + 1] = {i, j + 1}
          end
          return neighbors
      end
      local function get_paths(i, j, k)
          local paths = {}
          local function get_paths_rec(i, j, k, path)
              if k == 0 then
                  paths[#paths + 1] = path
              else
                  for _, neighbor in ipairs(get_neighbors(i, j)) do
                      local ni, nj = neighbor[1], neighbor[2]
                      get_paths_rec(ni, nj, k - 1, path .. grid[ni][nj])
                  end
              end
          end
          get_paths_rec(i, j, k, grid[i][j])
          return paths
      end
      local min_path = nil
      for i = 1, n do
          for j = 1, n do
              local paths = get_paths(i, j, k)
              for _, path in ipairs(paths) do
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
      end
      local result = {}
      for i = 1, #min_path do
          result[#result + 1] = tonumber(min_path:sub(i, i))
      end
      return result
  end
- |2-
      local n = #grid
      local function get(x, y)
          return grid[x][y]
      end
      local function isValid(x, y)
          return x >= 1 and x <= n and y >= 1 and y <= n
      end
      local function getNeighbors(x, y)
          local neighbors = {}
          for _, v in ipairs({{-1, 0}, {1, 0}, {0, -1}, {0, 1}}) do
              local nx, ny = x + v[1], y + v[2]
              if isValid(nx, ny) then
                  table.insert(neighbors, {nx, ny})
              end
          end
          return neighbors
      end
      local function getPath(x, y, k)
          if k == 0 then
              return {}
          end
          local minPath = nil
          for _, v in ipairs(getNeighbors(x, y)) do
              local path = getPath(v[1], v[2], k - 1)
              if path then
                  table.insert(path, 1, get(x, y))
                  if not minPath or path < minPath then
                      minPath = path
                  end
              end
          end
          return minPath
      end
      local minPath = nil
      for i = 1, n do
          for j = 1, n do
              local path = getPath(i, j, k)
              if path then
                  if not minPath or path < minPath then
                      minPath = path
                  end
              end
          end
      end
      return minPath
  end
- |2-
      local n = #grid
      local m = #grid[1]
      local dp = {}
      for i = 1, n do
          dp[i] = {}
          for j = 1, m do
              dp[i][j] = {}
          end
      end
      for i = 1, n do
          for j = 1, m do
              dp[i][j][1] = {grid[i][j]}
          end
      end
      for l = 2, k do
          for i = 1, n do
              for j = 1, m do
                  local min = nil
                  if i > 1 then
                      local v = dp[i - 1][j][l - 1]
                      if not min or v < min then
                          min = v
                      end
                  end
                  if i < n then
                      local v = dp[i + 1][j][l - 1]
                      if not min or v < min then
                          min = v
                      end
                  end
                  if j > 1 then
                      local v = dp[i][j - 1][l - 1]
                      if not min or v < min then
                          min = v
                      end
                  end
                  if j < m then
                      local v = dp[i][j + 1][l - 1]
                      if not min or v < min then
                          min = v
                      end
                  end
                  if min then
                      dp[i][j][l] = {grid[i][j]}
                      for _, v in ipairs(min) do
                          table.insert(dp[i][j][l], v)
                      end
                  end
              end
          end
      end
      local min = nil
      for i = 1, n do
          for j = 1, m do
              local v = dp[i][j][k]
              if v and (not min or v < min) then
                  min = v
              end
          end
      end
      return min
  end
- |2-
      local n = #grid
      local dp = {}
      for i = 1, n do
          dp[i] = {}
          for j = 1, n do
              dp[i][j] = {}
          end
      end
      for i = 1, n do
          for j = 1, n do
              dp[i][j][1] = {grid[i][j]}
          end
      end
      for i = 1, n do
          for j = 1, n do
              for l = 2, k do
                  local min = nil
                  if i > 1 then
                      local t = {unpack(dp[i - 1][j][l - 1])}
                      table.insert(t, grid[i][j])
                      if min == nil or t < min then
                          min = t
                      end
                  end
                  if i < n then
                      local t = {unpack(dp[i + 1][j][l - 1])}
                      table.insert(t, grid[i][j])
                      if min == nil or t < min then
                          min = t
                      end
                  end
                  if j > 1 then
                      local t = {unpack(dp[i][j - 1][l - 1])}
                      table.insert(t, grid[i][j])
                      if min == nil or t < min then
                          min = t
                      end
                  end
                  if j < n then
                      local t = {unpack(dp[i][j + 1][l - 1])}
                      table.insert(t, grid[i][j])
                      if min == nil or t < min then
                          min = t
                      end
                  end
                  dp[i][j][l] = min
              end
          end
      end
      local min = nil
      for i = 1, n do
          for j = 1, n do
              if min == nil or dp[i][j][k] < min then
                  min = dp[i][j][k]
              end
          end
      end
      return min
  end
- |2-
      local n = #grid
      local function get_neighbors(i, j)
          local neighbors = {}
          if i > 1 then
              neighbors[#neighbors + 1] = {i - 1, j}
          end
          if i < n then
              neighbors[#neighbors + 1] = {i + 1, j}
          end
          if j > 1 then
              neighbors[#neighbors + 1] = {i, j - 1}
          end
          if j < n then
              neighbors[#neighbors + 1] = {i, j + 1}
          end
          return neighbors
      end
      local function get_path(i, j, k)
          local path = {}
          local function dfs(i, j, k)
              if k == 0 then
                  return true
              end
              for _, neighbor in ipairs(get_neighbors(i, j)) do
                  local ni, nj = neighbor[1], neighbor[2]
                  if not path[ni] or not path[ni][nj] then
                      path[ni] = path[ni] or {}
                      path[ni][nj] = true
                      if dfs(ni, nj, k - 1) then
                          return true
                      end
                      path[ni][nj] = nil
                  end
              end
              return false
          end
          if dfs(i, j, k) then
              local lst = {}
              for i = 1, n do
                  for j = 1, n do
                      if path[i] and path[i][j] then
                          lst[#lst + 1] = grid[i][j]
                      end
                  end
              end
              return lst
          end
      end
      local min_path
      for i = 1, n do
          for j = 1, n do
              local path = get_path(i, j, k)
              if path then
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local function get(x, y)
          if x < 1 or x > n or y < 1 or y > n then
              return 0
          end
          return grid[x][y]
      end
      local function get_neighbors(x, y)
          local neighbors = {}
          for _, d in ipairs({{-1, 0}, {1, 0}, {0, -1}, {0, 1}}) do
              local nx, ny = x + d[1], y + d[2]
              if get(nx, ny) > 0 then
                  table.insert(neighbors, {nx, ny})
              end
          end
          return neighbors
      end
      local function get_path(x, y, k)
          local path = {}
          local function dfs(x, y, k)
              if k == 0 then
                  return true
              end
              for _, n in ipairs(get_neighbors(x, y)) do
                  local nx, ny = n[1], n[2]
                  if get(nx, ny) < get(x, y) then
                      table.insert(path, get(nx, ny))
                      if dfs(nx, ny, k - 1) then
                          return true
                      end
                      table.remove(path)
                  end
              end
              return false
          end
          dfs(x, y, k)
          return path
      end
      local min_path = {}
      for i = 1, n do
          for j = 1, n do
              local path = get_path(i, j, k)
              if #path > 0 and (#min_path == 0 or path < min_path) then
                  min_path = path
              end
          end
      end
      table.insert(min_path, 1, get(1, 1))
      return min_path
  end
- |2-
      local n = #grid
      local m = {}
      for i = 1, n do
          m[i] = {}
          for j = 1, n do
              m[i][j] = {grid[i][j]}
          end
      end
      for i = 2, k do
          for j = 1, n do
              for l = 1, n do
                  local t = {}
                  if j > 1 then
                      for _, v in ipairs(m[j - 1][l]) do
                          table.insert(t, v)
                      end
                  end
                  if j < n then
                      for _, v in ipairs(m[j + 1][l]) do
                          table.insert(t, v)
                      end
                  end
                  if l > 1 then
                      for _, v in ipairs(m[j][l - 1]) do
                          table.insert(t, v)
                      end
                  end
                  if l < n then
                      for _, v in ipairs(m[j][l + 1]) do
                          table.insert(t, v)
                      end
                  end
                  table.sort(t)
                  m[j][l] = t
              end
          end
      end
      local min = {}
      for i = 1, n do
          for j = 1, n do
              if not min[1] or m[i][j][1] < min[1] then
                  min = m[i][j]
              end
          end
      end
      return min
  end
- |2-
      local n = #grid
      local function get_neighbors(i, j)
          local neighbors = {}
          if i > 1 then
              neighbors[#neighbors + 1] = {i - 1, j}
          end
          if i < n then
              neighbors[#neighbors + 1] = {i + 1, j}
          end
          if j > 1 then
              neighbors[#neighbors + 1] = {i, j - 1}
          end
          if j < n then
              neighbors[#neighbors + 1] = {i, j + 1}
          end
          return neighbors
      end
      local function get_path(i, j, k)
          local path = {}
          local function dfs(i, j, k)
              if k == 0 then
                  return true
              end
              for _, neighbor in ipairs(get_neighbors(i, j)) do
                  local ni, nj = neighbor[1], neighbor[2]
                  if not path[ni] or not path[ni][nj] then
                      path[ni] = path[ni] or {}
                      path[ni][nj] = true
                      if dfs(ni, nj, k - 1) then
                          return true
                      end
                      path[ni][nj] = nil
                  end
              end
              return false
          end
          if dfs(i, j, k) then
              local result = {}
              for i, row in ipairs(path) do
                  for j, _ in pairs(row) do
                      result[#result + 1] = grid[i][j]
                  end
              end
              return result
          end
      end
      local min_path = nil
      for i = 1, n do
          for j = 1, n do
              local path = get_path(i, j, k)
              if path then
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local function get(x, y)
          return grid[x][y]
      end
      local function get_neighbors(x, y)
          local neighbors = {}
          if x > 1 then
              neighbors[#neighbors + 1] = {x - 1, y}
          end
          if x < n then
              neighbors[#neighbors + 1] = {x + 1, y}
          end
          if y > 1 then
              neighbors[#neighbors + 1] = {x, y - 1}
          end
          if y < n then
              neighbors[#neighbors + 1] = {x, y + 1}
          end
          return neighbors
      end
      local function get_path(x, y, k)
          if k == 0 then
              return {}
          end
          local neighbors = get_neighbors(x, y)
          local min_path
          for _, neighbor in ipairs(neighbors) do
              local path = get_path(neighbor[1], neighbor[2], k - 1)
              if not min_path or path < min_path then
                  min_path = path
              end
          end
          min_path[#min_path + 1] = get(x, y)
          return min_path
      end
      local min_path
      for i = 1, n do
          for j = 1, n do
              local path = get_path(i, j, k)
              if not min_path or path < min_path then
                  min_path = path
              end
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local function get(i, j)
          return grid[i][j]
      end
      local function get_neighbors(i, j)
          local neighbors = {}
          if i > 1 then
              neighbors[#neighbors + 1] = {i - 1, j}
          end
          if i < n then
              neighbors[#neighbors + 1] = {i + 1, j}
          end
          if j > 1 then
              neighbors[#neighbors + 1] = {i, j - 1}
          end
          if j < n then
              neighbors[#neighbors + 1] = {i, j + 1}
          end
          return neighbors
      end
      local function get_paths(i, j, k)
          if k == 0 then
              return {{}}
          end
          local paths = {}
          for _, neighbor in ipairs(get_neighbors(i, j)) do
              local ni, nj = neighbor[1], neighbor[2]
              for _, path in ipairs(get_paths(ni, nj, k - 1)) do
                  paths[#paths + 1] = {get(i, j)}
                  for _, cell in ipairs(path) do
                      paths[#paths][#paths[#paths] + 1] = cell
                  end
              end
          end
          return paths
      end
      local function compare(path1, path2)
          for i = 1, k do
              if path1[i] < path2[i] then
                  return true
              elseif path1[i] > path2[i] then
                  return false
              end
          end
          return false
      end
      local min_path
      for i = 1, n do
          for j = 1, n do
              for _, path in ipairs(get_paths(i, j, k)) do
                  if not min_path or compare(path, min_path) then
                      min_path = path
                  end
              end
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local function get(x, y)
          return grid[x][y]
      end
      local function cmp(a, b)
          for i = 1, k do
              if a[i] < b[i] then
                  return true
              elseif a[i] > b[i] then
                  return false
              end
          end
          return false
      end
      local function get_neighbors(x, y)
          local res = {}
          if x > 1 then
              table.insert(res, {x - 1, y})
          end
          if x < n then
              table.insert(res, {x + 1, y})
          end
          if y > 1 then
              table.insert(res, {x, y - 1})
          end
          if y < n then
              table.insert(res, {x, y + 1})
          end
          return res
      end
      local function dfs(x, y, k, path)
          if k == 0 then
              return path
          end
          local neighbors = get_neighbors(x, y)
          local res = nil
          for _, n in ipairs(neighbors) do
              local p = dfs(n[1], n[2], k - 1, path)
              if not res or cmp(p, res) then
                  res = p
              end
          end
          return res
      end
      local res = nil
      for i = 1, n do
          for j = 1, n do
              local p = dfs(i, j, k, {get(i, j)})
              if not res or cmp(p, res) then
                  res = p
              end
          end
      end
      return res
  end
- |2-
      local n = #grid
      local function get(i, j)
          return grid[i][j]
      end
      local function get_neighbors(i, j)
          local res = {}
          if i > 1 then
              table.insert(res, {i - 1, j})
          end
          if i < n then
              table.insert(res, {i + 1, j})
          end
          if j > 1 then
              table.insert(res, {i, j - 1})
          end
          if j < n then
              table.insert(res, {i, j + 1})
          end
          return res
      end
      local function get_path(i, j, k)
          if k == 0 then
              return {}
          end
          local res = {}
          for _, n in ipairs(get_neighbors(i, j)) do
              local ni, nj = n[1], n[2]
              local path = get_path(ni, nj, k - 1)
              if #path > 0 then
                  table.insert(path, 1, get(ni, nj))
                  table.insert(res, path)
              end
          end
          table.sort(res, function(a, b)
              for i = 1, #a do
                  if a[i] < b[i] then
                      return true
                  elseif a[i] > b[i] then
                      return false
                  end
              end
              return false
          end)
          return res[1] or {}
      end
      local res = {}
      for i = 1, n do
          for j = 1, n do
              local path = get_path(i, j, k)
              if #path > 0 then
                  table.insert(path, 1, get(i, j))
                  table.insert(res, path)
              end
          end
      end
      table.sort(res, function(a, b)
          for i = 1, #a do
              if a[i] < b[i] then
                  return true
              elseif a[i] > b[i] then
                  return false
- |2-
      local N = #grid
      local function get_neighbors(i, j)
          local result = {}
          if i > 1 then
              table.insert(result, {i - 1, j})
          end
          if i < N then
              table.insert(result, {i + 1, j})
          end
          if j > 1 then
              table.insert(result, {i, j - 1})
          end
          if j < N then
              table.insert(result, {i, j + 1})
          end
          return result
      end
      local function get_path(i, j, k)
          local result = {}
          local function dfs(i, j, k)
              if k == 0 then
                  return true
              end
              for _, neighbor in ipairs(get_neighbors(i, j)) do
                  local ni, nj = neighbor[1], neighbor[2]
                  if grid[ni][nj] < grid[i][j] then
                      table.insert(result, grid[ni][nj])
                      if dfs(ni, nj, k - 1) then
                          return true
                      end
                      table.remove(result)
                  end
              end
              return false
          end
          dfs(i, j, k)
          return result
      end
      local result = {}
      for i = 1, N do
          for j = 1, N do
              local path = get_path(i, j, k)
              if #path < #result or #result == 0 then
                  result = path
              end
          end
      end
      return result
  end
- |2-
      local n = #grid
      local function get(i, j)
          return grid[i][j]
      end
      local function isValid(i, j)
          return i >= 1 and i <= n and j >= 1 and j <= n
      end
      local function getNeighbors(i, j)
          local neighbors = {}
          if isValid(i - 1, j) then
              neighbors[#neighbors + 1] = {i - 1, j}
          end
          if isValid(i + 1, j) then
              neighbors[#neighbors + 1] = {i + 1, j}
          end
          if isValid(i, j - 1) then
              neighbors[#neighbors + 1] = {i, j - 1}
          end
          if isValid(i, j + 1) then
              neighbors[#neighbors + 1] = {i, j + 1}
          end
          return neighbors
      end
      local function getPaths(i, j, k)
          if k == 0 then
              return {{}}
          end
          local paths = {}
          for _, neighbor in ipairs(getNeighbors(i, j)) do
              local i1, j1 = neighbor[1], neighbor[2]
              for _, path in ipairs(getPaths(i1, j1, k - 1)) do
                  paths[#paths + 1] = {get(i, j)}
                  for _, cell in ipairs(path) do
                      paths[#paths][#paths[#paths] + 1] = cell
                  end
              end
          end
          return paths
      end
      local function compare(path1, path2)
          for i = 1, k do
              if path1[i] < path2[i] then
                  return true
              elseif path1[i] > path2[i] then
                  return false
              end
          end
          return false
      end
      local minPath = nil
      for i = 1, n do
          for j = 1, n do
              for _, path in ipairs(getPaths(i, j, k)) do
                  if
- |2-
      local n = #grid
      local function get(x, y)
          return grid[x][y]
      end
      local function get_neighbors(x, y)
          local neighbors = {}
          if x > 1 then
              neighbors[#neighbors + 1] = {x - 1, y}
          end
          if x < n then
              neighbors[#neighbors + 1] = {x + 1, y}
          end
          if y > 1 then
              neighbors[#neighbors + 1] = {x, y - 1}
          end
          if y < n then
              neighbors[#neighbors + 1] = {x, y + 1}
          end
          return neighbors
      end
      local function get_path(x, y, k)
          if k == 0 then
              return {}
          end
          local min_path = nil
          for _, neighbor in ipairs(get_neighbors(x, y)) do
              local path = get_path(neighbor[1], neighbor[2], k - 1)
              if path then
                  path[#path + 1] = get(x, y)
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
          return min_path
      end
      local min_path = nil
      for i = 1, n do
          for j = 1, n do
              local path = get_path(i, j, k)
              if path then
                  path[#path + 1] = get(i, j)
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
      end
      return min_path
  end
- |2-
      -- your code here
      return {}
  end
- |2-
      local N = #grid
      local function get_neighbors(i, j)
          local neighbors = {}
          if i > 1 then
              neighbors[#neighbors + 1] = {i - 1, j}
          end
          if i < N then
              neighbors[#neighbors + 1] = {i + 1, j}
          end
          if j > 1 then
              neighbors[#neighbors + 1] = {i, j - 1}
          end
          if j < N then
              neighbors[#neighbors + 1] = {i, j + 1}
          end
          return neighbors
      end
      local function get_path(i, j, k)
          if k == 0 then
              return {}
          end
          local min_path = nil
          for _, neighbor in ipairs(get_neighbors(i, j)) do
              local path = get_path(neighbor[1], neighbor[2], k - 1)
              if path then
                  path[#path + 1] = grid[i][j]
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
          return min_path
      end
      local min_path = nil
      for i = 1, N do
          for j = 1, N do
              local path = get_path(i, j, k)
              if path then
                  path[#path + 1] = grid[i][j]
                  if not min_path or path < min_path then
                      min_path = path
                  end
              end
          end
      end
      return min_path
  end
- |2-
      local n = #grid
      local function get_cell(x, y)
          return grid[x][y]
      end
      local function get_neighbors(x, y)
          local neighbors = {}
          if x > 1 then
              neighbors[#neighbors + 1] = {x - 1, y}
          end
          if x < n then
              neighbors[#neighbors + 1] = {x + 1, y}
          end
          if y > 1 then
              neighbors[#neighbors + 1] = {x, y - 1}
          end
          if y < n then
              neighbors[#neighbors + 1] = {x, y + 1}
          end
          return neighbors
      end
      local function compare(path1, path2)
          for i = 1, k do
              local cell1 = get_cell(path1[i][1], path1[i][2])
              local cell2 = get_cell(path2[i][1], path2[i][2])
              if cell1 < cell2 then
                  return true
              elseif cell1 > cell2 then
                  return false
              end
          end
          return false
      end
      local function get_path(path)
          local result = {}
          for i = 1, k do
              result[i] = get_cell(path[i][1], path[i][2])
          end
          return result
      end
      local function get_min_path(x, y, k)
          local min_path = nil
          local function dfs(x, y, k, path)
              if k == 0 then
                  if min_path == nil or compare(path, min_path) then
                      min_path = path
                  end
                  return
              end
              for _, neighbor in ipairs(get_neighbors(x, y)) do
                  path[#path + 1] = neighbor
                  dfs(neighbor[1], neighbor[2], k - 1, path)
                  path[#path] = nil
              end
          end
          dfs(x, y, k, {{x, y}})
          return get_path
- |2-
      local n = #grid
      local function get(i, j)
          return grid[i][j]
      end
      local function get_neighbors(i, j)
          local res = {}
          if i > 1 then
              table.insert(res, {i - 1, j})
          end
          if i < n then
              table.insert(res, {i + 1, j})
          end
          if j > 1 then
              table.insert(res, {i, j - 1})
          end
          if j < n then
              table.insert(res, {i, j + 1})
          end
          return res
      end
      local function get_path(i, j, k)
          if k == 0 then
              return {}
          end
          local res = {}
          for _, neighbor in ipairs(get_neighbors(i, j)) do
              local path = get_path(neighbor[1], neighbor[2], k - 1)
              if #path > 0 then
                  table.insert(path, 1, get(i, j))
                  table.insert(res, path)
              end
          end
          table.sort(res, function(a, b)
              for i = 1, k do
                  if a[i] < b[i] then
                      return true
                  elseif a[i] > b[i] then
                      return false
                  end
              end
              return false
          end)
          return res[1] or {}
      end
      local res = {}
      for i = 1, n do
          for j = 1, n do
              local path = get_path(i, j, k)
              if #path > 0 then
                  table.insert(res, path)
              end
          end
      end
      table.sort(res, function(a, b)
          for i = 1, k do
              if a[i] < b[i] then
                  return true
              elseif a[i] > b[i] then
                  return false
              end
          end
          return false
      end)
      return res[1]
  end
- |2-
      local n = #grid
      local function get_min_path(i, j, k)
          if k == 0 then
              return {}
          end
          local min_path = nil
          local function update_min_path(path)
              if min_path == nil or path < min_path then
                  min_path = path
              end
          end
          if i > 1 then
              update_min_path({grid[i - 1][j]} .. get_min_path(i - 1, j, k - 1))
          end
          if i < n then
              update_min_path({grid[i + 1][j]} .. get_min_path(i + 1, j, k - 1))
          end
          if j > 1 then
              update_min_path({grid[i][j - 1]} .. get_min_path(i, j - 1, k - 1))
          end
          if j < n then
              update_min_path({grid[i][j + 1]} .. get_min_path(i, j + 1, k - 1))
          end
          return min_path
      end
      local min_path = nil
      for i = 1, n do
          for j = 1, n do
              local path = {grid[i][j]} .. get_min_path(i, j, k - 1)
              if min_path == nil or path < min_path then
                  min_path = path
              end
          end
      end
      return min_path
  end
stop_tokens:
- |2-

  local
- |2-

  function
- |2-

  --
- "\n\n"
