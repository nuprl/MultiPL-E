name: HumanEval_70_strange_sort_list
language: lua
prompt: "-- Given table of integers, return table in strange order.\n-- Strange sorting,\
  \ is when you start with the minimum value,\n-- then maximum of the remaining integers,\
  \ then minimum and so on.\n-- Examples:\n-- >>> strange_sort_list({1, 2, 3, 4})\n\
  -- {1, 4, 2, 3}\n-- >>> strange_sort_list({5, 5, 5, 5})\n-- {5, 5, 5, 5}\n-- >>>\
  \ strange_sort_list({})\n-- {}\nlocal function strange_sort_list(lst)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = strange_sort_list\n\
  \    lu.assertEquals(candidate({1, 2, 3, 4}), {1, 4, 2, 3})\n    lu.assertEquals(candidate({5,\
  \ 6, 7, 8, 9}), {5, 9, 6, 8, 7})\n    lu.assertEquals(candidate({1, 2, 3, 4, 5}),\
  \ {1, 5, 2, 4, 3})\n    lu.assertEquals(candidate({5, 6, 7, 8, 9, 1}), {1, 9, 5,\
  \ 8, 6, 7})\n    lu.assertEquals(candidate({5, 5, 5, 5}), {5, 5, 5, 5})\n    lu.assertEquals(candidate({}),\
  \ {})\n    lu.assertEquals(candidate({1, 2, 3, 4, 5, 6, 7, 8}), {1, 8, 2, 7, 3,\
  \ 6, 4, 5})\n    lu.assertEquals(candidate({0, 2, 2, 2, 5, 5, -5, -5}), {-5, 5,\
  \ -5, 5, 0, 2, 2, 2})\n    lu.assertEquals(candidate({111111}), {111111})\nend\n\
  \nos.exit(lu.LuaUnit.run())"
completions: ["    local sorted = {}\n    local min, max = math.min(unpack(lst)),\
    \ math.max(unpack(lst))\n    local min_idx, max_idx = lst:index_of(min), lst:index_of(max)\n\
    \    local min_removed, max_removed = lst:remove_at(min_idx), lst:remove_at(max_idx)\n\
    \    local min_removed_idx, max_removed_idx = min_removed:index_of(min), max_removed:index_of(max)\n\
    \    local min_removed_removed, max_removed_removed = min_removed:remove_at(min_removed_idx),\
    \ max_removed:remove_at(max_removed_idx)\n    return sorted\nend", "  local function\
    \ strange_sort(lst, res)\n    if #lst == 0 then\n      return res\n    end\n \
    \   local min, max = math.min(unpack(lst)), math.max(unpack(lst))\n    table.remove_value(lst,\
    \ min)\n    table.remove_value(lst, max)\n    table.insert(res, min)\n    table.insert(res,\
    \ max)\n    return strange_sort(lst, res)\n  end\n  return strange_sort(lst, {})\n\
    end", "    local res = {}\n    local min = math.min(unpack(lst))\n    local max\
    \ = math.max(unpack(lst))\n    local min_idx = 1\n    local max_idx = 1\n    for\
    \ i, v in ipairs(lst) do\n        if v == min then\n            min_idx = i\n\
    \        elseif v == max then\n            max_idx = i\n        end\n    end\n\
    \    local min_val = table.remove(lst, min_idx)\n    local max_val = table.remove(lst,\
    \ max_idx - 1)\n    table.insert(res, min_val)\n    table.insert(res, max_val)\n\
    \    while #lst > 0 do\n        min = math.min(unpack(lst))\n        max = math.max(unpack(lst))\n\
    \        min_idx = 1\n        max_idx = 1\n        for i, v in ipairs(lst) do\n\
    \            if v == min then\n                min_idx = i\n            elseif\
    \ v == max then\n                max_idx = i\n            end\n        end\n \
    \       min_val = table.remove(lst, min_idx)\n        max_val = table.remove(lst,\
    \ max_idx - 1)\n        table.insert(res, min_val)\n        table.insert(res,\
    \ max_val)\n    end\n    return res\nend", "  local result = {}\n  local min_value,\
    \ max_value, min_index, max_index\n  local min_max_indexes = {}\n  local min_max_values\
    \ = {}\n  local min_max_index = 1\n  local min_max_value = 1\n  local min_max_value_index\
    \ = 1\n  local min_max_value_indexes = {}\n  local min_max_value_values = {}\n\
    \  local min_max_value_index_index = 1\n  local min_max_value_value_index = 1\n\
    \  local min_max_value_index_indexes = {}\n  local min_max_value_value_indexes\
    \ = {}\n  local min_max_value_index_index_index = 1\n  local min_max_value_value_index_index\
    \ = 1\n  local min_max_value_index_index_indexes = {}\n  local min_max_value_value_index_indexes\
    \ = {}\n  local min_max_value_index_index_index_index = 1\n  local min_max_value_value_index_index_index\
    \ = 1\n  local min_max_value_index_index_index_indexes = {}\n  local min_max_value_value_index_index_indexes\
    \ = {}\n  local min_max_value_index_index_index_index_index = 1\n  local min_max_value_value_index_index_index_index\
    \ = 1\n  local min_max_value_index_index_index_index_indexes = {}\n  local min_max_value_value_index_index_index_indexes\
    \ = {}\n  local min_max_value_index_index_index_index_index_index = 1\n  local\
    \ min_max_value_value_index_index_index_index_index = 1\n  local min_max_value_index_index_index_index_index_indexes\
    \ = {}\n  local min_max_value_value_index_index_index_index_indexes = {}\n  local\
    \ min_max_value_index_index_index_index_index_index_index = 1\n  local min_max_value_value_index_index_index",
  "  local res = {}\n  local min, max = math.min(unpack(lst)), math.max(unpack(lst))\n\
    \  local min_idx, max_idx = 1, 1\n  for i = 1, #lst do\n    if lst[i] == min then\n\
    \      min_idx = i\n    elseif lst[i] == max then\n      max_idx = i\n    end\n\
    \  end\n  local i = 1\n  while i <= #lst do\n    if i % 2 == 1 then\n      res[i]\
    \ = min\n      table.remove(lst, min_idx)\n    else\n      res[i] = max\n    \
    \  table.remove(lst, max_idx)\n    end\n    min, max = math.min(unpack(lst)),\
    \ math.max(unpack(lst))\n    min_idx, max_idx = 1, 1\n    for j = 1, #lst do\n\
    \      if lst[j] == min then\n        min_idx = j\n      elseif lst[j] == max\
    \ then\n        max_idx = j\n      end\n    end\n    i = i + 1\n  end\n  return\
    \ res\nend", "  local result = {}\n  local min_index, max_index = 1, #lst\n  local\
    \ min_value, max_value = lst[min_index], lst[max_index]\n  local min_found, max_found\
    \ = false, false\n  local min_count, max_count = 0, 0\n  local i = 1\n  while\
    \ i <= #lst do\n    if not min_found then\n      if lst[i] < min_value then\n\
    \        min_value = lst[i]\n        min_index = i\n      end\n      min_count\
    \ = min_count + 1\n      if min_count == #lst then\n        min_found = true\n\
    \      end\n    end\n    if not max_found then\n      if lst[i] > max_value then\n\
    \        max_value = lst[i]\n        max_index = i\n      end\n      max_count\
    \ = max_count + 1\n      if max_count == #lst then\n        max_found = true\n\
    \      end\n    end\n    i = i + 1\n  end\n  result[1] = min_value\n  result[2]\
    \ = max_value\n  local min_index_found, max_index_found = false, false\n  local\
    \ j = 1\n  while j <= #lst do\n    if not min_index_found then\n      if j ~=\
    \ min_index and j ~= max_index then\n        min_value = lst[j]\n        min_index\
    \ = j\n        min_index_found = true\n      end\n    end\n    if not max_index_found\
    \ then\n      if j ~= min_index and j ~= max_index then\n        max_value = lst[j]\n\
    \        max_index = j\n        max_index_found = true\n      end\n    end\n \
    \   j = j + 1\n  end\n  result[3] = min_value\n  result[4] = max_value\n  return\
    \ result\nend", "    local res = {}\n    local min = math.min(unpack(lst))\n \
    \   local max = math.max(unpack(lst))\n    local min_idx = 1\n    local max_idx\
    \ = #lst\n    local i = 1\n    while i <= #lst do\n        if i % 2 == 1 then\n\
    \            res[i] = min\n            min_idx = min_idx + 1\n        else\n \
    \           res[i] = max\n            max_idx = max_idx - 1\n        end\n   \
    \     i = i + 1\n    end\n    return res\nend", "    local sorted_lst = {}\n \
    \   local min_val, max_val = math.min(unpack(lst)), math.max(unpack(lst))\n  \
    \  local min_idx, max_idx = 1, 1\n    for i, v in ipairs(lst) do\n        if v\
    \ == min_val then\n            min_idx = i\n        elseif v == max_val then\n\
    \            max_idx = i\n        end\n    end\n    local min_max_idx = min_idx\
    \ > max_idx and min_idx or max_idx\n    local max_min_idx = min_idx > max_idx\
    \ and max_idx or min_idx\n    for i = 1, #lst, 2 do\n        table.insert(sorted_lst,\
    \ lst[min_max_idx])\n        table.insert(sorted_lst, lst[max_min_idx])\n    end\n\
    \    return sorted_lst\nend", "    local res = {}\n    local min, max = math.min(unpack(lst)),\
    \ math.max(unpack(lst))\n    local min_idx, max_idx = 1, 1\n    local min_found,\
    \ max_found = false, false\n    local min_cnt, max_cnt = 0, 0\n    for i = 1,\
    \ #lst do\n        if lst[i] == min then\n            min_cnt = min_cnt + 1\n\
    \        elseif lst[i] == max then\n            max_cnt = max_cnt + 1\n      \
    \  end\n    end\n    for i = 1, #lst do\n        if not min_found then\n     \
    \       if lst[i] == min then\n                min_idx = i\n                min_found\
    \ = true\n            end\n        elseif not max_found then\n            if lst[i]\
    \ == max then\n                max_idx = i\n                max_found = true\n\
    \            end\n        end\n        if min_found and max_found then\n     \
    \       break\n        end\n    end\n    if min_idx < max_idx then\n        for\
    \ i = 1, #lst do\n            if i % 2 == 1 then\n                table.insert(res,\
    \ min)\n            else\n                table.insert(res, max)\n           \
    \ end\n        end\n    else\n        for i = 1, #lst do\n            if i % 2\
    \ == 1 then\n                table.insert(res, max)\n            else\n      \
    \          table.insert(res, min)\n            end\n        end\n    end\n   \
    \ return res\nend", "  local res = {}\n  local min, max = math.min(unpack(lst)),\
    \ math.max(unpack(lst))\n  local i = 1\n  while min <= max do\n    if i % 2 ==\
    \ 1 then\n      res[#res + 1] = min\n      min = min + 1\n    else\n      res[#res\
    \ + 1] = max\n      max = max - 1\n    end\n    i = i + 1\n  end\n  return res\n\
    end", "    local res = {}\n    local min, max = math.min(unpack(lst)), math.max(unpack(lst))\n\
    \    local min_idx, max_idx = 1, 1\n    local min_found, max_found = false, false\n\
    \    for i = 1, #lst do\n        if lst[i] == min and not min_found then\n   \
    \         min_idx = i\n            min_found = true\n        elseif lst[i] ==\
    \ max and not max_found then\n            max_idx = i\n            max_found =\
    \ true\n        end\n    end\n    local min_lst, max_lst = {}, {}\n    for i =\
    \ 1, #lst do\n        if i ~= min_idx then\n            table.insert(min_lst,\
    \ lst[i])\n        end\n        if i ~= max_idx then\n            table.insert(max_lst,\
    \ lst[i])\n        end\n    end\n    local min_min, min_max = math.min(unpack(min_lst)),\
    \ math.max(unpack(min_lst))\n    local max_min, max_max = math.min(unpack(max_lst)),\
    \ math.max(unpack(max_lst))\n    local min_min_idx, min_max_idx = 1, 1\n    local\
    \ max_min_idx, max_max_idx = 1, 1\n    local min_min_found, min_max_found = false,\
    \ false\n    local max_min_found, max_max_found = false, false\n    for i = 1,\
    \ #min_lst do\n        if min_lst[i] == min_min and not min_min_found then\n \
    \           min_min_idx = i\n            min_min_found = true\n        elseif\
    \ min_lst[i] == min_max and not min_max_found then\n            min_max_idx =\
    \ i\n            min_max_found = true\n        end\n    end\n    for i = 1, #max_lst\
    \ do\n        if max_lst[i] == max_min and not max_", "  local result = {}\n \
    \ local min_value, max_value = math.min(unpack(lst)), math.max(unpack(lst))\n\
    \  local min_index, max_index = 1, #lst\n  local min_found, max_found = false,\
    \ false\n  for i = 1, #lst do\n    if not min_found and lst[i] == min_value then\n\
    \      min_index = i\n      min_found = true\n    end\n    if not max_found and\
    \ lst[i] == max_value then\n      max_index = i\n      max_found = true\n    end\n\
    \    if min_found and max_found then\n      break\n    end\n  end\n  local min_first\
    \ = min_index < max_index\n  for i = 1, #lst do\n    if min_first then\n     \
    \ result[i] = lst[min_index]\n      min_index = min_index + 1\n      min_first\
    \ = false\n    else\n      result[i] = lst[max_index]\n      max_index = max_index\
    \ - 1\n      min_first = true\n    end\n  end\n  return result\nend", "    local\
    \ res = {}\n    local min_idx = 1\n    local max_idx = 1\n    local min = lst[1]\n\
    \    local max = lst[1]\n    for i = 1, #lst do\n        if lst[i] < min then\n\
    \            min = lst[i]\n            min_idx = i\n        end\n        if lst[i]\
    \ > max then\n            max = lst[i]\n            max_idx = i\n        end\n\
    \    end\n    table.insert(res, min)\n    table.insert(res, max)\n    table.remove(lst,\
    \ min_idx)\n    table.remove(lst, max_idx - 1)\n    while #lst > 0 do\n      \
    \  min = lst[1]\n        min_idx = 1\n        max = lst[1]\n        max_idx =\
    \ 1\n        for i = 1, #lst do\n            if lst[i] < min then\n          \
    \      min = lst[i]\n                min_idx = i\n            end\n          \
    \  if lst[i] > max then\n                max = lst[i]\n                max_idx\
    \ = i\n            end\n        end\n        table.insert(res, min)\n        table.insert(res,\
    \ max)\n        table.remove(lst, min_idx)\n        table.remove(lst, max_idx\
    \ - 1)\n    end\n    return res\nend", "    local res = {}\n    local min, max\
    \ = math.min(unpack(lst)), math.max(unpack(lst))\n    local min_idx, max_idx =\
    \ 1, #lst\n    local min_found, max_found = false, false\n    for i = 1, #lst\
    \ do\n        if not min_found and lst[i] == min then\n            min_idx = i\n\
    \            min_found = true\n        end\n        if not max_found and lst[i]\
    \ == max then\n            max_idx = i\n            max_found = true\n       \
    \ end\n        if min_found and max_found then\n            break\n        end\n\
    \    end\n    local min_lst, max_lst = {}, {}\n    for i = 1, #lst do\n      \
    \  if i ~= min_idx and i ~= max_idx then\n            table.insert(min_lst, lst[i])\n\
    \            table.insert(max_lst, lst[i])\n        end\n    end\n    local min_lst_sorted\
    \ = strange_sort_list(min_lst)\n    local max_lst_sorted = strange_sort_list(max_lst)\n\
    \    local min_idx, max_idx = 1, 1\n    for i = 1, #lst do\n        if i % 2 ==\
    \ 1 then\n            res[i] = min_lst_sorted[min_idx]\n            min_idx =\
    \ min_idx + 1\n        else\n            res[i] = max_lst_sorted[max_idx]\n  \
    \          max_idx = max_idx + 1\n        end\n    end\n    return res\nend",
  "    local res = {}\n    local min = math.min(unpack(lst))\n    local max = math.max(unpack(lst))\n\
    \    local min_idx = 1\n    local max_idx = #lst\n    local is_min = true\n  \
    \  for i = 1, #lst do\n        if is_min then\n            res[i] = min\n    \
    \        min_idx = min_idx + 1\n            min = math.min(unpack(lst, min_idx))\n\
    \        else\n            res[i] = max\n            max_idx = max_idx - 1\n \
    \           max = math.max(unpack(lst, 1, max_idx))\n        end\n        is_min\
    \ = not is_min\n    end\n    return res\nend", "    local function strange_sort(lst,\
    \ res)\n        if #lst == 0 then\n            return res\n        end\n     \
    \   local min_val, min_idx = math.min(unpack(lst))\n        local max_val, max_idx\
    \ = math.max(unpack(lst))\n        table.insert(res, min_val)\n        table.remove(lst,\
    \ min_idx)\n        table.insert(res, max_val)\n        table.remove(lst, max_idx)\n\
    \        return strange_sort(lst, res)\n    end\n    return strange_sort(lst,\
    \ {})\nend", "  local res = {}\n  local min_idx = 1\n  local max_idx = #lst\n\
    \  local min_val = lst[min_idx]\n  local max_val = lst[max_idx]\n  local min_found\
    \ = false\n  local max_found = false\n  local i = 1\n  while i <= #lst do\n  \
    \  if not min_found then\n      for j = min_idx, max_idx do\n        if lst[j]\
    \ < min_val then\n          min_val = lst[j]\n          min_idx = j\n        end\n\
    \      end\n      res[i] = min_val\n      min_found = true\n      i = i + 1\n\
    \    end\n    if not max_found then\n      for j = max_idx, min_idx, -1 do\n \
    \       if lst[j] > max_val then\n          max_val = lst[j]\n          max_idx\
    \ = j\n        end\n      end\n      res[i] = max_val\n      max_found = true\n\
    \      i = i + 1\n    end\n    min_found = false\n    max_found = false\n    min_val\
    \ = lst[min_idx]\n    max_val = lst[max_idx]\n  end\n  return res\nend", "  local\
    \ function get_min_max(lst)\n    local min, max = math.huge, -math.huge\n    for\
    \ _, v in ipairs(lst) do\n      if v < min then min = v end\n      if v > max\
    \ then max = v end\n    end\n    return min, max\n  end", "  local result = {}\n\
    \  local min_index, max_index\n  local min, max\n  local min_removed, max_removed\n\
    \  local i = 1\n  while #lst > 0 do\n    min_index, max_index = 1, 1\n    min,\
    \ max = lst[1], lst[1]\n    for j = 1, #lst do\n      if lst[j] < min then\n \
    \       min_index = j\n        min = lst[j]\n      end\n      if lst[j] > max\
    \ then\n        max_index = j\n        max = lst[j]\n      end\n    end\n    if\
    \ i % 2 == 1 then\n      result[i] = min\n      min_removed = table.remove(lst,\
    \ min_index)\n    else\n      result[i] = max\n      max_removed = table.remove(lst,\
    \ max_index)\n    end\n    i = i + 1\n  end\n  return result\nend", "    local\
    \ sorted = {}\n    local min = math.min(unpack(lst))\n    local max = math.max(unpack(lst))\n\
    \    local i = 1\n    while i <= #lst do\n        if i % 2 == 1 then\n       \
    \     table.insert(sorted, min)\n            table.remove(lst, table.index_of(lst,\
    \ min))\n        else\n            table.insert(sorted, max)\n            table.remove(lst,\
    \ table.index_of(lst, max))\n        end\n        min = math.min(unpack(lst))\n\
    \        max = math.max(unpack(lst))\n        i = i + 1\n    end\n    return sorted\n\
    end"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
