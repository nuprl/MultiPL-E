---
name: HumanEval_127_intersection
language: lua
prompt: "-- You are given two intervals,\n-- where each interval is a pair of integers.
  For example, interval = (start, end) = (1, 2).\n-- The given intervals are closed
  which means that the interval (start, end)\n-- includes both start and end.\n--
  For each given interval, it is assumed that its start is less or equal its end.\n--
  Your task is to determine whether the length of intersection of these two \n-- intervals
  is a prime number.\n-- Example, the intersection of the intervals (1, 3), (2, 4)
  is (2, 3)\n-- which its length is 1, which not a prime number.\n-- If the length
  of the intersection is a prime number, return \"YES\",\n-- otherwise, return \"NO\".\n--
  If the two intervals don't intersect, return \"NO\".\n-- [input/output] samples:\n--
  >>> intersection({1, 2}, {2, 3})\n-- 'NO'\n-- >>> intersection({-1, 1}, {0, 4})\n--
  'NO'\n-- >>> intersection({-3, -1}, {-5, 5})\n-- 'YES'\nlocal function intersection(interval1,
  interval2)\n"
tests: |-
  lu = require('luaunit')

  function test_humaneval()
  local candidate = intersection
      lu.assertEquals(candidate({1, 2}, {2, 3}), 'NO')
      lu.assertEquals(candidate({-1, 1}, {0, 4}), 'NO')
      lu.assertEquals(candidate({-3, -1}, {-5, 5}), 'YES')
      lu.assertEquals(candidate({-2, 2}, {-4, 0}), 'YES')
      lu.assertEquals(candidate({-11, 2}, {-1, -1}), 'NO')
      lu.assertEquals(candidate({1, 2}, {3, 5}), 'NO')
      lu.assertEquals(candidate({1, 2}, {1, 2}), 'NO')
      lu.assertEquals(candidate({-2, -2}, {-3, -2}), 'NO')
  end

  os.exit(lu.LuaUnit.run())
completions:
- |2-
    local a, b = interval1[1], interval1[2]
    local c, d = interval2[1], interval2[2]
    local start, finish = math.max(a, c), math.min(b, d)
    if start > finish then return 'NO' end
    local length = finish - start + 1
    if length == 1 then return 'NO' end
    for i = 2, math.sqrt(length) do
      if length % i == 0 then return 'NO' end
    end
    return 'YES'
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    if start > finish then
      return 'NO'
    end
    local length = finish - start + 1
    if length == 1 then
      return 'NO'
    end
    for i = 2, length - 1 do
      if length % i == 0 then
        return 'NO'
      end
    end
    return 'YES'
  end
- |2-
      local start1, end1 = interval1[1], interval1[2]
      local start2, end2 = interval2[1], interval2[2]
      local start, end = math.max(start1, start2), math.min(end1, end2)
      if start > end then return 'NO' end
      local length = end - start + 1
      if length == 1 then return 'NO' end
      for i = 2, math.sqrt(length) do
          if length % i == 0 then return 'NO' end
      end
      return 'YES'
  end
- |2-
    local function is_prime(n)
      if n < 2 then return false end
      for i = 2, math.sqrt(n) do
        if n % i == 0 then return false end
      end
      return true
    end
    local function intersection_length(interval1, interval2)
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then return 0 end
      return finish - start + 1
    end
    return is_prime(intersection_length(interval1, interval2)) and 'YES' or 'NO'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local len = finish - start + 1
      if len == 1 then
          return 'NO'
      end
      for i = 2, math.sqrt(len) do
          if len % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local len = finish - start + 1
      local is_prime = true
      for i = 2, math.floor(math.sqrt(len)) do
          if len % i == 0 then
              is_prime = false
              break
          end
      end
      if is_prime then
          return 'YES'
      else
          return 'NO'
      end
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    if start > finish then
      return 'NO'
    end
    local length = finish - start + 1
    local is_prime = true
    for i = 2, math.sqrt(length) do
      if length % i == 0 then
        is_prime = false
        break
      end
    end
    if is_prime then
      return 'YES'
    else
      return 'NO'
    end
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local length = finish - start + 1
      if length == 1 then
          return 'NO'
      end
      for i = 2, math.sqrt(length) do
          if length % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    if start > finish then
      return 'NO'
    end
    local length = finish - start + 1
    if length == 1 then
      return 'NO'
    end
    for i = 2, math.sqrt(length) do
      if length % i == 0 then
        return 'NO'
      end
    end
    return 'YES'
  end
- |2-
      local start1, end1 = interval1[1], interval1[2]
      local start2, end2 = interval2[1], interval2[2]
      local start, end = math.max(start1, start2), math.min(end1, end2)
      if start > end then return 'NO' end
      local len = end - start + 1
      for i = 2, math.sqrt(len) do
          if len % i == 0 then return 'NO' end
      end
      return 'YES'
  end
- |2-
      local start1, end1 = interval1[1], interval1[2]
      local start2, end2 = interval2[1], interval2[2]
      local intersection = {math.max(start1, start2), math.min(end1, end2)}
      local start, end = intersection[1], intersection[2]
      if start > end then
          return 'NO'
      end
      local length = end - start + 1
      if length == 1 then
          return 'NO'
      end
      for i = 2, math.sqrt(length) do
          if length % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local length = finish - start + 1
      if length == 1 then
          return 'NO'
      end
      for i = 2, math.sqrt(length) do
          if length % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local len = finish - start + 1
      if len <= 1 then
          return 'NO'
      end
      for i = 2, math.sqrt(len) do
          if len % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    if start > finish then
      return 'NO'
    end
    local length = finish - start + 1
    if length == 1 then
      return 'NO'
    end
    for i = 2, math.sqrt(length) do
      if length % i == 0 then
        return 'NO'
      end
    end
    return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      local len = finish - start + 1
      if len <= 0 then
          return 'NO'
      end
      for i = 2, math.sqrt(len) do
          if len % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local length = finish - start + 1
      if length == 1 then
          return 'NO'
      end
      for i = 2, math.sqrt(length) do
          if length % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local length = finish - start + 1
      if length == 1 then
          return 'NO'
      end
      for i = 2, math.sqrt(length) do
          if length % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    local length = finish - start + 1
    if length < 0 then
      return 'NO'
    end
    local is_prime = true
    for i = 2, math.sqrt(length) do
      if length % i == 0 then
        is_prime = false
        break
      end
    end
    return is_prime and 'YES' or 'NO'
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    if start > finish then
      return 'NO'
    end
    local len = finish - start + 1
    if len < 2 then
      return 'NO'
    end
    for i = 2, math.sqrt(len) do
      if len % i == 0 then
        return 'NO'
      end
    end
    return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local len = finish - start + 1
      if len == 1 then
          return 'NO'
      end
      for i = 2, math.sqrt(len) do
          if len % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local length = finish - start + 1
      if length == 1 then
          return 'NO'
      end
      for i = 2, math.sqrt(length) do
          if length % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    if start > finish then
      return 'NO'
    end
    local len = finish - start + 1
    local isPrime = true
    for i = 2, math.floor(math.sqrt(len)) do
      if len % i == 0 then
        isPrime = false
        break
      end
    end
    if isPrime then
      return 'YES'
    else
      return 'NO'
    end
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      local length = finish - start + 1
      if length < 1 then
          return 'NO'
      end
      if length == 1 then
          return 'YES'
      end
      for i = 2, math.sqrt(length) do
          if length % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
      local start1, end1 = interval1[1], interval1[2]
      local start2, end2 = interval2[1], interval2[2]
      local start, end = math.max(start1, start2), math.min(end1, end2)
      if start <= end then
          local len = end - start + 1
          if len == 1 then
              return 'NO'
          end
          for i = 2, math.sqrt(len) do
              if len % i == 0 then
                  return 'NO'
              end
          end
          return 'YES'
      end
      return 'NO'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local length = finish - start + 1
      local isPrime = true
      for i = 2, length - 1 do
          if length % i == 0 then
              isPrime = false
              break
          end
      end
      if isPrime then
          return 'YES'
      else
          return 'NO'
      end
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local len = finish - start + 1
      if len == 1 then
          return 'NO'
      end
      for i = 2, math.sqrt(len) do
          if len % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    if start > finish then
      return 'NO'
    end
    local len = finish - start + 1
    if len == 1 then
      return 'NO'
    end
    for i = 2, math.sqrt(len) do
      if len % i == 0 then
        return 'NO'
      end
    end
    return 'YES'
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    if start > finish then
      return 'NO'
    end
    local length = finish - start + 1
    local isPrime = true
    for i = 2, math.sqrt(length) do
      if length % i == 0 then
        isPrime = false
        break
      end
    end
    return isPrime and 'YES' or 'NO'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local len = finish - start + 1
      local primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97}
      for _, p in ipairs(primes) do
          if p == len then
              return 'YES'
          end
      end
      return 'NO'
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    if start > finish then
      return 'NO'
    end
    local len = finish - start + 1
    if len == 1 then
      return 'NO'
    end
    for i = 2, math.sqrt(len) do
      if len % i == 0 then
        return 'NO'
      end
    end
    return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local len = finish - start + 1
      if len == 1 then
          return 'NO'
      end
      for i = 2, math.sqrt(len) do
          if len % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local len = finish - start + 1
      if len == 1 then
          return 'NO'
      end
      for i = 2, math.sqrt(len) do
          if len % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    if start > finish then
      return 'NO'
    end
    local length = finish - start + 1
    if length == 1 then
      return 'NO'
    end
    for i = 2, math.sqrt(length) do
      if length % i == 0 then
        return 'NO'
      end
    end
    return 'YES'
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    if start > finish then
      return 'NO'
    end
    local length = finish - start + 1
    if length == 1 then
      return 'NO'
    end
    for i = 2, math.sqrt(length) do
      if length % i == 0 then
        return 'NO'
      end
    end
    return 'YES'
  end
- |2-
    local start1, end1 = interval1[1], interval1[2]
    local start2, end2 = interval2[1], interval2[2]
    local start, end = math.max(start1, start2), math.min(end1, end2)
    local length = end - start + 1
    if length < 1 then return 'NO' end
    local isPrime = true
    for i = 2, math.sqrt(length) do
      if length % i == 0 then
        isPrime = false
        break
      end
    end
    return isPrime and 'YES' or 'NO'
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    local length = finish - start + 1
    if length < 0 then
      return 'NO'
    end
    for i = 2, math.floor(math.sqrt(length)) do
      if length % i == 0 then
        return 'NO'
      end
    end
    return 'YES'
  end
- |2-
    local start1, end1 = interval1[1], interval1[2]
    local start2, end2 = interval2[1], interval2[2]
    local start, end = math.max(start1, start2), math.min(end1, end2)
    if start > end then return 'NO' end
    local len = end - start + 1
    if len == 1 then return 'NO' end
    for i = 2, math.sqrt(len) do
      if len % i == 0 then return 'NO' end
    end
    return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local len = finish - start + 1
      if len < 2 then
          return 'NO'
      end
      for i = 2, math.sqrt(len) do
          if len % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local len = finish - start + 1
      for i = 2, math.sqrt(len) do
          if len % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local len = finish - start + 1
      for i = 2, math.sqrt(len) do
          if len % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local length = finish - start + 1
      if length == 1 then
          return 'NO'
      end
      for i = 2, math.sqrt(length) do
          if length % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local len = finish - start + 1
      if len == 1 then
          return 'NO'
      end
      for i = 2, math.sqrt(len) do
          if len % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
      local function is_prime(n)
          if n < 2 then return false end
          for i = 2, math.sqrt(n) do
              if n % i == 0 then return false end
          end
          return true
      end
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then return 'NO' end
      return is_prime(finish - start + 1) and 'YES' or 'NO'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local len = finish - start + 1
      local isPrime = true
      for i = 2, math.sqrt(len) do
          if len % i == 0 then
              isPrime = false
              break
          end
      end
      if isPrime then
          return 'YES'
      else
          return 'NO'
      end
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    if start > finish then
      return 'NO'
    end
    local len = finish - start + 1
    if len == 1 then
      return 'NO'
    end
    for i = 2, math.sqrt(len) do
      if len % i == 0 then
        return 'NO'
      end
    end
    return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local length = finish - start + 1
      for i = 2, math.sqrt(length) do
          if length % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local len = finish - start + 1
      for i = 2, math.sqrt(len) do
          if len % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    if start > finish then
      return 'NO'
    end
    local length = finish - start + 1
    if length == 1 then
      return 'NO'
    end
    for i = 2, math.sqrt(length) do
      if length % i == 0 then
        return 'NO'
      end
    end
    return 'YES'
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    if start > finish then
      return 'NO'
    end
    local length = finish - start + 1
    if length == 1 then
      return 'NO'
    end
    local primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97}
    for _, prime in ipairs(primes) do
      if length == prime then
        return 'YES'
      end
    end
    return 'NO'
  end
- |2-
      local start1, end1 = interval1[1], interval1[2]
      local start2, end2 = interval2[1], interval2[2]
      local start, end = math.max(start1, start2), math.min(end1, end2)
      if start > end then return 'NO' end
      local function isPrime(n)
          if n <= 1 then return false end
          for i = 2, math.sqrt(n) do
              if n % i == 0 then return false end
          end
          return true
      end
      return isPrime(end - start + 1) and 'YES' or 'NO'
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    if start > finish then
      return 'NO'
    end
    local length = finish - start + 1
    local isPrime = true
    for i = 2, length - 1 do
      if length % i == 0 then
        isPrime = false
        break
      end
    end
    if isPrime then
      return 'YES'
    else
      return 'NO'
    end
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    if start > finish then
      return 'NO'
    end
    local len = finish - start + 1
    for i = 2, math.sqrt(len) do
      if len % i == 0 then
        return 'NO'
      end
    end
    return 'YES'
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    if start > finish then
      return 'NO'
    end
    local len = finish - start + 1
    if len == 1 then
      return 'NO'
    end
    for i = 2, math.sqrt(len) do
      if len % i == 0 then
        return 'NO'
      end
    end
    return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local length = finish - start + 1
      if length == 1 then
          return 'NO'
      end
      for i = 2, math.sqrt(length) do
          if length % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
      local function isPrime(num)
          if num < 2 then return false end
          for i = 2, math.sqrt(num) do
              if num % i == 0 then return false end
          end
          return true
      end
      local function getIntersection(interval1, interval2)
          local start = math.max(interval1[1], interval2[1])
          local end_ = math.min(interval1[2], interval2[2])
          if start > end_ then return nil end
          return {start, end_}
      end
      local intersection = getIntersection(interval1, interval2)
      if not intersection then return 'NO' end
      local length = intersection[2] - intersection[1] + 1
      return isPrime(length) and 'YES' or 'NO'
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    if start > finish then
      return 'NO'
    end
    local len = finish - start + 1
    for i = 2, math.sqrt(len) do
      if len % i == 0 then
        return 'NO'
      end
    end
    return 'YES'
  end
- |2-
      local start1, end1 = interval1[1], interval1[2]
      local start2, end2 = interval2[1], interval2[2]
      local start, end = math.max(start1, start2), math.min(end1, end2)
      if start > end then return 'NO' end
      local len = end - start + 1
      for i = 2, math.sqrt(len) do
          if len % i == 0 then return 'NO' end
      end
      return 'YES'
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    local length = finish - start + 1
    if length < 1 then
      return 'NO'
    end
    for i = 2, math.sqrt(length) do
      if length % i == 0 then
        return 'NO'
      end
    end
    return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local len = finish - start + 1
      if len == 1 then
          return 'NO'
      end
      local i = 2
      while i * i <= len do
          if len % i == 0 then
              return 'NO'
          end
          i = i + 1
      end
      return 'YES'
  end
- |2-
      local start1, end1 = interval1[1], interval1[2]
      local start2, end2 = interval2[1], interval2[2]
      local start, end = math.max(start1, start2), math.min(end1, end2)
      if start > end then return 'NO' end
      local len = end - start + 1
      if len == 1 then return 'NO' end
      for i = 2, math.sqrt(len) do
          if len % i == 0 then return 'NO' end
      end
      return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local length = finish - start + 1
      if length == 1 then
          return 'NO'
      end
      for i = 2, math.sqrt(length) do
          if length % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local len = finish - start + 1
      for i = 2, math.sqrt(len) do
          if len % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local len = finish - start + 1
      if len == 1 then
          return 'NO'
      end
      for i = 2, math.sqrt(len) do
          if len % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local len = finish - start + 1
      for i = 2, math.sqrt(len) do
          if len % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    local length = finish - start + 1
    if length < 1 then
      return 'NO'
    end
    local isPrime = true
    for i = 2, math.sqrt(length) do
      if length % i == 0 then
        isPrime = false
        break
      end
    end
    return isPrime and 'YES' or 'NO'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local len = finish - start + 1
      if len == 1 then
          return 'NO'
      end
      for i = 2, math.sqrt(len) do
          if len % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local length = finish - start + 1
      for i = 2, math.floor(math.sqrt(length)) do
          if length % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
      local start1, end1 = interval1[1], interval1[2]
      local start2, end2 = interval2[1], interval2[2]
      local start, end = math.max(start1, start2), math.min(end1, end2)
      if start > end then return 'NO' end
      local len = end - start + 1
      for i = 2, math.floor(math.sqrt(len)) do
          if len % i == 0 then return 'NO' end
      end
      return 'YES'
  end
- |2-
      local start1, end1 = interval1[1], interval1[2]
      local start2, end2 = interval2[1], interval2[2]
      local start, end = math.max(start1, start2), math.min(end1, end2)
      if start > end then return 'NO' end
      local len = end - start + 1
      local primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97}
      for _, v in ipairs(primes) do
          if v == len then return 'YES' end
      end
      return 'NO'
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    if start > finish then
      return 'NO'
    end
    local length = finish - start + 1
    if length == 1 then
      return 'NO'
    end
    local isPrime = true
    for i = 2, math.sqrt(length) do
      if length % i == 0 then
        isPrime = false
        break
      end
    end
    if isPrime then
      return 'YES'
    else
      return 'NO'
    end
  end
- |2-
    local start, end_ = math.max(interval1[1], interval2[1]), math.min(interval1[2], interval2[2])
    if start > end_ then return 'NO' end
    local len = end_ - start + 1
    if len == 1 then return 'NO' end
    for i = 2, math.sqrt(len) do
      if len % i == 0 then return 'NO' end
    end
    return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local length = finish - start + 1
      local is_prime = true
      for i = 2, math.sqrt(length) do
          if length % i == 0 then
              is_prime = false
              break
          end
      end
      if is_prime then
          return 'YES'
      else
          return 'NO'
      end
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    if start > finish then
      return 'NO'
    end
    local length = finish - start + 1
    if length == 1 then
      return 'NO'
    end
    for i = 2, math.sqrt(length) do
      if length % i == 0 then
        return 'NO'
      end
    end
    return 'YES'
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    if start > finish then
      return 'NO'
    end
    local len = finish - start + 1
    for i = 2, math.sqrt(len) do
      if len % i == 0 then
        return 'NO'
      end
    end
    return 'YES'
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    if start > finish then
      return 'NO'
    end
    local length = finish - start + 1
    if length == 1 then
      return 'NO'
    end
    for i = 2, math.sqrt(length) do
      if length % i == 0 then
        return 'NO'
      end
    end
    return 'YES'
  end
- |2-
      local start1, end1 = interval1[1], interval1[2]
      local start2, end2 = interval2[1], interval2[2]
      local start, end = math.max(start1, start2), math.min(end1, end2)
      if start > end then return 'NO' end
      local length = end - start + 1
      local primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97}
      for _, prime in ipairs(primes) do
          if length == prime then return 'YES' end
      end
      return 'NO'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local len = finish - start + 1
      for i = 2, math.sqrt(len) do
          if len % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
    local start1, end1 = interval1[1], interval1[2]
    local start2, end2 = interval2[1], interval2[2]
    local start, end = math.max(start1, start2), math.min(end1, end2)
    if start > end then return 'NO' end
    local len = end - start + 1
    local isPrime = true
    for i = 2, math.sqrt(len) do
      if len % i == 0 then
        isPrime = false
        break
      end
    end
    return isPrime and 'YES' or 'NO'
  end
- |2-
      local start1, end1 = interval1[1], interval1[2]
      local start2, end2 = interval2[1], interval2[2]
      local start, end = math.max(start1, start2), math.min(end1, end2)
      if start > end then return 'NO' end
      local len = end - start + 1
      if len == 1 then return 'NO' end
      for i = 2, math.sqrt(len) do
          if len % i == 0 then return 'NO' end
      end
      return 'YES'
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    if start > finish then
      return 'NO'
    end
    local len = finish - start + 1
    if len == 1 then
      return 'NO'
    end
    for i = 2, math.sqrt(len) do
      if len % i == 0 then
        return 'NO'
      end
    end
    return 'YES'
  end
- |2-
    local function isPrime(n)
      if n < 2 then return false end
      for i = 2, math.sqrt(n) do
        if n % i == 0 then return false end
      end
      return true
    end
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    if start > finish then return 'NO' end
    return isPrime(finish - start + 1) and 'YES' or 'NO'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      local length = finish - start + 1
      if length < 0 then
          return 'NO'
      end
      local primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97}
      for _, prime in ipairs(primes) do
          if length == prime then
              return 'YES'
          end
      end
      return 'NO'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local len = finish - start + 1
      for i = 2, math.sqrt(len) do
          if len % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
    local start1, end1 = interval1[1], interval1[2]
    local start2, end2 = interval2[1], interval2[2]
    local start, end = math.max(start1, start2), math.min(end1, end2)
    if start > end then return 'NO' end
    local len = end - start + 1
    if len == 1 then return 'NO' end
    for i = 2, math.sqrt(len) do
      if len % i == 0 then return 'NO' end
    end
    return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local len = finish - start + 1
      if len == 1 then
          return 'NO'
      end
      for i = 2, math.sqrt(len) do
          if len % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local stop = math.min(interval1[2], interval2[2])
    if start > stop then return 'NO' end
    local len = stop - start + 1
    for i = 2, math.sqrt(len) do
      if len % i == 0 then return 'NO' end
    end
    return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      local length = finish - start + 1
      if length <= 0 then
          return 'NO'
      end
      local isPrime = true
      for i = 2, math.floor(math.sqrt(length)) do
          if length % i == 0 then
              isPrime = false
              break
          end
      end
      return isPrime and 'YES' or 'NO'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local length = finish - start + 1
      for i = 2, math.sqrt(length) do
          if length % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    if start > finish then
      return 'NO'
    end
    local length = finish - start + 1
    for i = 2, math.sqrt(length) do
      if length % i == 0 then
        return 'NO'
      end
    end
    return 'YES'
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    if start > finish then
      return 'NO'
    end
    local len = finish - start + 1
    if len == 1 then
      return 'NO'
    end
    for i = 2, math.sqrt(len) do
      if len % i == 0 then
        return 'NO'
      end
    end
    return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      local length = finish - start + 1
      if length < 1 then
          return 'NO'
      end
      if length == 1 then
          return 'YES'
      end
      if length % 2 == 0 then
          return 'NO'
      end
      for i = 3, math.sqrt(length) do
          if length % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    if start > finish then
      return 'NO'
    end
    local length = finish - start + 1
    if length == 1 then
      return 'NO'
    end
    for i = 2, math.sqrt(length) do
      if length % i == 0 then
        return 'NO'
      end
    end
    return 'YES'
  end
- |2-
      local start1, end1 = interval1[1], interval1[2]
      local start2, end2 = interval2[1], interval2[2]
      local start, end = math.max(start1, start2), math.min(end1, end2)
      if start > end then return 'NO' end
      local len = end - start + 1
      if len == 1 then return 'NO' end
      for i = 2, math.sqrt(len) do
          if len % i == 0 then return 'NO' end
      end
      return 'YES'
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    if start > finish then
      return 'NO'
    end
    local len = finish - start + 1
    if len == 1 then
      return 'NO'
    end
    for i = 2, math.sqrt(len) do
      if len % i == 0 then
        return 'NO'
      end
    end
    return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local len = finish - start + 1
      if len == 1 then
          return 'NO'
      end
      for i = 2, math.sqrt(len) do
          if len % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
    local start, end_ = math.max(interval1[1], interval2[1]), math.min(interval1[2], interval2[2])
    if start > end_ then return 'NO' end
    local len = end_ - start + 1
    if len == 1 then return 'NO' end
    for i = 2, math.sqrt(len) do
      if len % i == 0 then return 'NO' end
    end
    return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      local length = finish - start + 1
      if length < 1 then
          return 'NO'
      end
      if length == 1 then
          return 'YES'
      end
      for i = 2, math.sqrt(length) do
          if length % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local length = finish - start + 1
      if length == 1 then
          return 'NO'
      end
      for i = 2, math.sqrt(length) do
          if length % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local len = finish - start + 1
      if len == 1 then
          return 'NO'
      end
      for i = 2, math.sqrt(len) do
          if len % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    local length = finish - start + 1
    if length < 1 then return 'NO' end
    for i = 2, math.sqrt(length) do
      if length % i == 0 then return 'NO' end
    end
    return 'YES'
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    local length = finish - start
    if length < 0 then
      return 'NO'
    end
    local is_prime = true
    for i = 2, length - 1 do
      if length % i == 0 then
        is_prime = false
        break
      end
    end
    return is_prime and 'YES' or 'NO'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local len = finish - start + 1
      local isPrime = true
      for i = 2, math.sqrt(len) do
          if len % i == 0 then
              isPrime = false
              break
          end
      end
      if isPrime then
          return 'YES'
      else
          return 'NO'
      end
  end
- |2-
    local start1, end1 = interval1[1], interval1[2]
    local start2, end2 = interval2[1], interval2[2]
    local start, end = math.max(start1, start2), math.min(end1, end2)
    if start > end then return 'NO' end
    local len = end - start + 1
    if len == 1 then return 'NO' end
    for i = 2, math.sqrt(len) do
      if len % i == 0 then return 'NO' end
    end
    return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local len = finish - start + 1
      for i = 2, math.sqrt(len) do
          if len % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local length = finish - start + 1
      for i = 2, math.sqrt(length) do
          if length % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      local length = finish - start + 1
      if length <= 0 then
          return 'NO'
      end
      for i = 2, math.sqrt(length) do
          if length % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
    local start1, end1 = interval1[1], interval1[2]
    local start2, end2 = interval2[1], interval2[2]
    local start, end = math.max(start1, start2), math.min(end1, end2)
    if start > end then return 'NO' end
    local len = end - start + 1
    if len == 1 then return 'NO' end
    for i = 2, math.sqrt(len) do
      if len % i == 0 then return 'NO' end
    end
    return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local length = finish - start + 1
      for i = 2, math.sqrt(length) do
          if length % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      local len = finish - start + 1
      if len < 1 then
          return 'NO'
      end
      for i = 2, math.sqrt(len) do
          if len % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    if start > finish then
      return 'NO'
    end
    local len = finish - start + 1
    if len == 1 then
      return 'NO'
    end
    for i = 2, math.sqrt(len) do
      if len % i == 0 then
        return 'NO'
      end
    end
    return 'YES'
  end
- |2-
    local start1, end1 = interval1[1], interval1[2]
    local start2, end2 = interval2[1], interval2[2]
    local start, end = math.max(start1, start2), math.min(end1, end2)
    if start > end then return 'NO' end
    local len = end - start + 1
    for i = 2, math.sqrt(len) do
      if len % i == 0 then return 'NO' end
    end
    return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local len = finish - start + 1
      if len == 1 then
          return 'NO'
      end
      for i = 2, math.sqrt(len) do
          if len % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local len = finish - start + 1
      if len == 1 then
          return 'NO'
      end
      for i = 2, math.sqrt(len) do
          if len % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    local length = finish - start + 1
    if length <= 0 then
      return 'NO'
    end
    if length == 1 then
      return 'NO'
    end
    local i = 2
    while i * i <= length do
      if length % i == 0 then
        return 'NO'
      end
      i = i + 1
    end
    return 'YES'
  end
- |2-
      local start1, end1 = interval1[1], interval1[2]
      local start2, end2 = interval2[1], interval2[2]
      local start, end = math.max(start1, start2), math.min(end1, end2)
      if start > end then return 'NO' end
      local len = end - start + 1
      if len == 1 then return 'NO' end
      for i = 2, math.sqrt(len) do
          if len % i == 0 then return 'NO' end
      end
      return 'YES'
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    local length = finish - start + 1
    if length <= 0 then
      return 'NO'
    end
    local is_prime = true
    for i = 2, math.sqrt(length) do
      if length % i == 0 then
        is_prime = false
        break
      end
    end
    return is_prime and 'YES' or 'NO'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local length = finish - start + 1
      if length == 1 then
          return 'NO'
      end
      for i = 2, math.sqrt(length) do
          if length % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local length = finish - start + 1
      local primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97}
      for _, prime in ipairs(primes) do
          if prime == length then
              return 'YES'
          end
      end
      return 'NO'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local length = finish - start + 1
      if length <= 1 then
          return 'NO'
      end
      for i = 2, math.sqrt(length) do
          if length % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local len = finish - start + 1
      if len == 1 then
          return 'NO'
      end
      local isPrime = true
      for i = 2, math.sqrt(len) do
          if len % i == 0 then
              isPrime = false
              break
          end
      end
      if isPrime then
          return 'YES'
      else
          return 'NO'
      end
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    local length = finish - start + 1
    if length <= 0 then
      return 'NO'
    end
    for i = 2, math.sqrt(length) do
      if length % i == 0 then
        return 'NO'
      end
    end
    return 'YES'
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    local length = finish - start + 1
    if length < 1 then
      return 'NO'
    end
    for i = 2, math.sqrt(length) do
      if length % i == 0 then
        return 'NO'
      end
    end
    return 'YES'
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    if start > finish then
      return 'NO'
    end
    local length = finish - start + 1
    if length == 1 then
      return 'NO'
    end
    local is_prime = true
    for i = 2, math.sqrt(length) do
      if length % i == 0 then
        is_prime = false
        break
      end
    end
    if is_prime then
      return 'YES'
    else
      return 'NO'
    end
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      local length = finish - start + 1
      if length < 1 then
          return 'NO'
      end
      for i = 2, math.sqrt(length) do
          if length % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    if start > finish then
      return 'NO'
    end
    local len = finish - start + 1
    if len == 1 then
      return 'NO'
    end
    for i = 2, math.sqrt(len) do
      if len % i == 0 then
        return 'NO'
      end
    end
    return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local len = finish - start + 1
      for i = 2, math.sqrt(len) do
          if len % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    local length = finish - start + 1
    if length < 1 then
      return 'NO'
    end
    for i = 2, math.floor(math.sqrt(length)) do
      if length % i == 0 then
        return 'NO'
      end
    end
    return 'YES'
  end
- |2-
      local start1, end1 = interval1[1], interval1[2]
      local start2, end2 = interval2[1], interval2[2]
      local start, end = math.max(start1, start2), math.min(end1, end2)
      if start > end then return 'NO' end
      local len = end - start + 1
      if len == 1 then return 'NO' end
      for i = 2, math.sqrt(len) do
          if len % i == 0 then return 'NO' end
      end
      return 'YES'
  end
- |2-
      local start1, end1 = interval1[1], interval1[2]
      local start2, end2 = interval2[1], interval2[2]
      local start, end = math.max(start1, start2), math.min(end1, end2)
      if start > end then return 'NO' end
      local len = end - start + 1
      if len == 1 then return 'NO' end
      for i = 2, math.sqrt(len) do
          if len % i == 0 then return 'NO' end
      end
      return 'YES'
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    if start > finish then
      return 'NO'
    end
    local length = finish - start + 1
    local isPrime = true
    for i = 2, math.sqrt(length) do
      if length % i == 0 then
        isPrime = false
        break
      end
    end
    return isPrime and 'YES' or 'NO'
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    if start > finish then
      return 'NO'
    end
    local len = finish - start + 1
    if len == 1 then
      return 'NO'
    end
    for i = 2, math.sqrt(len) do
      if len % i == 0 then
        return 'NO'
      end
    end
    return 'YES'
  end
- |2-
    local function is_prime(n)
      if n < 2 then return false end
      for i = 2, math.sqrt(n) do
        if n % i == 0 then return false end
      end
      return true
    end
    local function intersect(a, b)
      local max_start = math.max(a[1], b[1])
      local min_end = math.min(a[2], b[2])
      if max_start > min_end then return nil end
      return {max_start, min_end}
    end
    local inter = intersect(interval1, interval2)
    if inter == nil then return 'NO' end
    return is_prime(inter[2] - inter[1] + 1) and 'YES' or 'NO'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      local length = finish - start + 1
      if length < 1 then
          return 'NO'
      end
      local is_prime = true
      for i = 2, math.sqrt(length) do
          if length % i == 0 then
              is_prime = false
              break
          end
      end
      return is_prime and 'YES' or 'NO'
  end
- |2-
      local start1, end1 = interval1[1], interval1[2]
      local start2, end2 = interval2[1], interval2[2]
      local start, end = math.max(start1, start2), math.min(end1, end2)
      if start > end then return 'NO' end
      local len = end - start + 1
      for i = 2, math.sqrt(len) do
          if len % i == 0 then return 'NO' end
      end
      return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local len = finish - start + 1
      if len < 2 then
          return 'NO'
      end
      for i = 2, math.sqrt(len) do
          if len % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    local length = finish - start + 1
    if length <= 0 then
      return 'NO'
    end
    for i = 2, math.sqrt(length) do
      if length % i == 0 then
        return 'NO'
      end
    end
    return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local len = finish - start + 1
      if len == 1 then
          return 'NO'
      end
      for i = 2, math.sqrt(len) do
          if len % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    if start > finish then
      return 'NO'
    end
    local length = finish - start + 1
    if length == 1 then
      return 'NO'
    end
    for i = 2, math.sqrt(length) do
      if length % i == 0 then
        return 'NO'
      end
    end
    return 'YES'
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    if start > finish then
      return 'NO'
    end
    local length = finish - start + 1
    if length == 1 then
      return 'NO'
    end
    for i = 2, math.sqrt(length) do
      if length % i == 0 then
        return 'NO'
      end
    end
    return 'YES'
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local stop = math.min(interval1[2], interval2[2])
    if start > stop then return 'NO' end
    local length = stop - start + 1
    if length == 1 then return 'NO' end
    for i = 2, math.sqrt(length) do
      if length % i == 0 then return 'NO' end
    end
    return 'YES'
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    if start > finish then
      return 'NO'
    end
    local len = finish - start + 1
    if len == 1 then
      return 'NO'
    end
    for i = 2, math.sqrt(len) do
      if len % i == 0 then
        return 'NO'
      end
    end
    return 'YES'
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    if start > finish then
      return 'NO'
    end
    local length = finish - start + 1
    if length == 1 then
      return 'NO'
    end
    for i = 2, math.sqrt(length) do
      if length % i == 0 then
        return 'NO'
      end
    end
    return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local length = finish - start + 1
      if length == 1 then
          return 'NO'
      end
      for i = 2, math.floor(math.sqrt(length)) do
          if length % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    local length = finish - start + 1
    if length < 0 then return 'NO' end
    if length == 1 then return 'NO' end
    for i = 2, length - 1 do
      if length % i == 0 then return 'NO' end
    end
    return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      local length = finish - start + 1
      if length < 0 then
          return 'NO'
      end
      for i = 2, math.sqrt(length) do
          if length % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    if start > finish then
      return 'NO'
    end
    local length = finish - start + 1
    if length == 1 then
      return 'NO'
    end
    for i = 2, math.sqrt(length) do
      if length % i == 0 then
        return 'NO'
      end
    end
    return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local length = finish - start + 1
      if length == 1 then
          return 'NO'
      end
      local is_prime = true
      for i = 2, math.sqrt(length) do
          if length % i == 0 then
              is_prime = false
              break
          end
      end
      if is_prime then
          return 'YES'
      else
          return 'NO'
      end
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local len = finish - start + 1
      if len == 1 then
          return 'NO'
      end
      if len == 2 then
          return 'YES'
      end
      for i = 2, math.floor(math.sqrt(len)) do
          if len % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local len = finish - start + 1
      if len == 1 then
          return 'NO'
      end
      for i = 2, math.sqrt(len) do
          if len % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    if start > finish then
      return 'NO'
    end
    local len = finish - start + 1
    if len == 1 then
      return 'NO'
    end
    for i = 2, math.sqrt(len) do
      if len % i == 0 then
        return 'NO'
      end
    end
    return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local len = finish - start + 1
      if len == 1 then
          return 'NO'
      end
      for i = 2, math.sqrt(len) do
          if len % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    if start > finish then
      return 'NO'
    end
    local len = finish - start + 1
    if len == 1 then
      return 'NO'
    end
    for i = 2, math.sqrt(len) do
      if len % i == 0 then
        return 'NO'
      end
    end
    return 'YES'
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    if start > finish then
      return 'NO'
    end
    local length = finish - start + 1
    local is_prime = true
    for i = 2, math.sqrt(length) do
      if length % i == 0 then
        is_prime = false
        break
      end
    end
    if is_prime then
      return 'YES'
    else
      return 'NO'
    end
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local len = finish - start + 1
      if len == 1 then
          return 'NO'
      end
      for i = 2, math.sqrt(len) do
          if len % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    if start > finish then
      return 'NO'
    end
    local length = finish - start + 1
    if length == 1 then
      return 'NO'
    end
    for i = 2, math.sqrt(length) do
      if length % i == 0 then
        return 'NO'
      end
    end
    return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local len = finish - start + 1
      if len == 1 then
          return 'NO'
      end
      for i = 2, math.sqrt(len) do
          if len % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
      local function isPrime(n)
          if n < 2 then return false end
          for i = 2, math.sqrt(n) do
              if n % i == 0 then return false end
          end
          return true
      end
      local function getIntersection(interval1, interval2)
          local start = math.max(interval1[1], interval2[1])
          local finish = math.min(interval1[2], interval2[2])
          if start > finish then return nil end
          return {start, finish}
      end
      local intersection = getIntersection(interval1, interval2)
      if not intersection then return 'NO' end
      local length = intersection[2] - intersection[1] + 1
      return isPrime(length) and 'YES' or 'NO'
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    local length = finish - start
    if length < 0 then
      return 'NO'
    end
    local primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97}
    for _, prime in ipairs(primes) do
      if length == prime then
        return 'YES'
      end
    end
    return 'NO'
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    if start > finish then
      return 'NO'
    end
    local len = finish - start + 1
    for i = 2, math.sqrt(len) do
      if len % i == 0 then
        return 'NO'
      end
    end
    return 'YES'
  end
- |2-
      local function is_prime(n)
          if n < 2 then return false end
          if n == 2 then return true end
          if n % 2 == 0 then return false end
          for i = 3, math.sqrt(n), 2 do
              if n % i == 0 then return false end
          end
          return true
      end
      local function intersect(interval1, interval2)
          local start = math.max(interval1[1], interval2[1])
          local finish = math.min(interval1[2], interval2[2])
          if start > finish then return nil end
          return {start, finish}
      end
      local interval = intersect(interval1, interval2)
      if interval == nil then return 'NO' end
      return is_prime(interval[2] - interval[1] + 1) and 'YES' or 'NO'
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    local length = finish - start + 1
    if length < 1 then
      return 'NO'
    end
    if length == 1 then
      return 'YES'
    end
    local i = 2
    while i * i <= length do
      if length % i == 0 then
        return 'NO'
      end
      i = i + 1
    end
    return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local len = finish - start + 1
      for i = 2, math.sqrt(len) do
          if len % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    local length = finish - start + 1
    if length < 0 then
      return 'NO'
    end
    local is_prime = true
    for i = 2, math.floor(math.sqrt(length)) do
      if length % i == 0 then
        is_prime = false
        break
      end
    end
    return is_prime and 'YES' or 'NO'
  end
- |2-
    local start, end_ = math.max(interval1[1], interval2[1]), math.min(interval1[2], interval2[2])
    if start > end_ then return 'NO' end
    local len = end_ - start + 1
    if len == 1 then return 'NO' end
    for i = 2, math.sqrt(len) do
      if len % i == 0 then return 'NO' end
    end
    return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local len = finish - start + 1
      local is_prime = true
      for i = 2, math.sqrt(len) do
          if len % i == 0 then
              is_prime = false
              break
          end
      end
      if is_prime then
          return 'YES'
      else
          return 'NO'
      end
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    if start > finish then
      return 'NO'
    end
    local len = finish - start + 1
    if len == 1 then
      return 'NO'
    end
    for i = 2, math.floor(math.sqrt(len)) do
      if len % i == 0 then
        return 'NO'
      end
    end
    return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local len = finish - start + 1
      local isPrime = true
      for i = 2, math.sqrt(len) do
          if len % i == 0 then
              isPrime = false
              break
          end
      end
      if isPrime then
          return 'YES'
      else
          return 'NO'
      end
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    if start > finish then
      return 'NO'
    end
    local len = finish - start + 1
    if len == 1 then
      return 'NO'
    end
    for i = 2, math.sqrt(len) do
      if len % i == 0 then
        return 'NO'
      end
    end
    return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local len = finish - start + 1
      if len == 1 then
          return 'NO'
      end
      for i = 2, math.sqrt(len) do
          if len % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
    local a, b = interval1[1], interval1[2]
    local c, d = interval2[1], interval2[2]
    local start, finish = math.max(a, c), math.min(b, d)
    if start > finish then return 'NO' end
    local length = finish - start + 1
    local is_prime = true
    for i = 2, math.sqrt(length) do
      if length % i == 0 then
        is_prime = false
        break
      end
    end
    return is_prime and 'YES' or 'NO'
  end
- |2-
      local start1, end1 = interval1[1], interval1[2]
      local start2, end2 = interval2[1], interval2[2]
      local start, end = math.max(start1, start2), math.min(end1, end2)
      if start > end then return 'NO' end
      local len = end - start + 1
      for i = 2, math.sqrt(len) do
          if len % i == 0 then return 'NO' end
      end
      return 'YES'
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    if start > finish then
      return 'NO'
    end
    local length = finish - start + 1
    if length == 1 then
      return 'NO'
    end
    local isPrime = true
    for i = 2, math.sqrt(length) do
      if length % i == 0 then
        isPrime = false
        break
      end
    end
    if isPrime then
      return 'YES'
    else
      return 'NO'
    end
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    if start > finish then
      return 'NO'
    end
    local len = finish - start + 1
    for i = 2, math.sqrt(len) do
      if len % i == 0 then
        return 'NO'
      end
    end
    return 'YES'
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    if start > finish then
      return 'NO'
    end
    local length = finish - start + 1
    if length == 1 then
      return 'NO'
    end
    local is_prime = true
    for i = 2, math.sqrt(length) do
      if length % i == 0 then
        is_prime = false
        break
      end
    end
    if is_prime then
      return 'YES'
    else
      return 'NO'
    end
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local len = finish - start + 1
      if len == 1 then
          return 'NO'
      end
      for i = 2, math.sqrt(len) do
          if len % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    if start > finish then
      return 'NO'
    end
    local len = finish - start + 1
    for i = 2, math.sqrt(len) do
      if len % i == 0 then
        return 'NO'
      end
    end
    return 'YES'
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    if start > finish then
      return 'NO'
    end
    local len = finish - start + 1
    for i = 2, math.sqrt(len) do
      if len % i == 0 then
        return 'NO'
      end
    end
    return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      local length = finish - start + 1
      if length < 1 then
          return 'NO'
      end
      local isPrime = true
      for i = 2, math.sqrt(length) do
          if length % i == 0 then
              isPrime = false
              break
          end
      end
      return isPrime and 'YES' or 'NO'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      local len = finish - start + 1
      if len <= 0 then
          return 'NO'
      end
      for i = 2, math.sqrt(len) do
          if len % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local stop = math.min(interval1[2], interval2[2])
      if start > stop then
          return 'NO'
      end
      local length = stop - start + 1
      for i = 2, math.sqrt(length) do
          if length % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      local length = finish - start + 1
      if length < 1 then
          return 'NO'
      end
      local isPrime = true
      for i = 2, math.sqrt(length) do
          if length % i == 0 then
              isPrime = false
              break
          end
      end
      return isPrime and 'YES' or 'NO'
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    local length = finish - start + 1
    if length < 1 then
      return 'NO'
    end
    for i = 2, math.sqrt(length) do
      if length % i == 0 then
        return 'NO'
      end
    end
    return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local len = finish - start + 1
      if len == 1 then
          return 'NO'
      end
      for i = 2, math.sqrt(len) do
          if len % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
      local start1, end1 = interval1[1], interval1[2]
      local start2, end2 = interval2[1], interval2[2]
      local start, end = math.max(start1, start2), math.min(end1, end2)
      if start > end then return 'NO' end
      local len = end - start + 1
      if len == 1 then return 'NO' end
      for i = 2, math.sqrt(len) do
          if len % i == 0 then return 'NO' end
      end
      return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local len = finish - start + 1
      if len == 1 then
          return 'NO'
      end
      for i = 2, math.sqrt(len) do
          if len % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      local length = finish - start + 1
      if length < 1 then return 'NO' end
      if length == 1 then return 'YES' end
      for i = 2, math.sqrt(length) do
          if length % i == 0 then return 'NO' end
      end
      return 'YES'
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    if start > finish then
      return 'NO'
    end
    local length = finish - start + 1
    if length == 1 then
      return 'NO'
    end
    for i = 2, math.sqrt(length) do
      if length % i == 0 then
        return 'NO'
      end
    end
    return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local len = finish - start + 1
      if len == 1 then
          return 'NO'
      end
      for i = 2, math.sqrt(len) do
          if len % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local len = finish - start + 1
      if len == 1 then
          return 'NO'
      end
      for i = 2, math.sqrt(len) do
          if len % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      local length = finish - start + 1
      if length < 1 then
          return 'NO'
      end
      for i = 2, math.sqrt(length) do
          if length % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local length = finish - start + 1
      if length == 1 then
          return 'NO'
      end
      for i = 2, math.sqrt(length) do
          if length % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      local length = finish - start + 1
      if length < 1 then
          return 'NO'
      end
      if length == 1 then
          return 'YES'
      end
      for i = 2, length - 1 do
          if length % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    if start > finish then
      return 'NO'
    end
    local length = finish - start + 1
    if length == 1 then
      return 'NO'
    end
    for i = 2, math.sqrt(length) do
      if length % i == 0 then
        return 'NO'
      end
    end
    return 'YES'
  end
- |2-
    local start1, end1 = interval1[1], interval1[2]
    local start2, end2 = interval2[1], interval2[2]
    local start, end = math.max(start1, start2), math.min(end1, end2)
    if start > end then return 'NO' end
    local len = end - start + 1
    for i = 2, math.sqrt(len) do
      if len % i == 0 then return 'NO' end
    end
    return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local len = finish - start + 1
      if len == 1 then
          return 'NO'
      end
      for i = 2, math.sqrt(len) do
          if len % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      if start > finish then
          return 'NO'
      end
      local length = finish - start + 1
      if length == 1 then
          return 'NO'
      end
      for i = 2, math.sqrt(length) do
          if length % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local stop = math.min(interval1[2], interval2[2])
    if start > stop then return 'NO' end
    local len = stop - start + 1
    if len == 1 then return 'NO' end
    for i = 2, math.sqrt(len) do
      if len % i == 0 then return 'NO' end
    end
    return 'YES'
  end
- |2-
      local start = math.max(interval1[1], interval2[1])
      local finish = math.min(interval1[2], interval2[2])
      local len = finish - start + 1
      if len < 1 then
          return 'NO'
      end
      for i = 2, math.sqrt(len) do
          if len % i == 0 then
              return 'NO'
          end
      end
      return 'YES'
  end
- |2-
    local start = math.max(interval1[1], interval2[1])
    local finish = math.min(interval1[2], interval2[2])
    if start > finish then
      return 'NO'
    end
    local length = finish - start + 1
    if length == 1 then
      return 'NO'
    end
    for i = 2, math.sqrt(length) do
      if length % i == 0 then
        return 'NO'
      end
    end
    return 'YES'
  end
- |2-
    local start1, end1 = interval1[1], interval1[2]
    local start2, end2 = interval2[1], interval2[2]
    local start, end = math.max(start1, start2), math.min(end1, end2)
    if start > end then return 'NO' end
    local len = end - start + 1
    if len == 1 then return 'NO' end
    local is_prime = true
    for i = 2, math.sqrt(len) do
      if len % i == 0 then
        is_prime = false
        break
      end
    end
    return is_prime and 'YES' or 'NO'
  end
stop_tokens:
- |2-

  local
- |2-

  function
- |2-

  --
- "\n\n"
