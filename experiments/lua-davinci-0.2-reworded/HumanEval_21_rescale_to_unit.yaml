---
name: HumanEval_21_rescale_to_unit
language: lua
prompt: |
  -- Given table of numbers (of at least two elements), apply a linear transform to that table,
  -- such that the smallest number will become 0 and the largest will become 1
  -- >>> rescale_to_unit({1.0, 2.0, 3.0, 4.0, 5.0})
  -- {0.0, 0.25, 0.5, 0.75, 1.0}
  local function rescale_to_unit(numbers)
tests: |-
  lu = require('luaunit')

  function test_humaneval()
  local candidate = rescale_to_unit
      lu.assertEquals(candidate({2.0, 49.9}), {0.0, 1.0})
      lu.assertEquals(candidate({100.0, 49.9}), {1.0, 0.0})
      lu.assertEquals(candidate({1.0, 2.0, 3.0, 4.0, 5.0}), {0.0, 0.25, 0.5, 0.75, 1.0})
      lu.assertEquals(candidate({2.0, 1.0, 5.0, 3.0, 4.0}), {0.25, 0.0, 1.0, 0.5, 0.75})
      lu.assertEquals(candidate({12.0, 11.0, 15.0, 13.0, 14.0}), {0.25, 0.0, 1.0, 0.5, 0.75})
  end

  os.exit(lu.LuaUnit.run())
completions:
- |2-
      local min = math.min(unpack(numbers))
      local max = math.max(unpack(numbers))
      local range = max - min
      local result = {}
      for _, v in ipairs(numbers) do
          table.insert(result, (v - min) / range)
      end
      return result
  end
- |2-
      local min_number = math.min(unpack(numbers))
      local max_number = math.max(unpack(numbers))
      local range = max_number - min_number
      local rescaled_numbers = {}
      for _, number in ipairs(numbers) do
          table.insert(rescaled_numbers, (number - min_number) / range)
      end
      return rescaled_numbers
  end
- "\tlocal min = numbers[1]\n\tlocal max = numbers[1]\n\tfor _, n in ipairs(numbers)
  do\n\t\tif n < min then\n\t\t\tmin = n\n\t\tend\n\t\tif n > max then\n\t\t\tmax
  = n\n\t\tend\n\tend\n\tlocal result = {}\n\tfor _, n in ipairs(numbers) do\n\t\ttable.insert(result,
  (n - min) / (max - min))\n\tend\n\treturn result\nend"
- |2-
      local min = math.min(unpack(numbers))
      local max = math.max(unpack(numbers))
      local range = max - min
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min) / range)
      end
      return result
  end
- |2-
      local min = math.min(unpack(numbers))
      local max = math.max(unpack(numbers))
      local scale = max - min
      local result = {}
      for _, v in ipairs(numbers) do
          table.insert(result, (v - min) / scale)
      end
      return result
  end
- |2-
    local min = numbers[1]
    local max = numbers[1]
    for i = 2, #numbers do
      if numbers[i] < min then
        min = numbers[i]
      elseif numbers[i] > max then
        max = numbers[i]
      end
    end
    local result = {}
    for i = 1, #numbers do
      result[i] = (numbers[i] - min) / (max - min)
    end
    return result
  end
- |2-
    local min_number = math.min(unpack(numbers))
    local max_number = math.max(unpack(numbers))
    local result = {}
    for _, number in ipairs(numbers) do
      table.insert(result, (number - min_number) / (max_number - min_number))
    end
    return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for i = 2, #numbers do
          if numbers[i] < min then
              min = numbers[i]
          elseif numbers[i] > max then
              max = numbers[i]
          end
      end
      local result = {}
      for i = 1, #numbers do
          result[i] = (numbers[i] - min) / (max - min)
      end
      return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, number in ipairs(numbers) do
          if number < min then
              min = number
          end
          if number > max then
              max = number
          end
      end
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min) / (max - min))
      end
      return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, number in ipairs(numbers) do
          if number < min then
              min = number
          end
          if number > max then
              max = number
          end
      end
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min) / (max - min))
      end
      return result
  end
- |2-
      local min = math.min(unpack(numbers))
      local max = math.max(unpack(numbers))
      local scale = max - min
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min) / scale)
      end
      return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for i = 2, #numbers do
          if numbers[i] < min then
              min = numbers[i]
          elseif numbers[i] > max then
              max = numbers[i]
          end
      end
      local result = {}
      for i = 1, #numbers do
          result[i] = (numbers[i] - min) / (max - min)
      end
      return result
  end
- |2-
      local min_number = numbers[1]
      local max_number = numbers[1]
      for _, number in ipairs(numbers) do
          if number < min_number then
              min_number = number
          end
          if number > max_number then
              max_number = number
          end
      end
      local scale = 1 / (max_number - min_number)
      local scaled_numbers = {}
      for _, number in ipairs(numbers) do
          table.insert(scaled_numbers, (number - min_number) * scale)
      end
      return scaled_numbers
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, n in ipairs(numbers) do
          if n < min then
              min = n
          end
          if n > max then
              max = n
          end
      end
      local scale = 1 / (max - min)
      local result = {}
      for _, n in ipairs(numbers) do
          table.insert(result, (n - min) * scale)
      end
      return result
  end
- |2-
      local min_number = math.min(unpack(numbers))
      local max_number = math.max(unpack(numbers))
      local range = max_number - min_number
      local rescaled_numbers = {}
      for _, number in ipairs(numbers) do
          table.insert(rescaled_numbers, (number - min_number) / range)
      end
      return rescaled_numbers
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, number in ipairs(numbers) do
          if number < min then
              min = number
          end
          if number > max then
              max = number
          end
      end
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min) / (max - min))
      end
      return result
  end
- |2-
      local min_number = math.min(unpack(numbers))
      local max_number = math.max(unpack(numbers))
      local range = max_number - min_number
      local rescaled_numbers = {}
      for _, number in ipairs(numbers) do
          table.insert(rescaled_numbers, (number - min_number) / range)
      end
      return rescaled_numbers
  end
- |2-
      local min = math.min(unpack(numbers))
      local max = math.max(unpack(numbers))
      local range = max - min
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min) / range)
      end
      return result
  end
- |2-
      local min = math.min(unpack(numbers))
      local max = math.max(unpack(numbers))
      local range = max - min
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min) / range)
      end
      return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, v in ipairs(numbers) do
          if v < min then
              min = v
          end
          if v > max then
              max = v
          end
      end
      local result = {}
      for _, v in ipairs(numbers) do
          table.insert(result, (v - min) / (max - min))
      end
      return result
  end
- |2-
      local min_number = math.min(unpack(numbers))
      local max_number = math.max(unpack(numbers))
      local range = max_number - min_number
      local rescaled_numbers = {}
      for _, number in ipairs(numbers) do
          table.insert(rescaled_numbers, (number - min_number) / range)
      end
      return rescaled_numbers
  end
- |2-
      local min = math.min(unpack(numbers))
      local max = math.max(unpack(numbers))
      local range = max - min
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min) / range)
      end
      return result
  end
- |2-
      local min = math.min(unpack(numbers))
      local max = math.max(unpack(numbers))
      local range = max - min
      local result = {}
      for _, v in ipairs(numbers) do
          table.insert(result, (v - min) / range)
      end
      return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, number in ipairs(numbers) do
          if number < min then
              min = number
          end
          if number > max then
              max = number
          end
      end
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min) / (max - min))
      end
      return result
  end
- |2-
    local min = numbers[1]
    local max = numbers[1]
    for i = 2, #numbers do
      if numbers[i] < min then
        min = numbers[i]
      elseif numbers[i] > max then
        max = numbers[i]
      end
    end
    local result = {}
    for i = 1, #numbers do
      result[i] = (numbers[i] - min) / (max - min)
    end
    return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, number in ipairs(numbers) do
          if number < min then
              min = number
          end
          if number > max then
              max = number
          end
      end
      local scale = 1 / (max - min)
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min) * scale)
      end
      return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, n in ipairs(numbers) do
          if n < min then
              min = n
          end
          if n > max then
              max = n
          end
      end
      local result = {}
      for _, n in ipairs(numbers) do
          table.insert(result, (n - min) / (max - min))
      end
      return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, n in ipairs(numbers) do
          if n < min then
              min = n
          end
          if n > max then
              max = n
          end
      end
      local range = max - min
      local result = {}
      for _, n in ipairs(numbers) do
          table.insert(result, (n - min) / range)
      end
      return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, n in ipairs(numbers) do
          if n < min then
              min = n
          end
          if n > max then
              max = n
          end
      end
      local result = {}
      for _, n in ipairs(numbers) do
          table.insert(result, (n - min) / (max - min))
      end
      return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, number in ipairs(numbers) do
          if number < min then
              min = number
          end
          if number > max then
              max = number
          end
      end
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min) / (max - min))
      end
      return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, number in ipairs(numbers) do
          if number < min then
              min = number
          end
          if number > max then
              max = number
          end
      end
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min) / (max - min))
      end
      return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, number in ipairs(numbers) do
          if number < min then
              min = number
          end
          if number > max then
              max = number
          end
      end
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min) / (max - min))
      end
      return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, number in ipairs(numbers) do
          if number < min then
              min = number
          end
          if number > max then
              max = number
          end
      end
      local range = max - min
      local rescaled = {}
      for _, number in ipairs(numbers) do
          table.insert(rescaled, (number - min) / range)
      end
      return rescaled
  end
- |2-
      local min = math.min(unpack(numbers))
      local max = math.max(unpack(numbers))
      local range = max - min
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min) / range)
      end
      return result
  end
- |2-
    local min_number = math.min(unpack(numbers))
    local max_number = math.max(unpack(numbers))
    local range = max_number - min_number
    local rescaled_numbers = {}
    for _, number in ipairs(numbers) do
      table.insert(rescaled_numbers, (number - min_number) / range)
    end
    return rescaled_numbers
  end
- |2-
      local min = math.min(unpack(numbers))
      local max = math.max(unpack(numbers))
      local result = {}
      for i, v in ipairs(numbers) do
          result[i] = (v - min) / (max - min)
      end
      return result
  end
- |2-
      local min_number = numbers[1]
      local max_number = numbers[1]
      for _, number in ipairs(numbers) do
          if number < min_number then
              min_number = number
          end
          if number > max_number then
              max_number = number
          end
      end
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min_number) / (max_number - min_number))
      end
      return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, number in ipairs(numbers) do
          if number < min then
              min = number
          end
          if number > max then
              max = number
          end
      end
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min) / (max - min))
      end
      return result
  end
- |2-
      local min = math.min(unpack(numbers))
      local max = math.max(unpack(numbers))
      local range = max - min
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min) / range)
      end
      return result
  end
- |2-
      local min = math.min(unpack(numbers))
      local max = math.max(unpack(numbers))
      local range = max - min
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min) / range)
      end
      return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for i = 2, #numbers do
          if numbers[i] < min then
              min = numbers[i]
          elseif numbers[i] > max then
              max = numbers[i]
          end
      end
      local result = {}
      for i = 1, #numbers do
          result[i] = (numbers[i] - min) / (max - min)
      end
      return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, number in ipairs(numbers) do
          if number < min then
              min = number
          end
          if number > max then
              max = number
          end
      end
      local scale = 1 / (max - min)
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min) * scale)
      end
      return result
  end
- |2-
      local min = math.min(unpack(numbers))
      local max = math.max(unpack(numbers))
      local range = max - min
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min) / range)
      end
      return result
  end
- |2-
      local min = math.min(unpack(numbers))
      local max = math.max(unpack(numbers))
      local range = max - min
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min) / range)
      end
      return result
  end
- |2-
      local min = math.min(unpack(numbers))
      local max = math.max(unpack(numbers))
      local range = max - min
      local result = {}
      for i, v in ipairs(numbers) do
          result[i] = (v - min) / range
      end
      return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, number in ipairs(numbers) do
          if number < min then
              min = number
          end
          if number > max then
              max = number
          end
      end
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min) / (max - min))
      end
      return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, n in ipairs(numbers) do
          if n < min then
              min = n
          end
          if n > max then
              max = n
          end
      end
      local result = {}
      for _, n in ipairs(numbers) do
          table.insert(result, (n - min) / (max - min))
      end
      return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, number in ipairs(numbers) do
          if number < min then
              min = number
          end
          if number > max then
              max = number
          end
      end
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min) / (max - min))
      end
      return result
  end
- |2-
      local min_number = math.min(unpack(numbers))
      local max_number = math.max(unpack(numbers))
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min_number) / (max_number - min_number))
      end
      return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, v in ipairs(numbers) do
          if v < min then
              min = v
          end
          if v > max then
              max = v
          end
      end
      local result = {}
      for _, v in ipairs(numbers) do
          table.insert(result, (v - min) / (max - min))
      end
      return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, number in ipairs(numbers) do
          if number < min then
              min = number
          end
          if number > max then
              max = number
          end
      end
      local scale = 1 / (max - min)
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min) * scale)
      end
      return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for i = 2, #numbers do
          if numbers[i] < min then
              min = numbers[i]
          elseif numbers[i] > max then
              max = numbers[i]
          end
      end
      local result = {}
      for i = 1, #numbers do
          result[i] = (numbers[i] - min) / (max - min)
      end
      return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for i = 2, #numbers do
          if numbers[i] < min then
              min = numbers[i]
          elseif numbers[i] > max then
              max = numbers[i]
          end
      end
      local result = {}
      for i = 1, #numbers do
          result[i] = (numbers[i] - min) / (max - min)
      end
      return result
  end
- |2-
      local min = math.min(unpack(numbers))
      local max = math.max(unpack(numbers))
      local scale = max - min
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min) / scale)
      end
      return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for i = 2, #numbers do
          if numbers[i] < min then
              min = numbers[i]
          elseif numbers[i] > max then
              max = numbers[i]
          end
      end
      local result = {}
      for i = 1, #numbers do
          result[i] = (numbers[i] - min) / (max - min)
      end
      return result
  end
- |2-
      local min_number = math.min(unpack(numbers))
      local max_number = math.max(unpack(numbers))
      local range = max_number - min_number
      local rescaled_numbers = {}
      for i, number in ipairs(numbers) do
          rescaled_numbers[i] = (number - min_number) / range
      end
      return rescaled_numbers
  end
- |2-
      local min = math.min(unpack(numbers))
      local max = math.max(unpack(numbers))
      local range = max - min
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min) / range)
      end
      return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, number in ipairs(numbers) do
          if number < min then
              min = number
          end
          if number > max then
              max = number
          end
      end
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min) / (max - min))
      end
      return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for i = 2, #numbers do
          if numbers[i] < min then
              min = numbers[i]
          elseif numbers[i] > max then
              max = numbers[i]
          end
      end
      local result = {}
      for i = 1, #numbers do
          result[i] = (numbers[i] - min) / (max - min)
      end
      return result
  end
- |2-
      local min = math.min(unpack(numbers))
      local max = math.max(unpack(numbers))
      local range = max - min
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min) / range)
      end
      return result
  end
- |2-
    local min = numbers[1]
    local max = numbers[1]
    for _, n in ipairs(numbers) do
      if n < min then min = n end
      if n > max then max = n end
    end
    local scale = 1.0 / (max - min)
    local result = {}
    for _, n in ipairs(numbers) do
      table.insert(result, (n - min) * scale)
    end
    return result
  end
- |2-
    local min = math.min(unpack(numbers))
    local max = math.max(unpack(numbers))
    local result = {}
    for _, v in ipairs(numbers) do
      table.insert(result, (v - min) / (max - min))
    end
    return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, number in ipairs(numbers) do
          if number < min then
              min = number
          end
          if number > max then
              max = number
          end
      end
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min) / (max - min))
      end
      return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, n in ipairs(numbers) do
          if n < min then
              min = n
          end
          if n > max then
              max = n
          end
      end
      local result = {}
      for _, n in ipairs(numbers) do
          table.insert(result, (n - min) / (max - min))
      end
      return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, n in ipairs(numbers) do
          if n < min then
              min = n
          end
          if n > max then
              max = n
          end
      end
      local result = {}
      for _, n in ipairs(numbers) do
          table.insert(result, (n - min) / (max - min))
      end
      return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for i = 2, #numbers do
          if numbers[i] < min then
              min = numbers[i]
          elseif numbers[i] > max then
              max = numbers[i]
          end
      end
      local range = max - min
      local result = {}
      for i = 1, #numbers do
          result[i] = (numbers[i] - min) / range
      end
      return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for i = 2, #numbers do
          if numbers[i] < min then
              min = numbers[i]
          elseif numbers[i] > max then
              max = numbers[i]
          end
      end
      local result = {}
      for i = 1, #numbers do
          result[i] = (numbers[i] - min) / (max - min)
      end
      return result
  end
- "\tlocal min, max = numbers[1], numbers[1]\n\tfor i = 2, #numbers do\n\t\tif numbers[i]
  < min then\n\t\t\tmin = numbers[i]\n\t\telseif numbers[i] > max then\n\t\t\tmax
  = numbers[i]\n\t\tend\n\tend\n\tlocal result = {}\n\tfor i = 1, #numbers do\n\t\tresult[i]
  = (numbers[i] - min) / (max - min)\n\tend\n\treturn result\nend"
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, number in ipairs(numbers) do
          if number < min then
              min = number
          end
          if number > max then
              max = number
          end
      end
      local range = max - min
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min) / range)
      end
      return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, n in ipairs(numbers) do
          if n < min then
              min = n
          end
          if n > max then
              max = n
          end
      end
      local result = {}
      for _, n in ipairs(numbers) do
          table.insert(result, (n - min) / (max - min))
      end
      return result
  end
- |2-
    local min = math.min(unpack(numbers))
    local max = math.max(unpack(numbers))
    local range = max - min
    local result = {}
    for _, number in ipairs(numbers) do
      table.insert(result, (number - min) / range)
    end
    return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, number in ipairs(numbers) do
          if number < min then
              min = number
          end
          if number > max then
              max = number
          end
      end
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min) / (max - min))
      end
      return result
  end
- |2-
      local min_number = numbers[1]
      local max_number = numbers[1]
      for i = 2, #numbers do
          if numbers[i] < min_number then
              min_number = numbers[i]
          elseif numbers[i] > max_number then
              max_number = numbers[i]
          end
      end
      local range = max_number - min_number
      local rescaled_numbers = {}
      for i = 1, #numbers do
          rescaled_numbers[i] = (numbers[i] - min_number) / range
      end
      return rescaled_numbers
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for i = 2, #numbers do
          if numbers[i] < min then
              min = numbers[i]
          elseif numbers[i] > max then
              max = numbers[i]
          end
      end
      local result = {}
      for i = 1, #numbers do
          result[i] = (numbers[i] - min) / (max - min)
      end
      return result
  end
- |2-
    local min = math.min(unpack(numbers))
    local max = math.max(unpack(numbers))
    local result = {}
    for _, number in ipairs(numbers) do
      table.insert(result, (number - min) / (max - min))
    end
    return result
  end
- |2-
      local min = math.min(unpack(numbers))
      local max = math.max(unpack(numbers))
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min) / (max - min))
      end
      return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, n in ipairs(numbers) do
          if n < min then
              min = n
          end
          if n > max then
              max = n
          end
      end
      local result = {}
      for _, n in ipairs(numbers) do
          table.insert(result, (n - min) / (max - min))
      end
      return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for i, number in ipairs(numbers) do
          if number < min then
              min = number
          end
          if number > max then
              max = number
          end
      end
      local result = {}
      for i, number in ipairs(numbers) do
          result[i] = (number - min) / (max - min)
      end
      return result
  end
- |2-
      local min_number = numbers[1]
      local max_number = numbers[1]
      for i, number in ipairs(numbers) do
          if number < min_number then
              min_number = number
          end
          if number > max_number then
              max_number = number
          end
      end
      local scale = 1.0 / (max_number - min_number)
      local result = {}
      for i, number in ipairs(numbers) do
          result[i] = (number - min_number) * scale
      end
      return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, n in ipairs(numbers) do
          if n < min then
              min = n
          end
          if n > max then
              max = n
          end
      end
      local result = {}
      for _, n in ipairs(numbers) do
          table.insert(result, (n - min) / (max - min))
      end
      return result
  end
- |2-
      local min_number = math.min(unpack(numbers))
      local max_number = math.max(unpack(numbers))
      local result = {}
      for _, number in ipairs(numbers) do
          result[#result + 1] = (number - min_number) / (max_number - min_number)
      end
      return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, n in ipairs(numbers) do
          if n < min then
              min = n
          end
          if n > max then
              max = n
          end
      end
      local range = max - min
      local result = {}
      for _, n in ipairs(numbers) do
          table.insert(result, (n - min) / range)
      end
      return result
  end
- |2-
      local min_number = math.min(unpack(numbers))
      local max_number = math.max(unpack(numbers))
      local scale = max_number - min_number
      local rescaled_numbers = {}
      for _, number in ipairs(numbers) do
          table.insert(rescaled_numbers, (number - min_number) / scale)
      end
      return rescaled_numbers
  end
- |2-
      local min_number = math.min(unpack(numbers))
      local max_number = math.max(unpack(numbers))
      local scale = max_number - min_number
      local scaled_numbers = {}
      for _, number in ipairs(numbers) do
          table.insert(scaled_numbers, (number - min_number) / scale)
      end
      return scaled_numbers
  end
- |2-
    local min = numbers[1]
    local max = numbers[1]
    for _, number in ipairs(numbers) do
      if number < min then
        min = number
      end
      if number > max then
        max = number
      end
    end
    local result = {}
    for _, number in ipairs(numbers) do
      table.insert(result, (number - min) / (max - min))
    end
    return result
  end
- |2-
      local min = math.min(unpack(numbers))
      local max = math.max(unpack(numbers))
      local range = max - min
      local rescaled = {}
      for _, number in ipairs(numbers) do
          table.insert(rescaled, (number - min) / range)
      end
      return rescaled
  end
- |2-
    local min = math.min(unpack(numbers))
    local max = math.max(unpack(numbers))
    local scale = max - min
    local result = {}
    for _, number in ipairs(numbers) do
      table.insert(result, (number - min) / scale)
    end
    return result
  end
- |2-
      local min_value = math.min(unpack(numbers))
      local max_value = math.max(unpack(numbers))
      local range = max_value - min_value
      local rescaled = {}
      for i, v in ipairs(numbers) do
          rescaled[i] = (v - min_value) / range
      end
      return rescaled
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, n in ipairs(numbers) do
          if n < min then
              min = n
          end
          if n > max then
              max = n
          end
      end
      local range = max - min
      local result = {}
      for _, n in ipairs(numbers) do
          table.insert(result, (n - min) / range)
      end
      return result
  end
- |2-
      local min = math.min(unpack(numbers))
      local max = math.max(unpack(numbers))
      local range = max - min
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min) / range)
      end
      return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for i = 2, #numbers do
          if numbers[i] < min then
              min = numbers[i]
          elseif numbers[i] > max then
              max = numbers[i]
          end
      end
      local result = {}
      for i = 1, #numbers do
          result[i] = (numbers[i] - min) / (max - min)
      end
      return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, n in ipairs(numbers) do
          if n < min then
              min = n
          end
          if n > max then
              max = n
          end
      end
      local result = {}
      for _, n in ipairs(numbers) do
          result[#result + 1] = (n - min) / (max - min)
      end
      return result
  end
- |2-
      local min_number = math.min(unpack(numbers))
      local max_number = math.max(unpack(numbers))
      local range = max_number - min_number
      local rescaled_numbers = {}
      for _, number in ipairs(numbers) do
          table.insert(rescaled_numbers, (number - min_number) / range)
      end
      return rescaled_numbers
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for i, number in ipairs(numbers) do
          if number < min then
              min = number
          end
          if number > max then
              max = number
          end
      end
      local result = {}
      for i, number in ipairs(numbers) do
          result[i] = (number - min) / (max - min)
      end
      return result
  end
- "\tlocal min = numbers[1]\n\tlocal max = numbers[1]\n\tfor i = 2, #numbers do\n\t\tif
  numbers[i] < min then\n\t\t\tmin = numbers[i]\n\t\telseif numbers[i] > max then\n\t\t\tmax
  = numbers[i]\n\t\tend\n\tend\n\tlocal result = {}\n\tfor i = 1, #numbers do\n\t\tresult[i]
  = (numbers[i] - min) / (max - min)\n\tend\n\treturn result\nend"
- |2-
      local min_number = math.min(unpack(numbers))
      local max_number = math.max(unpack(numbers))
      local range = max_number - min_number
      local rescaled_numbers = {}
      for _, number in ipairs(numbers) do
          table.insert(rescaled_numbers, (number - min_number) / range)
      end
      return rescaled_numbers
  end
- |2-
      local min = math.min(unpack(numbers))
      local max = math.max(unpack(numbers))
      local range = max - min
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min) / range)
      end
      return result
  end
- |2-
      local min = math.min(unpack(numbers))
      local max = math.max(unpack(numbers))
      local range = max - min
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min) / range)
      end
      return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, number in ipairs(numbers) do
          if number < min then
              min = number
          end
          if number > max then
              max = number
          end
      end
      local scale = 1.0 / (max - min)
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min) * scale)
      end
      return result
  end
- |2-
      local min = math.min(unpack(numbers))
      local max = math.max(unpack(numbers))
      local range = max - min
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min) / range)
      end
      return result
  end
- |2-
      local min_number = math.min(unpack(numbers))
      local max_number = math.max(unpack(numbers))
      local range = max_number - min_number
      local rescaled_numbers = {}
      for _, number in ipairs(numbers) do
          table.insert(rescaled_numbers, (number - min_number) / range)
      end
      return rescaled_numbers
  end
- |2-
      local min_number = math.min(unpack(numbers))
      local max_number = math.max(unpack(numbers))
      local scale = max_number - min_number
      local scaled_numbers = {}
      for _, number in ipairs(numbers) do
          table.insert(scaled_numbers, (number - min_number) / scale)
      end
      return scaled_numbers
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, number in ipairs(numbers) do
          if number < min then
              min = number
          end
          if number > max then
              max = number
          end
      end
      local result = {}
      for _, number in ipairs(numbers) do
          result[#result + 1] = (number - min) / (max - min)
      end
      return result
  end
- |2-
    local min = numbers[1]
    local max = numbers[1]
    for _, number in ipairs(numbers) do
      if number < min then
        min = number
      end
      if number > max then
        max = number
      end
    end
    local result = {}
    for _, number in ipairs(numbers) do
      table.insert(result, (number - min) / (max - min))
    end
    return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for i = 2, #numbers do
          if numbers[i] < min then
              min = numbers[i]
          elseif numbers[i] > max then
              max = numbers[i]
          end
      end
      local range = max - min
      local result = {}
      for i = 1, #numbers do
          result[i] = (numbers[i] - min) / range
      end
      return result
  end
- |2-
      local min = math.min(unpack(numbers))
      local max = math.max(unpack(numbers))
      local range = max - min
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min) / range)
      end
      return result
  end
- |2-
      local min = math.min(unpack(numbers))
      local max = math.max(unpack(numbers))
      local scale = max - min
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min) / scale)
      end
      return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, n in ipairs(numbers) do
          if n < min then
              min = n
          end
          if n > max then
              max = n
          end
      end
      local result = {}
      for _, n in ipairs(numbers) do
          table.insert(result, (n - min) / (max - min))
      end
      return result
  end
- |2-
      local min_number = numbers[1]
      local max_number = numbers[1]
      for _, number in ipairs(numbers) do
          if number < min_number then
              min_number = number
          end
          if number > max_number then
              max_number = number
          end
      end
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min_number) / (max_number - min_number))
      end
      return result
  end
- |2-
    local min = math.min(unpack(numbers))
    local max = math.max(unpack(numbers))
    local scale = max - min
    local result = {}
    for i, v in ipairs(numbers) do
      result[i] = (v - min) / scale
    end
    return result
  end
- |2-
    local min = math.min(unpack(numbers))
    local max = math.max(unpack(numbers))
    local range = max - min
    local rescaled = {}
    for i, v in ipairs(numbers) do
      rescaled[i] = (v - min) / range
    end
    return rescaled
  end
- |2-
      local min_number = math.min(unpack(numbers))
      local max_number = math.max(unpack(numbers))
      local range = max_number - min_number
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min_number) / range)
      end
      return result
  end
- |2-
      local min_number = numbers[1]
      local max_number = numbers[1]
      for _, number in ipairs(numbers) do
          if number < min_number then
              min_number = number
          end
          if number > max_number then
              max_number = number
          end
      end
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min_number) / (max_number - min_number))
      end
      return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, number in ipairs(numbers) do
          if number < min then
              min = number
          end
          if number > max then
              max = number
          end
      end
      local range = max - min
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min) / range)
      end
      return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, n in ipairs(numbers) do
          if n < min then
              min = n
          end
          if n > max then
              max = n
          end
      end
      local result = {}
      for _, n in ipairs(numbers) do
          table.insert(result, (n - min) / (max - min))
      end
      return result
  end
- |2-
      local min_number = math.min(unpack(numbers))
      local max_number = math.max(unpack(numbers))
      local range = max_number - min_number
      local rescaled_numbers = {}
      for _, number in ipairs(numbers) do
          table.insert(rescaled_numbers, (number - min_number) / range)
      end
      return rescaled_numbers
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, n in ipairs(numbers) do
          if n < min then
              min = n
          end
          if n > max then
              max = n
          end
      end
      local result = {}
      for _, n in ipairs(numbers) do
          table.insert(result, (n - min) / (max - min))
      end
      return result
  end
- |2-
      local min_number = math.min(unpack(numbers))
      local max_number = math.max(unpack(numbers))
      local range = max_number - min_number
      local rescaled_numbers = {}
      for _, number in ipairs(numbers) do
          table.insert(rescaled_numbers, (number - min_number) / range)
      end
      return rescaled_numbers
  end
- |2-
    local min = math.min(unpack(numbers))
    local max = math.max(unpack(numbers))
    local result = {}
    for _, number in ipairs(numbers) do
      table.insert(result, (number - min) / (max - min))
    end
    return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, n in ipairs(numbers) do
          if n < min then
              min = n
          end
          if n > max then
              max = n
          end
      end
      local result = {}
      for _, n in ipairs(numbers) do
          table.insert(result, (n - min) / (max - min))
      end
      return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, n in ipairs(numbers) do
          if n < min then
              min = n
          end
          if n > max then
              max = n
          end
      end
      local result = {}
      for _, n in ipairs(numbers) do
          table.insert(result, (n - min) / (max - min))
      end
      return result
  end
- |2-
      local min_number = numbers[1]
      local max_number = numbers[1]
      for _, number in ipairs(numbers) do
          if number < min_number then
              min_number = number
          end
          if number > max_number then
              max_number = number
          end
      end
      local range = max_number - min_number
      local rescaled_numbers = {}
      for _, number in ipairs(numbers) do
          local rescaled_number = (number - min_number) / range
          table.insert(rescaled_numbers, rescaled_number)
      end
      return rescaled_numbers
  end
- |2-
      local min = math.min(unpack(numbers))
      local max = math.max(unpack(numbers))
      local range = max - min
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min) / range)
      end
      return result
  end
- |2-
      local min = math.min(unpack(numbers))
      local max = math.max(unpack(numbers))
      local range = max - min
      local result = {}
      for _, number in ipairs(numbers) do
          result[#result + 1] = (number - min) / range
      end
      return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, n in ipairs(numbers) do
          if n < min then
              min = n
          end
          if n > max then
              max = n
          end
      end
      local result = {}
      for _, n in ipairs(numbers) do
          table.insert(result, (n - min) / (max - min))
      end
      return result
  end
- |2-
      local min = math.min(unpack(numbers))
      local max = math.max(unpack(numbers))
      local range = max - min
      local result = {}
      for _, v in ipairs(numbers) do
          table.insert(result, (v - min) / range)
      end
      return result
  end
- |2-
    local min = numbers[1]
    local max = numbers[1]
    for i = 2, #numbers do
      if numbers[i] < min then
        min = numbers[i]
      elseif numbers[i] > max then
        max = numbers[i]
      end
    end
    local result = {}
    for i = 1, #numbers do
      result[i] = (numbers[i] - min) / (max - min)
    end
    return result
  end
- |2-
      local min = math.min(unpack(numbers))
      local max = math.max(unpack(numbers))
      local range = max - min
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min) / range)
      end
      return result
  end
- |2-
      local min = math.min(unpack(numbers))
      local max = math.max(unpack(numbers))
      local range = max - min
      local result = {}
      for _, v in ipairs(numbers) do
          table.insert(result, (v - min) / range)
      end
      return result
  end
- |2-
      local min_number = math.min(unpack(numbers))
      local max_number = math.max(unpack(numbers))
      local range = max_number - min_number
      local rescaled_numbers = {}
      for _, number in ipairs(numbers) do
          table.insert(rescaled_numbers, (number - min_number) / range)
      end
      return rescaled_numbers
  end
- |2-
      local min = math.min(unpack(numbers))
      local max = math.max(unpack(numbers))
      local range = max - min
      local result = {}
      for _, v in ipairs(numbers) do
          table.insert(result, (v - min) / range)
      end
      return result
  end
- |2-
      local min = math.min(unpack(numbers))
      local max = math.max(unpack(numbers))
      local range = max - min
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min) / range)
      end
      return result
  end
- |2-
      local min_number = math.min(unpack(numbers))
      local max_number = math.max(unpack(numbers))
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min_number) / (max_number - min_number))
      end
      return result
  end
- |2-
      local min_number = math.min(unpack(numbers))
      local max_number = math.max(unpack(numbers))
      local range = max_number - min_number
      return map(function(x) return (x - min_number) / range end, numbers)
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for i = 2, #numbers do
          if numbers[i] < min then
              min = numbers[i]
          elseif numbers[i] > max then
              max = numbers[i]
          end
      end
      local range = max - min
      local result = {}
      for i = 1, #numbers do
          result[i] = (numbers[i] - min) / range
      end
      return result
  end
- |2-
      local min = math.min(unpack(numbers))
      local max = math.max(unpack(numbers))
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min) / (max - min))
      end
      return result
  end
- |2-
      local min = math.min(unpack(numbers))
      local max = math.max(unpack(numbers))
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min) / (max - min))
      end
      return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, n in ipairs(numbers) do
          if n < min then
              min = n
          end
          if n > max then
              max = n
          end
      end
      local result = {}
      for _, n in ipairs(numbers) do
          table.insert(result, (n - min) / (max - min))
      end
      return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, number in ipairs(numbers) do
          if number < min then
              min = number
          end
          if number > max then
              max = number
          end
      end
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min) / (max - min))
      end
      return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, number in ipairs(numbers) do
          if number < min then
              min = number
          end
          if number > max then
              max = number
          end
      end
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min) / (max - min))
      end
      return result
  end
- |2-
    local min = numbers[1]
    local max = numbers[1]
    for _, n in ipairs(numbers) do
      if n < min then min = n end
      if n > max then max = n end
    end
    local scale = 1 / (max - min)
    local result = {}
    for _, n in ipairs(numbers) do
      table.insert(result, (n - min) * scale)
    end
    return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for i = 2, #numbers do
          if numbers[i] < min then
              min = numbers[i]
          elseif numbers[i] > max then
              max = numbers[i]
          end
      end
      local result = {}
      for i = 1, #numbers do
          result[i] = (numbers[i] - min) / (max - min)
      end
      return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, number in ipairs(numbers) do
          if number < min then
              min = number
          end
          if number > max then
              max = number
          end
      end
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min) / (max - min))
      end
      return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, number in ipairs(numbers) do
          if number < min then
              min = number
          end
          if number > max then
              max = number
          end
      end
      local range = max - min
      local rescaled = {}
      for _, number in ipairs(numbers) do
          table.insert(rescaled, (number - min) / range)
      end
      return rescaled
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for i = 2, #numbers do
          if numbers[i] < min then
              min = numbers[i]
          elseif numbers[i] > max then
              max = numbers[i]
          end
      end
      local result = {}
      for i = 1, #numbers do
          result[i] = (numbers[i] - min) / (max - min)
      end
      return result
  end
- |2-
      local min_number = math.min(unpack(numbers))
      local max_number = math.max(unpack(numbers))
      local range = max_number - min_number
      local rescaled_numbers = {}
      for _, number in ipairs(numbers) do
          table.insert(rescaled_numbers, (number - min_number) / range)
      end
      return rescaled_numbers
  end
- |2-
    local min = numbers[1]
    local max = numbers[1]
    for _, number in ipairs(numbers) do
      if number < min then
        min = number
      end
      if number > max then
        max = number
      end
    end
    local result = {}
    for _, number in ipairs(numbers) do
      table.insert(result, (number - min) / (max - min))
    end
    return result
  end
- |2-
    local min = math.min(unpack(numbers))
    local max = math.max(unpack(numbers))
    local result = {}
    for _, number in ipairs(numbers) do
      table.insert(result, (number - min) / (max - min))
    end
    return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, number in ipairs(numbers) do
          if number < min then
              min = number
          end
          if number > max then
              max = number
          end
      end
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min) / (max - min))
      end
      return result
  end
- |2-
      local min = math.min(unpack(numbers))
      local max = math.max(unpack(numbers))
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min) / (max - min))
      end
      return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, n in ipairs(numbers) do
          if n < min then
              min = n
          end
          if n > max then
              max = n
          end
      end
      local result = {}
      for _, n in ipairs(numbers) do
          table.insert(result, (n - min) / (max - min))
      end
      return result
  end
- |2-
      local min_value = math.min(unpack(numbers))
      local max_value = math.max(unpack(numbers))
      local range = max_value - min_value
      local rescaled = {}
      for _, number in ipairs(numbers) do
          table.insert(rescaled, (number - min_value) / range)
      end
      return rescaled
  end
- |2-
      local min = math.min(unpack(numbers))
      local max = math.max(unpack(numbers))
      local range = max - min
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min) / range)
      end
      return result
  end
- |2-
      local min_number = math.min(unpack(numbers))
      local max_number = math.max(unpack(numbers))
      local range = max_number - min_number
      local rescaled_numbers = {}
      for _, number in ipairs(numbers) do
          table.insert(rescaled_numbers, (number - min_number) / range)
      end
      return rescaled_numbers
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, n in ipairs(numbers) do
          if n < min then
              min = n
          end
          if n > max then
              max = n
          end
      end
      local result = {}
      for _, n in ipairs(numbers) do
          table.insert(result, (n - min) / (max - min))
      end
      return result
  end
- |2-
      local min = math.min(unpack(numbers))
      local max = math.max(unpack(numbers))
      local range = max - min
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min) / range)
      end
      return result
  end
- |2-
      local min = math.min(unpack(numbers))
      local max = math.max(unpack(numbers))
      local range = max - min
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min) / range)
      end
      return result
  end
- |2-
    local min = numbers[1]
    local max = numbers[1]
    for _, number in ipairs(numbers) do
      if number < min then
        min = number
      end
      if number > max then
        max = number
      end
    end
    local result = {}
    for _, number in ipairs(numbers) do
      table.insert(result, (number - min) / (max - min))
    end
    return result
  end
- |2-
      local min = math.min(unpack(numbers))
      local max = math.max(unpack(numbers))
      local range = max - min
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min) / range)
      end
      return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, n in ipairs(numbers) do
          if n < min then
              min = n
          end
          if n > max then
              max = n
          end
      end
      local range = max - min
      local result = {}
      for _, n in ipairs(numbers) do
          table.insert(result, (n - min) / range)
      end
      return result
  end
- |2-
    local min_number = math.min(unpack(numbers))
    local max_number = math.max(unpack(numbers))
    local range = max_number - min_number
    local rescaled_numbers = {}
    for _, number in ipairs(numbers) do
      table.insert(rescaled_numbers, (number - min_number) / range)
    end
    return rescaled_numbers
  end
- |2-
    local min_number = numbers[1]
    local max_number = numbers[1]
    for i = 2, #numbers do
      if numbers[i] < min_number then
        min_number = numbers[i]
      end
      if numbers[i] > max_number then
        max_number = numbers[i]
      end
    end
    local range = max_number - min_number
    local result = {}
    for i = 1, #numbers do
      result[i] = (numbers[i] - min_number) / range
    end
    return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, n in ipairs(numbers) do
          if n < min then
              min = n
          end
          if n > max then
              max = n
          end
      end
      local scale = max - min
      local result = {}
      for _, n in ipairs(numbers) do
          table.insert(result, (n - min) / scale)
      end
      return result
  end
- |2-
      local min = math.min(unpack(numbers))
      local max = math.max(unpack(numbers))
      local range = max - min
      local rescaled = {}
      for _, number in ipairs(numbers) do
          table.insert(rescaled, (number - min) / range)
      end
      return rescaled
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, number in ipairs(numbers) do
          if number < min then
              min = number
          end
          if number > max then
              max = number
          end
      end
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min) / (max - min))
      end
      return result
  end
- |2-
    local min = math.min(unpack(numbers))
    local max = math.max(unpack(numbers))
    local result = {}
    for i, v in ipairs(numbers) do
      result[i] = (v - min) / (max - min)
    end
    return result
  end
- |2-
    local min = math.min(unpack(numbers))
    local max = math.max(unpack(numbers))
    local scale = max - min
    local result = {}
    for _, number in ipairs(numbers) do
      table.insert(result, (number - min) / scale)
    end
    return result
  end
- |2-
      local min = math.min(unpack(numbers))
      local max = math.max(unpack(numbers))
      local range = max - min
      local res = {}
      for _, v in ipairs(numbers) do
          table.insert(res, (v - min) / range)
      end
      return res
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for i = 2, #numbers do
          if numbers[i] < min then
              min = numbers[i]
          elseif numbers[i] > max then
              max = numbers[i]
          end
      end
      local result = {}
      for i = 1, #numbers do
          result[i] = (numbers[i] - min) / (max - min)
      end
      return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for i = 2, #numbers do
          if numbers[i] < min then
              min = numbers[i]
          elseif numbers[i] > max then
              max = numbers[i]
          end
      end
      local result = {}
      for i = 1, #numbers do
          result[i] = (numbers[i] - min) / (max - min)
      end
      return result
  end
- |2-
      local min_number = math.min(unpack(numbers))
      local max_number = math.max(unpack(numbers))
      local range = max_number - min_number
      local rescaled_numbers = {}
      for _, number in ipairs(numbers) do
          table.insert(rescaled_numbers, (number - min_number) / range)
      end
      return rescaled_numbers
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, n in ipairs(numbers) do
          if n < min then
              min = n
          end
          if n > max then
              max = n
          end
      end
      local scale = 1 / (max - min)
      local result = {}
      for _, n in ipairs(numbers) do
          table.insert(result, (n - min) * scale)
      end
      return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, n in ipairs(numbers) do
          if n < min then
              min = n
          end
          if n > max then
              max = n
          end
      end
      local result = {}
      for _, n in ipairs(numbers) do
          table.insert(result, (n - min) / (max - min))
      end
      return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, number in ipairs(numbers) do
          if number < min then
              min = number
          end
          if number > max then
              max = number
          end
      end
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min) / (max - min))
      end
      return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for i = 2, #numbers do
          if numbers[i] < min then
              min = numbers[i]
          elseif numbers[i] > max then
              max = numbers[i]
          end
      end
      local result = {}
      for i = 1, #numbers do
          result[i] = (numbers[i] - min) / (max - min)
      end
      return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, number in ipairs(numbers) do
          if number < min then
              min = number
          end
          if number > max then
              max = number
          end
      end
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min) / (max - min))
      end
      return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, n in ipairs(numbers) do
          if n < min then
              min = n
          end
          if n > max then
              max = n
          end
      end
      local result = {}
      for _, n in ipairs(numbers) do
          table.insert(result, (n - min) / (max - min))
      end
      return result
  end
- |2-
    local min = numbers[1]
    local max = numbers[1]
    for i = 2, #numbers do
      if numbers[i] < min then
        min = numbers[i]
      elseif numbers[i] > max then
        max = numbers[i]
      end
    end
    local result = {}
    for i = 1, #numbers do
      result[i] = (numbers[i] - min) / (max - min)
    end
    return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, n in ipairs(numbers) do
          if n < min then
              min = n
          end
          if n > max then
              max = n
          end
      end
      local result = {}
      for _, n in ipairs(numbers) do
          table.insert(result, (n - min) / (max - min))
      end
      return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for i = 2, #numbers do
          if numbers[i] < min then
              min = numbers[i]
          elseif numbers[i] > max then
              max = numbers[i]
          end
      end
      local result = {}
      for i = 1, #numbers do
          result[i] = (numbers[i] - min) / (max - min)
      end
      return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, number in ipairs(numbers) do
          if number < min then
              min = number
          end
          if number > max then
              max = number
          end
      end
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min) / (max - min))
      end
      return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, num in ipairs(numbers) do
          if num < min then
              min = num
          end
          if num > max then
              max = num
          end
      end
      local range = max - min
      local result = {}
      for _, num in ipairs(numbers) do
          table.insert(result, (num - min) / range)
      end
      return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, n in ipairs(numbers) do
          if n < min then
              min = n
          end
          if n > max then
              max = n
          end
      end
      local result = {}
      for _, n in ipairs(numbers) do
          table.insert(result, (n - min) / (max - min))
      end
      return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, n in ipairs(numbers) do
          if n < min then
              min = n
          end
          if n > max then
              max = n
          end
      end
      local result = {}
      for _, n in ipairs(numbers) do
          table.insert(result, (n - min) / (max - min))
      end
      return result
  end
- |2-
      local min = math.min(unpack(numbers))
      local max = math.max(unpack(numbers))
      local range = max - min
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min) / range)
      end
      return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, n in ipairs(numbers) do
          if n < min then
              min = n
          end
          if n > max then
              max = n
          end
      end
      local result = {}
      for _, n in ipairs(numbers) do
          table.insert(result, (n - min) / (max - min))
      end
      return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, number in ipairs(numbers) do
          if number < min then
              min = number
          end
          if number > max then
              max = number
          end
      end
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min) / (max - min))
      end
      return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, number in ipairs(numbers) do
          if number < min then
              min = number
          end
          if number > max then
              max = number
          end
      end
      local scale = 1.0 / (max - min)
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min) * scale)
      end
      return result
  end
- |2-
      local min_number = math.min(unpack(numbers))
      local max_number = math.max(unpack(numbers))
      local scale = max_number - min_number
      local scaled_numbers = {}
      for _, number in ipairs(numbers) do
          table.insert(scaled_numbers, (number - min_number) / scale)
      end
      return scaled_numbers
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, number in ipairs(numbers) do
          if number < min then
              min = number
          end
          if number > max then
              max = number
          end
      end
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min) / (max - min))
      end
      return result
  end
- |2-
      local min_number = math.min(unpack(numbers))
      local max_number = math.max(unpack(numbers))
      local range = max_number - min_number
      local rescaled_numbers = {}
      for _, number in ipairs(numbers) do
          table.insert(rescaled_numbers, (number - min_number) / range)
      end
      return rescaled_numbers
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, n in ipairs(numbers) do
          if n < min then
              min = n
          end
          if n > max then
              max = n
          end
      end
      local result = {}
      for _, n in ipairs(numbers) do
          table.insert(result, (n - min) / (max - min))
      end
      return result
  end
- |2-
      local min = math.min(unpack(numbers))
      local max = math.max(unpack(numbers))
      local result = {}
      for _, v in ipairs(numbers) do
          table.insert(result, (v - min) / (max - min))
      end
      return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, number in ipairs(numbers) do
          if number < min then
              min = number
          end
          if number > max then
              max = number
          end
      end
      local scale = 1 / (max - min)
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min) * scale)
      end
      return result
  end
- |2-
      local min = math.min(unpack(numbers))
      local max = math.max(unpack(numbers))
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min) / (max - min))
      end
      return result
  end
- |2-
      local min, max = math.min(unpack(numbers)), math.max(unpack(numbers))
      local range = max - min
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min) / range)
      end
      return result
  end
- |2-
      local min = math.min(unpack(numbers))
      local max = math.max(unpack(numbers))
      local result = {}
      for _, number in ipairs(numbers) do
          table.insert(result, (number - min) / (max - min))
      end
      return result
  end
- |2-
    local min = numbers[1]
    local max = numbers[1]
    for _, n in ipairs(numbers) do
      if n < min then min = n end
      if n > max then max = n end
    end
    local scale = 1.0 / (max - min)
    local result = {}
    for _, n in ipairs(numbers) do
      table.insert(result, (n - min) * scale)
    end
    return result
  end
- |2-
      local min = numbers[1]
      local max = numbers[1]
      for _, n in ipairs(numbers) do
          if n < min then
              min = n
          end
          if n > max then
              max = n
          end
      end
      local result = {}
      for _, n in ipairs(numbers) do
          table.insert(result, (n - min) / (max - min))
      end
      return result
  end
- |2-
      local min_number = math.min(unpack(numbers))
      local max_number = math.max(unpack(numbers))
      local result = {}
      for i, number in ipairs(numbers) do
          result[i] = (number - min_number) / (max_number - min_number)
      end
      return result
  end
stop_tokens:
- |2-

  local
- |2-

  function
- |2-

  --
- "\n\n"
