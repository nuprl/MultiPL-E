name: HumanEval_68_pluck
language: lua
prompt: "-- \"Given a table representing a branch of a tree that has non-negative\
  \ integer nodes\n-- your task is to pluck one of the nodes and return it.\n-- The\
  \ plucked node should be the node with the smallest even value.\n-- If multiple\
  \ nodes with the same smallest even value are found return the node that has smallest\
  \ index.\n-- The plucked node should be returned in a table, [ smalest_value, its\
  \ index ],\n-- If there are no even values or the given table is empty, return [].\n\
  -- Example 1:\n-- >>> pluck({4, 2, 3})\n-- {2, 1}\n-- Explanation: 2 has the smallest\
  \ even value, and 2 has the smallest index.\n-- Example 2:\n-- >>> pluck({1, 2,\
  \ 3})\n-- {2, 1}\n-- Explanation: 2 has the smallest even value, and 2 has the smallest\
  \ index.\n-- Example 3:\n-- >>> pluck({})\n-- {}\n-- Example 4:\n-- >>> pluck({5,\
  \ 0, 3, 0, 4, 2})\n-- {0, 1}\n-- Explanation: 0 is the smallest value, but  there\
  \ are two zeros,\n-- so we will choose the first zero, which has the smallest index.\n\
  -- Constraints:\n-- * 1 <= nodes.length <= 10000\n-- * 0 <= node.value\nlocal function\
  \ pluck(arr)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = pluck\n\
  \    lu.assertEquals(candidate({4, 2, 3}), {2, 1})\n    lu.assertEquals(candidate({1,\
  \ 2, 3}), {2, 1})\n    lu.assertEquals(candidate({}), {})\n    lu.assertEquals(candidate({5,\
  \ 0, 3, 0, 4, 2}), {0, 1})\n    lu.assertEquals(candidate({1, 2, 3, 0, 5, 3}), {0,\
  \ 3})\n    lu.assertEquals(candidate({5, 4, 8, 4, 8}), {4, 1})\n    lu.assertEquals(candidate({7,\
  \ 6, 7, 1}), {6, 1})\n    lu.assertEquals(candidate({7, 9, 7, 1}), {})\nend\n\n\
  os.exit(lu.LuaUnit.run())"
completions: ["  local min_even, min_even_idx\n  for i, v in ipairs(arr) do\n    if\
    \ v % 2 == 0 then\n      if not min_even or v < min_even then\n        min_even\
    \ = v\n        min_even_idx = i\n      end\n    end\n  end\n  return {min_even,\
    \ min_even_idx}\nend", "  local min = math.huge\n  local min_index = 0\n  for\
    \ i, v in ipairs(arr) do\n    if v % 2 == 0 and v < min then\n      min = v\n\
    \      min_index = i\n    end\n  end\n  if min == math.huge then\n    return {}\n\
    \  end\n  return {min, min_index}\nend", "  local smallest = nil\n  local smallest_index\
    \ = nil\n  for i, v in ipairs(arr) do\n    if v % 2 == 0 then\n      if smallest\
    \ == nil or v < smallest then\n        smallest = v\n        smallest_index =\
    \ i\n      end\n    end\n  end\n  if smallest == nil then\n    return {}\n  else\n\
    \    return {smallest, smallest_index}\n  end\nend", "  local min_even = math.huge\n\
    \  local min_even_idx = math.huge\n  for i, v in ipairs(arr) do\n    if v % 2\
    \ == 0 and v < min_even then\n      min_even = v\n      min_even_idx = i\n   \
    \ end\n  end\n  if min_even == math.huge then\n    return {}\n  end\n  return\
    \ {min_even, min_even_idx}\nend", "  local min = math.huge\n  local min_index\
    \ = math.huge\n  for i, v in ipairs(arr) do\n    if v % 2 == 0 and v < min then\n\
    \      min = v\n      min_index = i\n    end\n  end\n  if min == math.huge then\n\
    \    return {}\n  end\n  return {min, min_index}\nend", "  local min = math.huge\n\
    \  local min_idx = math.huge\n  for i, v in ipairs(arr) do\n    if v % 2 == 0\
    \ and v < min then\n      min = v\n      min_idx = i\n    end\n  end\n  if min\
    \ == math.huge then\n    return {}\n  end\n  return {min, min_idx}\nend", "  local\
    \ min = math.huge\n  local min_idx = math.huge\n  for i, v in ipairs(arr) do\n\
    \    if v % 2 == 0 and v < min then\n      min = v\n      min_idx = i\n    end\n\
    \  end\n  if min == math.huge then\n    return {}\n  end\n  return {min, min_idx}\n\
    end", "  local min = math.huge\n  local min_index = math.huge\n  for i, v in ipairs(arr)\
    \ do\n    if v % 2 == 0 and v < min then\n      min = v\n      min_index = i\n\
    \    end\n  end\n  if min == math.huge then\n    return {}\n  end\n  return {min,\
    \ min_index}\nend", "  local min = math.huge\n  local min_index = math.huge\n\
    \  for i, v in ipairs(arr) do\n    if v % 2 == 0 and v < min then\n      min =\
    \ v\n      min_index = i\n    end\n  end\n  if min == math.huge then\n    return\
    \ {}\n  end\n  return {min, min_index}\nend", "  local min = nil\n  local min_index\
    \ = nil\n  for i, v in ipairs(arr) do\n    if v % 2 == 0 then\n      if min ==\
    \ nil or v < min then\n        min = v\n        min_index = i\n      end\n   \
    \ end\n  end\n  if min == nil then\n    return {}\n  else\n    return {min, min_index}\n\
    \  end\nend", "  local min_even = math.huge\n  local min_even_idx = math.huge\n\
    \  for i, v in ipairs(arr) do\n    if v % 2 == 0 and v < min_even then\n     \
    \ min_even = v\n      min_even_idx = i\n    end\n  end\n  if min_even == math.huge\
    \ then\n    return {}\n  end\n  return {min_even, min_even_idx}\nend", "  local\
    \ min_value = math.huge\n  local min_index = math.huge\n  for i, v in ipairs(arr)\
    \ do\n    if v % 2 == 0 and v < min_value then\n      min_value = v\n      min_index\
    \ = i\n    end\n  end\n  if min_value == math.huge then\n    return {}\n  end\n\
    \  return {min_value, min_index}\nend", "  local min = math.huge\n  local min_idx\
    \ = math.huge\n  for i, v in ipairs(arr) do\n    if v % 2 == 0 and v < min then\n\
    \      min = v\n      min_idx = i\n    end\n  end\n  if min == math.huge then\n\
    \    return {}\n  end\n  return {min, min_idx}\nend", "  local smallest = nil\n\
    \  local smallest_index = nil\n  for i, v in ipairs(arr) do\n    if v % 2 == 0\
    \ then\n      if smallest == nil or v < smallest then\n        smallest = v\n\
    \        smallest_index = i\n      end\n    end\n  end\n  if smallest == nil then\n\
    \    return {}\n  else\n    return {smallest, smallest_index}\n  end\nend", " \
    \ local min_even, min_even_idx = math.huge, math.huge\n  for i, v in ipairs(arr)\
    \ do\n    if v % 2 == 0 and v < min_even then\n      min_even, min_even_idx =\
    \ v, i\n    end\n  end\n  return min_even == math.huge and {} or {min_even, min_even_idx}\n\
    end", "  local min = math.huge\n  local index = 0\n  for i, v in ipairs(arr) do\n\
    \    if v % 2 == 0 and v < min then\n      min = v\n      index = i\n    end\n\
    \  end\n  if min == math.huge then\n    return {}\n  end\n  return {min, index}\n\
    end", "  local min = math.huge\n  local min_index = math.huge\n  for i, v in ipairs(arr)\
    \ do\n    if v % 2 == 0 and v < min then\n      min = v\n      min_index = i\n\
    \    end\n  end\n  if min == math.huge then\n    return {}\n  end\n  return {min,\
    \ min_index}\nend", "  local min_even, min_even_idx = math.huge, math.huge\n \
    \ for i, v in ipairs(arr) do\n    if v % 2 == 0 and v < min_even then\n      min_even,\
    \ min_even_idx = v, i\n    end\n  end\n  return min_even == math.huge and {} or\
    \ {min_even, min_even_idx}\nend", "  local min = math.huge\n  local min_idx =\
    \ math.huge\n  for idx, val in ipairs(arr) do\n    if val % 2 == 0 and val < min\
    \ then\n      min = val\n      min_idx = idx\n    end\n  end\n  if min == math.huge\
    \ then\n    return {}\n  end\n  return {min, min_idx}\nend", "  local min = math.huge\n\
    \  local min_i = math.huge\n  for i, v in ipairs(arr) do\n    if v % 2 == 0 and\
    \ v < min then\n      min = v\n      min_i = i\n    end\n  end\n  if min == math.huge\
    \ then\n    return {}\n  end\n  return {min, min_i}\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
