name: HumanEval_119_match_parens
language: lua
results:
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(str)\n    local count = 0\n    for i = 1, #str do\n\
    \      if str:sub(i, i) == '(' then\n        count = count + 1\n      else\n \
    \       count = count - 1\n      end\n      if count < 0 then\n        return\
    \ false\n      end\n    end\n    return count == 0\n  end\n  return is_good(lst[1]\
    \ .. lst[2]) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpbv401je_.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpbv401je_.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmplf9z_wc_.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmplf9z_wc_.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \    local open, close = 0, 0\n    for _, s in ipairs(lst) do\n        for c in\
    \ s:gmatch('%(') do open = open + 1 end\n        for c in s:gmatch('%)') do close\
    \ = close + 1 end\n    end\n    return open == close and 'Yes' or 'No'\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpmiyiloh9.lua:35:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmpmiyiloh9.lua:35:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpsa_gk4y8.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpsa_gk4y8.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.010 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \    local function is_good(s)\n        local cnt = 0\n        for i = 1, #s do\n\
    \            if s:sub(i, i) == '(' then\n                cnt = cnt + 1\n     \
    \       else\n                cnt = cnt - 1\n            end\n            if cnt\
    \ < 0 then\n                return false\n            end\n        end\n     \
    \   return cnt == 0\n    end\n    return is_good(lst[1] .. lst[2]) and 'Yes' or\
    \ 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp5kw7_nc5.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp5kw7_nc5.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.010 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local a, b = lst[1], lst[2]\n  local n = #a + #b\n  local cnt = 0\n  for i\
    \ = 1, n do\n    if i <= #a then\n      if a:sub(i, i) == '(' then\n        cnt\
    \ = cnt + 1\n      else\n        cnt = cnt - 1\n      end\n    else\n      if\
    \ b:sub(i - #a, i - #a) == '(' then\n        cnt = cnt + 1\n      else\n     \
    \   cnt = cnt - 1\n      end\n    end\n    if cnt < 0 then\n      return 'No'\n\
    \    end\n  end\n  return 'Yes'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp0_ann18w.lua:45:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp0_ann18w.lua:45:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpbomgje0z.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpbomgje0z.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpmfsukvxt.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpmfsukvxt.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local s1, s2 = lst[1], lst[2]\n  local n1, n2 = #s1, #s2\n  local n = n1 +\
    \ n2\n  local cnt = 0\n  for i = 1, n do\n    local c = (i <= n1) and s1:sub(i,\
    \ i) or s2:sub(i - n1, i - n1)\n    if c == '(' then\n      cnt = cnt + 1\n  \
    \  else\n      cnt = cnt - 1\n    end\n    if cnt < 0 then\n      return 'No'\n\
    \    end\n  end\n  return (cnt == 0) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpb5w5gz3h.lua:39:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpb5w5gz3h.lua:39:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local count = 0\n    for c in s:gmatch('.')\
    \ do\n      if c == '(' then\n        count = count + 1\n      else\n        count\
    \ = count - 1\n      end\n      if count < 0 then\n        return false\n    \
    \  end\n    end\n    return count == 0\n  end\n  local s1, s2 = lst[1], lst[2]\n\
    \  return is_good(s1 .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpq_pi8z4f.lua:36:\
    \ expected: \"Yes\"\nactual: true\nstack traceback:\n\t/tmp/tmpq_pi8z4f.lua:36:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local count = 0\n    for c in s:gmatch(\".\"\
    ) do\n      if c == '(' then\n        count = count + 1\n      else\n        count\
    \ = count - 1\n      end\n      if count < 0 then\n        return false\n    \
    \  end\n    end\n    return count == 0\n  end\n  local s1, s2 = lst[1], lst[2]\n\
    \  return is_good(s1 .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpqu065m__.lua:36:\
    \ expected: \"Yes\"\nactual: true\nstack traceback:\n\t/tmp/tmpqu065m__.lua:36:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function count_parens(s)\n    local c = 0\n    for i = 1, #s do\n   \
    \   if s:sub(i, i) == '(' then\n        c = c + 1\n      else\n        c = c -\
    \ 1\n      end\n    end\n    return c\n  end\n  local c1, c2 = count_parens(lst[1]),\
    \ count_parens(lst[2])\n  if c1 == 0 and c2 == 0 then\n    return 'Yes'\n  elseif\
    \ c1 == 0 and c2 ~= 0 then\n    return 'No'\n  elseif c1 ~= 0 and c2 == 0 then\n\
    \    return 'No'\n  elseif c1 > 0 and c2 > 0 then\n    return 'No'\n  elseif c1\
    \ < 0 and c2 < 0 then\n    return 'No'\n  else\n    return 'Yes'\n  end\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpu8ys0kzv.lua:47:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmpu8ys0kzv.lua:47:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function count_parens(s)\n    local cnt = 0\n    for i = 1, #s do\n \
    \     if s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt\
    \ = cnt - 1\n      end\n    end\n    return cnt\n  end\n  local a, b = lst[1],\
    \ lst[2]\n  local cnt_a, cnt_b = count_parens(a), count_parens(b)\n  if cnt_a\
    \ == 0 and cnt_b == 0 then\n    return 'Yes'\n  elseif cnt_a == 0 then\n    return\
    \ 'No'\n  elseif cnt_b == 0 then\n    return 'No'\n  elseif cnt_a * cnt_b < 0\
    \ then\n    return 'Yes'\n  else\n    return 'No'\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp8up9o_u9.lua:46:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmp8up9o_u9.lua:46:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp96wn6jjv.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp96wn6jjv.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(str)\n    local count = 0\n    for c in str:gmatch('.')\
    \ do\n      if c == '(' then\n        count = count + 1\n      else\n        count\
    \ = count - 1\n      end\n      if count < 0 then\n        return false\n    \
    \  end\n    end\n    return count == 0\n  end\n  return is_good(lst[1] .. lst[2])\
    \ and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpwkbjqwif.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpwkbjqwif.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \    local s1, s2 = lst[1], lst[2]\n    local function is_good(s)\n        local\
    \ cnt = 0\n        for i = 1, #s do\n            if s:sub(i, i) == '(' then\n\
    \                cnt = cnt + 1\n            else\n                cnt = cnt -\
    \ 1\n            end\n            if cnt < 0 then\n                return false\n\
    \            end\n        end\n        return cnt == 0\n    end\n    return is_good(s1\
    \ .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpj8u8qsn3.lua:36:\
    \ expected: \"Yes\"\nactual: true\nstack traceback:\n\t/tmp/tmpj8u8qsn3.lua:36:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(str)\n    local count = 0\n    for i = 1, #str do\n\
    \      if str:sub(i, i) == '(' then\n        count = count + 1\n      else\n \
    \       count = count - 1\n      end\n      if count < 0 then\n        return\
    \ false\n      end\n    end\n    return count == 0\n  end\n  return is_good(lst[1]\
    \ .. lst[2]) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp7oicbsos.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp7oicbsos.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local count = 0\n    for c in s:gmatch('.')\
    \ do\n      if c == '(' then\n        count = count + 1\n      else\n        count\
    \ = count - 1\n      end\n      if count < 0 then\n        return false\n    \
    \  end\n    end\n    return count == 0\n  end\n  local s1, s2 = lst[1], lst[2]\n\
    \  if is_good(s1) then\n    return 'Yes'\n  elseif is_good(s2) then\n    return\
    \ 'Yes'\n  elseif is_good(s1 .. s2) then\n    return 'Yes'\n  elseif is_good(s2\
    \ .. s1) then\n    return 'Yes'\n  else\n    return 'No'\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp3kt0_s96.lua:51:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmp3kt0_s96.lua:51:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local s1, s2 = lst[1], lst[2]\n  local n1, n2 = #s1, #s2\n  local i, j = 1,\
    \ 1\n  local c1, c2 = 0, 0\n  while i <= n1 and j <= n2 do\n    if s1:sub(i, i)\
    \ == '(' then\n      c1 = c1 + 1\n    else\n      c1 = c1 - 1\n    end\n    if\
    \ s2:sub(j, j) == '(' then\n      c2 = c2 + 1\n    else\n      c2 = c2 - 1\n \
    \   end\n    if c1 < 0 or c2 < 0 then\n      return 'No'\n    end\n    i = i +\
    \ 1\n    j = j + 1\n  end\n  if c1 == 0 and c2 == 0 then\n    return 'Yes'\n \
    \ end\n  if c1 > 0 then\n    while i <= n1 do\n      if s1:sub(i, i) == '(' then\n\
    \        c1 = c1 + 1\n      else\n        c1 = c1 - 1\n      end\n      if c1\
    \ < 0 then\n        return 'No'\n      end\n      i = i + 1\n    end\n  else\n\
    \    while j <= n2 do\n      if s2:sub(j, j) == '(' then\n        c2 = c2 + 1\n\
    \      else\n        c2 = c2 - 1\n      end\n      if c2 < 0 then\n        return\
    \ 'No'\n      end\n      j = j + 1\n    end\n  end\n  if c1 == 0 and c2 == 0 then\n\
    \    return 'Yes'\n  end\n  return 'No'\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp1u_5_kqt.lua:73:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp1u_5_kqt.lua:73:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp1p3ixy6q.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp1p3ixy6q.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpj2dli_ae.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpj2dli_ae.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(str)\n    local count = 0\n    for i = 1, #str do\n\
    \      if str:sub(i, i) == '(' then\n        count = count + 1\n      else\n \
    \       count = count - 1\n      end\n      if count < 0 then\n        return\
    \ false\n      end\n    end\n    return count == 0\n  end\n  local str1, str2\
    \ = lst[1], lst[2]\n  return is_good(str1 .. str2) or is_good(str2 .. str1) and\
    \ 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpt42kgjs1.lua:36:\
    \ expected: \"Yes\"\nactual: true\nstack traceback:\n\t/tmp/tmpt42kgjs1.lua:36:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpp7s5if_d.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpp7s5if_d.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local s1, s2 = lst[1], lst[2]\n  local n1, n2 = #s1, #s2\n  local p1, p2 =\
    \ 0, 0\n  for i = 1, n1 do\n    if s1:sub(i, i) == '(' then\n      p1 = p1 + 1\n\
    \    else\n      p1 = p1 - 1\n    end\n  end\n  for i = 1, n2 do\n    if s2:sub(i,\
    \ i) == '(' then\n      p2 = p2 + 1\n    else\n      p2 = p2 - 1\n    end\n  end\n\
    \  if p1 + p2 == 0 then\n    return 'Yes'\n  else\n    return 'No'\n  end\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp7hziu8az.lua:51:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmp7hziu8az.lua:51:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local s1, s2 = lst[1], lst[2]\n  local n1, n2 = #s1, #s2\n  local n = n1 +\
    \ n2\n  local c = 0\n  for i = 1, n do\n    local c1 = s1:sub(i, i) == '(' and\
    \ 1 or -1\n    local c2 = s2:sub(i, i) == '(' and 1 or -1\n    c = c + c1 + c2\n\
    \    if c < 0 then return 'No' end\n  end\n  return c == 0 and 'Yes' or 'No'\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpngiewz92.lua:31:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpngiewz92.lua:31:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpofmad34s.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpofmad34s.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(str)\n    local count = 0\n    for i = 1, #str do\n\
    \      if str:sub(i, i) == '(' then\n        count = count + 1\n      else\n \
    \       count = count - 1\n      end\n      if count < 0 then\n        return\
    \ false\n      end\n    end\n    return count == 0\n  end\n  return is_good(lst[1]\
    \ .. lst[2]) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpscw_s38c.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpscw_s38c.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpyy3zwck7.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpyy3zwck7.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \    local function is_good(s)\n        local cnt = 0\n        for i = 1, #s do\n\
    \            if s:sub(i, i) == '(' then\n                cnt = cnt + 1\n     \
    \       else\n                cnt = cnt - 1\n            end\n            if cnt\
    \ < 0 then\n                return false\n            end\n        end\n     \
    \   return cnt == 0\n    end\n    local s1, s2 = lst[1], lst[2]\n    return is_good(s1\
    \ .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmppocvpvsm.lua:36:\
    \ expected: \"Yes\"\nactual: true\nstack traceback:\n\t/tmp/tmppocvpvsm.lua:36:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(str)\n    local count = 0\n    for i = 1, #str do\n\
    \      if str:sub(i, i) == '(' then\n        count = count + 1\n      else\n \
    \       count = count - 1\n      end\n      if count < 0 then\n        return\
    \ false\n      end\n    end\n    return count == 0\n  end\n  return is_good(lst[1]\
    \ .. lst[2]) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpj04txpyd.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpj04txpyd.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local s1, s2 = lst[1], lst[2]\n  local c1, c2 = 0, 0\n  for i = 1, #s1 do\n\
    \    if s1:sub(i, i) == '(' then\n      c1 = c1 + 1\n    else\n      c1 = c1 -\
    \ 1\n    end\n  end\n  for i = 1, #s2 do\n    if s2:sub(i, i) == '(' then\n  \
    \    c2 = c2 + 1\n    else\n      c2 = c2 - 1\n    end\n  end\n  if c1 == 0 and\
    \ c2 == 0 then\n    return 'Yes'\n  elseif c1 == 0 and c2 > 0 then\n    return\
    \ 'No'\n  elseif c1 > 0 and c2 == 0 then\n    return 'No'\n  elseif c1 > 0 and\
    \ c2 > 0 then\n    return 'Yes'\n  elseif c1 < 0 and c2 < 0 then\n    return 'No'\n\
    \  elseif c1 < 0 and c2 == 0 then\n    return 'No'\n  elseif c1 == 0 and c2 <\
    \ 0 then\n    return 'No'\n  elseif c1 < 0 and c2 > 0 then\n    return 'Yes'\n\
    \  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpr_4jyy4d.lua:53:\
    \ expected: \"Yes\"\nactual: nil\nstack traceback:\n\t/tmp/tmpr_4jyy4d.lua:53:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local s = lst[1] .. lst[2]\n  local c = 0\n  for i = 1, #s do\n    if s:sub(i,\
    \ i) == '(' then\n      c = c + 1\n    else\n      c = c - 1\n    end\n    if\
    \ c < 0 then\n      return 'No'\n    end\n  end\n  return c == 0 and 'Yes' or\
    \ 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp53iamedj.lua:36:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp53iamedj.lua:36:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \    local function is_good(s)\n        local cnt = 0\n        for i = 1, #s do\n\
    \            if s:sub(i, i) == '(' then\n                cnt = cnt + 1\n     \
    \       else\n                cnt = cnt - 1\n            end\n            if cnt\
    \ < 0 then\n                return false\n            end\n        end\n     \
    \   return cnt == 0\n    end\n    local s1, s2 = lst[1], lst[2]\n    return is_good(s1\
    \ .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpwde1avdz.lua:36:\
    \ expected: \"Yes\"\nactual: true\nstack traceback:\n\t/tmp/tmpwde1avdz.lua:36:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  local s1, s2 = lst[1], lst[2]\n  return is_good(s1\
    \ .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmph6n_yg3y.lua:36:\
    \ expected: \"Yes\"\nactual: true\nstack traceback:\n\t/tmp/tmph6n_yg3y.lua:36:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  local s1, s2 = lst[1], lst[2]\n  return is_good(s1\
    \ .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpp2jygw2u.lua:36:\
    \ expected: \"Yes\"\nactual: true\nstack traceback:\n\t/tmp/tmpp2jygw2u.lua:36:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local open, close = 0, 0\n  for _, s in ipairs(lst) do\n    for c in s:gmatch('%(')\
    \ do open = open + 1 end\n    for c in s:gmatch('%)') do close = close + 1 end\n\
    \  end\n  return open == close and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpzrs8hg1y.lua:35:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmpzrs8hg1y.lua:35:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local s1, s2 = lst[1], lst[2]\n  local n1, n2 = #s1, #s2\n  local n = n1 +\
    \ n2\n  local cnt = 0\n  for i = 1, n do\n    local c = i <= n1 and s1:sub(i,\
    \ i) or s2:sub(i - n1, i - n1)\n    if c == '(' then\n      cnt = cnt + 1\n  \
    \  else\n      cnt = cnt - 1\n    end\n    if cnt < 0 then\n      return 'No'\n\
    \    end\n  end\n  return cnt == 0 and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpdockm28a.lua:39:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpdockm28a.lua:39:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpuigx0x_2.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpuigx0x_2.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpwkwq9ymm.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpwkwq9ymm.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(str)\n    local cnt = 0\n    for i = 1, #str do\n  \
    \    if str:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n       \
    \ cnt = cnt - 1\n      end\n      if cnt < 0 then\n        return false\n    \
    \  end\n    end\n    return cnt == 0\n  end\n  local s1, s2 = lst[1], lst[2]\n\
    \  return is_good(s1 .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpiy4l7qme.lua:36:\
    \ expected: \"Yes\"\nactual: true\nstack traceback:\n\t/tmp/tmpiy4l7qme.lua:36:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(str)\n    local count = 0\n    for i = 1, #str do\n\
    \      if str:sub(i, i) == '(' then\n        count = count + 1\n      else\n \
    \       count = count - 1\n      end\n      if count < 0 then\n        return\
    \ false\n      end\n    end\n    return count == 0\n  end\n  return is_good(lst[1]\
    \ .. lst[2]) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpn0gzwwfi.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpn0gzwwfi.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp_2rt45ij.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp_2rt45ij.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local open = 0\n  local close = 0\n  for _, s in ipairs(lst) do\n    for c\
    \ in s:gmatch('.') do\n      if c == '(' then\n        open = open + 1\n     \
    \ else\n        close = close + 1\n      end\n    end\n  end\n  return (open ==\
    \ close) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpr03yke3b.lua:41:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmpr03yke3b.lua:41:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpsc_0cfzt.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpsc_0cfzt.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp0t5dxrkk.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp0t5dxrkk.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \    local function is_good(s)\n        local cnt = 0\n        for i = 1, #s do\n\
    \            if s:sub(i, i) == '(' then\n                cnt = cnt + 1\n     \
    \       else\n                cnt = cnt - 1\n            end\n            if cnt\
    \ < 0 then\n                return false\n            end\n        end\n     \
    \   return cnt == 0\n    end\n    return is_good(lst[1] .. lst[2]) and 'Yes' or\
    \ 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpic5dfgxc.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpic5dfgxc.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp4mjgnqff.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp4mjgnqff.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmprm5gpojr.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmprm5gpojr.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \    local s1, s2 = lst[1], lst[2]\n    local function is_good(s)\n        local\
    \ n = 0\n        for i = 1, #s do\n            if s:sub(i, i) == '(' then\n  \
    \              n = n + 1\n            else\n                n = n - 1\n      \
    \      end\n            if n < 0 then\n                return false\n        \
    \    end\n        end\n        return n == 0\n    end\n    return is_good(s1 ..\
    \ s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpjcurmx4h.lua:36:\
    \ expected: \"Yes\"\nactual: true\nstack traceback:\n\t/tmp/tmpjcurmx4h.lua:36:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(str)\n    local cnt = 0\n    for i = 1, #str do\n  \
    \    if str:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n       \
    \ cnt = cnt - 1\n      end\n      if cnt < 0 then\n        return false\n    \
    \  end\n    end\n    return cnt == 0\n  end\n  local str1, str2 = lst[1], lst[2]\n\
    \  return is_good(str1 .. str2) or is_good(str2 .. str1) and 'Yes' or 'No'\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpqak4usyb.lua:36:\
    \ expected: \"Yes\"\nactual: true\nstack traceback:\n\t/tmp/tmpqak4usyb.lua:36:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local s1, s2 = lst[1], lst[2]\n  local n1, n2 = #s1, #s2\n  local n = n1 +\
    \ n2\n  local cnt = 0\n  for i = 1, n do\n    local c = i <= n1 and s1:sub(i,\
    \ i) or s2:sub(i - n1, i - n1)\n    if c == '(' then\n      cnt = cnt + 1\n  \
    \  else\n      cnt = cnt - 1\n    end\n    if cnt < 0 then\n      return 'No'\n\
    \    end\n  end\n  return cnt == 0 and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmptbp3w_f7.lua:39:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmptbp3w_f7.lua:39:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpd7pf3xjd.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpd7pf3xjd.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(str)\n    local count = 0\n    for i = 1, #str do\n\
    \      if str:sub(i, i) == '(' then\n        count = count + 1\n      else\n \
    \       count = count - 1\n      end\n      if count < 0 then\n        return\
    \ false\n      end\n    end\n    return count == 0\n  end\n  return is_good(lst[1]\
    \ .. lst[2]) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmps2a8sh_j.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmps2a8sh_j.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function count_parens(s)\n    local c = 0\n    for i = 1, #s do\n   \
    \   if s:sub(i, i) == '(' then\n        c = c + 1\n      else\n        c = c -\
    \ 1\n      end\n    end\n    return c\n  end\n  if count_parens(lst[1]) + count_parens(lst[2])\
    \ == 0 then\n    return 'Yes'\n  else\n    return 'No'\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpel0t50m0.lua:45:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmpel0t50m0.lua:45:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(str)\n    local cnt = 0\n    for i = 1, #str do\n  \
    \    if str:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n       \
    \ cnt = cnt - 1\n      end\n      if cnt < 0 then\n        return false\n    \
    \  end\n    end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2])\
    \ and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpvle28z1_.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpvle28z1_.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local s1, s2 = lst[1], lst[2]\n  local n1, n2 = #s1, #s2\n  local n = n1 +\
    \ n2\n  local cnt = 0\n  for i = 1, n do\n    local c = (i <= n1) and s1:sub(i,\
    \ i) or s2:sub(i - n1, i - n1)\n    if c == '(' then\n      cnt = cnt + 1\n  \
    \  else\n      cnt = cnt - 1\n    end\n    if cnt < 0 then\n      return 'No'\n\
    \    end\n  end\n  return (cnt == 0) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp0wva_l_4.lua:39:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp0wva_l_4.lua:39:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local open = 0\n  local close = 0\n  for _, v in ipairs(lst) do\n    for _,\
    \ c in ipairs(v:split('')) do\n      if c == '(' then\n        open = open + 1\n\
    \      else\n        close = close + 1\n      end\n    end\n  end\n  return open\
    \ == close and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpfbg1e_sh.lua:18:\
    \ attempt to call a nil value (method 'split')\nstack traceback:\n\t/tmp/tmpfbg1e_sh.lua:18:\
    \ in local 'candidate'\n\t/tmp/tmpfbg1e_sh.lua:32: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpd0b9sagc.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpd0b9sagc.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \    local left, right = 0, 0\n    for _, v in ipairs(lst) do\n        for _,\
    \ c in ipairs(v) do\n            if c == '(' then\n                left = left\
    \ + 1\n            else\n                right = right + 1\n            end\n\
    \        end\n    end\n    return left == right and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpif2iiq38.lua:32:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmpif2iiq38.lua:32:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(str)\n    local cnt = 0\n    for i = 1, #str do\n  \
    \    if str:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n       \
    \ cnt = cnt - 1\n      end\n      if cnt < 0 then\n        return false\n    \
    \  end\n    end\n    return cnt == 0\n  end\n  local s1, s2 = lst[1], lst[2]\n\
    \  return is_good(s1 .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmphgv6i75n.lua:36:\
    \ expected: \"Yes\"\nactual: true\nstack traceback:\n\t/tmp/tmphgv6i75n.lua:36:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpgwk58ywn.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpgwk58ywn.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpbv207y3p.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpbv207y3p.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local open = 0\n  local close = 0\n  for i = 1, #lst[1] do\n    if lst[1]:sub(i,\
    \ i) == '(' then\n      open = open + 1\n    else\n      close = close + 1\n \
    \   end\n  end\n  for i = 1, #lst[2] do\n    if lst[2]:sub(i, i) == '(' then\n\
    \      open = open + 1\n    else\n      close = close + 1\n    end\n  end\n  if\
    \ open == close then\n    return 'Yes'\n  else\n    return 'No'\n  end\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp9uybsyql.lua:50:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmp9uybsyql.lua:50:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  local s1, s2 = lst[1], lst[2]\n  return is_good(s1\
    \ .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp550ylqwz.lua:36:\
    \ expected: \"Yes\"\nactual: true\nstack traceback:\n\t/tmp/tmp550ylqwz.lua:36:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpeqqd3942.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpeqqd3942.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local count = 0\n    for i = 1, #s do\n    \
    \  if s:sub(i, i) == '(' then\n        count = count + 1\n      else\n       \
    \ count = count - 1\n      end\n      if count < 0 then\n        return false\n\
    \      end\n    end\n    return count == 0\n  end\n  return (is_good(lst[1]) and\
    \ is_good(lst[2])) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp01imt6bc.lua:35:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp01imt6bc.lua:35:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp50fvkp60.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp50fvkp60.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function check(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return check(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp8ce7jxzo.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp8ce7jxzo.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp8dusvwev.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp8dusvwev.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \    local function is_good(s)\n        local count = 0\n        for c in s:gmatch('.')\
    \ do\n            if c == '(' then\n                count = count + 1\n      \
    \      else\n                count = count - 1\n            end\n            if\
    \ count < 0 then\n                return false\n            end\n        end\n\
    \        return count == 0\n    end\n    return is_good(lst[1] .. lst[2]) and\
    \ 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp467hp1z1.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp467hp1z1.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local count = 0\n    for i = 1, #s do\n    \
    \  if s:sub(i, i) == '(' then\n        count = count + 1\n      else\n       \
    \ count = count - 1\n      end\n      if count < 0 then\n        return false\n\
    \      end\n    end\n    return count == 0\n  end\n  return is_good(lst[1] ..\
    \ lst[2]) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpsx9pc2vz.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpsx9pc2vz.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(str)\n    local count = 0\n    for i = 1, #str do\n\
    \      if str:sub(i, i) == '(' then\n        count = count + 1\n      else\n \
    \       count = count - 1\n      end\n      if count < 0 then\n        return\
    \ false\n      end\n    end\n    return count == 0\n  end\n  return is_good(lst[1]\
    \ .. lst[2]) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmprb2y_gll.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmprb2y_gll.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpwzbdbd27.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpwzbdbd27.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp1a5h6nih.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp1a5h6nih.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local count = 0\n    for i = 1, #s do\n    \
    \  if s:sub(i, i) == '(' then\n        count = count + 1\n      else\n       \
    \ count = count - 1\n      end\n      if count < 0 then\n        return false\n\
    \      end\n    end\n    return count == 0\n  end\n  return is_good(lst[1] ..\
    \ lst[2]) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpfsfd3uo4.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpfsfd3uo4.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \    local function is_good(s)\n        local count = 0\n        for c in s:gmatch('.')\
    \ do\n            if c == '(' then\n                count = count + 1\n      \
    \      else\n                count = count - 1\n            end\n            if\
    \ count < 0 then\n                return false\n            end\n        end\n\
    \        return count == 0\n    end\n    return is_good(lst[1] .. lst[2]) and\
    \ 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpavjehl3b.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpavjehl3b.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \    local function is_good(s)\n        local count = 0\n        for c in s:gmatch('.')\
    \ do\n            if c == '(' then\n                count = count + 1\n      \
    \      else\n                count = count - 1\n            end\n            if\
    \ count < 0 then\n                return false\n            end\n        end\n\
    \        return count == 0\n    end\n    return is_good(lst[1] .. lst[2]) and\
    \ 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp3kdvt0t4.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp3kdvt0t4.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local s1, s2 = lst[1], lst[2]\n  local function is_good(s)\n    local count\
    \ = 0\n    for i = 1, #s do\n      if s:sub(i, i) == '(' then\n        count =\
    \ count + 1\n      else\n        count = count - 1\n      end\n      if count\
    \ < 0 then\n        return false\n      end\n    end\n    return count == 0\n\
    \  end\n  return is_good(s1 .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpeve5wqkj.lua:36:\
    \ expected: \"Yes\"\nactual: true\nstack traceback:\n\t/tmp/tmpeve5wqkj.lua:36:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpu3m6logf.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpu3m6logf.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpyaq9iwum.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpyaq9iwum.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp5rn2wrta.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp5rn2wrta.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local count = 0\n    for i = 1, #s do\n    \
    \  if s:sub(i, i) == '(' then\n        count = count + 1\n      else\n       \
    \ count = count - 1\n      end\n      if count < 0 then\n        return false\n\
    \      end\n    end\n    return count == 0\n  end\n  return is_good(lst[1] ..\
    \ lst[2]) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpl4ausg5g.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpl4ausg5g.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local s1, s2 = lst[1], lst[2]\n  local c1, c2 = 0, 0\n  for i = 1, #s1 do\n\
    \    if s1:sub(i, i) == '(' then\n      c1 = c1 + 1\n    else\n      c1 = c1 -\
    \ 1\n    end\n  end\n  for i = 1, #s2 do\n    if s2:sub(i, i) == '(' then\n  \
    \    c2 = c2 + 1\n    else\n      c2 = c2 - 1\n    end\n  end\n  if c1 < 0 or\
    \ c2 < 0 then\n    return 'No'\n  end\n  if c1 % 2 == 0 then\n    return 'Yes'\n\
    \  end\n  if c2 % 2 == 0 then\n    return 'Yes'\n  end\n  return 'No'\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp8i37v_0y.lua:46:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp8i37v_0y.lua:46:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local s1, s2 = lst[1], lst[2]\n  local n1, n2 = s1:len(), s2:len()\n  local\
    \ c1, c2 = 0, 0\n  for i = 1, n1 do\n    if s1:sub(i, i) == '(' then\n      c1\
    \ = c1 + 1\n    else\n      c1 = c1 - 1\n    end\n  end\n  for i = 1, n2 do\n\
    \    if s2:sub(i, i) == '(' then\n      c2 = c2 + 1\n    else\n      c2 = c2 -\
    \ 1\n    end\n  end\n  if c1 == 0 and c2 == 0 then\n    return 'Yes'\n  elseif\
    \ c1 == 0 and c2 ~= 0 then\n    return 'No'\n  elseif c1 ~= 0 and c2 == 0 then\n\
    \    return 'No'\n  elseif c1 < 0 and c2 > 0 then\n    return 'Yes'\n  elseif\
    \ c1 > 0 and c2 < 0 then\n    return 'Yes'\n  else\n    return 'No'\n  end\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpov4zfb61.lua:52:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmpov4zfb61.lua:52:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpcgo9z278.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpcgo9z278.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function check(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return check(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpzzyei6hr.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpzzyei6hr.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \    local s1, s2 = lst[1], lst[2]\n    local n1, n2 = #s1, #s2\n    local n =\
    \ n1 + n2\n    local cnt = 0\n    for i = 1, n do\n        if i <= n1 then\n \
    \           if s1:sub(i, i) == '(' then\n                cnt = cnt + 1\n     \
    \       else\n                cnt = cnt - 1\n            end\n        else\n \
    \           if s2:sub(i - n1, i - n1) == '(' then\n                cnt = cnt +\
    \ 1\n            else\n                cnt = cnt - 1\n            end\n      \
    \  end\n        if cnt < 0 then\n            return 'No'\n        end\n    end\n\
    \    return 'Yes'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpt4ydkw5l.lua:46:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpt4ydkw5l.lua:46:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpdkjlud1m.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpdkjlud1m.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2giz6b_z.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp2giz6b_z.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpmrfeh6h0.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpmrfeh6h0.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local count = 0\n    for i = 1, #s do\n    \
    \  if s:sub(i, i) == '(' then\n        count = count + 1\n      else\n       \
    \ count = count - 1\n      end\n      if count < 0 then\n        return false\n\
    \      end\n    end\n    return count == 0\n  end\n  return is_good(lst[1] ..\
    \ lst[2]) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpaf9bupwd.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpaf9bupwd.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local s1, s2 = lst[1], lst[2]\n  local c1, c2 = 0, 0\n  for i = 1, #s1 do\n\
    \    if s1:sub(i, i) == '(' then\n      c1 = c1 + 1\n    else\n      c1 = c1 -\
    \ 1\n    end\n  end\n  for i = 1, #s2 do\n    if s2:sub(i, i) == '(' then\n  \
    \    c2 = c2 + 1\n    else\n      c2 = c2 - 1\n    end\n  end\n  if c1 < 0 and\
    \ c2 < 0 then\n    return 'No'\n  elseif c1 < 0 and c2 > 0 then\n    return 'Yes'\n\
    \  elseif c1 > 0 and c2 < 0 then\n    return 'Yes'\n  elseif c1 > 0 and c2 > 0\
    \ then\n    return 'Yes'\n  else\n    return 'No'\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpxcubgl74.lua:49:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmpxcubgl74.lua:49:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpgv0ik7qh.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpgv0ik7qh.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \    local function check(s)\n        local cnt = 0\n        for i = 1, #s do\n\
    \            if s:sub(i, i) == '(' then\n                cnt = cnt + 1\n     \
    \       else\n                cnt = cnt - 1\n            end\n            if cnt\
    \ < 0 then\n                return false\n            end\n        end\n     \
    \   return cnt == 0\n    end\n    return check(lst[1] .. lst[2]) and 'Yes' or\
    \ 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpkw14_gk4.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpkw14_gk4.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \    local s1, s2 = lst[1], lst[2]\n    local function is_good(s)\n        local\
    \ cnt = 0\n        for i = 1, #s do\n            if s:sub(i, i) == '(' then\n\
    \                cnt = cnt + 1\n            else\n                cnt = cnt -\
    \ 1\n            end\n            if cnt < 0 then\n                return false\n\
    \            end\n        end\n        return cnt == 0\n    end\n    return is_good(s1\
    \ .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp_4u3bs7c.lua:36:\
    \ expected: \"Yes\"\nactual: true\nstack traceback:\n\t/tmp/tmp_4u3bs7c.lua:36:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp5vwa__kg.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp5vwa__kg.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local open, close = 0, 0\n  for i = 1, #lst[1] do\n    if lst[1]:sub(i, i)\
    \ == '(' then\n      open = open + 1\n    else\n      close = close + 1\n    end\n\
    \  end\n  for i = 1, #lst[2] do\n    if lst[2]:sub(i, i) == '(' then\n      open\
    \ = open + 1\n    else\n      close = close + 1\n    end\n  end\n  if open ==\
    \ close then\n    return 'Yes'\n  else\n    return 'No'\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpd56rpxh7.lua:49:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmpd56rpxh7.lua:49:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp7yekidal.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp7yekidal.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(str)\n    local count = 0\n    for i = 1, #str do\n\
    \      if str:sub(i, i) == '(' then\n        count = count + 1\n      else\n \
    \       count = count - 1\n      end\n      if count < 0 then\n        return\
    \ false\n      end\n    end\n    return count == 0\n  end\n  return is_good(lst[1]\
    \ .. lst[2]) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpr5hzpvbg.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpr5hzpvbg.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpjihtyu94.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpjihtyu94.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(str)\n    local count = 0\n    for i = 1, #str do\n\
    \      if str:sub(i, i) == '(' then\n        count = count + 1\n      else\n \
    \       count = count - 1\n      end\n      if count < 0 then\n        return\
    \ false\n      end\n    end\n    return count == 0\n  end\n  local str1, str2\
    \ = lst[1], lst[2]\n  return is_good(str1 .. str2) or is_good(str2 .. str1) and\
    \ 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpvsa50izb.lua:36:\
    \ expected: \"Yes\"\nactual: true\nstack traceback:\n\t/tmp/tmpvsa50izb.lua:36:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp8kau7yaq.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp8kau7yaq.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpu8mn0ctk.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpu8mn0ctk.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \    local s1, s2 = lst[1], lst[2]\n    local c1, c2 = 0, 0\n    for i = 1, #s1\
    \ do\n        if s1:sub(i, i) == '(' then\n            c1 = c1 + 1\n        else\n\
    \            c1 = c1 - 1\n        end\n    end\n    for i = 1, #s2 do\n      \
    \  if s2:sub(i, i) == '(' then\n            c2 = c2 + 1\n        else\n      \
    \      c2 = c2 - 1\n        end\n    end\n    if c1 == 0 and c2 == 0 then\n  \
    \      return 'Yes'\n    elseif c1 == 0 and c2 < 0 then\n        return 'Yes'\n\
    \    elseif c1 < 0 and c2 == 0 then\n        return 'Yes'\n    elseif c1 < 0 and\
    \ c2 < 0 then\n        return 'Yes'\n    else\n        return 'No'\n    end\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp63ygw8nf.lua:47:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp63ygw8nf.lua:47:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local s1, s2 = lst[1], lst[2]\n  local c1, c2 = 0, 0\n  for i = 1, #s1 do\n\
    \    if s1:sub(i, i) == '(' then\n      c1 = c1 + 1\n    else\n      c1 = c1 -\
    \ 1\n    end\n  end\n  for i = 1, #s2 do\n    if s2:sub(i, i) == '(' then\n  \
    \    c2 = c2 + 1\n    else\n      c2 = c2 - 1\n    end\n  end\n  if c1 == 0 and\
    \ c2 == 0 then\n    return 'Yes'\n  elseif c1 == 0 and c2 < 0 then\n    return\
    \ 'Yes'\n  elseif c1 < 0 and c2 == 0 then\n    return 'Yes'\n  elseif c1 < 0 and\
    \ c2 < 0 then\n    return 'Yes'\n  else\n    return 'No'\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpt3scmsrp.lua:47:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpt3scmsrp.lua:47:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local open, close = 0, 0\n  for _, s in ipairs(lst) do\n    for c in s:gmatch('%(')\
    \ do open = open + 1 end\n    for c in s:gmatch('%)') do close = close + 1 end\n\
    \  end\n  return open == close and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpoqz3u439.lua:35:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmpoqz3u439.lua:35:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local count = 0\n    for i = 1, #s do\n    \
    \  if s:sub(i, i) == '(' then\n        count = count + 1\n      else\n       \
    \ count = count - 1\n      end\n      if count < 0 then\n        return false\n\
    \      end\n    end\n    return count == 0\n  end\n  return is_good(lst[1] ..\
    \ lst[2]) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpyeoc4_vw.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpyeoc4_vw.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \    local function is_good(s)\n        local cnt = 0\n        for i = 1, #s do\n\
    \            if s:sub(i, i) == '(' then\n                cnt = cnt + 1\n     \
    \       else\n                cnt = cnt - 1\n            end\n            if cnt\
    \ < 0 then\n                return false\n            end\n        end\n     \
    \   return cnt == 0\n    end\n    return is_good(lst[1] .. lst[2]) and 'Yes' or\
    \ 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpts1q9_pv.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpts1q9_pv.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpz9n0uv28.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpz9n0uv28.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpf3oz8913.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpf3oz8913.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmph03_ly86.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmph03_ly86.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpga6qd42q.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpga6qd42q.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local count = 0\n    for i = 1, #s do\n    \
    \  if s:sub(i, i) == '(' then\n        count = count + 1\n      else\n       \
    \ count = count - 1\n      end\n      if count < 0 then\n        return false\n\
    \      end\n    end\n    return count == 0\n  end\n  return is_good(lst[1] ..\
    \ lst[2]) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp3y2fg7yg.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp3y2fg7yg.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local count = 0\n    for i = 1, #s do\n    \
    \  if s:sub(i, i) == '(' then\n        count = count + 1\n      else\n       \
    \ count = count - 1\n      end\n      if count < 0 then\n        return false\n\
    \      end\n    end\n    return count == 0\n  end\n  local s1, s2 = lst[1], lst[2]\n\
    \  return is_good(s1 .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnwv9fny3.lua:36:\
    \ expected: \"Yes\"\nactual: true\nstack traceback:\n\t/tmp/tmpnwv9fny3.lua:36:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpngaomkch.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpngaomkch.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpsmgjdqdp.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpsmgjdqdp.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \    local function is_good(s)\n        local cnt = 0\n        for i = 1, #s do\n\
    \            if s:sub(i, i) == '(' then\n                cnt = cnt + 1\n     \
    \       else\n                cnt = cnt - 1\n            end\n            if cnt\
    \ < 0 then\n                return false\n            end\n        end\n     \
    \   return cnt == 0\n    end\n    return is_good(lst[1] .. lst[2]) and 'Yes' or\
    \ 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnt_ti4tx.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpnt_ti4tx.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(str)\n    local count = 0\n    for i = 1, #str do\n\
    \      if str:sub(i, i) == '(' then\n        count = count + 1\n      else\n \
    \       count = count - 1\n      end\n      if count < 0 then\n        return\
    \ false\n      end\n    end\n    return count == 0\n  end\n  local str1, str2\
    \ = lst[1], lst[2]\n  return is_good(str1 .. str2) or is_good(str2 .. str1) and\
    \ 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmprd9kehgu.lua:36:\
    \ expected: \"Yes\"\nactual: true\nstack traceback:\n\t/tmp/tmprd9kehgu.lua:36:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local open, close = 0, 0\n  for i = 1, #lst[1] do\n    if lst[1]:sub(i, i)\
    \ == '(' then\n      open = open + 1\n    else\n      close = close + 1\n    end\n\
    \  end\n  for i = 1, #lst[2] do\n    if lst[2]:sub(i, i) == '(' then\n      open\
    \ = open + 1\n    else\n      close = close + 1\n    end\n  end\n  if open ==\
    \ close then\n    return 'Yes'\n  else\n    return 'No'\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpulxce101.lua:49:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmpulxce101.lua:49:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \    local function is_good(s)\n        local cnt = 0\n        for i = 1, #s do\n\
    \            if s:sub(i, i) == '(' then\n                cnt = cnt + 1\n     \
    \       else\n                cnt = cnt - 1\n            end\n            if cnt\
    \ < 0 then\n                return false\n            end\n        end\n     \
    \   return cnt == 0\n    end\n    return is_good(lst[1] .. lst[2]) and 'Yes' or\
    \ 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpdsbnno1v.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpdsbnno1v.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \    local function is_good(str)\n        local cnt = 0\n        for i = 1, #str\
    \ do\n            if str:sub(i, i) == '(' then\n                cnt = cnt + 1\n\
    \            else\n                cnt = cnt - 1\n            end\n          \
    \  if cnt < 0 then\n                return false\n            end\n        end\n\
    \        return cnt == 0\n    end\n    local s1, s2 = lst[1], lst[2]\n    return\
    \ is_good(s1 .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpiq5ti0fw.lua:36:\
    \ expected: \"Yes\"\nactual: true\nstack traceback:\n\t/tmp/tmpiq5ti0fw.lua:36:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(str)\n    local count = 0\n    for i = 1, #str do\n\
    \      if str:sub(i, i) == '(' then\n        count = count + 1\n      else\n \
    \       count = count - 1\n      end\n      if count < 0 then\n        return\
    \ false\n      end\n    end\n    return count == 0\n  end\n  return is_good(lst[1]\
    \ .. lst[2]) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp7e3a2gc0.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp7e3a2gc0.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local s1, s2 = lst[1], lst[2]\n  local s = s1 .. s2\n  local cnt = 0\n  for\
    \ i = 1, #s do\n    if s:sub(i, i) == '(' then\n      cnt = cnt + 1\n    else\n\
    \      cnt = cnt - 1\n    end\n    if cnt < 0 then\n      return 'No'\n    end\n\
    \  end\n  return 'Yes'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpdcodkkcm.lua:37:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpdcodkkcm.lua:37:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local count = 0\n    for c in s:gmatch('.')\
    \ do\n      if c == '(' then\n        count = count + 1\n      else\n        count\
    \ = count - 1\n      end\n      if count < 0 then\n        return false\n    \
    \  end\n    end\n    return count == 0\n  end\n  local s1, s2 = lst[1], lst[2]\n\
    \  return (is_good(s1 .. s2) or is_good(s2 .. s1)) and 'Yes' or 'No'\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(str)\n    local count = 0\n    for _, c in ipairs(str)\
    \ do\n      if c == '(' then\n        count = count + 1\n      else\n        count\
    \ = count - 1\n      end\n      if count < 0 then\n        return false\n    \
    \  end\n    end\n    return count == 0\n  end\n  return is_good(lst[1] .. lst[2])\
    \ and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp0qqlmuf4.lua:36:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmp0qqlmuf4.lua:36:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpgz7v8769.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpgz7v8769.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmprc3wfli_.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmprc3wfli_.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local c = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        c = c + 1\n      else\n        c = c - 1\n\
    \      end\n      if c < 0 then\n        return false\n      end\n    end\n  \
    \  return c == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes' or 'No'\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp7ol2auq9.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp7ol2auq9.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  local s1, s2 = lst[1], lst[2]\n  return is_good(s1\
    \ .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpdi6r1a2s.lua:36:\
    \ expected: \"Yes\"\nactual: true\nstack traceback:\n\t/tmp/tmpdi6r1a2s.lua:36:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(str)\n    local count = 0\n    for i = 1, #str do\n\
    \      if str:sub(i, i) == '(' then\n        count = count + 1\n      else\n \
    \       count = count - 1\n      end\n      if count < 0 then\n        return\
    \ false\n      end\n    end\n    return count == 0\n  end\n  return is_good(lst[1]\
    \ .. lst[2]) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp5mxbgroz.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp5mxbgroz.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \    local function is_good(s)\n        local cnt = 0\n        for i = 1, #s do\n\
    \            if s:sub(i, i) == '(' then\n                cnt = cnt + 1\n     \
    \       else\n                cnt = cnt - 1\n            end\n            if cnt\
    \ < 0 then\n                return false\n            end\n        end\n     \
    \   return cnt == 0\n    end\n    return is_good(lst[1] .. lst[2]) and 'Yes' or\
    \ 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpkj8o0oqx.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpkj8o0oqx.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(str)\n    local count = 0\n    for i = 1, #str do\n\
    \      if str:sub(i, i) == '(' then\n        count = count + 1\n      else\n \
    \       count = count - 1\n      end\n      if count < 0 then\n        return\
    \ false\n      end\n    end\n    return count == 0\n  end\n  return is_good(lst[1]\
    \ .. lst[2]) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpq8tu0nmo.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpq8tu0nmo.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpkr1zsq66.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpkr1zsq66.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      local\
    \ c = s:sub(i, i)\n      if c == '(' then\n        cnt = cnt + 1\n      else\n\
    \        cnt = cnt - 1\n      end\n      if cnt < 0 then\n        return false\n\
    \      end\n    end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2])\
    \ and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpjerwo6_w.lua:39:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpjerwo6_w.lua:39:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return (is_good(lst[1]) and is_good(lst[2]))\
    \ and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpkn_odk_g.lua:35:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpkn_odk_g.lua:35:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \    local function is_good(s)\n        local cnt = 0\n        for i = 1, #s do\n\
    \            if s:sub(i, i) == '(' then\n                cnt = cnt + 1\n     \
    \       else\n                cnt = cnt - 1\n            end\n            if cnt\
    \ < 0 then\n                return false\n            end\n        end\n     \
    \   return cnt == 0\n    end\n    local s1, s2 = lst[1], lst[2]\n    return is_good(s1\
    \ .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpij8igsn4.lua:36:\
    \ expected: \"Yes\"\nactual: true\nstack traceback:\n\t/tmp/tmpij8igsn4.lua:36:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp0qultr5k.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp0qultr5k.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpp4svamlc.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpp4svamlc.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local count = 0\n    for i = 1, #s do\n    \
    \  if s:sub(i, i) == '(' then\n        count = count + 1\n      else\n       \
    \ count = count - 1\n      end\n      if count < 0 then\n        return false\n\
    \      end\n    end\n    return count == 0\n  end\n  return is_good(lst[1] ..\
    \ lst[2]) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp0ux9sj5i.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp0ux9sj5i.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local s1, s2 = lst[1], lst[2]\n  local n1, n2 = s1:len(), s2:len()\n  local\
    \ n = n1 + n2\n  local i, j = 1, 1\n  local cnt = 0\n  while i <= n1 and j <=\
    \ n2 do\n    if s1:sub(i, i) == '(' then\n      cnt = cnt + 1\n    else\n    \
    \  cnt = cnt - 1\n    end\n    if s2:sub(j, j) == '(' then\n      cnt = cnt +\
    \ 1\n    else\n      cnt = cnt - 1\n    end\n    if cnt < 0 then\n      return\
    \ 'No'\n    end\n    i = i + 1\n    j = j + 1\n  end\n  if cnt == 0 then\n   \
    \ return 'Yes'\n  else\n    return 'No'\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp3vdfdq04.lua:49:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmp3vdfdq04.lua:49:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(str)\n    local count = 0\n    for i = 1, #str do\n\
    \      if str:sub(i, i) == '(' then\n        count = count + 1\n      else\n \
    \       count = count - 1\n      end\n      if count < 0 then\n        return\
    \ false\n      end\n    end\n    return count == 0\n  end\n  if is_good(lst[1])\
    \ and is_good(lst[2]) then\n    return 'Yes'\n  end\n  if is_good(lst[1] .. lst[2])\
    \ then\n    return 'Yes'\n  end\n  if is_good(lst[2] .. lst[1]) then\n    return\
    \ 'Yes'\n  end\n  return 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local count = 0\n    for i = 1, #s do\n    \
    \  if s:sub(i, i) == '(' then\n        count = count + 1\n      else\n       \
    \ count = count - 1\n      end\n      if count < 0 then\n        return false\n\
    \      end\n    end\n    return count == 0\n  end\n  return is_good(lst[1] ..\
    \ lst[2]) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpkn3h3_cg.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpkn3h3_cg.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      local\
    \ c = s:sub(i, i)\n      if c == '(' then\n        cnt = cnt + 1\n      else\n\
    \        cnt = cnt - 1\n      end\n      if cnt < 0 then\n        return false\n\
    \      end\n    end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2])\
    \ and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp9981diwp.lua:39:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp9981diwp.lua:39:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  local s1, s2 = lst[1], lst[2]\n  return is_good(s1\
    \ .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp1i3ktn_q.lua:36:\
    \ expected: \"Yes\"\nactual: true\nstack traceback:\n\t/tmp/tmp1i3ktn_q.lua:36:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \    local function is_good(s)\n        local cnt = 0\n        for i = 1, #s do\n\
    \            if s:sub(i, i) == '(' then\n                cnt = cnt + 1\n     \
    \       else\n                cnt = cnt - 1\n            end\n            if cnt\
    \ < 0 then\n                return false\n            end\n        end\n     \
    \   return cnt == 0\n    end\n    return is_good(lst[1] .. lst[2]) and 'Yes' or\
    \ 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpzp5055yz.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpzp5055yz.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpczfa6352.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpczfa6352.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \    local open = 0\n    local close = 0\n    for i = 1, #lst[1] do\n        if\
    \ lst[1]:sub(i, i) == '(' then\n            open = open + 1\n        else\n  \
    \          close = close + 1\n        end\n    end\n    for i = 1, #lst[2] do\n\
    \        if lst[2]:sub(i, i) == '(' then\n            open = open + 1\n      \
    \  else\n            close = close + 1\n        end\n    end\n    if open == close\
    \ then\n        return 'Yes'\n    else\n        return 'No'\n    end\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp1u4alfhv.lua:50:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmp1u4alfhv.lua:50:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpmvg8p9iw.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpmvg8p9iw.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpu7b4ceji.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpu7b4ceji.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpcxwmq8zg.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpcxwmq8zg.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpb9s5mv_m.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpb9s5mv_m.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  local s1, s2 = lst[1], lst[2]\n  return is_good(s1\
    \ .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpfkm3z1bv.lua:36:\
    \ expected: \"Yes\"\nactual: true\nstack traceback:\n\t/tmp/tmpfkm3z1bv.lua:36:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local s1, s2 = lst[1], lst[2]\n  local s = s1 .. s2\n  local cnt = 0\n  for\
    \ i = 1, #s do\n    local c = s:sub(i, i)\n    if c == '(' then\n      cnt = cnt\
    \ + 1\n    else\n      cnt = cnt - 1\n    end\n    if cnt < 0 then\n      return\
    \ 'No'\n    end\n  end\n  return cnt == 0 and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmptcsb6yma.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmptcsb6yma.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \    local function is_good(str)\n        local count = 0\n        for i = 1,\
    \ #str do\n            local c = str:sub(i, i)\n            if c == '(' then\n\
    \                count = count + 1\n            else\n                count =\
    \ count - 1\n            end\n            if count < 0 then\n                return\
    \ false\n            end\n        end\n        return count == 0\n    end\n  \
    \  local str1, str2 = lst[1], lst[2]\n    return is_good(str1 .. str2) or is_good(str2\
    \ .. str1) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpqi6y_x3f.lua:37:\
    \ expected: \"Yes\"\nactual: true\nstack traceback:\n\t/tmp/tmpqi6y_x3f.lua:37:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmphof7u5b2.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmphof7u5b2.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \    local s1, s2 = lst[1], lst[2]\n    local s = s1 .. s2\n    local cnt = 0\n\
    \    for i = 1, #s do\n        if s:sub(i, i) == '(' then\n            cnt = cnt\
    \ + 1\n        else\n            cnt = cnt - 1\n        end\n        if cnt <\
    \ 0 then\n            return 'No'\n        end\n    end\n    return 'Yes'\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp03gbjb93.lua:37:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp03gbjb93.lua:37:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local count = 0\n    for i = 1, #s do\n    \
    \  if s:sub(i, i) == '(' then\n        count = count + 1\n      else\n       \
    \ count = count - 1\n      end\n      if count < 0 then\n        return false\n\
    \      end\n    end\n    return count == 0\n  end\n  local s1, s2 = lst[1], lst[2]\n\
    \  return is_good(s1 .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp8q7n7tu6.lua:36:\
    \ expected: \"Yes\"\nactual: true\nstack traceback:\n\t/tmp/tmp8q7n7tu6.lua:36:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local count = 0\n    for i = 1, #s do\n    \
    \  if s:sub(i, i) == '(' then\n        count = count + 1\n      else\n       \
    \ count = count - 1\n      end\n      if count < 0 then\n        return false\n\
    \      end\n    end\n    return count == 0\n  end\n  return is_good(lst[1] ..\
    \ lst[2]) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmppo8iz50h.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmppo8iz50h.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(str)\n    local count = 0\n    for i = 1, #str do\n\
    \      if str:sub(i, i) == '(' then\n        count = count + 1\n      else\n \
    \       count = count - 1\n      end\n      if count < 0 then\n        return\
    \ false\n      end\n    end\n    return count == 0\n  end\n  local str1, str2\
    \ = lst[1], lst[2]\n  if is_good(str1) and is_good(str2) then\n    return 'Yes'\n\
    \  end\n  if is_good(str1 .. str2) then\n    return 'Yes'\n  end\n  if is_good(str2\
    \ .. str1) then\n    return 'Yes'\n  end\n  return 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \    local function is_good(s)\n        local cnt = 0\n        for i = 1, #s do\n\
    \            if s:sub(i, i) == '(' then\n                cnt = cnt + 1\n     \
    \       else\n                cnt = cnt - 1\n            end\n            if cnt\
    \ < 0 then\n                return false\n            end\n        end\n     \
    \   return cnt == 0\n    end\n    local s1, s2 = lst[1], lst[2]\n    return is_good(s1\
    \ .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpm2o6f8en.lua:36:\
    \ expected: \"Yes\"\nactual: true\nstack traceback:\n\t/tmp/tmpm2o6f8en.lua:36:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp9ljjuk4s.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp9ljjuk4s.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \    local function is_good(s)\n        local cnt = 0\n        for i = 1, #s do\n\
    \            if s:sub(i, i) == '(' then\n                cnt = cnt + 1\n     \
    \       else\n                cnt = cnt - 1\n            end\n            if cnt\
    \ < 0 then\n                return false\n            end\n        end\n     \
    \   return cnt == 0\n    end\n    return is_good(lst[1] .. lst[2]) and 'Yes' or\
    \ 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmptk8msg8g.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmptk8msg8g.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function check(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return check(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp5whm3488.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp5whm3488.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpxv2olyed.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpxv2olyed.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp1jfwj781.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp1jfwj781.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local s1, s2 = lst[1], lst[2]\n  local n1, n2 = #s1, #s2\n  local n = n1 +\
    \ n2\n  local cnt = 0\n  for i = 1, n do\n    local c = (i <= n1) and s1:sub(i,\
    \ i) or s2:sub(i - n1, i - n1)\n    if c == '(' then\n      cnt = cnt + 1\n  \
    \  else\n      cnt = cnt - 1\n    end\n    if cnt < 0 then\n      return 'No'\n\
    \    end\n  end\n  return (cnt == 0) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpynb8nuv3.lua:39:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpynb8nuv3.lua:39:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp318arop2.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp318arop2.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \    local s1, s2 = lst[1], lst[2]\n    local n1, n2 = #s1, #s2\n    local n =\
    \ n1 + n2\n    local cnt = 0\n    for i = 1, n do\n        local c = i <= n1 and\
    \ s1:sub(i, i) or s2:sub(i - n1, i - n1)\n        if c == '(' then\n         \
    \   cnt = cnt + 1\n        else\n            cnt = cnt - 1\n        end\n    \
    \    if cnt < 0 then\n            return 'No'\n        end\n    end\n    return\
    \ cnt == 0 and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp0vfjb73r.lua:39:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp0vfjb73r.lua:39:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local count = 0\n    for i = 1, #s do\n    \
    \  if s:sub(i, i) == '(' then\n        count = count + 1\n      else\n       \
    \ count = count - 1\n      end\n      if count < 0 then\n        return false\n\
    \      end\n    end\n    return count == 0\n  end\n  local s1, s2 = lst[1], lst[2]\n\
    \  return is_good(s1 .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp_7nfj8rx.lua:36:\
    \ expected: \"Yes\"\nactual: true\nstack traceback:\n\t/tmp/tmp_7nfj8rx.lua:36:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpq0_t4fg3.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpq0_t4fg3.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpwvcd9yni.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpwvcd9yni.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local s1, s2 = lst[1], lst[2]\n  local c1, c2 = 0, 0\n  for i = 1, #s1 do\n\
    \    if s1:sub(i, i) == '(' then\n      c1 = c1 + 1\n    else\n      c1 = c1 -\
    \ 1\n    end\n  end\n  for i = 1, #s2 do\n    if s2:sub(i, i) == '(' then\n  \
    \    c2 = c2 + 1\n    else\n      c2 = c2 - 1\n    end\n  end\n  if c1 == 0 and\
    \ c2 == 0 then\n    return 'Yes'\n  elseif c1 > 0 and c2 < 0 and c1 + c2 == 0\
    \ then\n    return 'Yes'\n  elseif c1 < 0 and c2 > 0 and c1 + c2 == 0 then\n \
    \   return 'Yes'\n  else\n    return 'No'\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpaxg3gb7b.lua:54:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmpaxg3gb7b.lua:54:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function check(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return check(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmprgvs72xc.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmprgvs72xc.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \    local open, close = 0, 0\n    for _, s in ipairs(lst) do\n        for c in\
    \ s:gmatch('%(') do open = open + 1 end\n        for c in s:gmatch('%)') do close\
    \ = close + 1 end\n    end\n    return (open == close) and 'Yes' or 'No'\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpn15hrtle.lua:35:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmpn15hrtle.lua:35:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp5e_yolxb.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp5e_yolxb.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local count = 0\n    for i = 1, #s do\n    \
    \  if s:sub(i, i) == '(' then\n        count = count + 1\n      else\n       \
    \ count = count - 1\n      end\n      if count < 0 then\n        return false\n\
    \      end\n    end\n    return count == 0\n  end\n  return is_good(lst[1] ..\
    \ lst[2]) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpppj7nt8m.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpppj7nt8m.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(str)\n    local cnt = 0\n    for i = 1, #str do\n  \
    \    if str:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n       \
    \ cnt = cnt - 1\n      end\n      if cnt < 0 then\n        return false\n    \
    \  end\n    end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2])\
    \ and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpm3dqil5c.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpm3dqil5c.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return (is_good(lst[1]) and is_good(lst[2]))\
    \ and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpe27g6q3t.lua:35:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpe27g6q3t.lua:35:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local count = 0\n    for i = 1, #s do\n    \
    \  if s:sub(i, i) == '(' then\n        count = count + 1\n      else\n       \
    \ count = count - 1\n      end\n      if count < 0 then\n        return false\n\
    \      end\n    end\n    return count == 0\n  end\n  return is_good(lst[1] ..\
    \ lst[2]) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpouuk2kgv.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpouuk2kgv.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return (is_good(lst[1]) and is_good(lst[2]))\
    \ and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp437iph60.lua:35:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp437iph60.lua:35:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local open, close = 0, 0\n  for _, s in ipairs(lst) do\n    for c in s:gmatch('%(')\
    \ do open = open + 1 end\n    for c in s:gmatch('%)') do close = close + 1 end\n\
    \  end\n  return open == close and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp1hpsd0a0.lua:35:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmp1hpsd0a0.lua:35:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function count_parens(s)\n    local c = 0\n    for i = 1, #s do\n   \
    \   if s:sub(i, i) == '(' then\n        c = c + 1\n      else\n        c = c -\
    \ 1\n      end\n    end\n    return c\n  end\n  local c1, c2 = count_parens(lst[1]),\
    \ count_parens(lst[2])\n  if c1 == 0 and c2 == 0 then\n    return 'Yes'\n  elseif\
    \ c1 == 0 and c2 < 0 then\n    return 'Yes'\n  elseif c1 > 0 and c2 == 0 then\n\
    \    return 'Yes'\n  elseif c1 > 0 and c2 < 0 and c1 == -c2 then\n    return 'Yes'\n\
    \  else\n    return 'No'\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpsbto5giz.lua:46:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpsbto5giz.lua:46:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(str)\n    local cnt = 0\n    for i = 1, #str do\n  \
    \    if str:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n       \
    \ cnt = cnt - 1\n      end\n      if cnt < 0 then\n        return false\n    \
    \  end\n    end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2])\
    \ and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp62eok56t.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp62eok56t.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp6bjp1ut5.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp6bjp1ut5.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local open, close = 0, 0\n  for _, v in ipairs(lst) do\n    for c in v:gmatch('%(')\
    \ do open = open + 1 end\n    for c in v:gmatch('%)') do close = close + 1 end\n\
    \  end\n  return open == close and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmppgeeaclk.lua:35:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmppgeeaclk.lua:35:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(str)\n    local count = 0\n    for i = 1, #str do\n\
    \      local c = str:sub(i, i)\n      if c == '(' then\n        count = count\
    \ + 1\n      else\n        count = count - 1\n      end\n      if count < 0 then\n\
    \        return false\n      end\n    end\n    return count == 0\n  end\n  local\
    \ s1, s2 = lst[1], lst[2]\n  return is_good(s1 .. s2) or is_good(s2 .. s1) and\
    \ 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmplavrbrux.lua:37:\
    \ expected: \"Yes\"\nactual: true\nstack traceback:\n\t/tmp/tmplavrbrux.lua:37:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local count = 0\n    for i = 1, #s do\n    \
    \  if s:sub(i, i) == '(' then\n        count = count + 1\n      else\n       \
    \ count = count - 1\n      end\n      if count < 0 then\n        return false\n\
    \      end\n    end\n    return count == 0\n  end\n  local s1, s2 = lst[1], lst[2]\n\
    \  return is_good(s1 .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpirza7aeu.lua:36:\
    \ expected: \"Yes\"\nactual: true\nstack traceback:\n\t/tmp/tmpirza7aeu.lua:36:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local s1, s2 = lst[1], lst[2]\n  local c1, c2 = 0, 0\n  for i = 1, #s1 do\n\
    \    if s1:sub(i, i) == '(' then\n      c1 = c1 + 1\n    else\n      c1 = c1 -\
    \ 1\n    end\n  end\n  for i = 1, #s2 do\n    if s2:sub(i, i) == '(' then\n  \
    \    c2 = c2 + 1\n    else\n      c2 = c2 - 1\n    end\n  end\n  if c1 == 0 and\
    \ c2 == 0 then\n    return 'Yes'\n  elseif c1 == 0 and c2 < 0 then\n    return\
    \ 'Yes'\n  elseif c1 < 0 and c2 == 0 then\n    return 'Yes'\n  elseif c1 < 0 and\
    \ c2 < 0 then\n    return 'Yes'\n  else\n    return 'No'\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpsbofo2fv.lua:47:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpsbofo2fv.lua:47:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function check(s)\n    local count = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        count = count + 1\n      else\n        count\
    \ = count - 1\n      end\n      if count < 0 then\n        return false\n    \
    \  end\n    end\n    return count == 0\n  end\n  return check(lst[1] .. lst[2])\
    \ and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpmfzm0n65.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpmfzm0n65.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmprbt_tmwh.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmprbt_tmwh.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmppfmq3f0f.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmppfmq3f0f.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpbm1aiy38.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpbm1aiy38.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmprk9oeend.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmprk9oeend.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local count = 0\n    for i = 1, #s do\n    \
    \  if s:sub(i, i) == '(' then\n        count = count + 1\n      else\n       \
    \ count = count - 1\n      end\n      if count < 0 then\n        return false\n\
    \      end\n    end\n    return count == 0\n  end\n  return is_good(lst[1] ..\
    \ lst[2]) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpe2adrq58.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpe2adrq58.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpenpod0ep.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpenpod0ep.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local s1, s2 = lst[1], lst[2]\n  local function is_good(s)\n    local count\
    \ = 0\n    for i = 1, #s do\n      if s:sub(i, i) == '(' then\n        count =\
    \ count + 1\n      else\n        count = count - 1\n      end\n      if count\
    \ < 0 then\n        return false\n      end\n    end\n    return count == 0\n\
    \  end\n  if is_good(s1) and is_good(s2) then\n    return 'Yes'\n  end\n  if is_good(s1\
    \ .. s2) then\n    return 'Yes'\n  end\n  if is_good(s2 .. s1) then\n    return\
    \ 'Yes'\n  end\n  return 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpb_uwbjw9.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpb_uwbjw9.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpmgcmn02i.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpmgcmn02i.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(str)\n    local cnt = 0\n    for i = 1, #str do\n  \
    \    if str:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n       \
    \ cnt = cnt - 1\n      end\n      if cnt < 0 then\n        return false\n    \
    \  end\n    end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2])\
    \ and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmphe7xwo7j.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmphe7xwo7j.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a table of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- >>> match_parens({'()(',\
    \ ')'})\n-- 'Yes'\n-- >>> match_parens({')', ')'})\n-- 'No'\nlocal function match_parens(lst)\n\
    \  local l, r = lst[1], lst[2]\n  local lc, rc = 0, 0\n  for i = 1, #l do\n  \
    \  if l:sub(i, i) == '(' then\n      lc = lc + 1\n    else\n      lc = lc - 1\n\
    \    end\n  end\n  for i = 1, #r do\n    if r:sub(i, i) == '(' then\n      rc\
    \ = rc + 1\n    else\n      rc = rc - 1\n    end\n  end\n  if lc == rc then\n\
    \    return 'Yes'\n  else\n    return 'No'\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp0et1y7ge.lua:41:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp0et1y7ge.lua:41:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
