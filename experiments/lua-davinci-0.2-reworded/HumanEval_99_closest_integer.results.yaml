name: HumanEval_99_closest_integer
language: lua
results:
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    if num == nil then\n        return nil\n    end\n    local int = math.floor(num)\n\
    \    local frac = num - int\n    if frac >= 0.5 then\n        return int + 1\n\
    \    else\n        return int\n    end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpl44o8fsh.lua:33:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpl44o8fsh.lua:33: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp8v44bjcl.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp8v44bjcl.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpxszocpc4.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpxszocpc4.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnn139qrh.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpnn139qrh.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpa62fgqls.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpa62fgqls.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local num = tonumber(value)\n\
    \  if num == nil then\n    return nil\n  end\n  local int = math.floor(num)\n\
    \  if num - int >= 0.5 then\n    return int + 1\n  else\n    return int\n  end\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpzg1tx4l8.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpzg1tx4l8.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    if number > 0 then\n        return math.floor(number\
    \ + 0.5)\n    else\n        return math.ceil(number - 0.5)\n    end\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local number =\
    \ tonumber(value)\n  if number > 0 then\n    return math.floor(number + 0.5)\n\
    \  else\n    return math.ceil(number - 0.5)\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2x17_sid.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp2x17_sid.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    if num == nil then\n        return nil\n    end\n    local int = math.floor(num)\n\
    \    if num - int >= 0.5 then\n        return int + 1\n    else\n        return\
    \ int\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpodpbqjku.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpodpbqjku.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    if number == nil then\n        return nil\n    end\n\
    \    local int, frac = math.modf(number)\n    if frac >= 0.5 then\n        return\
    \ int + 1\n    else\n        return int\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmps21zxh7j.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmps21zxh7j.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpzltczr1o.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpzltczr1o.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpk9d9bn3x.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpk9d9bn3x.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpyu50g6dk.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpyu50g6dk.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    if number == math.floor(number) then\n        return\
    \ number\n    end\n    local floor = math.floor(number)\n    local ceil = math.ceil(number)\n\
    \    if number - floor < ceil - number then\n        return floor\n    else\n\
    \        return ceil\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpkniirpty.lua:33:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpkniirpty.lua:33: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local number =\
    \ tonumber(value)\n  local integer = math.floor(number)\n  if number - integer\
    \ >= 0.5 then\n    return integer + 1\n  else\n    return integer\n  end\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp4jadmcav.lua:29:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp4jadmcav.lua:29: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpjsnlfifc.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpjsnlfifc.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp92ztgoen.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp92ztgoen.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp5q62zn_d.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp5q62zn_d.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpozai4ije.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpozai4ije.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local num = tonumber(value)\n\
    \  if num > 0 then\n    return math.floor(num + 0.5)\n  else\n    return math.ceil(num\
    \ - 0.5)\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    if num > 0 then\n        return math.floor(num + 0.5)\n    else\n       \
    \ return math.ceil(num - 0.5)\n    end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpvr7pb9nk.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpvr7pb9nk.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp6ivhy54y.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp6ivhy54y.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local number =\
    \ tonumber(value)\n  if number == nil then\n    return nil\n  end\n  local integer\
    \ = math.floor(number)\n  if number - integer >= 0.5 then\n    return integer\
    \ + 1\n  else\n    return integer\n  end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpam16x4qs.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpam16x4qs.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpxh8cupsy.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpxh8cupsy.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local num = tonumber(value)\n\
    \  if num then\n    return math.floor(num + 0.5)\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp1ih63k5a.lua:26:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp1ih63k5a.lua:26: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    if number == nil then\n        return nil\n    end\n\
    \    local integer = math.floor(number)\n    if number - integer >= 0.5 then\n\
    \        integer = integer + 1\n    end\n    return integer\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpv8g3a02r.lua:31:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpv8g3a02r.lua:31: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local num = tonumber(value)\n\
    \  if num == nil then\n    return nil\n  end\n  local int = math.floor(num)\n\
    \  if num - int >= 0.5 then\n    return int + 1\n  else\n    return int\n  end\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpibxagupv.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpibxagupv.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    if num == nil then\n        return nil\n    end\n    local int = math.floor(num)\n\
    \    if num - int >= 0.5 then\n        return int + 1\n    else\n        return\
    \ int\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp3djhnlen.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp3djhnlen.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpu7o6vay9.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpu7o6vay9.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    local int = math.floor(num)\n    if num - int >= 0.5 then\n        return\
    \ int + 1\n    else\n        return int\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmprzt6cm8u.lua:29:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmprzt6cm8u.lua:29: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    if num == nil then\n        return nil\n    end\n    local int = math.floor(num)\n\
    \    if num - int >= 0.5 then\n        return int + 1\n    else\n        return\
    \ int\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmppmkkglp_.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmppmkkglp_.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    if number == nil then\n        return nil\n    end\n\
    \    if number >= 0 then\n        return math.floor(number + 0.5)\n    else\n\
    \        return math.ceil(number - 0.5)\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local num = tonumber(value)\n\
    \  local int = math.floor(num)\n  if num - int >= 0.5 then\n    return int + 1\n\
    \  else\n    return int\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpys29nu0p.lua:29:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpys29nu0p.lua:29: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpisnulkfi.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpisnulkfi.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    if number == nil then\n        return nil\n    end\n\
    \    local integer = math.floor(number)\n    if number - integer > 0.5 then\n\
    \        return integer + 1\n    else\n        return integer\n    end\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp9qja73ws.lua:31:\
    \ expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmp9qja73ws.lua:31: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmple6zwe9o.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmple6zwe9o.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp1zzr9ry3.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp1zzr9ry3.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    local int = math.floor(num)\n    local frac = num - int\n    if frac >= 0.5\
    \ then\n        return int + 1\n    else\n        return int\n    end\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmplvfnafya.lua:30:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmplvfnafya.lua:30: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    if num == nil then\n        return nil\n    end\n    local int = math.floor(num)\n\
    \    if num - int > 0.5 then\n        return int + 1\n    else\n        return\
    \ int\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmplcv7fjr0.lua:31:\
    \ expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmplcv7fjr0.lua:31: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    if num > 0 then\n        return math.floor(num + 0.5)\n    else\n       \
    \ return math.ceil(num - 0.5)\n    end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpst1csvzx.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpst1csvzx.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp9o6219og.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp9o6219og.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp4_jo_83x.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp4_jo_83x.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpuhkz4_jp.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpuhkz4_jp.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    if num == nil then\n        return nil\n    end\n    local int = math.floor(num)\n\
    \    if num - int >= 0.5 then\n        return int + 1\n    else\n        return\
    \ int\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpsz8prlua.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpsz8prlua.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpr9g81muo.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpr9g81muo.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    if num > 0 then\n        return math.floor(num + 0.5)\n    else\n       \
    \ return math.ceil(num - 0.5)\n    end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    if number < 0 then\n        return math.ceil(number)\n\
    \    else\n        return math.floor(number)\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpccay6hv1.lua:27:\
    \ expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmpccay6hv1.lua:27: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpz1c2gbxj.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpz1c2gbxj.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    if number > 0 then\n        return math.floor(number\
    \ + 0.5)\n    else\n        return math.ceil(number - 0.5)\n    end\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpdvdb8_w0.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpdvdb8_w0.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    if num > 0 then\n        return math.floor(num + 0.5)\n    else\n       \
    \ return math.ceil(num - 0.5)\n    end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    local integer = math.floor(number)\n    if number - integer\
    \ >= 0.5 then\n        return integer + 1\n    else\n        return integer\n\
    \    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpdswy0dy1.lua:29:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpdswy0dy1.lua:29: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    -- TODO: implement\
    \ this function\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp1lmhz41t.lua:21:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmp1lmhz41t.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp3sko1pji.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp3sko1pji.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp754lm4xp.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp754lm4xp.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    if num > 0 then\n        return math.floor(num + 0.5)\n    else\n       \
    \ return math.ceil(num - 0.5)\n    end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local number =\
    \ tonumber(value)\n  if number == nil then\n    return nil\n  end\n  local integer\
    \ = math.floor(number)\n  if number - integer >= 0.5 then\n    return integer\
    \ + 1\n  else\n    return integer\n  end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpet_2wyrv.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpet_2wyrv.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local number =\
    \ tonumber(value)\n  if number == nil then\n    return nil\n  end\n  local decimal\
    \ = number - math.floor(number)\n  if decimal < 0.5 then\n    return math.floor(number)\n\
    \  else\n    return math.ceil(number)\n  end\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpbk8oe8bc.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpbk8oe8bc.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local number =\
    \ tonumber(value)\n  local integer = math.floor(number)\n  local decimal = number\
    \ - integer\n  if decimal >= 0.5 then\n    return integer + 1\n  else\n    return\
    \ integer\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpvb62ct61.lua:30:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpvb62ct61.lua:30: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpglc7kiy_.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpglc7kiy_.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local int, frac\
    \ = math.modf(tonumber(value))\n  if frac >= 0.5 then\n    return int + 1\n  else\n\
    \    return int\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp6eemc1yz.lua:28:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp6eemc1yz.lua:28: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp7no4vdpy.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp7no4vdpy.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2fnbuwc5.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp2fnbuwc5.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    if num == nil then\n        return nil\n    end\n    local int = math.floor(num)\n\
    \    if num - int >= 0.5 then\n        return int + 1\n    else\n        return\
    \ int\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpd2jw1slh.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpd2jw1slh.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp9vgm04py.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp9vgm04py.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local int_value\
    \ = tonumber(value)\n    if int_value == nil then\n        return nil\n    end\n\
    \    local int_part = math.floor(int_value)\n    local decimal_part = int_value\
    \ - int_part\n    if decimal_part >= 0.5 then\n        return int_part + 1\n \
    \   else\n        return int_part\n    end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpoohxavjf.lua:33:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpoohxavjf.lua:33: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    local integer = math.floor(number)\n    if number - integer\
    \ >= 0.5 then\n        return integer + 1\n    else\n        return integer\n\
    \    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpjuqalfjl.lua:29:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpjuqalfjl.lua:29: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local number =\
    \ tonumber(value)\n  if number == nil then\n    return nil\n  end\n  local integer\
    \ = math.floor(number)\n  if number - integer < 0.5 then\n    return integer\n\
    \  else\n    return integer + 1\n  end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp6irluqif.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp6irluqif.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local number =\
    \ tonumber(value)\n  if number > 0 then\n    return math.floor(number + 0.5)\n\
    \  else\n    return math.ceil(number - 0.5)\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpuuf0_rzz.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpuuf0_rzz.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpsz3xv3cl.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpsz3xv3cl.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpj76almmn.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpj76almmn.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local num = tonumber(value)\n\
    \  if num > 0 then\n    return math.floor(num + 0.5)\n  else\n    return math.ceil(num\
    \ - 0.5)\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local num = tonumber(value)\n\
    \  if num > 0 then\n    return math.floor(num + 0.5)\n  else\n    return math.ceil(num\
    \ - 0.5)\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp28y8f5vs.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp28y8f5vs.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    if num == nil then\n        return nil\n    end\n    local int = math.floor(num)\n\
    \    if num - int < 0.5 then\n        return int\n    else\n        return int\
    \ + 1\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpyd3h_p8s.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpyd3h_p8s.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    local integer = math.floor(number)\n    local decimal\
    \ = number - integer\n    if decimal >= 0.5 then\n        return integer + 1\n\
    \    else\n        return integer\n    end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmph_27i988.lua:30:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmph_27i988.lua:30: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    local integer = math.floor(number)\n    local decimal\
    \ = number - integer\n    if decimal >= 0.5 then\n        return integer + 1\n\
    \    else\n        return integer\n    end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmprxjbg3k0.lua:30:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmprxjbg3k0.lua:30: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    if num == nil then\n        return nil\n    end\n    local int = math.floor(num)\n\
    \    local frac = num - int\n    if frac >= 0.5 then\n        return int + 1\n\
    \    else\n        return int\n    end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmphq94axdm.lua:33:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmphq94axdm.lua:33: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    local int = math.floor(num)\n    local dec = num - int\n    if dec >= 0.5\
    \ then\n        return int + 1\n    else\n        return int\n    end\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmphy6jila7.lua:30:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmphy6jila7.lua:30: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpwo10au4s.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpwo10au4s.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2mwzp83i.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp2mwzp83i.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local num = tonumber(value)\n\
    \  if num == math.floor(num) then\n    return num\n  else\n    local int = math.floor(num)\n\
    \    local dec = num - int\n    if dec >= 0.5 then\n      return int + 1\n   \
    \ else\n      return int\n    end\n  end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp6ey3tnt7.lua:34:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp6ey3tnt7.lua:34: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    if number == nil then\n        return nil\n    end\n\
    \    local integer = math.floor(number)\n    local fraction = number - integer\n\
    \    if fraction >= 0.5 then\n        return integer + 1\n    else\n        return\
    \ integer\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpd67el56e.lua:33:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpd67el56e.lua:33: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpm6xa3qaf.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpm6xa3qaf.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp8kwdejr3.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp8kwdejr3.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpv5afycdd.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpv5afycdd.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    local integer = math.floor(number)\n    if number - integer\
    \ >= 0.5 then\n        return integer + 1\n    else\n        return integer\n\
    \    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpb2eflh83.lua:29:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpb2eflh83.lua:29: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpsvqn0zvw.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpsvqn0zvw.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpuy_24xlh.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpuy_24xlh.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local number =\
    \ tonumber(value)\n  local integer = math.floor(number)\n  local decimal = number\
    \ - integer\n  if decimal >= 0.5 then\n    return integer + 1\n  else\n    return\
    \ integer\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp054l20sf.lua:30:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp054l20sf.lua:30: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local number =\
    \ tonumber(value)\n  if number == nil then\n    return nil\n  end\n  if number\
    \ > 0 then\n    return math.floor(number + 0.5)\n  else\n    return math.ceil(number\
    \ - 0.5)\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local num = tonumber(value)\n\
    \  if num > 0 then\n    return math.floor(num + 0.5)\n  else\n    return math.ceil(num\
    \ - 0.5)\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local number =\
    \ tonumber(value)\n  if number == nil then\n    return nil\n  end\n  local integer\
    \ = math.floor(number)\n  local fraction = number - integer\n  if fraction >=\
    \ 0.5 then\n    return integer + 1\n  else\n    return integer\n  end\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp_ykl5o0d.lua:33:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp_ykl5o0d.lua:33: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    local int, frac = math.modf(number)\n    if frac >= 0.5\
    \ then\n        return int + 1\n    else\n        return int\n    end\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp84wu9qk7.lua:29:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp84wu9qk7.lua:29: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpkc9s3tnl.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpkc9s3tnl.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local number =\
    \ tonumber(value)\n  if number == nil then\n    return nil\n  end\n  local integer\
    \ = math.floor(number)\n  if number - integer >= 0.5 then\n    return integer\
    \ + 1\n  else\n    return integer\n  end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp4f95rvlj.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp4f95rvlj.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    if num == nil then\n        return nil\n    end\n    local int = math.floor(num)\n\
    \    if num - int >= 0.5 then\n        return int + 1\n    else\n        return\
    \ int\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp0f6sjo_4.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp0f6sjo_4.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpu01v110o.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpu01v110o.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpj7msd3xt.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpj7msd3xt.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    if number > 0 then\n        return math.floor(number\
    \ + 0.5)\n    else\n        return math.ceil(number - 0.5)\n    end\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  -- TODO: implement\
    \ this function\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpqfuot6x8.lua:21:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmpqfuot6x8.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    if number < 0 then\n        return math.ceil(number)\n\
    \    else\n        return math.floor(number)\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpw26554c9.lua:27:\
    \ expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmpw26554c9.lua:27: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local num = tonumber(value)\n\
    \  if num == nil then\n    return nil\n  end\n  local int = math.floor(num)\n\
    \  if num - int >= 0.5 then\n    return int + 1\n  else\n    return int\n  end\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpl08ofdf9.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpl08ofdf9.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2zmzq0q7.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp2zmzq0q7.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    if number == nil then\n        return nil\n    end\n\
    \    local integer = math.floor(number)\n    local decimal = number - integer\n\
    \    if decimal >= 0.5 then\n        return integer + 1\n    else\n        return\
    \ integer\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpaul2c961.lua:33:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpaul2c961.lua:33: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local number =\
    \ tonumber(value)\n  if number == nil then\n    return nil\n  end\n  local floor\
    \ = math.floor(number)\n  local ceil = math.ceil(number)\n  if number - floor\
    \ < ceil - number then\n    return floor\n  else\n    return ceil\n  end\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpkfn28o92.lua:33:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpkfn28o92.lua:33: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    if num == nil then\n        return nil\n    end\n    local int = math.floor(num)\n\
    \    if num - int >= 0.5 then\n        return int + 1\n    else\n        return\
    \ int\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpwljj2d05.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpwljj2d05.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    if num == math.floor(num) then\n        return num\n    else\n        local\
    \ int = math.floor(num)\n        local dec = num - int\n        if dec >= 0.5\
    \ then\n            return int + 1\n        else\n            return int\n   \
    \     end\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp4qqj4oyf.lua:34:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp4qqj4oyf.lua:34: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local num = tonumber(value)\n\
    \  if num == nil then\n    return nil\n  end\n  local int = math.floor(num)\n\
    \  if num - int >= 0.5 then\n    return int + 1\n  else\n    return int\n  end\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp86fpyo0l.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp86fpyo0l.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpgg3_pnk7.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpgg3_pnk7.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp614483tt.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp614483tt.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    if num == nil then\n        return nil\n    end\n    local int = math.floor(num)\n\
    \    if num - int >= 0.5 then\n        return int + 1\n    else\n        return\
    \ int\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpfn3yc0kj.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpfn3yc0kj.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    if number == nil then\n        return nil\n    end\n\
    \    if number > 0 then\n        return math.floor(number + 0.5)\n    else\n \
    \       return math.ceil(number - 0.5)\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpdfoac5qw.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpdfoac5qw.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local num = tonumber(value)\n\
    \  local int = math.floor(num)\n  local frac = num - int\n  if frac >= 0.5 then\n\
    \    return int + 1\n  else\n    return int\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpgc26l8qv.lua:30:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpgc26l8qv.lua:30: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    if num == nil then\n        return nil\n    end\n    local int, frac = math.modf(num)\n\
    \    if frac >= 0.5 then\n        return int + 1\n    else\n        return int\n\
    \    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpl6uycqtd.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpl6uycqtd.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    local integer = math.floor(number)\n    if number - integer\
    \ >= 0.5 then\n        return integer + 1\n    else\n        return integer\n\
    \    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpcmg2b7lj.lua:29:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpcmg2b7lj.lua:29: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp5cfkmqpx.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp5cfkmqpx.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpehczpqle.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpehczpqle.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpc8bognuv.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpc8bognuv.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    if number == nil then\n        return nil\n    end\n\
    \    local integer = math.floor(number)\n    if number - integer >= 0.5 then\n\
    \        integer = integer + 1\n    end\n    return integer\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnrqu5y1o.lua:31:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpnrqu5y1o.lua:31: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    if num == nil then\n        return nil\n    end\n    local int = math.floor(num)\n\
    \    if num - int >= 0.5 then\n        return int + 1\n    else\n        return\
    \ int\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpx31ry_mz.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpx31ry_mz.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    return number % 1 >= 0.5 and math.ceil(number) or math.floor(number)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpy53n58fc.lua:24:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpy53n58fc.lua:24: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local number =\
    \ tonumber(value)\n  local integer = math.floor(number)\n  local decimal = number\
    \ - integer\n  if decimal >= 0.5 then\n    return integer + 1\n  else\n    return\
    \ integer\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp591fkln1.lua:30:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp591fkln1.lua:30: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local num = tonumber(value)\n\
    \  if num > 0 then\n    return math.floor(num + 0.5)\n  else\n    return math.ceil(num\
    \ - 0.5)\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local number =\
    \ tonumber(value)\n  if number == nil then\n    return nil\n  end\n  local floor\
    \ = math.floor(number)\n  local ceil = math.ceil(number)\n  if number - floor\
    \ < ceil - number then\n    return floor\n  else\n    return ceil\n  end\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp7wyeccul.lua:33:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp7wyeccul.lua:33: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpe6_pge2t.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpe6_pge2t.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpq3kvbqa2.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpq3kvbqa2.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    if num == nil then\n        return nil\n    end\n    local int = math.floor(num)\n\
    \    if num - int >= 0.5 then\n        return int + 1\n    else\n        return\
    \ int\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp22237ub3.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp22237ub3.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp7c6bhkaa.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp7c6bhkaa.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    if num == nil then\n        return nil\n    end\n    local int, frac = math.modf(num)\n\
    \    if frac >= 0.5 then\n        return int + 1\n    else\n        return int\n\
    \    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnybuulmu.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpnybuulmu.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  -- TODO: Implement\
    \ me!\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpyv4lozrs.lua:21:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmpyv4lozrs.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    if number == nil then\n        return nil\n    end\n\
    \    local int = math.floor(number)\n    if number - int >= 0.5 then\n       \
    \ return int + 1\n    else\n        return int\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp5e_uh1g_.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp5e_uh1g_.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp59w4jjbu.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp59w4jjbu.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpqhvpqp2m.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpqhvpqp2m.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpogwakw0w.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpogwakw0w.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpgn5sjcvj.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpgn5sjcvj.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    if num == nil then\n        return nil\n    end\n    local int = math.floor(num)\n\
    \    if num - int >= 0.5 then\n        return int + 1\n    else\n        return\
    \ int\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpl7u4mfyb.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpl7u4mfyb.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    if number == nil then\n        return nil\n    end\n\
    \    local integer = math.floor(number)\n    if number - integer < 0.5 then\n\
    \        return integer\n    else\n        return integer + 1\n    end\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpqs5pm131.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpqs5pm131.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    if num == nil then\n        return nil\n    end\n    if num > 0 then\n  \
    \      return math.floor(num + 0.5)\n    else\n        return math.ceil(num -\
    \ 0.5)\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local number =\
    \ tonumber(value)\n  if number == nil then\n    return nil\n  end\n  local integer\
    \ = math.floor(number)\n  local fraction = number - integer\n  if fraction >=\
    \ 0.5 then\n    return integer + 1\n  else\n    return integer\n  end\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp854gukh8.lua:33:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp854gukh8.lua:33: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp5ctbrswi.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp5ctbrswi.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local number =\
    \ tonumber(value)\n  if number == nil then\n    return nil\n  end\n  local integer\
    \ = math.floor(number)\n  if number - integer >= 0.5 then\n    return integer\
    \ + 1\n  else\n    return integer\n  end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpviknqoet.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpviknqoet.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpp0y0iy9l.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpp0y0iy9l.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local number =\
    \ tonumber(value)\n  return number % 1 >= 0.5 and math.ceil(number) or math.floor(number)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp23b3y1mg.lua:24:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp23b3y1mg.lua:24: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    if number == nil then\n        return nil\n    end\n\
    \    local integer = math.floor(number)\n    if number - integer >= 0.5 then\n\
    \        integer = integer + 1\n    end\n    return integer\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp09_xzu73.lua:31:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp09_xzu73.lua:31: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp1qvvlc80.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp1qvvlc80.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    if num - math.floor(num) >= 0.5 then\n        return math.ceil(num)\n   \
    \ else\n        return math.floor(num)\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpj07_m2s5.lua:28:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpj07_m2s5.lua:28: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local number =\
    \ tonumber(value)\n  if number == nil then\n    return nil\n  end\n  local integer\
    \ = math.floor(number)\n  if number - integer >= 0.5 then\n    return integer\
    \ + 1\n  else\n    return integer\n  end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpes1_47di.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpes1_47di.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp75podp8f.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp75podp8f.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpwumzg_is.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpwumzg_is.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local num = tonumber(value)\n\
    \  if num > 0 then\n    return math.floor(num + 0.5)\n  else\n    return math.ceil(num\
    \ - 0.5)\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmplqit501d.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmplqit501d.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local num = tonumber(value)\n\
    \  if num == nil then\n    return nil\n  end\n  local int, frac = math.modf(num)\n\
    \  if frac >= 0.5 then\n    return int + 1\n  else\n    return int\n  end\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmph8xhexyh.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmph8xhexyh.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp_2dnhhzc.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp_2dnhhzc.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp1p6yck4j.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp1p6yck4j.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local number =\
    \ tonumber(value)\n  if number == nil then\n    return nil\n  end\n  local integer\
    \ = math.floor(number)\n  if number - integer >= 0.5 then\n    return integer\
    \ + 1\n  else\n    return integer\n  end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp07jqkwit.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp07jqkwit.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local number =\
    \ tonumber(value)\n  if number == nil then\n    return nil\n  end\n  return math.floor(number\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpcd7yp3zq.lua:27:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpcd7yp3zq.lua:27: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    if num == math.floor(num) then\n        return num\n    else\n        local\
    \ floor = math.floor(num)\n        local ceil = math.ceil(num)\n        if num\
    \ - floor > ceil - num then\n            return ceil\n        else\n         \
    \   return floor\n        end\n    end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpvui09ib5.lua:33:\
    \ expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmpvui09ib5.lua:33: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp1cwy_2ay.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp1cwy_2ay.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpuxhz5ftg.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpuxhz5ftg.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpcyofm6d3.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpcyofm6d3.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmphmotlasy.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmphmotlasy.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp847qm3pj.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp847qm3pj.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    if number == nil then\n        return nil\n    end\n\
    \    local integer = math.floor(number)\n    if number - integer >= 0.5 then\n\
    \        integer = integer + 1\n    end\n    return integer\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpufx5571t.lua:31:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpufx5571t.lua:31: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local number =\
    \ tonumber(value)\n  if number == nil then\n    return nil\n  end\n  local integer\
    \ = math.floor(number)\n  if number - integer >= 0.5 then\n    return integer\
    \ + 1\n  else\n    return integer\n  end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp4r6o8q6j.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp4r6o8q6j.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpqaab6yu_.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpqaab6yu_.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    if num > 0 then\n        return math.floor(num + 0.5)\n    else\n       \
    \ return math.ceil(num - 0.5)\n    end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  -- TODO: Implement\
    \ me!\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp5m1bzxxn.lua:21:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmp5m1bzxxn.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpp1ap879d.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpp1ap879d.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  -- your code here\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpmagup9vs.lua:21:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmpmagup9vs.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpayu3oi10.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpayu3oi10.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpbloklker.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpbloklker.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpt0tdayd0.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpt0tdayd0.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    -- TODO: implement\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmplddozwwl.lua:21:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmplddozwwl.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    if num % 1 >= 0.5 then\n        return math.ceil(num)\n    else\n       \
    \ return math.floor(num)\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpb7_rc320.lua:28:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpb7_rc320.lua:28: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp5rozk8oq.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp5rozk8oq.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp_09wh9if.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp_09wh9if.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    if number > 0 then\n        return math.floor(number\
    \ + 0.5)\n    else\n        return math.ceil(number - 0.5)\n    end\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp4u8rc7z3.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp4u8rc7z3.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  -- your code here\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpgzsfo2id.lua:21:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmpgzsfo2id.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local number =\
    \ tonumber(value)\n  if number == nil then\n    return nil\n  end\n  local integer\
    \ = math.floor(number)\n  if number - integer < 0.5 then\n    return integer\n\
    \  else\n    return integer + 1\n  end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp89_dpq2g.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp89_dpq2g.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp8ldukoi3.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp8ldukoi3.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpiy2o19tw.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpiy2o19tw.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    if number < 0 then\n        return math.ceil(number)\n\
    \    else\n        return math.floor(number)\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp4ofdfugn.lua:27:\
    \ expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmp4ofdfugn.lua:27: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    -- TODO: Implement\
    \ the function here\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp3swzjm85.lua:21:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmp3swzjm85.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    if number == nil then\n        return nil\n    end\n\
    \    local integer = math.floor(number)\n    if number - integer >= 0.5 then\n\
    \        integer = integer + 1\n    end\n    return integer\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpsyhzg632.lua:31:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpsyhzg632.lua:31: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp8hr6zgy3.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp8hr6zgy3.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    if number > 0 then\n        return math.floor(number\
    \ + 0.5)\n    else\n        return math.ceil(number - 0.5)\n    end\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  local number =\
    \ tonumber(value)\n  if number == nil then\n    return nil\n  end\n  local integer\
    \ = math.floor(number)\n  if number - integer >= 0.5 then\n    return integer\
    \ + 1\n  else\n    return integer\n  end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmplv4smsq8.lua:32:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmplv4smsq8.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp52cmxz4b.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp52cmxz4b.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    local integer = math.floor(number)\n    local decimal\
    \ = number - integer\n    if decimal >= 0.5 then\n        return integer + 1\n\
    \    else\n        return integer\n    end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmplk0gcndq.lua:30:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmplk0gcndq.lua:30: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    -- your code\
    \ here\n    return math.floor(value + 0.5)\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmph6h89mbc.lua:24:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmph6h89mbc.lua:24: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n\
    \    if num == nil then\n        return nil\n    end\n    if num > 0 then\n  \
    \      return math.floor(num + 0.5)\n    else\n        return math.ceil(num -\
    \ 0.5)\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local number\
    \ = tonumber(value)\n    if number < 0 then\n        return math.ceil(number)\n\
    \    else\n        return math.floor(number)\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpgdmb8q9s.lua:27:\
    \ expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmpgdmb8q9s.lua:27: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer('10')\n\
    -- 10\n-- >>> closest_integer('15.3')\n-- 15\n-- Note:\n-- Rounding away from\
    \ zero means that if the given number is equidistant\n-- from two integers, the\
    \ one you should return is the one that is the\n-- farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\nlocal function closest_integer(value)\n    local n = tonumber(value)\n\
    \    if n == math.floor(n) then\n        return n\n    else\n        local floor\
    \ = math.floor(n)\n        local ceil = math.ceil(n)\n        if n - floor > ceil\
    \ - n then\n            return ceil\n        else\n            return floor\n\
    \        end\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpup4er643.lua:33:\
    \ expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmpup4er643.lua:33: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
