---
name: HumanEval_47_median
language: lua
prompt: |
  -- Return median of elements in the table l.
  -- >>> median({3, 1, 2, 4, 5})
  -- 3
  -- >>> median({-10, 4, 6, 1000, 10, 20})
  -- 15.0
  local function median(l)
tests: |-
  lu = require('luaunit')

  function test_humaneval()
  local candidate = median
      lu.assertEquals(candidate({3, 1, 2, 4, 5}), 3)
      lu.assertEquals(candidate({-10, 4, 6, 1000, 10, 20}), 8.0)
      lu.assertEquals(candidate({5}), 5)
      lu.assertEquals(candidate({6, 5}), 5.5)
      lu.assertEquals(candidate({8, 1, 3, 9, 9, 2, 7}), 7)
  end

  os.exit(lu.LuaUnit.run())
completions:
- |2-
      local t = {}
      for _, v in ipairs(l) do
          table.insert(t, v)
      end
      table.sort(t)
      local n = #t
      if n == 0 then
          return nil
      elseif n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
    local t = copy(l)
    sort(t)
    local n = #t
    if n == 0 then
      return nil
    elseif n % 2 == 0 then
      return (t[n / 2] + t[n / 2 + 1]) / 2
    else
      return t[(n + 1) / 2]
    end
  end
- |2-
      local t = copy(l)
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          t[#t + 1] = v
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
    local m = {}
    for _, v in ipairs(l) do
      m[#m + 1] = v
    end
    table.sort(m)
    local n = #m
    if n % 2 == 0 then
      return (m[n / 2] + m[n / 2 + 1]) / 2
    else
      return m[(n + 1) / 2]
    end
  end
- |2-
    local t = {}
    for _, v in ipairs(l) do
      t[#t + 1] = v
    end
    table.sort(t)
    local n = #t
    if n % 2 == 0 then
      return (t[n / 2] + t[n / 2 + 1]) / 2
    else
      return t[(n + 1) / 2]
    end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          t[#t + 1] = v
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          t[#t + 1] = v
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          t[#t + 1] = v
      end
      table.sort(t)
      if #t % 2 == 0 then
          return (t[#t / 2] + t[#t / 2 + 1]) / 2
      else
          return t[math.ceil(#t / 2)]
      end
  end
- |2-
      local t = copy(l)
      table.sort(t)
      local n = #t
      if n == 0 then
          return nil
      elseif n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
    local t = {}
    for _, v in ipairs(l) do
      table.insert(t, v)
    end
    table.sort(t)
    local n = #t
    if n % 2 == 0 then
      return (t[n / 2] + t[n / 2 + 1]) / 2
    else
      return t[(n + 1) / 2]
    end
  end
- |2-
    local t = copy(l)
    table.sort(t)
    local n = #t
    if n == 0 then
      return nil
    elseif n % 2 == 0 then
      return (t[n / 2] + t[n / 2 + 1]) / 2
    else
      return t[(n + 1) / 2]
    end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          t[#t + 1] = v
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
      local t = copy(l)
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          t[#t + 1] = v
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          t[#t + 1] = v
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          t[#t + 1] = v
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
    local t = {}
    for _, v in ipairs(l) do
      t[#t + 1] = v
    end
    table.sort(t)
    local n = #t
    if n % 2 == 0 then
      return (t[n / 2] + t[n / 2 + 1]) / 2
    else
      return t[(n + 1) / 2]
    end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          table.insert(t, v)
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          table.insert(t, v)
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          t[#t + 1] = v
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
    local t = {}
    for _, v in ipairs(l) do
      t[#t + 1] = v
    end
    table.sort(t)
    local n = #t
    if n % 2 == 0 then
      return (t[n / 2] + t[n / 2 + 1]) / 2
    else
      return t[(n + 1) / 2]
    end
  end
- |2-
    local t = {}
    for _, v in ipairs(l) do
      t[#t + 1] = v
    end
    table.sort(t)
    local n = #t
    if n % 2 == 0 then
      return (t[n / 2] + t[n / 2 + 1]) / 2
    else
      return t[(n + 1) / 2]
    end
  end
- |2-
      local t = copy(l)
      table.sort(t)
      local n = #t
      if n == 0 then
          return nil
      elseif n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
    local t = {}
    for _, v in ipairs(l) do
      table.insert(t, v)
    end
    table.sort(t)
    local n = #t
    if n % 2 == 0 then
      return (t[n / 2] + t[n / 2 + 1]) / 2
    else
      return t[(n + 1) / 2]
    end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          t[#t + 1] = v
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          table.insert(t, v)
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
    local t = {}
    for _, v in ipairs(l) do
      t[#t + 1] = v
    end
    table.sort(t)
    local n = #t
    if n % 2 == 0 then
      return (t[n / 2] + t[n / 2 + 1]) / 2
    else
      return t[(n + 1) / 2]
    end
  end
- |2-
      local t = {}
      for i, v in ipairs(l) do
          t[i] = v
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n/2] + t[n/2+1]) / 2
      else
          return t[(n+1)/2]
      end
  end
- |2-
    local t = {}
    for _, v in ipairs(l) do
      t[#t + 1] = v
    end
    table.sort(t)
    local n = #t
    if n % 2 == 0 then
      return (t[n / 2] + t[n / 2 + 1]) / 2
    else
      return t[(n + 1) / 2]
    end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          t[#t + 1] = v
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
    local t = {}
    for _, v in ipairs(l) do
      t[#t + 1] = v
    end
    table.sort(t)
    local n = #t
    if n % 2 == 0 then
      return (t[n / 2] + t[n / 2 + 1]) / 2
    else
      return t[(n + 1) / 2]
    end
  end
- |2-
    local t = {}
    for _, v in ipairs(l) do
      table.insert(t, v)
    end
    table.sort(t)
    local n = #t
    if n % 2 == 0 then
      return (t[n / 2] + t[n / 2 + 1]) / 2
    else
      return t[(n + 1) / 2]
    end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          table.insert(t, v)
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          t[#t + 1] = v
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          table.insert(t, v)
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[math.ceil(n / 2)]
      end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          t[#t + 1] = v
      end
      table.sort(t)
      if #t % 2 == 0 then
          return (t[#t / 2] + t[#t / 2 + 1]) / 2
      else
          return t[math.ceil(#t / 2)]
      end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          table.insert(t, v)
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          t[#t + 1] = v
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          t[#t + 1] = v
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
      local t = copy(l)
      table.sort(t)
      local n = #t
      if n == 0 then
          return nil
      elseif n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
    local t = {}
    for _, v in ipairs(l) do
      table.insert(t, v)
    end
    table.sort(t)
    local n = #t
    if n % 2 == 0 then
      return (t[n / 2] + t[n / 2 + 1]) / 2
    else
      return t[(n + 1) / 2]
    end
  end
- |2-
    local t = {}
    for _, v in ipairs(l) do
      table.insert(t, v)
    end
    table.sort(t)
    local n = #t
    if n % 2 == 0 then
      return (t[n / 2] + t[n / 2 + 1]) / 2
    else
      return t[(n + 1) / 2]
    end
  end
- |2-
      local t = copy(l)
      table.sort(t)
      local n = #t
      if n == 0 then
          return nil
      elseif n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          table.insert(t, v)
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
    local m = #l
    if m == 0 then return 0 end
    local t = sort(l)
    if m % 2 == 0 then
      return (t[m/2] + t[m/2+1]) / 2
    else
      return t[(m+1)/2]
    end
  end
- |2-
    local t = {}
    for _, v in ipairs(l) do
      t[#t + 1] = v
    end
    table.sort(t)
    local n = #t
    if n % 2 == 0 then
      return (t[n / 2] + t[n / 2 + 1]) / 2
    else
      return t[(n + 1) / 2]
    end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          t[#t + 1] = v
      end
      table.sort(t)
      if #t % 2 == 0 then
          return (t[#t / 2] + t[#t / 2 + 1]) / 2
      else
          return t[math.ceil(#t / 2)]
      end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          table.insert(t, v)
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
    local t = {}
    for _, v in ipairs(l) do
      t[#t + 1] = v
    end
    table.sort(t)
    local n = #t
    if n % 2 == 0 then
      return (t[n / 2] + t[n / 2 + 1]) / 2
    else
      return t[(n + 1) / 2]
    end
  end
- |2-
      local t = copy(l)
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
      local t = copy(l)
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
    local t = {}
    for _, v in ipairs(l) do
      t[#t + 1] = v
    end
    table.sort(t)
    local n = #t
    if n % 2 == 0 then
      return (t[n / 2] + t[n / 2 + 1]) / 2
    else
      return t[(n + 1) / 2]
    end
  end
- |2-
    local t = copy(l)
    table.sort(t)
    local n = #t
    if n % 2 == 0 then
      return (t[n / 2] + t[n / 2 + 1]) / 2
    else
      return t[(n + 1) / 2]
    end
  end
- |2-
    local t = {}
    for _, v in ipairs(l) do
      t[#t + 1] = v
    end
    table.sort(t)
    local n = #t
    if n == 0 then
      return nil
    elseif n % 2 == 0 then
      return (t[n / 2] + t[n / 2 + 1]) / 2
    else
      return t[(n + 1) / 2]
    end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          table.insert(t, v)
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
    local t = {}
    for _, v in ipairs(l) do
      t[#t + 1] = v
    end
    table.sort(t)
    local n = #t
    if n % 2 == 0 then
      return (t[n / 2] + t[n / 2 + 1]) / 2
    else
      return t[(n + 1) / 2]
    end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          table.insert(t, v)
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[math.ceil(n / 2)]
      end
  end
- |2-
    local t = {}
    for _, v in ipairs(l) do
      t[#t + 1] = v
    end
    table.sort(t)
    local n = #t
    if n % 2 == 0 then
      return (t[n / 2] + t[n / 2 + 1]) / 2
    else
      return t[(n + 1) / 2]
    end
  end
- |2-
      local n = #l
      if n == 0 then
          return nil
      end
      table.sort(l)
      if n % 2 == 0 then
          return (l[n / 2] + l[n / 2 + 1]) / 2
      else
          return l[(n + 1) / 2]
      end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          t[#t + 1] = v
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          t[#t + 1] = v
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          t[#t + 1] = v
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
    local sorted = copy(l)
    table.sort(sorted)
    local n = #sorted
    if n % 2 == 0 then
      return (sorted[n / 2] + sorted[n / 2 + 1]) / 2
    else
      return sorted[math.ceil(n / 2)]
    end
  end
- |2-
    local t = {}
    for _, v in ipairs(l) do
      t[#t + 1] = v
    end
    table.sort(t)
    local n = #t
    if n % 2 == 0 then
      return (t[n / 2] + t[n / 2 + 1]) / 2
    else
      return t[(n + 1) / 2]
    end
  end
- |2-
    local t = {}
    for _, v in ipairs(l) do
      t[#t + 1] = v
    end
    table.sort(t)
    local n = #t
    if n % 2 == 0 then
      return (t[n / 2] + t[n / 2 + 1]) / 2
    else
      return t[(n + 1) / 2]
    end
  end
- |2-
      local t = copy(l)
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
    local n = #l
    if n == 0 then return nil end
    local s = table.sort(l)
    if n % 2 == 0 then
      return (s[n/2] + s[n/2+1]) / 2
    else
      return s[math.ceil(n/2)]
    end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          t[#t + 1] = v
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
      local t = {}
      for i, v in ipairs(l) do
          t[i] = v
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          t[#t + 1] = v
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          t[#t + 1] = v
      end
      table.sort(t)
      local m = #t
      if m % 2 == 0 then
          return (t[m / 2] + t[m / 2 + 1]) / 2
      else
          return t[math.ceil(m / 2)]
      end
  end
- |2-
    local t = {}
    for _, v in ipairs(l) do
      t[#t + 1] = v
    end
    table.sort(t)
    local n = #t
    if n % 2 == 0 then
      return (t[n / 2] + t[n / 2 + 1]) / 2
    else
      return t[(n + 1) / 2]
    end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          t[#t + 1] = v
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
      local t = table.copy(l)
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          t[#t + 1] = v
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          t[#t + 1] = v
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          t[#t + 1] = v
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
    local t = {}
    for i, v in ipairs(l) do
      t[i] = v
    end
    table.sort(t)
    local n = #t
    if n % 2 == 0 then
      return (t[n / 2] + t[n / 2 + 1]) / 2
    else
      return t[(n + 1) / 2]
    end
  end
- |2-
    local t = {}
    for _, v in ipairs(l) do
      t[#t + 1] = v
    end
    table.sort(t)
    local n = #t
    if n % 2 == 0 then
      return (t[n / 2] + t[n / 2 + 1]) / 2
    else
      return t[(n + 1) / 2]
    end
  end
- "\tlocal t = {}\n\tfor _, v in ipairs(l) do\n\t\ttable.insert(t, v)\n\tend\n\ttable.sort(t)\n\tlocal
  n = #t\n\tif n % 2 == 0 then\n\t\treturn (t[n / 2] + t[n / 2 + 1]) / 2\n\telse\n\t\treturn
  t[(n + 1) / 2]\n\tend\nend"
- |2-
    local t = {}
    for _, v in ipairs(l) do
      table.insert(t, v)
    end
    table.sort(t)
    local n = #t
    if n % 2 == 0 then
      return (t[n / 2] + t[n / 2 + 1]) / 2
    else
      return t[(n + 1) / 2]
    end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          table.insert(t, v)
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
    local t = {}
    for _, v in ipairs(l) do
      t[#t + 1] = v
    end
    table.sort(t)
    local n = #t
    if n % 2 == 0 then
      return (t[n / 2] + t[n / 2 + 1]) / 2
    else
      return t[math.ceil(n / 2)]
    end
  end
- |2-
    local t = {}
    for _, v in ipairs(l) do
      t[#t + 1] = v
    end
    table.sort(t)
    local n = #t
    if n % 2 == 0 then
      return (t[n / 2] + t[n / 2 + 1]) / 2
    else
      return t[(n + 1) / 2]
    end
  end
- |2-
      local n = #l
      if n == 0 then
          return nil
      end
      local sorted = {}
      for i, v in ipairs(l) do
          sorted[i] = v
      end
      table.sort(sorted)
      if n % 2 == 1 then
          return sorted[(n + 1) / 2]
      else
          return (sorted[n / 2] + sorted[n / 2 + 1]) / 2
      end
  end
- |2-
    local t = copy(l)
    table.sort(t)
    local n = #t
    if n % 2 == 0 then
      return (t[n / 2] + t[n / 2 + 1]) / 2
    else
      return t[(n + 1) / 2]
    end
  end
- |2-
    local t = copy(l)
    table.sort(t)
    local n = #t
    if n == 0 then
      return nil
    elseif n % 2 == 0 then
      return (t[n / 2] + t[n / 2 + 1]) / 2
    else
      return t[(n + 1) / 2]
    end
  end
- |2-
    local t = {}
    for _, v in ipairs(l) do
      t[#t + 1] = v
    end
    table.sort(t)
    local n = #t
    if n % 2 == 0 then
      return (t[n / 2] + t[n / 2 + 1]) / 2
    else
      return t[(n + 1) / 2]
    end
  end
- |2-
    local t = {}
    for i, v in ipairs(l) do
      t[i] = v
    end
    table.sort(t)
    local n = #t
    if n % 2 == 0 then
      return (t[n / 2] + t[n / 2 + 1]) / 2
    else
      return t[(n + 1) / 2]
    end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          table.insert(t, v)
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
    local n = #l
    if n == 0 then return nil end
    if n == 1 then return l[1] end
    local t = {}
    for i = 1, n do
      t[i] = l[i]
    end
    table.sort(t)
    if n % 2 == 0 then
      return (t[n / 2] + t[n / 2 + 1]) / 2
    else
      return t[math.ceil(n / 2)]
    end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          t[#t + 1] = v
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
      local n = #l
      if n == 0 then
          return nil
      end
      table.sort(l)
      if n % 2 == 0 then
          return (l[n / 2] + l[n / 2 + 1]) / 2
      else
          return l[(n + 1) / 2]
      end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          t[#t + 1] = v
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          table.insert(t, v)
      end
      table.sort(t)
      local n = #t
      if n == 0 then
          return 0
      elseif n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          table.insert(t, v)
      end
      table.sort(t)
      local n = #t
      if n == 0 then
          return nil
      elseif n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
    local l = copy(l)
    local n = #l
    if n == 0 then
      return nil
    end
    table.sort(l)
    if n % 2 == 0 then
      return (l[n / 2] + l[n / 2 + 1]) / 2
    else
      return l[(n + 1) / 2]
    end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          t[#t + 1] = v
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
    local t = {}
    for _, v in ipairs(l) do
      t[#t + 1] = v
    end
    table.sort(t)
    local n = #t
    if n % 2 == 0 then
      return (t[n / 2] + t[n / 2 + 1]) / 2
    else
      return t[(n + 1) / 2]
    end
  end
- |2-
    local t = l
    local n = #t
    if n == 0 then return nil end
    if n == 1 then return t[1] end
    table.sort(t)
    if n % 2 == 0 then
      return (t[n/2] + t[n/2+1]) / 2
    else
      return t[math.ceil(n/2)]
    end
  end
- |2-
      local t = table.copy(l)
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n/2] + t[n/2+1]) / 2
      else
          return t[(n+1)/2]
      end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          t[#t + 1] = v
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          table.insert(t, v)
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          t[#t + 1] = v
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
    local t = {}
    for _, v in ipairs(l) do
      t[#t + 1] = v
    end
    table.sort(t)
    local n = #t
    if n % 2 == 0 then
      return (t[n / 2] + t[n / 2 + 1]) / 2
    else
      return t[(n + 1) / 2]
    end
  end
- |2-
    local t = {}
    for _, v in ipairs(l) do
      t[#t + 1] = v
    end
    table.sort(t)
    local n = #t
    if n % 2 == 0 then
      return (t[n / 2] + t[n / 2 + 1]) / 2
    else
      return t[(n + 1) / 2]
    end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          t[#t + 1] = v
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
    local m = {}
    for k, v in pairs(l) do
      m[#m + 1] = v
    end
    table.sort(m)
    if #m % 2 == 0 then
      return (m[#m / 2] + m[#m / 2 + 1]) / 2
    else
      return m[math.ceil(#m / 2)]
    end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          t[#t + 1] = v
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
    local t = {}
    for _, v in ipairs(l) do
      table.insert(t, v)
    end
    table.sort(t)
    local n = #t
    if n == 0 then
      return 0
    elseif n % 2 == 0 then
      return (t[n/2] + t[n/2+1]) / 2
    else
      return t[(n+1)/2]
    end
  end
- |2-
    local t = {}
    for _, v in ipairs(l) do
      t[#t + 1] = v
    end
    table.sort(t)
    local n = #t
    if n % 2 == 0 then
      return (t[n / 2] + t[n / 2 + 1]) / 2
    else
      return t[(n + 1) / 2]
    end
  end
- |2-
    local t = copy(l)
    table.sort(t)
    local n = #t
    if n == 0 then
      return nil
    elseif n % 2 == 0 then
      return (t[n / 2] + t[n / 2 + 1]) / 2
    else
      return t[(n + 1) / 2]
    end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          t[#t + 1] = v
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
    local t = {}
    for _, v in ipairs(l) do
      t[#t + 1] = v
    end
    table.sort(t)
    local n = #t
    if n == 0 then
      return nil
    elseif n % 2 == 0 then
      return (t[n / 2] + t[n / 2 + 1]) / 2
    else
      return t[(n + 1) / 2]
    end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          t[#t + 1] = v
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
    local t = {}
    for _, v in ipairs(l) do
      t[#t + 1] = v
    end
    table.sort(t)
    local n = #t
    if n % 2 == 0 then
      return (t[n / 2] + t[n / 2 + 1]) / 2
    else
      return t[(n + 1) / 2]
    end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          t[#t + 1] = v
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          t[#t + 1] = v
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
    local t = {}
    for _, v in ipairs(l) do
      t[#t + 1] = v
    end
    table.sort(t)
    local n = #t
    if n % 2 == 0 then
      return (t[n / 2] + t[n / 2 + 1]) / 2
    else
      return t[(n + 1) / 2]
    end
  end
- |2-
      local sorted = table.sort(l)
      local len = #sorted
      if len % 2 == 0 then
          return (sorted[len / 2] + sorted[len / 2 + 1]) / 2
      else
          return sorted[(len + 1) / 2]
      end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          table.insert(t, v)
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
    local t = {}
    for _, v in ipairs(l) do
      t[#t + 1] = v
    end
    table.sort(t)
    local n = #t
    if n % 2 == 0 then
      return (t[n / 2] + t[n / 2 + 1]) / 2
    else
      return t[(n + 1) / 2]
    end
  end
- |2-
    local t = table.copy(l)
    table.sort(t)
    local n = #t
    if n % 2 == 0 then
      return (t[n / 2] + t[n / 2 + 1]) / 2
    else
      return t[(n + 1) / 2]
    end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          t[#t + 1] = v
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          t[#t + 1] = v
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
      local n = #l
      if n == 0 then
          return nil
      end
      local sorted = table.copy(l)
      table.sort(sorted)
      if n % 2 == 1 then
          return sorted[(n + 1) / 2]
      else
          return (sorted[n / 2] + sorted[n / 2 + 1]) / 2
      end
  end
- |2-
    local t = {}
    for _, v in ipairs(l) do
      table.insert(t, v)
    end
    table.sort(t)
    local n = #t
    if n % 2 == 0 then
      return (t[n / 2] + t[n / 2 + 1]) / 2
    else
      return t[(n + 1) / 2]
    end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          t[#t + 1] = v
      end
      table.sort(t)
      if #t % 2 == 0 then
          return (t[#t / 2] + t[#t / 2 + 1]) / 2
      else
          return t[math.ceil(#t / 2)]
      end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          table.insert(t, v)
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
    local t = {}
    for _, v in ipairs(l) do
      t[#t + 1] = v
    end
    table.sort(t)
    local n = #t
    if n % 2 == 0 then
      return (t[n / 2] + t[n / 2 + 1]) / 2
    else
      return t[math.ceil(n / 2)]
    end
  end
- |2-
    local t = {}
    for _, v in ipairs(l) do
      table.insert(t, v)
    end
    table.sort(t)
    local n = #t
    if n == 0 then
      return nil
    elseif n % 2 == 0 then
      return (t[n / 2] + t[n / 2 + 1]) / 2
    else
      return t[(n + 1) / 2]
    end
  end
- |2-
      local t = copy(l)
      table.sort(t)
      local n = #t
      if n == 0 then
          return nil
      elseif n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
      local t = table.copy(l)
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n/2] + t[n/2+1]) / 2
      else
          return t[(n+1)/2]
      end
  end
- |2-
    local t = {}
    for _, v in ipairs(l) do
      t[#t + 1] = v
    end
    table.sort(t)
    local n = #t
    if n % 2 == 0 then
      return (t[n / 2] + t[n / 2 + 1]) / 2
    else
      return t[(n + 1) / 2]
    end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          t[#t + 1] = v
      end
      table.sort(t)
      local n = #t
      if n == 0 then
          return nil
      elseif n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
    local t = {}
    for _, v in ipairs(l) do
      t[#t + 1] = v
    end
    table.sort(t)
    local n = #t
    if n % 2 == 0 then
      return (t[n / 2] + t[n / 2 + 1]) / 2
    else
      return t[(n + 1) / 2]
    end
  end
- |2-
    local t = {}
    for _, v in ipairs(l) do
      t[#t + 1] = v
    end
    table.sort(t)
    local n = #t
    if n % 2 == 0 then
      return (t[n / 2] + t[n / 2 + 1]) / 2
    else
      return t[(n + 1) / 2]
    end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          table.insert(t, v)
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          table.insert(t, v)
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          table.insert(t, v)
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
    local t = {}
    for _, v in ipairs(l) do
      t[#t + 1] = v
    end
    table.sort(t)
    local n = #t
    if n % 2 == 0 then
      return (t[n / 2] + t[n / 2 + 1]) / 2
    else
      return t[(n + 1) / 2]
    end
  end
- |2-
      local t = copy(l)
      table.sort(t)
      local n = #t
      if n == 0 then
          return nil
      elseif n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
    local t = {}
    for _, v in ipairs(l) do
      t[#t + 1] = v
    end
    table.sort(t)
    if #t % 2 == 0 then
      return (t[#t / 2] + t[#t / 2 + 1]) / 2
    else
      return t[math.ceil(#t / 2)]
    end
  end
- |2-
    local t = {}
    for _, v in ipairs(l) do
      table.insert(t, v)
    end
    table.sort(t)
    local n = #t
    if n % 2 == 0 then
      return (t[n / 2] + t[n / 2 + 1]) / 2
    else
      return t[(n + 1) / 2]
    end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          t[#t + 1] = v
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          t[#t + 1] = v
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
      local n = #l
      if n == 0 then
          return nil
      end
      local sorted = {}
      for i, v in ipairs(l) do
          sorted[i] = v
      end
      table.sort(sorted)
      if n % 2 == 1 then
          return sorted[(n + 1) / 2]
      else
          return (sorted[n / 2] + sorted[n / 2 + 1]) / 2
      end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          t[#t + 1] = v
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          t[#t + 1] = v
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          t[#t + 1] = v
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- "\tlocal t = {}\n\tfor _, v in ipairs(l) do\n\t\ttable.insert(t, v)\n\tend\n\ttable.sort(t)\n\tlocal
  n = #t\n\tif n % 2 == 0 then\n\t\treturn (t[n / 2] + t[n / 2 + 1]) / 2\n\telse\n\t\treturn
  t[(n + 1) / 2]\n\tend\nend"
- |2-
      local t = copy(l)
      table.sort(t)
      local n = #t
      if n == 0 then
          return nil
      elseif n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
      local n = #l
      local m = n % 2
      local t = sort(l)
      if m == 0 then
          return (t[n/2] + t[n/2+1]) / 2
      else
          return t[(n+1)/2]
      end
  end
- |2-
      local n = #l
      local m = n % 2
      local s = sort(l)
      if m == 0 then
          return (s[n/2] + s[n/2+1]) / 2
      else
          return s[(n+1)/2]
      end
  end
- |2-
    local t = copy(l)
    table.sort(t)
    local n = #t
    if n % 2 == 0 then
      return (t[n / 2] + t[n / 2 + 1]) / 2
    else
      return t[(n + 1) / 2]
    end
  end
- |2-
    local t = table.copy(l)
    table.sort(t)
    local n = #t
    if n % 2 == 0 then
      return (t[n / 2] + t[n / 2 + 1]) / 2
    else
      return t[(n + 1) / 2]
    end
  end
- |2-
      local t = copy(l)
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          table.insert(t, v)
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          t[#t + 1] = v
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          t[#t + 1] = v
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
    local t = {}
    for _, v in ipairs(l) do
      table.insert(t, v)
    end
    table.sort(t)
    local n = #t
    if n % 2 == 0 then
      return (t[n / 2] + t[n / 2 + 1]) / 2
    else
      return t[(n + 1) / 2]
    end
  end
- |2-
    local t = {}
    for _, v in ipairs(l) do
      t[#t + 1] = v
    end
    table.sort(t)
    local n = #t
    if n % 2 == 0 then
      return (t[n / 2] + t[n / 2 + 1]) / 2
    else
      return t[(n + 1) / 2]
    end
  end
- |2-
    local t = {}
    for _, v in ipairs(l) do
      table.insert(t, v)
    end
    table.sort(t)
    local n = #t
    if n % 2 == 0 then
      return (t[n / 2] + t[n / 2 + 1]) / 2
    else
      return t[(n + 1) / 2]
    end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          table.insert(t, v)
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
    local t = {}
    for _, v in ipairs(l) do
      table.insert(t, v)
    end
    table.sort(t)
    local n = #t
    if n % 2 == 0 then
      return (t[n / 2] + t[n / 2 + 1]) / 2
    else
      return t[(n + 1) / 2]
    end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          table.insert(t, v)
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n/2] + t[n/2+1]) / 2
      else
          return t[(n+1)/2]
      end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          t[#t + 1] = v
      end
      table.sort(t)
      local n = #t
      if n == 0 then
          return nil
      elseif n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
      local t = copy(l)
      table.sort(t)
      local n = #t
      if n == 0 then
          return nil
      elseif n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          table.insert(t, v)
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
    local t = {}
    for _, v in ipairs(l) do
      t[#t + 1] = v
    end
    table.sort(t)
    if #t % 2 == 0 then
      return (t[#t / 2] + t[#t / 2 + 1]) / 2
    else
      return t[math.ceil(#t / 2)]
    end
  end
- |2-
    local n = #l
    if n == 0 then return nil end
    local m = math.floor(n / 2)
    if n % 2 == 0 then
      return (l[m] + l[m + 1]) / 2
    else
      return l[m + 1]
    end
  end
- |2-
    local t = {}
    for _, v in ipairs(l) do
      t[#t + 1] = v
    end
    table.sort(t)
    local n = #t
    if n % 2 == 0 then
      return (t[n / 2] + t[n / 2 + 1]) / 2
    else
      return t[(n + 1) / 2]
    end
  end
- |2-
      local n = #l
      if n == 0 then
          return nil
      end
      local sorted = table.sort(l)
      if n % 2 == 1 then
          return sorted[(n + 1) / 2]
      else
          return (sorted[n / 2] + sorted[n / 2 + 1]) / 2
      end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          t[#t + 1] = v
      end
      table.sort(t)
      if #t % 2 == 0 then
          return (t[#t / 2] + t[#t / 2 + 1]) / 2
      else
          return t[math.ceil(#t / 2)]
      end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          t[#t + 1] = v
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          t[#t + 1] = v
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          table.insert(t, v)
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          t[#t + 1] = v
      end
      table.sort(t)
      if #t % 2 == 0 then
          return (t[#t / 2] + t[#t / 2 + 1]) / 2
      else
          return t[math.ceil(#t / 2)]
      end
  end
- |2-
    local t = {}
    for _, v in ipairs(l) do
      table.insert(t, v)
    end
    table.sort(t)
    local n = #t
    if n % 2 == 0 then
      return (t[n / 2] + t[n / 2 + 1]) / 2
    else
      return t[(n + 1) / 2]
    end
  end
- |2-
      local t = copy(l)
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
    local t = copy(l)
    table.sort(t)
    local n = #t
    if n % 2 == 0 then
      return (t[n / 2] + t[n / 2 + 1]) / 2
    else
      return t[(n + 1) / 2]
    end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          t[#t + 1] = v
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
      local t = table.copy(l)
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          table.insert(t, v)
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          table.insert(t, v)
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          table.insert(t, v)
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
    local t = {}
    for _, v in ipairs(l) do
      t[#t + 1] = v
    end
    table.sort(t)
    local n = #t
    if n % 2 == 0 then
      return (t[n / 2] + t[n / 2 + 1]) / 2
    else
      return t[math.ceil(n / 2)]
    end
  end
- "\tlocal t = {}\n\tfor _, v in ipairs(l) do\n\t\ttable.insert(t, v)\n\tend\n\ttable.sort(t)\n\tlocal
  n = #t\n\tif n % 2 == 0 then\n\t\treturn (t[n / 2] + t[n / 2 + 1]) / 2\n\telse\n\t\treturn
  t[(n + 1) / 2]\n\tend\nend"
- |2-
    local t = {}
    for _, v in ipairs(l) do
      t[#t + 1] = v
    end
    table.sort(t)
    local n = #t
    if n % 2 == 0 then
      return (t[n / 2] + t[n / 2 + 1]) / 2
    else
      return t[math.ceil(n / 2)]
    end
  end
- |2-
    local t = copy(l)
    table.sort(t)
    local n = #t
    if n == 0 then
      return nil
    elseif n % 2 == 0 then
      return (t[n / 2] + t[n / 2 + 1]) / 2
    else
      return t[(n + 1) / 2]
    end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          table.insert(t, v)
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
    local t = {}
    for _, v in ipairs(l) do
      t[#t + 1] = v
    end
    table.sort(t)
    local n = #t
    if n % 2 == 0 then
      return (t[n / 2] + t[n / 2 + 1]) / 2
    else
      return t[(n + 1) / 2]
    end
  end
- |2-
    local sorted = {}
    for _, v in ipairs(l) do
      table.insert(sorted, v)
    end
    table.sort(sorted)
    local n = #sorted
    if n == 0 then
      return nil
    elseif n % 2 == 0 then
      return (sorted[n / 2] + sorted[n / 2 + 1]) / 2
    else
      return sorted[(n + 1) / 2]
    end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          t[#t + 1] = v
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          table.insert(t, v)
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- "\tlocal t = {}\n\tfor _, v in ipairs(l) do\n\t\ttable.insert(t, v)\n\tend\n\ttable.sort(t)\n\tlocal
  n = #t\n\tif n % 2 == 0 then\n\t\treturn (t[n / 2] + t[n / 2 + 1]) / 2\n\telse\n\t\treturn
  t[(n + 1) / 2]\n\tend\nend"
- |2-
      local t = {}
      for _, v in ipairs(l) do
          table.insert(t, v)
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n / 2] + t[n / 2 + 1]) / 2
      else
          return t[(n + 1) / 2]
      end
  end
- |2-
      local t = {}
      for _, v in ipairs(l) do
          table.insert(t, v)
      end
      table.sort(t)
      local n = #t
      if n % 2 == 0 then
          return (t[n/2] + t[n/2+1]) / 2
      else
          return t[(n+1)/2]
      end
  end
- |2-
    local n = #l
    if n == 0 then return 0 end
    local m = math.floor(n / 2)
    if n % 2 == 0 then
      return (l[m] + l[m + 1]) / 2
    else
      return l[m + 1]
    end
  end
stop_tokens:
- |2-

  local
- |2-

  function
- |2-

  --
- "\n\n"
