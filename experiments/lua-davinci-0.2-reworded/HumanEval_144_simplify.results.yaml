---
name: HumanEval_144_simplify
language: lua
results:
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local x_numerator, x_denominator = x:match("(%d+)/(%d+)")
        local n_numerator, n_denominator = n:match("(%d+)/(%d+)")
        return (x_numerator * n_denominator) % (x_denominator * n_numerator) == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpvyqlan0g.lua:21:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmpvyqlan0g.lua:21: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
        local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
        local result_numerator = x_numerator * n_numerator
        local result_denominator = x_denominator * n_denominator
        return result_numerator % result_denominator == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: |
    .
    Ran 1 tests in 0.000 seconds, 1 success, 0 failures
    OK
  stderr: ''
  exit_code: 0
  status: OK
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
      local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
      local x_numerator, x_denominator = tonumber(x_numerator), tonumber(x_denominator)
      local n_numerator, n_denominator = tonumber(n_numerator), tonumber(n_denominator)
      local result = x_numerator * n_denominator * n_numerator * x_denominator
      return result % 1 == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp06qqk1f6.lua:25:
    expected: false, actual: true\nstack traceback:\n\t/tmp/tmp06qqk1f6.lua:25: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_num, x_den = x:match('(%d+)/(%d+)')
      local n_num, n_den = n:match('(%d+)/(%d+)')
      local num = x_num * n_num
      local den = x_den * n_den
      local gcd = math.gcd(num, den)
      return num / gcd == den / gcd
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpuxtwp4a7.lua:17:
    attempt to call a nil value (field 'gcd')\nstack traceback:\n\t/tmp/tmpuxtwp4a7.lua:17:
    in local 'candidate'\n\t/tmp/tmpuxtwp4a7.lua:24: in function 'test_humaneval'\n\nRan
    1 tests in 0.010 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local x_num, x_den = x:match('(%d+)/(%d+)')
        local n_num, n_den = n:match('(%d+)/(%d+)')
        x_num, x_den = tonumber(x_num), tonumber(x_den)
        n_num, n_den = tonumber(n_num), tonumber(n_den)
        local res_num = x_num * n_num
        local res_den = x_den * n_den
        local res = res_num / res_den
        return res % 1 == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: |
    .
    Ran 1 tests in 0.000 seconds, 1 success, 0 failures
    OK
  stderr: ''
  exit_code: 0
  status: OK
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
      local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
      x_numerator, x_denominator = tonumber(x_numerator), tonumber(x_denominator)
      n_numerator, n_denominator = tonumber(n_numerator), tonumber(n_denominator)
      local result = x_numerator * n_denominator * n_numerator * x_denominator
      return result % 1 == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpmzxx63tn.lua:25:
    expected: false, actual: true\nstack traceback:\n\t/tmp/tmpmzxx63tn.lua:25: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
      local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
      local numerator = x_numerator * n_denominator
      local denominator = x_denominator * n_numerator
      return numerator % denominator == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpe4p_skm2.lua:23:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmpe4p_skm2.lua:23: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
        local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
        local numerator = tonumber(x_numerator) * tonumber(n_denominator)
        local denominator = tonumber(x_denominator) * tonumber(n_numerator)
        if numerator % denominator == 0 then
            return true
        else
            return false
        end
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpcz9jdz1x.lua:27:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmpcz9jdz1x.lua:27: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_num, x_den = x:match('(%d+)/(%d+)')
      local n_num, n_den = n:match('(%d+)/(%d+)')
      local num = tonumber(x_num) * tonumber(n_den)
      local den = tonumber(x_den) * tonumber(n_num)
      return num % den == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmps8ra1dn6.lua:23:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmps8ra1dn6.lua:23: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local function gcd(a, b)
            if b == 0 then
                return a
            else
                return gcd(b, a % b)
            end
        end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: ''
  stderr: 'lua: /tmp/tmpiqjgcsr3.lua:39: ''end'' expected (to close ''function'' at
    line 12) near <eof>

    '
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
      local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
      local numerator = x_numerator * n_denominator
      local denominator = x_denominator * n_numerator
      return numerator % denominator == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp5z1_byh6.lua:23:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmp5z1_byh6.lua:23: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
        local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
        local numerator = x_numerator * n_denominator
        local denominator = x_denominator * n_numerator
        if numerator % denominator == 0 then
            return true
        else
            return false
        end
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2s0gk2jf.lua:27:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmp2s0gk2jf.lua:27: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
        local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
        local result_numerator = x_numerator * n_numerator
        local result_denominator = x_denominator * n_denominator
        local result = result_numerator / result_denominator
        return result % 1 == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: |
    .
    Ran 1 tests in 0.000 seconds, 1 success, 0 failures
    OK
  stderr: ''
  exit_code: 0
  status: OK
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_num, x_den = x:match('(%d+)/(%d+)')
      local n_num, n_den = n:match('(%d+)/(%d+)')
      local num = x_num * n_num
      local den = x_den * n_den
      local gcd = math.gcd(num, den)
      return num / gcd == den / gcd
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpkmwofapa.lua:17:
    attempt to call a nil value (field 'gcd')\nstack traceback:\n\t/tmp/tmpkmwofapa.lua:17:
    in local 'candidate'\n\t/tmp/tmpkmwofapa.lua:24: in function 'test_humaneval'\n\nRan
    1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
        local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
        local numerator = tonumber(x_numerator) * tonumber(n_denominator)
        local denominator = tonumber(x_denominator) * tonumber(n_numerator)
        return numerator % denominator == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpfpacdw3w.lua:23:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmpfpacdw3w.lua:23: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
        local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
        local x_numerator = tonumber(x_numerator)
        local x_denominator = tonumber(x_denominator)
        local n_numerator = tonumber(n_numerator)
        local n_denominator = tonumber(n_denominator)
        local result = x_numerator * n_denominator * n_numerator * x_denominator
        if result % (x_denominator * n_denominator) == 0 then
            return true
        else
            return false
        end
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpm96yy2qf.lua:31:
    expected: false, actual: true\nstack traceback:\n\t/tmp/tmpm96yy2qf.lua:31: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
      local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
      return (x_numerator * n_denominator) % (x_denominator * n_numerator) == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp4diufn3h.lua:21:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmp4diufn3h.lua:21: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
        local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
        local numerator = tonumber(x_numerator) * tonumber(n_denominator)
        local denominator = tonumber(x_denominator) * tonumber(n_numerator)
        return numerator % denominator == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpac6uek4m.lua:23:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmpac6uek4m.lua:23: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
      local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
      local result_numerator = x_numerator * n_numerator
      local result_denominator = x_denominator * n_denominator
      local result = result_numerator / result_denominator
      return result % 1 == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: |
    .
    Ran 1 tests in 0.000 seconds, 1 success, 0 failures
    OK
  stderr: ''
  exit_code: 0
  status: OK
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      -- TODO: Implement me
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp7y90cc4s.lua:19:
    expected: true, actual: nil\nstack traceback:\n\t/tmp/tmp7y90cc4s.lua:19: in function
    'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
        local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
        local numerator = x_numerator * n_denominator
        local denominator = x_denominator * n_numerator
        local gcd = math.gcd(numerator, denominator)
        return numerator / gcd == denominator / gcd
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpaick48tp.lua:17:
    attempt to call a nil value (field 'gcd')\nstack traceback:\n\t/tmp/tmpaick48tp.lua:17:
    in local 'candidate'\n\t/tmp/tmpaick48tp.lua:24: in function 'test_humaneval'\n\nRan
    1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_num, x_den = x:match('(%d+)/(%d+)')
      local n_num, n_den = n:match('(%d+)/(%d+)')
      local num = x_num * n_num
      local den = x_den * n_den
      local gcd = math.gcd(num, den)
      return num / gcd == den / gcd
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpxprprxvf.lua:17:
    attempt to call a nil value (field 'gcd')\nstack traceback:\n\t/tmp/tmpxprprxvf.lua:17:
    in local 'candidate'\n\t/tmp/tmpxprprxvf.lua:24: in function 'test_humaneval'\n\nRan
    1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
      local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
      local result_numerator = x_numerator * n_numerator
      local result_denominator = x_denominator * n_denominator
      local result = result_numerator / result_denominator
      return result % 1 == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: |
    .
    Ran 1 tests in 0.000 seconds, 1 success, 0 failures
    OK
  stderr: ''
  exit_code: 0
  status: OK
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
        local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
        local numerator = tonumber(x_numerator) * tonumber(n_denominator)
        local denominator = tonumber(x_denominator) * tonumber(n_numerator)
        return numerator % denominator == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpmny2tbno.lua:23:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmpmny2tbno.lua:23: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local function gcd(a, b)
        if b == 0 then return a end
        return gcd(b, a % b)
      end
      local function lcm(a, b)
        return a * b / gcd(a, b)
      end
      local function simplify(x)
        local n, d = x:match('(%d+)/(%d+)')
        n, d = tonumber(n), tonumber(d)
        local g = gcd(n, d)
        return n / g, d / g
      end
      local xn, xd = simplify(x)
      local nn, nd = simplify(n)
      local l = lcm(xd, nd)
      return xn * l / xd == nn * l / nd
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpxjjq2o7e.lua:35:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmpxjjq2o7e.lua:35: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
      local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
      local numerator = x_numerator * n_denominator
      local denominator = x_denominator * n_numerator
      return numerator % denominator == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp5w_2637f.lua:23:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmp5w_2637f.lua:23: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local x_num, x_den = x:match('(%d+)/(%d+)')
        local n_num, n_den = n:match('(%d+)/(%d+)')
        local num = x_num * n_num
        local den = x_den * n_den
        local gcd = math.gcd(num, den)
        return num / gcd == den / gcd
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmps9qkv4vp.lua:17:
    attempt to call a nil value (field 'gcd')\nstack traceback:\n\t/tmp/tmps9qkv4vp.lua:17:
    in local 'candidate'\n\t/tmp/tmps9qkv4vp.lua:24: in function 'test_humaneval'\n\nRan
    1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
      local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
      local numerator = x_numerator * n_denominator
      local denominator = x_denominator * n_numerator
      local gcd = math.gcd(numerator, denominator)
      return numerator / gcd == denominator / gcd
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpc5npx3gs.lua:17:
    attempt to call a nil value (field 'gcd')\nstack traceback:\n\t/tmp/tmpc5npx3gs.lua:17:
    in local 'candidate'\n\t/tmp/tmpc5npx3gs.lua:24: in function 'test_humaneval'\n\nRan
    1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
        local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
        local numerator = tonumber(x_numerator) * tonumber(n_denominator)
        local denominator = tonumber(x_denominator) * tonumber(n_numerator)
        return numerator % denominator == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp7byoewut.lua:23:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmp7byoewut.lua:23: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local x_numerator, x_denominator = x:match("(%d+)/(%d+)")
        local n_numerator, n_denominator = n:match("(%d+)/(%d+)")
        local numerator = x_numerator * n_denominator
        local denominator = x_denominator * n_numerator
        local gcd = math.gcd(numerator, denominator)
        return numerator / gcd == denominator / gcd
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpryxzdw39.lua:17:
    attempt to call a nil value (field 'gcd')\nstack traceback:\n\t/tmp/tmpryxzdw39.lua:17:
    in local 'candidate'\n\t/tmp/tmpryxzdw39.lua:24: in function 'test_humaneval'\n\nRan
    1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local x_num, x_den = x:match("(%d+)/(%d+)")
        local n_num, n_den = n:match("(%d+)/(%d+)")
        local num = x_num * n_den
        local den = x_den * n_num
        local gcd = math.gcd(num, den)
        return num / gcd == den / gcd
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpgj49p0iy.lua:17:
    attempt to call a nil value (field 'gcd')\nstack traceback:\n\t/tmp/tmpgj49p0iy.lua:17:
    in local 'candidate'\n\t/tmp/tmpgj49p0iy.lua:24: in function 'test_humaneval'\n\nRan
    1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
      local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
      local result_numerator = x_numerator * n_numerator
      local result_denominator = x_denominator * n_denominator
      return result_numerator % result_denominator == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: |
    .
    Ran 1 tests in 0.000 seconds, 1 success, 0 failures
    OK
  stderr: ''
  exit_code: 0
  status: OK
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
      local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
      local x_numerator, x_denominator = tonumber(x_numerator), tonumber(x_denominator)
      local n_numerator, n_denominator = tonumber(n_numerator), tonumber(n_denominator)
      local result = x_numerator * n_denominator * n_numerator * x_denominator
      return result % 1 == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpuxw8xppt.lua:25:
    expected: false, actual: true\nstack traceback:\n\t/tmp/tmpuxw8xppt.lua:25: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local function gcd(a, b)
        if b == 0 then return a end
        return gcd(b, a % b)
      end
      local function lcm(a, b)
        return a * b / gcd(a, b)
      end
      local function is_whole(x)
        return x % 1 == 0
      end
      local function to_number(x)
        return tonumber(x:match('(%d+)/(%d+)'))
      end
      local x_numerator, x_denominator = to_number(x)
      local n_numerator, n_denominator = to_number(n)
      local lcm_denominator = lcm(x_denominator, n_denominator)
      local x_numerator_lcm = x_numerator * (lcm_denominator / x_denominator)
      local n_numerator_lcm = n_numerator * (lcm_denominator / n_denominator)
      local result = x_numerator_lcm * n_numerator_lcm
      return is_whole(result)
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp3_dovjvc.lua:24:
    bad argument #2 to 'tonumber' (base out of range)\nstack traceback:\n\t/tmp/tmp3_dovjvc.lua:24:
    in local 'to_number'\n\t/tmp/tmp3_dovjvc.lua:27: in local 'candidate'\n\t/tmp/tmp3_dovjvc.lua:38:
    in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_num, x_den = x:match('(%d+)/(%d+)')
      local n_num, n_den = n:match('(%d+)/(%d+)')
      local num = tonumber(x_num) * tonumber(n_den)
      local den = tonumber(x_den) * tonumber(n_num)
      return num % den == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp9djgpwwx.lua:23:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmp9djgpwwx.lua:23: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_num, x_den = x:match('(%d+)/(%d+)')
      local n_num, n_den = n:match('(%d+)/(%d+)')
      local num = x_num * n_num
      local den = x_den * n_den
      local gcd = math.gcd(num, den)
      return den / gcd == num / gcd
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpjbn10tbo.lua:17:
    attempt to call a nil value (field 'gcd')\nstack traceback:\n\t/tmp/tmpjbn10tbo.lua:17:
    in local 'candidate'\n\t/tmp/tmpjbn10tbo.lua:24: in function 'test_humaneval'\n\nRan
    1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
        local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
        local numerator = tonumber(x_numerator) * tonumber(n_denominator)
        local denominator = tonumber(x_denominator) * tonumber(n_numerator)
        return numerator % denominator == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpm5o43b8o.lua:23:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmpm5o43b8o.lua:23: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local xn = x * n
      return xn % 1 == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp9x7jmewx.lua:13:
    attempt to perform arithmetic on a string value (local 'x')\nstack traceback:\n\t/tmp/tmp9x7jmewx.lua:13:
    in local 'candidate'\n\t/tmp/tmp9x7jmewx.lua:20: in function 'test_humaneval'\n\nRan
    1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
        local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
        local numerator = x_numerator * n_denominator
        local denominator = x_denominator * n_numerator
        return numerator % denominator == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp3sm1g8rj.lua:23:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmp3sm1g8rj.lua:23: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local function gcd(a, b)
        while b ~= 0 do
          a, b = b, a % b
        end
        return a
      end
      local function lcm(a, b)
        return a * b / gcd(a, b)
      end
      local function simplify_fraction(x)
        local numerator, denominator = x:match('(%d+)/(%d+)')
        local g = gcd(numerator, denominator)
        return numerator / g, denominator / g
      end
      local x_numerator, x_denominator = simplify_fraction(x)
      local n_numerator, n_denominator = simplify_fraction(n)
      local l = lcm(x_denominator, n_denominator)
      return (x_numerator * l / x_denominator) % (n_numerator * l / n_denominator) == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp909g4yxl.lua:36:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmp909g4yxl.lua:36: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
        local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
        return (x_numerator * n_denominator) % (x_denominator * n_numerator) == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpn4dtgqjt.lua:21:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmpn4dtgqjt.lua:21: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local function gcd(a, b)
            while b ~= 0 do
                local r = a % b
                a = b
                b = r
            end
            return a
        end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: ''
  stderr: 'lua: /tmp/tmpwek8t7c2.lua:40: ''end'' expected (to close ''function'' at
    line 12) near <eof>

    '
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local function gcd(a, b)
        if b == 0 then return a end
        return gcd(b, a % b)
      end
      local function lcm(a, b)
        return a * b / gcd(a, b)
      end
      local function simplify_fraction(x)
        local numerator, denominator = x:match("(%d+)/(%d+)")
        local gcd_ = gcd(numerator, denominator)
        return numerator / gcd_, denominator / gcd_
      end
      local x_numerator, x_denominator = simplify_fraction(x)
      local n_numerator, n_denominator = simplify_fraction(n)
      local lcm_ = lcm(x_denominator, n_denominator)
      return (x_numerator * lcm_ / x_denominator) % (n_numerator * lcm_ / n_denominator) == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmph4bx8nid.lua:34:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmph4bx8nid.lua:34: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
        local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
        x_numerator, x_denominator = tonumber(x_numerator), tonumber(x_denominator)
        n_numerator, n_denominator = tonumber(n_numerator), tonumber(n_denominator)
        local result = x_numerator * n_denominator * n_numerator * x_denominator
        return result % 1 == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpgrmasvot.lua:25:
    expected: false, actual: true\nstack traceback:\n\t/tmp/tmpgrmasvot.lua:25: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_num, x_den = x:match('(%d+)/(%d+)')
      local n_num, n_den = n:match('(%d+)/(%d+)')
      local num = x_num * n_num
      local den = x_den * n_den
      local gcd = math.gcd(num, den)
      return num / gcd == den / gcd
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpfzpq2g6j.lua:17:
    attempt to call a nil value (field 'gcd')\nstack traceback:\n\t/tmp/tmpfzpq2g6j.lua:17:
    in local 'candidate'\n\t/tmp/tmpfzpq2g6j.lua:24: in function 'test_humaneval'\n\nRan
    1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_num, x_den = x:match('(%d+)/(%d+)')
      local n_num, n_den = n:match('(%d+)/(%d+)')
      local num = x_num * n_num
      local den = x_den * n_den
      return num % den == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: |
    .
    Ran 1 tests in 0.000 seconds, 1 success, 0 failures
    OK
  stderr: ''
  exit_code: 0
  status: OK
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
        local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
        local numerator = tonumber(x_numerator) * tonumber(n_denominator)
        local denominator = tonumber(x_denominator) * tonumber(n_numerator)
        return numerator % denominator == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpkfthnslv.lua:23:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmpkfthnslv.lua:23: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
      local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
      local result_numerator = x_numerator * n_numerator
      local result_denominator = x_denominator * n_denominator
      local result = result_numerator / result_denominator
      return result % 1 == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: |
    .
    Ran 1 tests in 0.000 seconds, 1 success, 0 failures
    OK
  stderr: ''
  exit_code: 0
  status: OK
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
      local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
      local numerator = x_numerator * n_denominator
      local denominator = x_denominator * n_numerator
      return numerator % denominator == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpwadq4kuc.lua:23:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmpwadq4kuc.lua:23: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
        local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
        local numerator = x_numerator * n_denominator
        local denominator = x_denominator * n_numerator
        return numerator % denominator == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp7ig_59sc.lua:23:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmp7ig_59sc.lua:23: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
      local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
      local numerator = x_numerator * n_denominator
      local denominator = x_denominator * n_numerator
      return numerator % denominator == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpq90w0mvh.lua:23:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmpq90w0mvh.lua:23: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
      local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
      local numerator = x_numerator * n_denominator
      local denominator = x_denominator * n_numerator
      return numerator % denominator == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpc7oy65vx.lua:23:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmpc7oy65vx.lua:23: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
      local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
      local numerator = x_numerator * n_denominator
      local denominator = x_denominator * n_numerator
      local gcd = math.gcd(numerator, denominator)
      numerator = numerator / gcd
      denominator = denominator / gcd
      return numerator % denominator == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpf9wmd_h3.lua:17:
    attempt to call a nil value (field 'gcd')\nstack traceback:\n\t/tmp/tmpf9wmd_h3.lua:17:
    in local 'candidate'\n\t/tmp/tmpf9wmd_h3.lua:26: in function 'test_humaneval'\n\nRan
    1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
        local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
        local result_numerator = x_numerator * n_numerator
        local result_denominator = x_denominator * n_denominator
        local result = result_numerator / result_denominator
        return result % 1 == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: |
    .
    Ran 1 tests in 0.000 seconds, 1 success, 0 failures
    OK
  stderr: ''
  exit_code: 0
  status: OK
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
      local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
      local x_numerator = tonumber(x_numerator)
      local x_denominator = tonumber(x_denominator)
      local n_numerator = tonumber(n_numerator)
      local n_denominator = tonumber(n_denominator)
      local result = x_numerator * n_denominator * n_numerator * x_denominator
      if result % 1 == 0 then
        return true
      else
        return false
      end
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpn1kaekb1.lua:31:
    expected: false, actual: true\nstack traceback:\n\t/tmp/tmpn1kaekb1.lua:31: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      -- TODO: implement this function
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpudy26n79.lua:19:
    expected: true, actual: nil\nstack traceback:\n\t/tmp/tmpudy26n79.lua:19: in function
    'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
        local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
        return (x_numerator * n_denominator) % (x_denominator * n_numerator) == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpb1xe5rgt.lua:21:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmpb1xe5rgt.lua:21: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_num, x_den = x:match('(%d+)/(%d+)')
      local n_num, n_den = n:match('(%d+)/(%d+)')
      local num = x_num * n_num
      local den = x_den * n_den
      return num % den == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: |
    .
    Ran 1 tests in 0.000 seconds, 1 success, 0 failures
    OK
  stderr: ''
  exit_code: 0
  status: OK
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match("(%d+)/(%d+)")
      local n_numerator, n_denominator = n:match("(%d+)/(%d+)")
      local numerator = x_numerator * n_denominator
      local denominator = x_denominator * n_numerator
      return numerator % denominator == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpsn55vl3i.lua:23:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmpsn55vl3i.lua:23: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local x_num, x_den = x:match('(%d+)/(%d+)')
        local n_num, n_den = n:match('(%d+)/(%d+)')
        local num = x_num * n_num
        local den = x_den * n_den
        local gcd = math.gcd(num, den)
        num = num / gcd
        den = den / gcd
        return num % den == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp8apkcqqd.lua:17:
    attempt to call a nil value (field 'gcd')\nstack traceback:\n\t/tmp/tmp8apkcqqd.lua:17:
    in local 'candidate'\n\t/tmp/tmp8apkcqqd.lua:26: in function 'test_humaneval'\n\nRan
    1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
        local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
        return (x_numerator * n_denominator) % (x_denominator * n_numerator) == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpk5xxms9l.lua:21:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmpk5xxms9l.lua:21: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
      local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
      local numerator = x_numerator * n_denominator
      local denominator = x_denominator * n_numerator
      return numerator % denominator == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp1mxga30v.lua:23:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmp1mxga30v.lua:23: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
      local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
      local numerator = x_numerator * n_denominator
      local denominator = x_denominator * n_numerator
      return numerator % denominator == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnmop6dkf.lua:23:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmpnmop6dkf.lua:23: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_num, x_den = x:match('(%d+)/(%d+)')
      local n_num, n_den = n:match('(%d+)/(%d+)')
      local num = x_num * n_num
      local den = x_den * n_den
      return num % den == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: |
    .
    Ran 1 tests in 0.000 seconds, 1 success, 0 failures
    OK
  stderr: ''
  exit_code: 0
  status: OK
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_num, x_den = x:match('(%d+)/(%d+)')
      local n_num, n_den = n:match('(%d+)/(%d+)')
      local num = x_num * n_num
      local den = x_den * n_den
      local gcd = math.gcd(num, den)
      return num / gcd == den / gcd
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpshrrb81g.lua:17:
    attempt to call a nil value (field 'gcd')\nstack traceback:\n\t/tmp/tmpshrrb81g.lua:17:
    in local 'candidate'\n\t/tmp/tmpshrrb81g.lua:24: in function 'test_humaneval'\n\nRan
    1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
      local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
      local numerator = x_numerator * n_denominator
      local denominator = x_denominator * n_numerator
      return numerator % denominator == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpu90s0pxx.lua:23:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmpu90s0pxx.lua:23: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local function gcd(a, b)
            if b == 0 then
                return a
            else
                return gcd(b, a % b)
            end
        end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: ''
  stderr: 'lua: /tmp/tmpm4_durz0.lua:39: ''end'' expected (to close ''function'' at
    line 12) near <eof>

    '
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
      local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
      local numerator = tonumber(x_numerator) * tonumber(n_denominator)
      local denominator = tonumber(x_denominator) * tonumber(n_numerator)
      return numerator % denominator == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpw9j4y0a1.lua:23:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmpw9j4y0a1.lua:23: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local function gcd(a, b)
        if b == 0 then return a end
        return gcd(b, a % b)
      end
      local function lcm(a, b)
        return a * b / gcd(a, b)
      end
      local function parse(s)
        local n, d = s:match('(%d+)/(%d+)')
        return tonumber(n), tonumber(d)
      end
      local xn, xd = parse(x)
      local nn, nd = parse(n)
      local l = lcm(xd, nd)
      return (xn * l / xd) * (nn * l / nd) % l == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpimypgonm.lua:34:
    expected: false, actual: true\nstack traceback:\n\t/tmp/tmpimypgonm.lua:34: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
      local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
      local result_numerator = x_numerator * n_numerator
      local result_denominator = x_denominator * n_denominator
      local result = result_numerator / result_denominator
      return result % 1 == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: |
    .
    Ran 1 tests in 0.000 seconds, 1 success, 0 failures
    OK
  stderr: ''
  exit_code: 0
  status: OK
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
      local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
      local numerator = x_numerator * n_denominator
      local denominator = x_denominator * n_numerator
      return numerator % denominator == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpxawwy8qn.lua:23:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmpxawwy8qn.lua:23: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_num, x_den = x:match('(%d+)/(%d+)')
      local n_num, n_den = n:match('(%d+)/(%d+)')
      local num = x_num * n_num
      local den = x_den * n_den
      return num % den == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: |
    .
    Ran 1 tests in 0.000 seconds, 1 success, 0 failures
    OK
  stderr: ''
  exit_code: 0
  status: OK
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_num, x_den = x:match('(%d+)/(%d+)')
      local n_num, n_den = n:match('(%d+)/(%d+)')
      local num = x_num * n_num
      local den = x_den * n_den
      local gcd = math.gcd(num, den)
      return num / gcd == den / gcd
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp85bdn4cv.lua:17:
    attempt to call a nil value (field 'gcd')\nstack traceback:\n\t/tmp/tmp85bdn4cv.lua:17:
    in local 'candidate'\n\t/tmp/tmp85bdn4cv.lua:24: in function 'test_humaneval'\n\nRan
    1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_num, x_den = x:match('(%d+)/(%d+)')
      local n_num, n_den = n:match('(%d+)/(%d+)')
      local num = x_num * n_num
      local den = x_den * n_den
      local gcd = math.gcd(num, den)
      num = num / gcd
      den = den / gcd
      return num % den == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp4oug8wkz.lua:17:
    attempt to call a nil value (field 'gcd')\nstack traceback:\n\t/tmp/tmp4oug8wkz.lua:17:
    in local 'candidate'\n\t/tmp/tmp4oug8wkz.lua:26: in function 'test_humaneval'\n\nRan
    1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
      local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
      local numerator = tonumber(x_numerator) * tonumber(n_denominator)
      local denominator = tonumber(x_denominator) * tonumber(n_numerator)
      return numerator % denominator == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmphf33v5zq.lua:23:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmphf33v5zq.lua:23: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local x_num, x_den = x:match('(%d+)/(%d+)')
        local n_num, n_den = n:match('(%d+)/(%d+)')
        local num = x_num * n_num
        local den = x_den * n_den
        return num % den == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: |
    .
    Ran 1 tests in 0.000 seconds, 1 success, 0 failures
    OK
  stderr: ''
  exit_code: 0
  status: OK
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local x_num, x_den = x:match('(%d+)/(%d+)')
        local n_num, n_den = n:match('(%d+)/(%d+)')
        local num = x_num * n_num
        local den = x_den * n_den
        local gcd = math.gcd(num, den)
        return num / gcd == den / gcd
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpjuti20pz.lua:17:
    attempt to call a nil value (field 'gcd')\nstack traceback:\n\t/tmp/tmpjuti20pz.lua:17:
    in local 'candidate'\n\t/tmp/tmpjuti20pz.lua:24: in function 'test_humaneval'\n\nRan
    1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local x_num, x_den = x:match('(%d+)/(%d+)')
        local n_num, n_den = n:match('(%d+)/(%d+)')
        local num = x_num * n_num
        local den = x_den * n_den
        local gcd = math.gcd(num, den)
        return num / gcd == den / gcd
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpglsxp6e2.lua:17:
    attempt to call a nil value (field 'gcd')\nstack traceback:\n\t/tmp/tmpglsxp6e2.lua:17:
    in local 'candidate'\n\t/tmp/tmpglsxp6e2.lua:24: in function 'test_humaneval'\n\nRan
    1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
        local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
        local numerator = x_numerator * n_denominator
        local denominator = x_denominator * n_numerator
        local gcd = math.gcd(numerator, denominator)
        numerator = numerator / gcd
        denominator = denominator / gcd
        return numerator % denominator == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp1im8jvor.lua:17:
    attempt to call a nil value (field 'gcd')\nstack traceback:\n\t/tmp/tmp1im8jvor.lua:17:
    in local 'candidate'\n\t/tmp/tmp1im8jvor.lua:26: in function 'test_humaneval'\n\nRan
    1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
        local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
        return (x_numerator * n_denominator) % (x_denominator * n_numerator) == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpag3g7m6o.lua:21:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmpag3g7m6o.lua:21: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_num, x_den = x:match('(%d+)/(%d+)')
      local n_num, n_den = n:match('(%d+)/(%d+)')
      local num = x_num * n_num
      local den = x_den * n_den
      return num % den == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: |
    .
    Ran 1 tests in 0.000 seconds, 1 success, 0 failures
    OK
  stderr: ''
  exit_code: 0
  status: OK
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local xn = x * n
      return xn == math.floor(xn)
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpa3j14k65.lua:13:
    attempt to perform arithmetic on a string value (local 'x')\nstack traceback:\n\t/tmp/tmpa3j14k65.lua:13:
    in local 'candidate'\n\t/tmp/tmpa3j14k65.lua:20: in function 'test_humaneval'\n\nRan
    1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local function gcd(a, b)
            if b == 0 then
                return a
            else
                return gcd(b, a % b)
            end
        end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: ''
  stderr: 'lua: /tmp/tmpwksjcb3r.lua:39: ''end'' expected (to close ''function'' at
    line 12) near <eof>

    '
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
      local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
      local numerator = tonumber(x_numerator) * tonumber(n_denominator)
      local denominator = tonumber(x_denominator) * tonumber(n_numerator)
      return numerator % denominator == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpfant_fgb.lua:23:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmpfant_fgb.lua:23: in
    function 'test_humaneval'\n\nRan 1 tests in 0.010 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local function gcd(a, b)
        if b == 0 then return a end
        return gcd(b, a % b)
      end
      local function lcm(a, b)
        return (a * b) / gcd(a, b)
      end
      local function simplify_fraction(x)
        local numerator, denominator = x:match("(%d+)/(%d+)")
        local g = gcd(numerator, denominator)
        return numerator / g, denominator / g
      end
      local x_numerator, x_denominator = simplify_fraction(x)
      local n_numerator, n_denominator = simplify_fraction(n)
      local l = lcm(x_denominator, n_denominator)
      return (x_numerator * (l / x_denominator)) % (n_numerator * (l / n_denominator)) == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpgojv84ck.lua:34:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmpgojv84ck.lua:34: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
        local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
        local numerator = x_numerator * n_denominator
        local denominator = x_denominator * n_numerator
        return numerator % denominator == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpxlaa22uc.lua:23:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmpxlaa22uc.lua:23: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local x_num, x_den = x:match('(%d+)/(%d+)')
        local n_num, n_den = n:match('(%d+)/(%d+)')
        local num = x_num * n_num
        local den = x_den * n_den
        local gcd = math.gcd(num, den)
        num = num / gcd
        den = den / gcd
        return num % den == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpgu1r9bsd.lua:17:
    attempt to call a nil value (field 'gcd')\nstack traceback:\n\t/tmp/tmpgu1r9bsd.lua:17:
    in local 'candidate'\n\t/tmp/tmpgu1r9bsd.lua:26: in function 'test_humaneval'\n\nRan
    1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_num, x_den = x:match('(%d+)/(%d+)')
      local n_num, n_den = n:match('(%d+)/(%d+)')
      local num = x_num * n_num
      local den = x_den * n_den
      return num % den == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: |
    .
    Ran 1 tests in 0.000 seconds, 1 success, 0 failures
    OK
  stderr: ''
  exit_code: 0
  status: OK
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local function gcd(a, b)
        if b == 0 then return a end
        return gcd(b, a % b)
      end
      local function lcm(a, b)
        return a * b / gcd(a, b)
      end
      local function parse(x)
        local numerator, denominator = x:match('(%d+)/(%d+)')
        return tonumber(numerator), tonumber(denominator)
      end
      local xn, xd = parse(x)
      local nn, nd = parse(n)
      local l = lcm(xd, nd)
      return (xn * l / xd) % (nn * l / nd) == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp0mv8yi10.lua:33:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmp0mv8yi10.lua:33: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
      local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
      local numerator = x_numerator * n_denominator
      local denominator = x_denominator * n_numerator
      return numerator % denominator == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmplij8o0z0.lua:23:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmplij8o0z0.lua:23: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local function gcd(a, b)
        while b ~= 0 do
          a, b = b, a % b
        end
        return a
      end
      local function lcm(a, b)
        return a * b / gcd(a, b)
      end
      local function simplify(x)
        local numerator, denominator = x:match('(%d+)/(%d+)')
        local g = gcd(numerator, denominator)
        return numerator / g, denominator / g
      end
      local xn, xd = simplify(x)
      local nn, nd = simplify(n)
      local l = lcm(xd, nd)
      return l % (xn * nn) == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpzlxnv242.lua:37:
    expected: false, actual: true\nstack traceback:\n\t/tmp/tmpzlxnv242.lua:37: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
      local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
      local x_numerator, x_denominator = tonumber(x_numerator), tonumber(x_denominator)
      local n_numerator, n_denominator = tonumber(n_numerator), tonumber(n_denominator)
      local result = x_numerator * n_denominator * n_numerator * x_denominator
      return result % 1 == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpm__twfn4.lua:25:
    expected: false, actual: true\nstack traceback:\n\t/tmp/tmpm__twfn4.lua:25: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
      local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
      local result_numerator = x_numerator * n_numerator
      local result_denominator = x_denominator * n_denominator
      return result_numerator % result_denominator == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: |
    .
    Ran 1 tests in 0.000 seconds, 1 success, 0 failures
    OK
  stderr: ''
  exit_code: 0
  status: OK
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
      local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
      local numerator = tonumber(x_numerator) * tonumber(n_denominator)
      local denominator = tonumber(x_denominator) * tonumber(n_numerator)
      return numerator % denominator == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmptpjs1mtu.lua:23:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmptpjs1mtu.lua:23: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
      local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
      local numerator = tonumber(x_numerator) * tonumber(n_denominator)
      local denominator = tonumber(x_denominator) * tonumber(n_numerator)
      return numerator % denominator == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp44bke7c0.lua:23:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmp44bke7c0.lua:23: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local x_numerator, x_denominator = x:match("(%d+)/(%d+)")
        local n_numerator, n_denominator = n:match("(%d+)/(%d+)")
        local numerator = x_numerator * n_denominator
        local denominator = x_denominator * n_numerator
        return numerator % denominator == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpcugwt1a4.lua:23:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmpcugwt1a4.lua:23: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      -- your code here
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpj9ogi3yn.lua:19:
    expected: true, actual: nil\nstack traceback:\n\t/tmp/tmpj9ogi3yn.lua:19: in function
    'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local function gcd(a, b)
        if b == 0 then return a end
        return gcd(b, a % b)
      end
      local function lcm(a, b)
        return (a * b) / gcd(a, b)
      end
      local function simplify(x)
        local numerator, denominator = x:match('(%d+)/(%d+)')
        local g = gcd(numerator, denominator)
        return numerator / g, denominator / g
      end
      local xn, xd = simplify(x)
      local nn, nd = simplify(n)
      local l = lcm(xd, nd)
      return (l / xd) * xn == (l / nd) * nn
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpqsebqmcu.lua:34:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmpqsebqmcu.lua:34: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local function gcd(a, b)
            if b == 0 then
                return a
            else
                return gcd(b, a % b)
            end
        end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: ''
  stderr: 'lua: /tmp/tmpjnlwmxxr.lua:39: ''end'' expected (to close ''function'' at
    line 12) near <eof>

    '
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
        local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
        local result_numerator = x_numerator * n_numerator
        local result_denominator = x_denominator * n_denominator
        return result_numerator % result_denominator == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: |
    .
    Ran 1 tests in 0.000 seconds, 1 success, 0 failures
    OK
  stderr: ''
  exit_code: 0
  status: OK
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local function gcd(a, b)
            if b == 0 then
                return a
            else
                return gcd(b, a % b)
            end
        end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: ''
  stderr: 'lua: /tmp/tmp67dc_5nr.lua:39: ''end'' expected (to close ''function'' at
    line 12) near <eof>

    '
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local function gcd(a, b)
            if b == 0 then
                return a
            else
                return gcd(b, a % b)
            end
        end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: ''
  stderr: 'lua: /tmp/tmp8crq0gmd.lua:39: ''end'' expected (to close ''function'' at
    line 12) near <eof>

    '
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
        local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
        return (x_numerator * n_denominator) % (x_denominator * n_numerator) == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpa_1d_xsi.lua:21:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmpa_1d_xsi.lua:21: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
      local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
      local x_numerator, x_denominator = tonumber(x_numerator), tonumber(x_denominator)
      local n_numerator, n_denominator = tonumber(n_numerator), tonumber(n_denominator)
      local result = x_numerator * n_denominator * n_numerator * x_denominator
      return result % 1 == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpmn_hsdu2.lua:25:
    expected: false, actual: true\nstack traceback:\n\t/tmp/tmpmn_hsdu2.lua:25: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
      local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
      local result_numerator = x_numerator * n_numerator
      local result_denominator = x_denominator * n_denominator
      local result = result_numerator / result_denominator
      return result % 1 == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: |
    .
    Ran 1 tests in 0.000 seconds, 1 success, 0 failures
    OK
  stderr: ''
  exit_code: 0
  status: OK
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_num, x_den = x:match('(%d+)/(%d+)')
      local n_num, n_den = n:match('(%d+)/(%d+)')
      local num = x_num * n_num
      local den = x_den * n_den
      local gcd = math.gcd(num, den)
      return num / gcd == den / gcd
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpbi536hzw.lua:17:
    attempt to call a nil value (field 'gcd')\nstack traceback:\n\t/tmp/tmpbi536hzw.lua:17:
    in local 'candidate'\n\t/tmp/tmpbi536hzw.lua:24: in function 'test_humaneval'\n\nRan
    1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local function gcd(a, b)
        if b == 0 then return a end
        return gcd(b, a % b)
      end
      local function lcm(a, b)
        return a * b / gcd(a, b)
      end
      local function simplify_fraction(x)
        local numerator, denominator = x:match("(%d+)/(%d+)")
        local gcd_ = gcd(numerator, denominator)
        return numerator / gcd_, denominator / gcd_
      end
      local x_numerator, x_denominator = simplify_fraction(x)
      local n_numerator, n_denominator = simplify_fraction(n)
      local lcm_ = lcm(x_denominator, n_denominator)
      return (lcm_ / x_denominator) * x_numerator == (lcm_ / n_denominator) * n_numerator
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmptprbramu.lua:34:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmptprbramu.lua:34: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
      local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
      local x_numerator, x_denominator = tonumber(x_numerator), tonumber(x_denominator)
      local n_numerator, n_denominator = tonumber(n_numerator), tonumber(n_denominator)
      local x_numerator, x_denominator = x_numerator * n_denominator, x_denominator * n_numerator
      local gcd = math.gcd(x_numerator, x_denominator)
      x_numerator, x_denominator = x_numerator / gcd, x_denominator / gcd
      return x_numerator % x_denominator == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmprm1tgbsg.lua:18:
    attempt to call a nil value (field 'gcd')\nstack traceback:\n\t/tmp/tmprm1tgbsg.lua:18:
    in local 'candidate'\n\t/tmp/tmprm1tgbsg.lua:26: in function 'test_humaneval'\n\nRan
    1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_num, x_den = x:match('(%d+)/(%d+)')
      local n_num, n_den = n:match('(%d+)/(%d+)')
      local num = x_num * n_num
      local den = x_den * n_den
      local gcd = math.gcd(num, den)
      num = num / gcd
      den = den / gcd
      return num % den == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp3b36hthq.lua:17:
    attempt to call a nil value (field 'gcd')\nstack traceback:\n\t/tmp/tmp3b36hthq.lua:17:
    in local 'candidate'\n\t/tmp/tmp3b36hthq.lua:26: in function 'test_humaneval'\n\nRan
    1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
      local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
      local result_numerator = x_numerator * n_numerator
      local result_denominator = x_denominator * n_denominator
      local result = result_numerator / result_denominator
      return result % 1 == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: |
    .
    Ran 1 tests in 0.000 seconds, 1 success, 0 failures
    OK
  stderr: ''
  exit_code: 0
  status: OK
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local function gcd(a, b)
        if b == 0 then return a end
        return gcd(b, a % b)
      end
      local function lcm(a, b)
        return a * b / gcd(a, b)
      end
      local function parse(s)
        local n, d = s:match('(%d+)/(%d+)')
        return tonumber(n), tonumber(d)
      end
      local xn, xd = parse(x)
      local nn, nd = parse(n)
      return lcm(xd, nd) % (xn * nn) == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp5wzc2zhk.lua:33:
    expected: false, actual: true\nstack traceback:\n\t/tmp/tmp5wzc2zhk.lua:33: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
        local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
        local numerator = x_numerator * n_denominator
        local denominator = x_denominator * n_numerator
        return numerator % denominator == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp70dhekj9.lua:23:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmp70dhekj9.lua:23: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
        local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
        return (x_numerator * n_denominator) % (x_denominator * n_numerator) == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpgt746i34.lua:21:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmpgt746i34.lua:21: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_num, x_den = x:match('(%d+)/(%d+)')
      local n_num, n_den = n:match('(%d+)/(%d+)')
      local num = x_num * n_num
      local den = x_den * n_den
      return num % den == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: |
    .
    Ran 1 tests in 0.000 seconds, 1 success, 0 failures
    OK
  stderr: ''
  exit_code: 0
  status: OK
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local x_num, x_den = x:match('(%d+)/(%d+)')
        local n_num, n_den = n:match('(%d+)/(%d+)')
        local num = x_num * n_num
        local den = x_den * n_den
        return num % den == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: |
    .
    Ran 1 tests in 0.000 seconds, 1 success, 0 failures
    OK
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Your task is to implement a function that will simplify the expression\n--
    x * n. The function returns true if x * n evaluates to a whole number and false\n--
    otherwise. Both x and n, are string representation of a fraction, and have the
    following format,\n-- <numerator>/<denominator> where both numerator and denominator
    are positive whole numbers.\n-- You can assume that x, and n are valid fractions,
    and do not have zero as denominator.\n-- >>> simplify('1/5', '5/1')\n-- true\n--
    >>> simplify('1/6', '2/1')\n-- false\n-- >>> simplify('7/10', '10/2')\n-- false\nlocal
    function simplify(x, n)\n  local function gcd(a, b)\n    if b == 0 then return
    a end\n    return gcd(b, a % b)\n  end\n  local function lcm(a, b)\n    return
    a * b / gcd(a, b)\n  end\n  local function to_number(x)\n    local numerator,
    denominator = x:match('(%d+)/(%d+)')\n    return tonumber(numerator) / tonumber(denominator)\n
    \ end\n  local function to_fraction(x)\n    local numerator, denominator = x:match('(%d+)/(%d+)')\n
    \   local g = gcd(numerator, denominator)\n    return string.format('%d/%d', numerator
    / g, denominator / g)\n  end\n  local function is_integer(x)\n    return x % 1
    == 0\n  end\n  local function multiply(x, n)\n    local numerator, denominator
    = x:match('(%d+)/(%d+)')\n    local numerator_n, denominator_n = n:match('(%d+)/(%d+)')\n
    \   return string.format('%d/%d', numerator * numerator_n, denominator * denominator_n)\n
    \ end\n  local function divide(x, n)\n    local numerator, denominator = x:match('(%d+)/(%d+)')\n
    \   local numerator_n, denominator_n = n:match('(%d+)/(%d+)')\n    return string.format('%d/%d',
    numerator * denominator_n, denominator * numerator_n)\n  end\n  local function
    add(x, n)\n    local numerator, denominator = x:match('(%d+)/(%d+)')\n    local
    numerator_n, denominator_n = n:match('(%d+)/(%d+)')\n    local l = lcm(denominator,
    denominator_n)\n    return string.format('%d/%d', numerator * l / denominator
    + numerator_n * l / denominator_n, l)\n \nlu = require('luaunit')\n\nfunction
    test_humaneval()\nlocal candidate = simplify\n    lu.assertEquals(candidate('1/5',
    '5/1'), true)\n    lu.assertEquals(candidate('1/6', '2/1'), false)\n    lu.assertEquals(candidate('5/1',
    '3/1'), true)\n    lu.assertEquals(candidate('7/10', '10/2'), false)\n    lu.assertEquals(candidate('2/10',
    '50/10'), true)\n    lu.assertEquals(candidate('7/2', '4/2'), true)\n    lu.assertEquals(candidate('11/6',
    '6/1'), true)\n    lu.assertEquals(candidate('2/3', '5/2'), false)\n    lu.assertEquals(candidate('5/2',
    '3/5'), false)\n    lu.assertEquals(candidate('2/4', '8/4'), true)\n    lu.assertEquals(candidate('2/4',
    '4/2'), true)\n    lu.assertEquals(candidate('1/5', '5/1'), true)\n    lu.assertEquals(candidate('1/5',
    '1/5'), false)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: 'lua: /tmp/tmp0igso1a5.lua:48: ''end'' expected (to close ''function'' at
    line 42) near ''lu''

    '
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      -- your code here
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpje_gk7vl.lua:19:
    expected: true, actual: nil\nstack traceback:\n\t/tmp/tmpje_gk7vl.lua:19: in function
    'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      -- your code here
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp8z9kbm7i.lua:19:
    expected: true, actual: nil\nstack traceback:\n\t/tmp/tmp8z9kbm7i.lua:19: in function
    'test_humaneval'\n\nRan 1 tests in 0.010 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
      local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
      local result_numerator = x_numerator * n_numerator
      local result_denominator = x_denominator * n_denominator
      local result = result_numerator / result_denominator
      return result % 1 == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: |
    .
    Ran 1 tests in 0.000 seconds, 1 success, 0 failures
    OK
  stderr: ''
  exit_code: 0
  status: OK
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match("(%d+)/(%d+)")
      local n_numerator, n_denominator = n:match("(%d+)/(%d+)")
      local x_numerator, x_denominator = tonumber(x_numerator), tonumber(x_denominator)
      local n_numerator, n_denominator = tonumber(n_numerator), tonumber(n_denominator)
      local x_numerator = x_numerator * n_denominator
      local x_denominator = x_denominator * n_numerator
      local x_numerator, x_denominator = math.floor(x_numerator), math.floor(x_denominator)
      return x_numerator % x_denominator == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpte8pxb5e.lua:26:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmpte8pxb5e.lua:26: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
      local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
      local numerator = tonumber(x_numerator) * tonumber(n_denominator)
      local denominator = tonumber(x_denominator) * tonumber(n_numerator)
      return numerator % denominator == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp6ujss02c.lua:23:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmp6ujss02c.lua:23: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
        local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
        local result_numerator = x_numerator * n_numerator
        local result_denominator = x_denominator * n_denominator
        local result = result_numerator / result_denominator
        return result % 1 == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: |
    .
    Ran 1 tests in 0.000 seconds, 1 success, 0 failures
    OK
  stderr: ''
  exit_code: 0
  status: OK
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
      local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
      local numerator = x_numerator * n_denominator
      local denominator = x_denominator * n_numerator
      local gcd = math.gcd(numerator, denominator)
      numerator = numerator / gcd
      denominator = denominator / gcd
      return numerator % denominator == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmphzwcu6oh.lua:17:
    attempt to call a nil value (field 'gcd')\nstack traceback:\n\t/tmp/tmphzwcu6oh.lua:17:
    in local 'candidate'\n\t/tmp/tmphzwcu6oh.lua:26: in function 'test_humaneval'\n\nRan
    1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local function gcd(a, b)
        if b == 0 then return a end
        return gcd(b, a % b)
      end
      local function lcm(a, b)
        return a * b / gcd(a, b)
      end
      local function simplify_fraction(x)
        local numerator, denominator = x:match('(%d+)/(%d+)')
        numerator, denominator = tonumber(numerator), tonumber(denominator)
        local g = gcd(numerator, denominator)
        return numerator / g, denominator / g
      end
      local x_numerator, x_denominator = simplify_fraction(x)
      local n_numerator, n_denominator = simplify_fraction(n)
      local l = lcm(x_denominator, n_denominator)
      return l % (x_numerator * n_numerator) == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp02zc49g0.lua:36:
    expected: false, actual: true\nstack traceback:\n\t/tmp/tmp02zc49g0.lua:36: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local function gcd(a, b)
            if b == 0 then
                return a
            else
                return gcd(b, a % b)
            end
        end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: ''
  stderr: 'lua: /tmp/tmprefy5_5g.lua:39: ''end'' expected (to close ''function'' at
    line 12) near <eof>

    '
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_num, x_den = x:match('(%d+)/(%d+)')
      local n_num, n_den = n:match('(%d+)/(%d+)')
      x_num, x_den = tonumber(x_num), tonumber(x_den)
      n_num, n_den = tonumber(n_num), tonumber(n_den)
      local num = x_num * n_num
      local den = x_den * n_den
      local gcd = math.gcd(num, den)
      num = num / gcd
      den = den / gcd
      return num % den == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp13kxkkj0.lua:19:
    attempt to call a nil value (field 'gcd')\nstack traceback:\n\t/tmp/tmp13kxkkj0.lua:19:
    in local 'candidate'\n\t/tmp/tmp13kxkkj0.lua:28: in function 'test_humaneval'\n\nRan
    1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local function gcd(a, b)
        if b == 0 then return a end
        return gcd(b, a % b)
      end
      local function lcm(a, b)
        return a * b / gcd(a, b)
      end
      local function to_num(x)
        local num, den = x:match('(%d+)/(%d+)')
        return tonumber(num), tonumber(den)
      end
      local x_num, x_den = to_num(x)
      local n_num, n_den = to_num(n)
      local l = lcm(x_den, n_den)
      return (x_num * l / x_den) % (n_num * l / n_den) == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpma3gvci8.lua:33:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmpma3gvci8.lua:33: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      -- TODO: Implement me
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpy4rlc8is.lua:19:
    expected: true, actual: nil\nstack traceback:\n\t/tmp/tmpy4rlc8is.lua:19: in function
    'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_num, x_den = x:match('(%d+)/(%d+)')
      local n_num, n_den = n:match('(%d+)/(%d+)')
      local num = x_num * n_num
      local den = x_den * n_den
      return num % den == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: |
    .
    Ran 1 tests in 0.000 seconds, 1 success, 0 failures
    OK
  stderr: ''
  exit_code: 0
  status: OK
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
      local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
      local result_numerator = x_numerator * n_numerator
      local result_denominator = x_denominator * n_denominator
      local result = result_numerator / result_denominator
      return result % 1 == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: |
    .
    Ran 1 tests in 0.000 seconds, 1 success, 0 failures
    OK
  stderr: ''
  exit_code: 0
  status: OK
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_num, x_den = x:match('(%d+)/(%d+)')
      local n_num, n_den = n:match('(%d+)/(%d+)')
      local num = x_num * n_num
      local den = x_den * n_den
      local gcd = math.gcd(num, den)
      return num / gcd == den / gcd
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpya9envnp.lua:17:
    attempt to call a nil value (field 'gcd')\nstack traceback:\n\t/tmp/tmpya9envnp.lua:17:
    in local 'candidate'\n\t/tmp/tmpya9envnp.lua:24: in function 'test_humaneval'\n\nRan
    1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
        local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
        local numerator = x_numerator * n_denominator
        local denominator = x_denominator * n_numerator
        local gcd = math.gcd(numerator, denominator)
        numerator = numerator / gcd
        denominator = denominator / gcd
        return numerator % denominator == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp1pchy70i.lua:17:
    attempt to call a nil value (field 'gcd')\nstack traceback:\n\t/tmp/tmp1pchy70i.lua:17:
    in local 'candidate'\n\t/tmp/tmp1pchy70i.lua:26: in function 'test_humaneval'\n\nRan
    1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
        local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
        local numerator = x_numerator * n_denominator
        local denominator = x_denominator * n_numerator
        return numerator % denominator == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmphxky8il3.lua:23:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmphxky8il3.lua:23: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
      local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
      return (x_numerator * n_denominator) % (x_denominator * n_numerator) == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp6myl2ru6.lua:21:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmp6myl2ru6.lua:21: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local function gcd(a, b)
        if b == 0 then return a end
        return gcd(b, a % b)
      end
      local function lcm(a, b)
        return a * b / gcd(a, b)
      end
      local function is_whole(x)
        return x % 1 == 0
      end
      local function to_num(x)
        return tonumber(x)
      end
      local function to_str(x)
        return tostring(x)
      end
      local function to_frac(x)
        local num, den = x:match('(%d+)/(%d+)')
        return to_num(num), to_num(den)
      end
      local function to_str_frac(x)
        local num, den = x:match('(%d+)/(%d+)')
        return to_str(num), to_str(den)
      end
      local function mul(x, n)
        local x_num, x_den = to_frac(x)
        local n_num, n_den = to_frac(n)
        local num = x_num * n_num
        local den = x_den * n_den
        return to_str(num) .. '/' .. to_str(den)
      end
      local function simplify_frac(x)
        local num, den = to_frac(x)
        local g = gcd(num, den)
        return to_str(num / g) .. '/' .. to_str(den / g)
      end
      local function is_simplified(x)
        local num, den = to_frac(x)
        return num == 1 or den == 1
      end
      local function is_whole_frac(x)
        local num, den = to_frac(x)
        return is_whole(num / den)
      end
      local function is_whole_mul(x, n)
        local x_num, x_den = to_frac(x)
        local n_num, n_den = to_frac(n)
        local l
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: ''
  stderr: 'lua: /tmp/tmpb2bmhe4h.lua:80: ''end'' expected (to close ''function'' at
    line 57) near <eof>

    '
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_num, x_den = x:match('(%d+)/(%d+)')
      local n_num, n_den = n:match('(%d+)/(%d+)')
      local num = x_num * n_num
      local den = x_den * n_den
      return num % den == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: |
    .
    Ran 1 tests in 0.000 seconds, 1 success, 0 failures
    OK
  stderr: ''
  exit_code: 0
  status: OK
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
        local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
        local result_numerator = x_numerator * n_numerator
        local result_denominator = x_denominator * n_denominator
        local result = result_numerator / result_denominator
        return result % 1 == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: |
    .
    Ran 1 tests in 0.000 seconds, 1 success, 0 failures
    OK
  stderr: ''
  exit_code: 0
  status: OK
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
        local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
        local numerator = tonumber(x_numerator) * tonumber(n_denominator)
        local denominator = tonumber(x_denominator) * tonumber(n_numerator)
        return numerator % denominator == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpctv2zd50.lua:23:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmpctv2zd50.lua:23: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
      local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
      local numerator = tonumber(x_numerator) * tonumber(n_denominator)
      local denominator = tonumber(x_denominator) * tonumber(n_numerator)
      return numerator % denominator == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpixbewuy0.lua:23:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmpixbewuy0.lua:23: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local function gcd(a, b)
            if b == 0 then
                return a
            else
                return gcd(b, a % b)
            end
        end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: ''
  stderr: 'lua: /tmp/tmp68_1sb4g.lua:39: ''end'' expected (to close ''function'' at
    line 12) near <eof>

    '
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
      local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
      local x_numerator, x_denominator = tonumber(x_numerator), tonumber(x_denominator)
      local n_numerator, n_denominator = tonumber(n_numerator), tonumber(n_denominator)
      local numerator = x_numerator * n_numerator
      local denominator = x_denominator * n_denominator
      local gcd = math.gcd(numerator, denominator)
      numerator = numerator / gcd
      denominator = denominator / gcd
      return numerator % denominator == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpklz9inyv.lua:19:
    attempt to call a nil value (field 'gcd')\nstack traceback:\n\t/tmp/tmpklz9inyv.lua:19:
    in local 'candidate'\n\t/tmp/tmpklz9inyv.lua:28: in function 'test_humaneval'\n\nRan
    1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
        local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
        local numerator = x_numerator * n_denominator
        local denominator = x_denominator * n_numerator
        return numerator % denominator == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpxmk7n2ct.lua:23:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmpxmk7n2ct.lua:23: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local x_num, x_den = x:match('(%d+)/(%d+)')
        local n_num, n_den = n:match('(%d+)/(%d+)')
        local num = x_num * n_num
        local den = x_den * n_den
        local gcd = math.gcd(num, den)
        return num / gcd == den / gcd
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpdcba35qn.lua:17:
    attempt to call a nil value (field 'gcd')\nstack traceback:\n\t/tmp/tmpdcba35qn.lua:17:
    in local 'candidate'\n\t/tmp/tmpdcba35qn.lua:24: in function 'test_humaneval'\n\nRan
    1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_num, x_den = x:match('(%d+)/(%d+)')
      local n_num, n_den = n:match('(%d+)/(%d+)')
      local num = x_num * n_num
      local den = x_den * n_den
      local gcd = math.gcd(num, den)
      num = num / gcd
      den = den / gcd
      return num % den == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpb4q6eidj.lua:17:
    attempt to call a nil value (field 'gcd')\nstack traceback:\n\t/tmp/tmpb4q6eidj.lua:17:
    in local 'candidate'\n\t/tmp/tmpb4q6eidj.lua:26: in function 'test_humaneval'\n\nRan
    1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_num, x_den = x:match('(%d+)/(%d+)')
      local n_num, n_den = n:match('(%d+)/(%d+)')
      local num = x_num * n_num
      local den = x_den * n_den
      return num % den == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: |
    .
    Ran 1 tests in 0.000 seconds, 1 success, 0 failures
    OK
  stderr: ''
  exit_code: 0
  status: OK
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local function gcd(a, b)
        if b == 0 then return a end
        return gcd(b, a % b)
      end
      local function lcm(a, b)
        return a * b / gcd(a, b)
      end
      local function simplify_fraction(x)
        local numerator, denominator = x:match('(%d+)/(%d+)')
        numerator, denominator = tonumber(numerator), tonumber(denominator)
        local g = gcd(numerator, denominator)
        return numerator / g, denominator / g
      end
      local x_numerator, x_denominator = simplify_fraction(x)
      local n_numerator, n_denominator = simplify_fraction(n)
      local l = lcm(x_denominator, n_denominator)
      return (x_numerator * l / x_denominator) % (n_numerator * l / n_denominator) == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp9nw401pc.lua:35:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmp9nw401pc.lua:35: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local x_num, x_den = x:match("(%d+)/(%d+)")
        local n_num, n_den = n:match("(%d+)/(%d+)")
        local x_num, x_den = tonumber(x_num), tonumber(x_den)
        local n_num, n_den = tonumber(n_num), tonumber(n_den)
        local num = x_num * n_num
        local den = x_den * n_den
        local gcd = math.gcd(num, den)
        num = num / gcd
        den = den / gcd
        return num % den == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpe4dzu5a3.lua:19:
    attempt to call a nil value (field 'gcd')\nstack traceback:\n\t/tmp/tmpe4dzu5a3.lua:19:
    in local 'candidate'\n\t/tmp/tmpe4dzu5a3.lua:28: in function 'test_humaneval'\n\nRan
    1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local x_num, x_den = x:match('(%d+)/(%d+)')
        local n_num, n_den = n:match('(%d+)/(%d+)')
        local num = x_num * n_num
        local den = x_den * n_den
        local gcd = math.gcd(num, den)
        return gcd == den
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp1fvf5ups.lua:17:
    attempt to call a nil value (field 'gcd')\nstack traceback:\n\t/tmp/tmp1fvf5ups.lua:17:
    in local 'candidate'\n\t/tmp/tmp1fvf5ups.lua:24: in function 'test_humaneval'\n\nRan
    1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local xn = x * n
      return xn % 1 == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpyn_i596p.lua:13:
    attempt to perform arithmetic on a string value (local 'x')\nstack traceback:\n\t/tmp/tmpyn_i596p.lua:13:
    in local 'candidate'\n\t/tmp/tmpyn_i596p.lua:20: in function 'test_humaneval'\n\nRan
    1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_num, x_den = x:match('(%d+)/(%d+)')
      local n_num, n_den = n:match('(%d+)/(%d+)')
      local num = x_num * n_num
      local den = x_den * n_den
      local gcd = math.gcd(num, den)
      return den / gcd == num / gcd
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpqj9e9ste.lua:17:
    attempt to call a nil value (field 'gcd')\nstack traceback:\n\t/tmp/tmpqj9e9ste.lua:17:
    in local 'candidate'\n\t/tmp/tmpqj9e9ste.lua:24: in function 'test_humaneval'\n\nRan
    1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
      local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
      return (x_numerator * n_denominator) % (x_denominator * n_numerator) == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpjsy3ipyl.lua:21:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmpjsy3ipyl.lua:21: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
      local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
      local x_numerator = tonumber(x_numerator)
      local x_denominator = tonumber(x_denominator)
      local n_numerator = tonumber(n_numerator)
      local n_denominator = tonumber(n_denominator)
      local result = x_numerator * n_denominator
      local result_denominator = x_denominator * n_numerator
      if result % result_denominator == 0 then
        return true
      else
        return false
      end
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp7zqg1wpd.lua:31:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmp7zqg1wpd.lua:31: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_num, x_den = x:match('(%d+)/(%d+)')
      local n_num, n_den = n:match('(%d+)/(%d+)')
      local num = x_num * n_num
      local den = x_den * n_den
      return num % den == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: |
    .
    Ran 1 tests in 0.000 seconds, 1 success, 0 failures
    OK
  stderr: ''
  exit_code: 0
  status: OK
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
        local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
        local x_numerator = tonumber(x_numerator)
        local x_denominator = tonumber(x_denominator)
        local n_numerator = tonumber(n_numerator)
        local n_denominator = tonumber(n_denominator)
        local numerator = x_numerator * n_denominator
        local denominator = x_denominator * n_numerator
        local result = numerator / denominator
        if result % 1 == 0 then
            return true
        else
            return false
        end
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmprpzqj1hv.lua:32:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmprpzqj1hv.lua:32: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
      local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
      local numerator = x_numerator * n_denominator
      local denominator = x_denominator * n_numerator
      return numerator % denominator == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp1md_71sf.lua:23:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmp1md_71sf.lua:23: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
      local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
      local numerator = x_numerator * n_denominator
      local denominator = x_denominator * n_numerator
      return numerator % denominator == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmplvl4495v.lua:23:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmplvl4495v.lua:23: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
      local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
      local result_numerator = x_numerator * n_numerator
      local result_denominator = x_denominator * n_denominator
      local result = result_numerator / result_denominator
      return result % 1 == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: |
    .
    Ran 1 tests in 0.000 seconds, 1 success, 0 failures
    OK
  stderr: ''
  exit_code: 0
  status: OK
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local x_num, x_den = x:match('(%d+)/(%d+)')
        local n_num, n_den = n:match('(%d+)/(%d+)')
        local num = x_num * n_num
        local den = x_den * n_den
        local gcd = math.gcd(num, den)
        return num / gcd == den / gcd
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpighr3p3x.lua:17:
    attempt to call a nil value (field 'gcd')\nstack traceback:\n\t/tmp/tmpighr3p3x.lua:17:
    in local 'candidate'\n\t/tmp/tmpighr3p3x.lua:24: in function 'test_humaneval'\n\nRan
    1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local x_numerator, x_denominator = x:match("(%d+)/(%d+)")
        local n_numerator, n_denominator = n:match("(%d+)/(%d+)")
        local x_numerator, x_denominator = tonumber(x_numerator), tonumber(x_denominator)
        local n_numerator, n_denominator = tonumber(n_numerator), tonumber(n_denominator)
        local result = x_numerator * n_denominator * n_numerator * x_denominator
        return result % 1 == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp1avehsov.lua:25:
    expected: false, actual: true\nstack traceback:\n\t/tmp/tmp1avehsov.lua:25: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
      local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
      local numerator = tonumber(x_numerator) * tonumber(n_denominator)
      local denominator = tonumber(x_denominator) * tonumber(n_numerator)
      return numerator % denominator == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpy_2w4fy_.lua:23:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmpy_2w4fy_.lua:23: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
      local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
      local numerator = x_numerator * n_denominator
      local denominator = x_denominator * n_numerator
      return numerator % denominator == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpti0md7n9.lua:23:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmpti0md7n9.lua:23: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
      local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
      local numerator = tonumber(x_numerator) * tonumber(n_denominator)
      local denominator = tonumber(x_denominator) * tonumber(n_numerator)
      return numerator % denominator == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmposdfutwt.lua:23:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmposdfutwt.lua:23: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_num, x_den = x:match('(%d+)/(%d+)')
      local n_num, n_den = n:match('(%d+)/(%d+)')
      local num = x_num * n_num
      local den = x_den * n_den
      return num % den == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: |
    .
    Ran 1 tests in 0.000 seconds, 1 success, 0 failures
    OK
  stderr: ''
  exit_code: 0
  status: OK
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local function gcd(a, b)
        if b == 0 then return a end
        return gcd(b, a % b)
      end
      local function lcm(a, b)
        return a * b / gcd(a, b)
      end
      local function parse(s)
        local n, d = s:match('(%d+)/(%d+)')
        return tonumber(n), tonumber(d)
      end
      local xn, xd = parse(x)
      local nn, nd = parse(n)
      return lcm(xd, nd) % (xd * nn) == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp73kc8417.lua:32:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmp73kc8417.lua:32: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match("(%d+)/(%d+)")
      local n_numerator, n_denominator = n:match("(%d+)/(%d+)")
      local result = (x_numerator * n_denominator) / (x_denominator * n_numerator)
      return result % 1 == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp1z0v9xw6.lua:22:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmp1z0v9xw6.lua:22: in
    function 'test_humaneval'\n\nRan 1 tests in 0.010 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match("(%d+)/(%d+)")
      local n_numerator, n_denominator = n:match("(%d+)/(%d+)")
      local numerator = x_numerator * n_denominator
      local denominator = x_denominator * n_numerator
      return numerator % denominator == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp5d2ztele.lua:23:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmp5d2ztele.lua:23: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local function gcd(a, b)
        while b ~= 0 do
          a, b = b, a % b
        end
        return a
      end
      local function lcm(a, b)
        return a * b / gcd(a, b)
      end
      local function simplify_fraction(x)
        local numerator, denominator = x:match('(%d+)/(%d+)')
        local g = gcd(numerator, denominator)
        return numerator / g, denominator / g
      end
      local x_numerator, x_denominator = simplify_fraction(x)
      local n_numerator, n_denominator = simplify_fraction(n)
      local l = lcm(x_denominator, n_denominator)
      return (x_numerator * l / x_denominator) % (n_numerator * l / n_denominator) == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp00il9emp.lua:36:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmp00il9emp.lua:36: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local x_num, x_den = x:match('(%d+)/(%d+)')
        local n_num, n_den = n:match('(%d+)/(%d+)')
        local num = x_num * n_num
        local den = x_den * n_den
        local gcd = math.gcd(num, den)
        num = num / gcd
        den = den / gcd
        return num % den == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpknwmy_2v.lua:17:
    attempt to call a nil value (field 'gcd')\nstack traceback:\n\t/tmp/tmpknwmy_2v.lua:17:
    in local 'candidate'\n\t/tmp/tmpknwmy_2v.lua:26: in function 'test_humaneval'\n\nRan
    1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
      local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
      return (x_numerator * n_denominator) % (x_denominator * n_numerator) == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpekx0zwnd.lua:21:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmpekx0zwnd.lua:21: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
      local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
      local numerator = x_numerator * n_denominator
      local denominator = x_denominator * n_numerator
      return numerator % denominator == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmphtucnww0.lua:23:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmphtucnww0.lua:23: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_num, x_den = x:match("(%d+)/(%d+)")
      local n_num, n_den = n:match("(%d+)/(%d+)")
      local num = x_num * n_den
      local den = x_den * n_num
      return num % den == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp6z_dt50s.lua:23:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmp6z_dt50s.lua:23: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
      local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
      local x_numerator = tonumber(x_numerator)
      local x_denominator = tonumber(x_denominator)
      local n_numerator = tonumber(n_numerator)
      local n_denominator = tonumber(n_denominator)
      local result = x_numerator * n_denominator * n_numerator * x_denominator
      if result % (x_denominator * n_denominator) == 0 then
        return true
      else
        return false
      end
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpm0xr5w4u.lua:31:
    expected: false, actual: true\nstack traceback:\n\t/tmp/tmpm0xr5w4u.lua:31: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
      local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
      local numerator = x_numerator * n_denominator
      local denominator = x_denominator * n_numerator
      return numerator % denominator == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp7cx1i0vc.lua:23:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmp7cx1i0vc.lua:23: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_num, x_den = x:match("(%d+)/(%d+)")
      local n_num, n_den = n:match("(%d+)/(%d+)")
      local num = x_num * n_den
      local den = x_den * n_num
      return num % den == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpjd9n1lcg.lua:23:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmpjd9n1lcg.lua:23: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local x_num, x_den = x:match('(%d+)/(%d+)')
        local n_num, n_den = n:match('(%d+)/(%d+)')
        local num = x_num * n_num
        local den = x_den * n_den
        local gcd = math.gcd(num, den)
        return num / gcd == den / gcd
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp85hr_0fo.lua:17:
    attempt to call a nil value (field 'gcd')\nstack traceback:\n\t/tmp/tmp85hr_0fo.lua:17:
    in local 'candidate'\n\t/tmp/tmp85hr_0fo.lua:24: in function 'test_humaneval'\n\nRan
    1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local x_numerator, x_denominator = x:match("(%d+)/(%d+)")
        local n_numerator, n_denominator = n:match("(%d+)/(%d+)")
        local x_numerator = tonumber(x_numerator)
        local x_denominator = tonumber(x_denominator)
        local n_numerator = tonumber(n_numerator)
        local n_denominator = tonumber(n_denominator)
        local result = x_numerator * n_denominator * n_numerator * x_denominator
        if result % 1 == 0 then
            return true
        else
            return false
        end
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpcdmjbes2.lua:31:
    expected: false, actual: true\nstack traceback:\n\t/tmp/tmpcdmjbes2.lua:31: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
        local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
        local numerator = x_numerator * n_denominator
        local denominator = x_denominator * n_numerator
        return numerator % denominator == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp614p9486.lua:23:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmp614p9486.lua:23: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local function gcd(a, b)
            if b == 0 then
                return a
            else
                return gcd(b, a % b)
            end
        end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: ''
  stderr: 'lua: /tmp/tmp531kxwno.lua:39: ''end'' expected (to close ''function'' at
    line 12) near <eof>

    '
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local function gcd(a, b)
        if b == 0 then return a end
        return gcd(b, a % b)
      end
      local function lcm(a, b)
        return a * b / gcd(a, b)
      end
      local function simplify_fraction(x)
        local numerator, denominator = x:match('(%d+)/(%d+)')
        local g = gcd(numerator, denominator)
        return numerator / g, denominator / g
      end
      local x_numerator, x_denominator = simplify_fraction(x)
      local n_numerator, n_denominator = simplify_fraction(n)
      local l = lcm(x_denominator, n_denominator)
      return (l / x_denominator) * x_numerator == (l / n_denominator) * n_numerator
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmppz7xxx5l.lua:34:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmppz7xxx5l.lua:34: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_num, x_den = x:match('(%d+)/(%d+)')
      local n_num, n_den = n:match('(%d+)/(%d+)')
      return (x_num * n_den) % (x_den * n_num) == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpcad3nljz.lua:21:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmpcad3nljz.lua:21: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local x_num, x_den = x:match('(%d+)/(%d+)')
        local n_num, n_den = n:match('(%d+)/(%d+)')
        local num = x_num * n_num
        local den = x_den * n_den
        return num % den == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: |
    .
    Ran 1 tests in 0.000 seconds, 1 success, 0 failures
    OK
  stderr: ''
  exit_code: 0
  status: OK
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_num, x_den = x:match("(%d+)/(%d+)")
      local n_num, n_den = n:match("(%d+)/(%d+)")
      local num = x_num * n_num
      local den = x_den * n_den
      local gcd = math.gcd(num, den)
      return num / gcd == den / gcd
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp0pg4sbgp.lua:17:
    attempt to call a nil value (field 'gcd')\nstack traceback:\n\t/tmp/tmp0pg4sbgp.lua:17:
    in local 'candidate'\n\t/tmp/tmp0pg4sbgp.lua:24: in function 'test_humaneval'\n\nRan
    1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local function gcd(a, b)
        if b == 0 then return a end
        return gcd(b, a % b)
      end
      local function lcm(a, b)
        return a * b / gcd(a, b)
      end
      local function to_num(s)
        local num, den = s:match('(%d+)/(%d+)')
        return tonumber(num), tonumber(den)
      end
      local x_num, x_den = to_num(x)
      local n_num, n_den = to_num(n)
      return (x_num * n_den) % (x_den * n_num) == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpe5r6k6lf.lua:32:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmpe5r6k6lf.lua:32: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local x_numerator, x_denominator = x:match("(%d+)/(%d+)")
        local n_numerator, n_denominator = n:match("(%d+)/(%d+)")
        local x_numerator = tonumber(x_numerator)
        local x_denominator = tonumber(x_denominator)
        local n_numerator = tonumber(n_numerator)
        local n_denominator = tonumber(n_denominator)
        local result = x_numerator * n_denominator * n_numerator * x_denominator
        if result % x_denominator == 0 then
            return true
        else
            return false
        end
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmphs6jct46.lua:31:
    expected: false, actual: true\nstack traceback:\n\t/tmp/tmphs6jct46.lua:31: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
        local function gcd(a, b)
            while b ~= 0 do
                a, b = b, a % b
            end
            return a
        end
        local function lcm(a, b)
            return a * b / gcd(a, b)
        end
        local function simplify_fraction(x)
            local numerator, denominator = x:match('(%d+)/(%d+)')
            numerator, denominator = tonumber(numerator), tonumber(denominator)
            local g = gcd(numerator, denominator)
            return numerator / g, denominator / g
        end
        local x_numerator, x_denominator = simplify_fraction(x)
        local n_numerator, n_denominator = simplify_fraction(n)
        local l = lcm(x_denominator, n_denominator)
        return (l / x_denominator) * x_numerator % l == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp7ru1moq8.lua:37:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmp7ru1moq8.lua:37: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
      local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
      local result_numerator = x_numerator * n_numerator
      local result_denominator = x_denominator * n_denominator
      return result_numerator % result_denominator == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: |
    .
    Ran 1 tests in 0.000 seconds, 1 success, 0 failures
    OK
  stderr: ''
  exit_code: 0
  status: OK
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
      local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
      local numerator = x_numerator * n_denominator
      local denominator = x_denominator * n_numerator
      return numerator % denominator == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpgrht8wpm.lua:23:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmpgrht8wpm.lua:23: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
      local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
      local numerator = x_numerator * n_denominator
      local denominator = x_denominator * n_numerator
      return numerator % denominator == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpg1bfgfzc.lua:23:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmpg1bfgfzc.lua:23: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
      local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
      local numerator = tonumber(x_numerator) * tonumber(n_denominator)
      local denominator = tonumber(x_denominator) * tonumber(n_numerator)
      return numerator % denominator == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp45u2p49z.lua:23:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmp45u2p49z.lua:23: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local function gcd(a, b)
        while b ~= 0 do
          a, b = b, a % b
        end
        return a
      end
      local function lcm(a, b)
        return a * b / gcd(a, b)
      end
      local function simplify(x)
        local numerator, denominator = x:match('(%d+)/(%d+)')
        numerator, denominator = tonumber(numerator), tonumber(denominator)
        local g = gcd(numerator, denominator)
        return numerator / g, denominator / g
      end
      local x_numerator, x_denominator = simplify(x)
      local n_numerator, n_denominator = simplify(n)
      local l = lcm(x_denominator, n_denominator)
      return (l / x_denominator) * x_numerator % l == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp0czr7s0j.lua:37:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmp0czr7s0j.lua:37: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
      local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
      local numerator = x_numerator * n_denominator
      local denominator = x_denominator * n_numerator
      local gcd = math.gcd(numerator, denominator)
      numerator = numerator / gcd
      denominator = denominator / gcd
      return numerator % denominator == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp0m_v8nja.lua:17:
    attempt to call a nil value (field 'gcd')\nstack traceback:\n\t/tmp/tmp0m_v8nja.lua:17:
    in local 'candidate'\n\t/tmp/tmp0m_v8nja.lua:26: in function 'test_humaneval'\n\nRan
    1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
      local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
      local numerator = x_numerator * n_denominator
      local denominator = x_denominator * n_numerator
      return numerator % denominator == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmplee3y40w.lua:23:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmplee3y40w.lua:23: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
      local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
      local result_numerator = x_numerator * n_numerator
      local result_denominator = x_denominator * n_denominator
      return result_numerator % result_denominator == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: |
    .
    Ran 1 tests in 0.000 seconds, 1 success, 0 failures
    OK
  stderr: ''
  exit_code: 0
  status: OK
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_num, x_den = x:match("(%d+)/(%d+)")
      local n_num, n_den = n:match("(%d+)/(%d+)")
      local num = x_num * n_num
      local den = x_den * n_den
      return num % den == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: |
    .
    Ran 1 tests in 0.000 seconds, 1 success, 0 failures
    OK
  stderr: ''
  exit_code: 0
  status: OK
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
      local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
      local numerator = tonumber(x_numerator) * tonumber(n_denominator)
      local denominator = tonumber(x_denominator) * tonumber(n_numerator)
      return numerator % denominator == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpfmu49_e9.lua:23:
    expected: true, actual: false\nstack traceback:\n\t/tmp/tmpfmu49_e9.lua:23: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
      local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
      local x_numerator = tonumber(x_numerator)
      local x_denominator = tonumber(x_denominator)
      local n_numerator = tonumber(n_numerator)
      local n_denominator = tonumber(n_denominator)
      local result = x_numerator * n_denominator * n_numerator * x_denominator
      if result % 1 == 0 then
        return true
      else
        return false
      end
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpr_e8h6yy.lua:31:
    expected: false, actual: true\nstack traceback:\n\t/tmp/tmpr_e8h6yy.lua:31: in
    function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
      local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
      local numerator = x_numerator * n_denominator
      local denominator = x_denominator * n_numerator
      local gcd = math.gcd(numerator, denominator)
      return numerator / gcd == denominator / gcd
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpns78moew.lua:17:
    attempt to call a nil value (field 'gcd')\nstack traceback:\n\t/tmp/tmpns78moew.lua:17:
    in local 'candidate'\n\t/tmp/tmpns78moew.lua:24: in function 'test_humaneval'\n\nRan
    1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_num, x_den = x:match('(%d+)/(%d+)')
      local n_num, n_den = n:match('(%d+)/(%d+)')
      local num = x_num * n_num
      local den = x_den * n_den
      local gcd = math.gcd(num, den)
      return num / gcd == den / gcd
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp94ziyv4c.lua:17:
    attempt to call a nil value (field 'gcd')\nstack traceback:\n\t/tmp/tmp94ziyv4c.lua:17:
    in local 'candidate'\n\t/tmp/tmp94ziyv4c.lua:24: in function 'test_humaneval'\n\nRan
    1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_numerator, x_denominator = x:match('(%d+)/(%d+)')
      local n_numerator, n_denominator = n:match('(%d+)/(%d+)')
      local result_numerator = x_numerator * n_numerator
      local result_denominator = x_denominator * n_denominator
      local result = result_numerator / result_denominator
      return result % 1 == 0
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: |
    .
    Ran 1 tests in 0.000 seconds, 1 success, 0 failures
    OK
  stderr: ''
  exit_code: 0
  status: OK
- program: |-
    -- Your task is to implement a function that will simplify the expression
    -- x * n. The function returns true if x * n evaluates to a whole number and false
    -- otherwise. Both x and n, are string representation of a fraction, and have the following format,
    -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.
    -- You can assume that x, and n are valid fractions, and do not have zero as denominator.
    -- >>> simplify('1/5', '5/1')
    -- true
    -- >>> simplify('1/6', '2/1')
    -- false
    -- >>> simplify('7/10', '10/2')
    -- false
    local function simplify(x, n)
      local x_num, x_den = x:match('(%d+)/(%d+)')
      local n_num, n_den = n:match('(%d+)/(%d+)')
      local num = x_num * n_num
      local den = x_den * n_den
      local gcd = math.gcd(num, den)
      return num / gcd == den / gcd
    end
    lu = require('luaunit')

    function test_humaneval()
    local candidate = simplify
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/6', '2/1'), false)
        lu.assertEquals(candidate('5/1', '3/1'), true)
        lu.assertEquals(candidate('7/10', '10/2'), false)
        lu.assertEquals(candidate('2/10', '50/10'), true)
        lu.assertEquals(candidate('7/2', '4/2'), true)
        lu.assertEquals(candidate('11/6', '6/1'), true)
        lu.assertEquals(candidate('2/3', '5/2'), false)
        lu.assertEquals(candidate('5/2', '3/5'), false)
        lu.assertEquals(candidate('2/4', '8/4'), true)
        lu.assertEquals(candidate('2/4', '4/2'), true)
        lu.assertEquals(candidate('1/5', '5/1'), true)
        lu.assertEquals(candidate('1/5', '1/5'), false)
    end

    os.exit(lu.LuaUnit.run())
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpfmiqd_6q.lua:17:
    attempt to call a nil value (field 'gcd')\nstack traceback:\n\t/tmp/tmpfmiqd_6q.lua:17:
    in local 'candidate'\n\t/tmp/tmpfmiqd_6q.lua:24: in function 'test_humaneval'\n\nRan
    1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
