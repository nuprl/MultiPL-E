---
name: HumanEval_115_max_fill
language: lua
prompt: "-- You are given a rectangular grid of wells. Each row represents a single
  well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well has
  a corresponding bucket that can be used to extract water from it, \n-- and all buckets
  have the same capacity.\n-- Your task is to use the buckets to empty the wells.\n--
  Output the number of times you need to lower the buckets.\n-- Example 1:\n-- >>>
  max_fill({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1)\n-- 6\n-- Example 2:\n--
  >>> max_fill({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2)\n-- 5\n--
  Example 3:\n-- >>> max_fill({{0, 0, 0}, {0, 0, 0}}, 5)\n-- 0\n-- Constraints:\n--
  * all wells have the same length\n-- * 1 <= grid.length <= 10^2\n-- * 1 <= grid[:,1].length
  <= 10^2\n-- * grid[i][j] -> 0 | 1\n-- * 1 <= capacity <= 10\nlocal function max_fill(grid,
  capacity)\n"
tests: |-
  lu = require('luaunit')

  function test_humaneval()
  local candidate = max_fill
      lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)
      lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1, 1, 1}}, 2), 5)
      lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}}, 5), 0)
      lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)
      lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)
  end

  os.exit(lu.LuaUnit.run())
completions:
- |2-
      local function fill(row, col)
          local function fill_row(row, col)
              local function fill_col(row, col)
                  if col > #grid[1] then
                      return 0
                  end
                  if grid[row][col] == 1 then
                      grid[row][col] = 0
                      return 1 + fill_col(row, col + 1)
                  else
                      return fill_col(row, col + 1)
                  end
              end
              return fill_col(row, col)
          end
          if row > #grid then
              return 0
          end
          local filled = fill_row(row, col)
          if filled == 0 then
              return fill(row + 1, col)
          else
              return filled + fill(row + 1, col)
          end
      end
      local function fill_all(row, col)
          local filled = fill(row, col)
          if filled == 0 then
              return 0
          else
              return 1 + fill_all(row, col)
          end
      end
      return fill_all(1, 1)
  end
- |2-
    local function fill(grid, capacity)
      local function fill_row(row, capacity)
        local filled = 0
        for i = 1, #row do
          if row[i] == 1 then
            filled = filled + 1
            row[i] = 0
          end
        end
        return filled
      end
      local filled = 0
      for i = 1, #grid do
        filled = filled + fill_row(grid[i], capacity)
      end
      return filled
    end
    local function fill_all(grid, capacity)
      local filled = 0
      while fill(grid, capacity) > 0 do
        filled = filled + 1
      end
      return filled
    end
    return fill_all(grid, capacity)
  end
- |2-
      local function fill(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_cell(cell, capacity)
                  if cell == 0 then
                      return 0
                  else
                      return capacity
                  end
              end
              return map(fill_cell, row, capacity)
          end
          return map(fill_row, grid, capacity)
      end
      local function sum_grid(grid)
          local function sum_row(row)
              local function sum_cell(cell)
                  return cell
              end
              return reduce(sum_cell, row, 0)
          end
          return reduce(sum_row, grid, 0)
      end
      local function empty(grid)
          local function empty_row(row)
              local function empty_cell(cell)
                  return 0
              end
              return map(empty_cell, row)
          end
          return map(empty_row, grid)
      end
      local function fill_and_empty(grid, capacity)
          return empty(fill(grid, capacity))
      end
      local function fill_and_empty_n_times(grid, capacity, n)
          if n == 0 then
              return grid
          else
              return fill_and_empty_n_times(fill_and_empty(grid, capacity), capacity, n - 1)
          end
      end
      local function fill_and_empty_until_empty(grid, capacity)
          local function fill_and_empty_until_empty_helper(grid, capacity, n)
              if sum_grid(grid) == 0 then
                  return n
              else
                  return fill_and_empty_until_empty_helper(fill_and_empty(grid, capacity), capacity, n + 1)
              end
          end
          return fill_and_empty_until_empty_helper(grid, capacity, 0)
      end
      return fill_and_empty_until_empty(grid, capacity)
  end
- |2-
      local function get_max_fill(grid, capacity)
          local max_fill = 0
          for _, row in ipairs(grid) do
              local fill = 0
              for _, cell in ipairs(row) do
                  if cell == 1 then
                      fill = fill + 1
                  else
                      if fill > max_fill then
                          max_fill = fill
                      end
                      fill = 0
                  end
              end
              if fill > max_fill then
                  max_fill = fill
              end
          end
          return max_fill
      end
      local max_fill = get_max_fill(grid, capacity)
      return math.ceil(max_fill / capacity)
  end
- |2-
      local function fill(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_cell(cell, capacity)
                  if cell == 1 then
                      return capacity - 1
                  else
                      return capacity
                  end
              end
              local function fill_row_helper(row, capacity, index)
                  if index > #row then
                      return capacity
                  else
                      return fill_row_helper(row, fill_cell(row[index], capacity), index + 1)
                  end
              end
              return fill_row_helper(row, capacity, 1)
          end
          local function fill_grid_helper(grid, capacity, index)
              if index > #grid then
                  return capacity
              else
                  return fill_grid_helper(grid, fill_row(grid[index], capacity), index + 1)
              end
          end
          return fill_grid_helper(grid, capacity, 1)
      end
      local function fill_helper(grid, capacity, count)
          local new_capacity = fill(grid, capacity)
          if new_capacity == capacity then
              return count
          else
              return fill_helper(grid, new_capacity, count + 1)
          end
      end
      return fill_helper(grid, capacity, 0)
  end
- |2-
      local function fill(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_col(col, capacity)
                  if capacity == 0 then
                      return 0
                  end
                  if col > #row then
                      return capacity
                  end
                  if row[col] == 1 then
                      row[col] = 0
                      return fill_col(col + 1, capacity - 1)
                  end
                  return fill_col(col + 1, capacity)
              end
              return fill_col(1, capacity)
          end
          local function fill_grid(grid, capacity)
              if capacity == 0 then
                  return 0
              end
              if #grid == 0 then
                  return capacity
              end
              local row = table.remove(grid, 1)
              local capacity = fill_row(row, capacity)
              return 1 + fill_grid(grid, capacity)
          end
          return fill_grid(grid, capacity)
      end
      return fill(grid, capacity)
  end
- |2-
    local function fill(row, col)
      if row < 1 or row > #grid or col < 1 or col > #grid[1] then
        return 0
      end
      if grid[row][col] == 0 then
        return 0
      end
      grid[row][col] = 0
      return 1 + fill(row - 1, col) + fill(row + 1, col) + fill(row, col - 1) + fill(row, col + 1)
    end
    local function fill_all()
      local count = 0
      for row = 1, #grid do
        for col = 1, #grid[1] do
          count = count + fill(row, col)
        end
      end
      return count
    end
    local count = 0
    while fill_all() > 0 do
      count = count + 1
    end
    return count
  end
- |2-
    local function fill_row(row, capacity)
      local count = 0
      for i = 1, #row do
        if row[i] == 1 then
          row[i] = 0
          capacity = capacity - 1
          count = count + 1
        end
        if capacity == 0 then
          return count
        end
      end
      return count
    end
    local count = 0
    for i = 1, #grid do
      count = count + fill_row(grid[i], capacity)
    end
    return count
  end
- |2-
      local function fill(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_cell(cell, capacity)
                  if cell == 0 then
                      return 0
                  else
                      return capacity
                  end
              end
              return map(fill_cell, row, capacity)
          end
          return map(fill_row, grid, capacity)
      end
      local function empty(grid, capacity)
          local function empty_row(row, capacity)
              local function empty_cell(cell, capacity)
                  if cell == 0 then
                      return 0
                  else
                      return capacity
                  end
              end
              return map(empty_cell, row, capacity)
          end
          return map(empty_row, grid, capacity)
      end
      local function sum(grid)
          local function sum_row(row)
              local function sum_cell(cell)
                  return cell
              end
              return reduce(sum_cell, row, 0)
          end
          return reduce(sum_row, grid, 0)
      end
      local function fill_and_empty(grid, capacity)
          return empty(fill(grid, capacity), capacity)
      end
      local function fill_and_empty_n(grid, capacity, n)
          if n == 0 then
              return grid
          else
              return fill_and_empty_n(fill_and_empty(grid, capacity), capacity, n - 1)
          end
      end
      local function fill_and_empty_until_empty(grid, capacity)
          local function is_empty(grid)
              local function is_empty_row(row)
                  local function is_empty_cell(cell)
                      return cell == 0
                  end
                  return reduce(is_empty_cell, row, true)
              end
              return reduce(is_empty_row, grid, true)
          end
          local function fill_and_empty_until_empty_n(grid, capacity, n)
              if is_empty(grid) then
                  return n
              else
                  return fill_and_empty_until_empty_n(fill_and_empty(grid, capacity), capacity, n + 1)
              end
- |2-
      local function fill(grid, capacity)
          local filled = 0
          for i, row in ipairs(grid) do
              for j, cell in ipairs(row) do
                  if cell == 1 then
                      filled = filled + 1
                      row[j] = 0
                  end
              end
          end
          return filled
      end
      local function drop(grid, capacity)
          local dropped = 0
          for i, row in ipairs(grid) do
              for j, cell in ipairs(row) do
                  if cell == 0 then
                      dropped = dropped + 1
                      row[j] = 1
                  end
              end
          end
          return dropped
      end
      local function is_empty(grid)
          for i, row in ipairs(grid) do
              for j, cell in ipairs(row) do
                  if cell == 1 then
                      return false
                  end
              end
          end
          return true
      end
      local function is_full(grid)
          for i, row in ipairs(grid) do
              for j, cell in ipairs(row) do
                  if cell == 0 then
                      return false
                  end
              end
          end
          return true
      end
      local function is_done(grid)
          return is_empty(grid) or is_full(grid)
      end
      local function print_grid(grid)
          for i, row in ipairs(grid) do
              for j, cell in ipairs(row) do
                  io.write(cell)
              end
              io.write('\n')
          end
      end
      local function copy_grid(grid)
          local copy = {}
          for i, row in ipairs(grid) do
              copy[i] = {}
              for j, cell in ipairs(row) do
                  copy[i][j] = cell
              end
          end
          return copy
      end
      local function fill_and_drop(grid, capacity)
          local filled = fill(grid, capacity)
          local dropped = drop(grid, capacity)
          return filled, dropped
      end
      local function fill_and_drop_until_done(grid, capacity
- |2-
      local function fill(row, col)
          local count = 0
          for i = 1, row do
              for j = 1, col do
                  if grid[i][j] == 1 then
                      grid[i][j] = 0
                      count = count + 1
                  end
              end
          end
          return count
      end
      local row = #grid
      local col = #grid[1]
      local count = 0
      for i = 1, row do
          local filled = fill(i, col)
          count = count + math.ceil(filled / capacity)
      end
      return count
  end
- |2-
      local function max_fill_row(row, capacity)
          local count = 0
          local i = 1
          while i <= #row do
              if row[i] == 1 then
                  count = count + 1
                  i = i + capacity
              else
                  i = i + 1
              end
          end
          return count
      end
      local count = 0
      for _, row in ipairs(grid) do
          count = count + max_fill_row(row, capacity)
      end
      return count
  end
- |2-
      local function max_fill_row(row, capacity)
          local count = 0
          local i = 1
          while i <= #row do
              if row[i] == 1 then
                  count = count + 1
                  i = i + capacity
              else
                  i = i + 1
              end
          end
          return count
      end
      local count = 0
      for _, row in ipairs(grid) do
          count = count + max_fill_row(row, capacity)
      end
      return count
  end
- |2-
    local function fill(row, col)
      if row < 1 or row > #grid or col < 1 or col > #grid[1] then
        return 0
      end
      if grid[row][col] == 0 then
        return 0
      end
      grid[row][col] = 0
      return 1 + fill(row - 1, col) + fill(row + 1, col) + fill(row, col - 1) + fill(row, col + 1)
    end
    local function fill_all()
      local count = 0
      for row = 1, #grid do
        for col = 1, #grid[1] do
          if grid[row][col] == 1 then
            count = count + fill(row, col)
          end
        end
      end
      return count
    end
    local count = 0
    while fill_all() > 0 do
      count = count + 1
    end
    return count
  end
- |2-
      local function fill_bucket(bucket, wells)
          local function fill_well(well)
              local function fill_unit(unit)
                  if unit == 1 then
                      unit = 0
                      bucket = bucket - 1
                  end
                  return unit
              end
              return table.map(fill_unit, well)
          end
          return table.map(fill_well, wells)
      end
      local function empty_bucket(bucket, wells)
          local function empty_well(well)
              local function empty_unit(unit)
                  if unit == 0 and bucket > 0 then
                      unit = 1
                      bucket = bucket - 1
                  end
                  return unit
              end
              return table.map(empty_unit, well)
          end
          return table.map(empty_well, wells)
      end
      local function count_units(grid)
          local function count_well(well)
              local function count_unit(unit)
                  return unit == 1 and 1 or 0
              end
              return table.sum(table.map(count_unit, well))
          end
          return table.sum(table.map(count_well, grid))
      end
      local function is_empty(grid)
          return count_units(grid) == 0
      end
      local function is_full(grid)
          return count_units(grid) == #grid * #grid[1]
      end
      local function fill_wells(grid, capacity)
          local function fill_well(well)
              local function fill_unit(unit)
                  if unit == 1 and capacity > 0 then
                      unit = 0
                      capacity = capacity - 1
                  end
                  return unit
              end
              return table.map(fill_unit, well)
          end
          return table.map(fill_well, grid)
      end
      local function empty_wells(grid, capacity)
          local function empty_well(well)
              local function empty_unit(unit)
                  if unit == 0 and capacity > 0 then
                      unit = 1
                      capacity = capacity - 1
                  end
                  return unit
              end
              return table.map(empty_unit, well)
          end
- |2-
      local function fill(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_well(well, capacity)
                  local function fill_bucket(bucket, capacity)
                      if capacity == 0 then
                          return 0
                      elseif bucket == 0 then
                          return 0
                      else
                          return 1
                      end
                  end
                  return fill_bucket(well, capacity)
              end
              local function fill_wells(wells, capacity)
                  if capacity == 0 then
                      return 0
                  elseif #wells == 0 then
                      return 0
                  else
                      return fill_well(wells[1], capacity) + fill_wells(wells, capacity - fill_well(wells[1], capacity))
                  end
              end
              return fill_wells(row, capacity)
          end
          local function fill_rows(rows, capacity)
              if capacity == 0 then
                  return 0
              elseif #rows == 0 then
                  return 0
              else
                  return fill_row(rows[1], capacity) + fill_rows(rows, capacity - fill_row(rows[1], capacity))
              end
          end
          return fill_rows(grid, capacity)
      end
      return fill(grid, capacity)
  end
- |2-
      local function fill(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_cell(cell, capacity)
                  if cell == 0 then
                      return 0
                  else
                      return capacity
                  end
              end
              return map(row, function(cell) return fill_cell(cell, capacity) end)
          end
          return map(grid, function(row) return fill_row(row, capacity) end)
      end
      local function count_fill(grid)
          local function count_row(row)
              local function count_cell(cell)
                  if cell == 0 then
                      return 0
                  else
                      return 1
                  end
              end
              return reduce(row, function(acc, cell) return acc + count_cell(cell) end, 0)
          end
          return reduce(grid, function(acc, row) return acc + count_row(row) end, 0)
      end
      local function empty(grid)
          local function empty_row(row)
              local function empty_cell(cell)
                  if cell == 0 then
                      return 0
                  else
                      return 1
                  end
              end
              return map(row, function(cell) return empty_cell(cell) end)
          end
          return map(grid, function(row) return empty_row(row) end)
      end
      local function count_empty(grid)
          local function count_row(row)
              local function count_cell(cell)
                  if cell == 0 then
                      return 0
                  else
                      return 1
                  end
              end
              return reduce(row, function(acc, cell) return acc + count_cell(cell) end, 0)
          end
          return reduce(grid, function(acc, row) return acc + count_row(row) end, 0)
      end
      local function transpose(grid)
          local function transpose_row(row, grid)
              local function transpose_cell(cell, row, grid)
                  return map(grid, function(row) return row[cell] end)
              end
              return map(row, function(cell) return transpose_cell(cell, row, grid) end
- |2-
      local function fill(row, col)
          if row < 1 or row > #grid or col < 1 or col > #grid[1] then
              return 0
          end
          if grid[row][col] == 0 then
              return 0
          end
          grid[row][col] = 0
          return 1 + fill(row + 1, col) + fill(row - 1, col) + fill(row, col + 1) + fill(row, col - 1)
      end
      local function fill_all()
          local count = 0
          for row = 1, #grid do
              for col = 1, #grid[1] do
                  count = count + fill(row, col)
              end
          end
          return count
      end
      local function fill_one()
          for row = 1, #grid do
              for col = 1, #grid[1] do
                  if grid[row][col] == 1 then
                      grid[row][col] = 0
                      return
                  end
              end
          end
      end
      local count = 0
      while fill_all() > 0 do
          count = count + 1
          for i = 1, capacity do
              fill_one()
          end
      end
      return count
  end
- |2-
      local function fill(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_column(column, capacity)
                  if column > #row then
                      return 0
                  end
                  if row[column] == 1 then
                      row[column] = 0
                      return 1 + fill_column(column + 1, capacity - 1)
                  end
                  return fill_column(column + 1, capacity)
              end
              return fill_column(1, capacity)
          end
          if #grid == 0 then
              return 0
          end
          return fill_row(grid[1], capacity) + fill(grid, capacity)
      end
      return fill(grid, capacity)
  end
- |2-
    local function fill(grid, capacity)
      local function fill_row(row, capacity)
        local count = 0
        for i = 1, #row do
          if row[i] == 1 then
            row[i] = 0
            count = count + 1
          end
        end
        return count
      end
      local count = 0
      for i = 1, #grid do
        count = count + fill_row(grid[i], capacity)
      end
      return count
    end
    local count = 0
    while true do
      local filled = fill(grid, capacity)
      if filled == 0 then
        break
      end
      count = count + filled
    end
    return count
  end
- |2-
      local function fill(row, col)
          if row == #grid then
              return grid[row][col]
          end
          local next_row = row + 1
          local next_col = col
          if grid[next_row][next_col] == 0 then
              next_col = next_col + 1
          end
          return grid[row][col] + fill(next_row, next_col)
      end
      local function max_fill_helper(row, col)
          if row == #grid then
              return 0
          end
          local next_row = row + 1
          local next_col = col
          if grid[next_row][next_col] == 0 then
              next_col = next_col + 1
          end
          local next_fill = max_fill_helper(next_row, next_col)
          local current_fill = fill(row, col)
          if current_fill > capacity then
              return 1 + next_fill
          else
              return next_fill
          end
      end
      return max_fill_helper(1, 1)
  end
- |2-
      local max_fill = 0
      for _, row in ipairs(grid) do
          local fill = 0
          for _, column in ipairs(row) do
              if column == 1 then
                  fill = fill + 1
              else
                  if fill > 0 then
                      max_fill = max_fill + 1
                      fill = 0
                  end
              end
          end
          if fill > 0 then
              max_fill = max_fill + 1
          end
      end
      return max_fill * capacity
  end
- |2-
      local function max_fill_row(row, capacity)
          local count = 0
          local bucket = 0
          for _, v in ipairs(row) do
              if v == 1 then
                  if bucket < capacity then
                      bucket = capacity
                      count = count + 1
                  else
                      bucket = bucket - 1
                  end
              else
                  bucket = bucket - 1
              end
          end
          return count
      end
      local count = 0
      for _, row in ipairs(grid) do
          count = count + max_fill_row(row, capacity)
      end
      return count
  end
- |2-
      local function fill(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_cell(cell, capacity)
                  if cell == 0 then
                      return 0
                  else
                      return capacity
                  end
              end
              return map(fill_cell, row, capacity)
          end
          return map(fill_row, grid, capacity)
      end
      local function sum_rows(grid)
          local function sum_row(row)
              local function sum_cell(cell)
                  return cell
              end
              return reduce(sum_cell, row, 0)
          end
          return map(sum_row, grid)
      end
      local function sum_grid(grid)
          local function sum_row(row)
              local function sum_cell(cell)
                  return cell
              end
              return reduce(sum_cell, row, 0)
          end
          return reduce(sum_row, grid, 0)
      end
      local function fill_grid(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_cell(cell, capacity)
                  if cell == 0 then
                      return 0
                  else
                      return capacity
                  end
              end
              return map(fill_cell, row, capacity)
          end
          return map(fill_row, grid, capacity)
      end
      local function sum_grid(grid)
          local function sum_row(row)
              local function sum_cell(cell)
                  return cell
              end
              return reduce(sum_cell, row, 0)
          end
          return reduce(sum_row, grid, 0)
      end
      local function fill_grid(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_cell(cell, capacity)
                  if cell == 0 then
                      return 0
                  else
                      return capacity
                  end
              end
              return map(fill_cell, row, capacity)
          end
          return map(fill_row, grid, capacity)
      end
      local function sum_grid(grid)
          local function sum_row(row)
              local function sum_cell(cell)
                  return
- |2-
    local function fill(grid, capacity)
      local function fill_row(row, capacity)
        local function fill_cell(cell, capacity)
          if cell == 0 then
            return 0
          else
            return capacity
          end
        end
        return map(row, fill_cell, capacity)
      end
      return map(grid, fill_row, capacity)
    end
    local function sum_grid(grid)
      local function sum_row(row)
        return reduce(row, function(a, b) return a + b end, 0)
      end
      return reduce(grid, function(a, b) return a + b end, 0)
    end
    local function is_empty(grid)
      local function is_empty_row(row)
        return reduce(row, function(a, b) return a + b end, 0) == 0
      end
      return reduce(grid, function(a, b) return a and b end, true)
    end
    local function fill_grid(grid, capacity)
      local filled_grid = fill(grid, capacity)
      local sum = sum_grid(filled_grid)
      return filled_grid, sum
    end
    local function reduce_grid(grid)
      local function reduce_row(row)
        local function reduce_cell(cell)
          if cell > 0 then
            return cell - 1
          else
            return 0
          end
        end
        return map(row, reduce_cell)
      end
      return map(grid, reduce_row)
    end
    local function reduce_grid_until_empty(grid)
      local sum = 0
      while not is_empty(grid) do
        grid = reduce_grid(grid)
        sum = sum + 1
      end
      return sum
    end
    local filled_grid, sum = fill_grid(grid, capacity)
    return sum + reduce_grid_until_empty(filled_grid)
  end
- |2-
      local function fill(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_cell(cell, capacity)
                  if cell == 0 then
                      return 0
                  else
                      return capacity
                  end
              end
              return map(fill_cell, row, capacity)
          end
          return map(fill_row, grid, capacity)
      end
      local function sum_grid(grid)
          local function sum_row(row)
              local function sum_cell(cell)
                  return cell
              end
              return reduce(sum_cell, row, 0)
          end
          return reduce(sum_row, grid, 0)
      end
      local function empty(grid)
          local function empty_row(row)
              local function empty_cell(cell)
                  return 0
              end
              return map(empty_cell, row)
          end
          return map(empty_row, grid)
      end
      local function max_fill_rec(grid, capacity, count)
          local filled = fill(grid, capacity)
          local sum = sum_grid(filled)
          if sum == 0 then
              return count
          else
              return max_fill_rec(empty(filled), capacity, count + 1)
          end
      end
      return max_fill_rec(grid, capacity, 0)
  end
- |2-
    local function fill(grid, capacity)
      local function fill_row(row, capacity)
        local function fill_cell(cell, capacity)
          if cell == 0 then
            return 0
          else
            return capacity
          end
        end
        return map(fill_cell, row, capacity)
      end
      return map(fill_row, grid, capacity)
    end
    local function sum_grid(grid)
      local function sum_row(row)
        local function sum_cell(cell)
          return cell
        end
        return reduce(sum_cell, row, 0)
      end
      return reduce(sum_row, grid, 0)
    end
    local function subtract_grid(grid, capacity)
      local function subtract_row(row, capacity)
        local function subtract_cell(cell, capacity)
          if cell == 0 then
            return 0
          else
            return cell - capacity
          end
        end
        return map(subtract_cell, row, capacity)
      end
      return map(subtract_row, grid, capacity)
    end
    local function all_zeros(grid)
      local function all_zeros_row(row)
        local function all_zeros_cell(cell)
          return cell == 0
        end
        return all(all_zeros_cell, row)
      end
      return all(all_zeros_row, grid)
    end
    local function max_fill_iter(grid, capacity, count)
      if all_zeros(grid) then
        return count
      else
        return max_fill_iter(subtract_grid(grid, capacity), capacity, count + sum_grid(fill(grid, capacity)))
      end
    end
    return max_fill_iter(grid, capacity, 0)
  end
- |2-
      local function fill_well(well, capacity)
          local water = 0
          for i = 1, #well do
              if well[i] == 1 then
                  water = water + 1
              end
          end
          return math.ceil(water / capacity)
      end
      local function fill_wells(grid, capacity)
          local count = 0
          for i = 1, #grid do
              count = count + fill_well(grid[i], capacity)
          end
          return count
      end
      return fill_wells(grid, capacity)
  end
- |2-
      local function fill(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_cell(cell, capacity)
                  if cell == 0 then
                      return 0
                  else
                      return capacity
                  end
              end
              return map(row, function(cell) return fill_cell(cell, capacity) end)
          end
          return map(grid, function(row) return fill_row(row, capacity) end)
      end
      local function empty(grid, capacity)
          local function empty_row(row, capacity)
              local function empty_cell(cell, capacity)
                  if cell == 0 then
                      return 0
                  else
                      return capacity
                  end
              end
              return map(row, function(cell) return empty_cell(cell, capacity) end)
          end
          return map(grid, function(row) return empty_row(row, capacity) end)
      end
      local function count_water(grid)
          local function count_row(row)
              local function count_cell(cell)
                  if cell == 0 then
                      return 0
                  else
                      return 1
                  end
              end
              return sum(map(row, function(cell) return count_cell(cell) end))
          end
          return sum(map(grid, function(row) return count_row(row) end))
      end
      local function is_empty(grid)
          local function is_row_empty(row)
              local function is_cell_empty(cell)
                  if cell == 0 then
                      return true
                  else
                      return false
                  end
              end
              return all(map(row, function(cell) return is_cell_empty(cell) end))
          end
          return all(map(grid, function(row) return is_row_empty(row) end))
      end
      local function fill_until_empty(grid, capacity)
          local function fill_until_empty_row(row, capacity)
              local function fill_until_empty_cell(cell, capacity)
                  if cell == 0 then
                      return 0
                  else
                      return capacity
                  end
              end
              return map(row, function(cell
- |2-
      local function fill(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_cell(cell, capacity)
                  if cell == 0 then
                      return 0
                  else
                      return capacity
                  end
              end
              return map(fill_cell, row, capacity)
          end
          return map(fill_row, grid, capacity)
      end
      local function empty(grid, capacity)
          local function empty_row(row, capacity)
              local function empty_cell(cell, capacity)
                  if cell == 0 then
                      return 0
                  else
                      return cell - capacity
                  end
              end
              return map(empty_cell, row, capacity)
          end
          return map(empty_row, grid, capacity)
      end
      local function sum(grid)
          local function sum_row(row)
              local function sum_cell(cell)
                  return cell
              end
              return reduce(sum_cell, row, 0)
          end
          return reduce(sum_row, grid, 0)
      end
      local function is_empty(grid)
          local function is_empty_row(row)
              local function is_empty_cell(cell)
                  return cell == 0
              end
              return all(is_empty_cell, row)
          end
          return all(is_empty_row, grid)
      end
      local function max_fill_iter(grid, capacity, count)
          if is_empty(grid) then
              return count
          else
              return max_fill_iter(empty(fill(grid, capacity), capacity), capacity, count + 1)
          end
      end
      return max_fill_iter(grid, capacity, 0)
  end
- |2-
      local function fill(grid, capacity)
          local count = 0
          for i = 1, #grid do
              local row = grid[i]
              for j = 1, #row do
                  if row[j] == 1 then
                      count = count + 1
                      row[j] = 0
                      capacity = capacity - 1
                      if capacity == 0 then
                          return count
                      end
                  end
              end
          end
          return count
      end
      local function fill_row(grid, capacity)
          local count = 0
          for i = 1, #grid do
              local row = grid[i]
              for j = 1, #row do
                  if row[j] == 1 then
                      count = count + 1
                      row[j] = 0
                      capacity = capacity - 1
                      if capacity == 0 then
                          return count
                      end
                  end
              end
          end
          return count
      end
      local function fill_col(grid, capacity)
          local count = 0
          for j = 1, #grid[1] do
              for i = 1, #grid do
                  local row = grid[i]
                  if row[j] == 1 then
                      count = count + 1
                      row[j] = 0
                      capacity = capacity - 1
                      if capacity == 0 then
                          return count
                      end
                  end
              end
          end
          return count
      end
      local count = 0
      while true do
          local c = fill(grid, capacity)
          if c == 0 then
              break
          end
          count = count + c
      end
      while true do
          local c = fill_row(grid, capacity)
          if c == 0 then
              break
          end
          count = count + c
      end
      while true do
          local c = fill_col(grid, capacity)
          if c == 0 then
              break
          end
          count = count + c
      end
      return count
  end
- |2-
      local function fill(row, col)
          local function fill_row(row, col)
              local function fill_col(row, col)
                  if grid[row][col] == 1 then
                      grid[row][col] = 0
                      return 1
                  end
                  return 0
              end
              local count = 0
              for i = 1, #grid[row] do
                  count = count + fill_col(row, i)
              end
              return count
          end
          local count = 0
          for i = 1, #grid do
              count = count + fill_row(i, col)
          end
          return count
      end
      local count = 0
      for i = 1, #grid[1] do
          count = count + fill(1, i)
      end
      return count * capacity
  end
- |2-
      local rows = #grid
      local cols = #grid[1]
      local max_water = 0
      for i = 1, rows do
          for j = 1, cols do
              if grid[i][j] == 1 then
                  max_water = max_water + capacity
              end
          end
      end
      return max_water
  end
- |2-
      local function fill(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_cell(cell, capacity)
                  if cell == 0 then
                      return capacity
                  else
                      return capacity - 1
                  end
              end
              local function fill_row_helper(row, capacity, result)
                  if capacity == 0 then
                      return result
                  else
                      return fill_row_helper(row, capacity - 1, result + 1)
                  end
              end
              return fill_row_helper(row, capacity, 0)
          end
          local function fill_grid_helper(grid, capacity, result)
              if #grid == 0 then
                  return result
              else
                  return fill_grid_helper(table.slice(grid, 2), capacity, result + fill_row(grid[1], capacity))
              end
          end
          return fill_grid_helper(grid, capacity, 0)
      end
      local function max_fill_helper(grid, capacity, result)
          if capacity == 0 then
              return result
          else
              return max_fill_helper(grid, capacity - 1, math.max(result, fill(grid, capacity)))
          end
      end
      return max_fill_helper(grid, capacity, 0)
  end
- |2-
      local function fill(grid, capacity)
          local function fill_row(grid, capacity, row)
              local function fill_cell(grid, capacity, row, col)
                  local function fill_cell_rec(grid, capacity, row, col)
                      if row < 1 or row > #grid or col < 1 or col > #grid[1] then
                          return 0
                      end
                      if grid[row][col] == 0 then
                          return 0
                      end
                      grid[row][col] = 0
                      return 1 + fill_cell_rec(grid, capacity, row - 1, col) +
                                   fill_cell_rec(grid, capacity, row + 1, col) +
                                   fill_cell_rec(grid, capacity, row, col - 1) +
                                   fill_cell_rec(grid, capacity, row, col + 1)
                  end
                  return fill_cell_rec(grid, capacity, row, col)
              end
              local function fill_cell_rec(grid, capacity, row, col)
                  if col > #grid[1] then
                      return 0
                  end
                  local filled = fill_cell(grid, capacity, row, col)
                  if filled > capacity then
                      return 1 + fill_cell_rec(grid, capacity, row, col + 1)
                  end
                  return fill_cell_rec(grid, capacity, row, col + 1)
              end
              return fill_cell_rec(grid, capacity, row, 1)
          end
          local function fill_row_rec(grid, capacity, row)
              if row > #grid then
                  return 0
              end
              return fill_row(grid, capacity, row) + fill_row_rec(grid, capacity, row + 1)
          end
          return fill_row_rec(grid, capacity, 1)
      end
      return fill(grid, capacity)
  end
- "    local function min(a, b)\n        if a < b then\n            return a\n        else\n
  \           return b\n        end\n    end\n    local function max(a, b)\n        if
  a > b then\n            return a\n        else\n            return b\n        end\n
  \   end\n    local function sum(t)\n        local s = 0\n        for _, v in ipairs(t)
  do\n            s = s + v\n        end\n        return s\n    end\n    local function
  fill(grid, capacity)\n        local n = #grid\n        local m = #grid[1]\n        local
  filled = 0\n        for i = 1, n do\n            local row = grid[i]\n            local
  row_filled = 0\n            for j = 1, m do\n                if row[j] == 1 then\n
  \                   row_filled = row_filled + 1\n                end\n            end\n
  \           filled = filled + min(row_filled, capacity)\n        end\n        return
  filled\n    end\n    local function fill_col(grid, capacity, col)\n        local
  n = #grid\n        local m = #grid[1]\n        local filled = 0\n        for i =
  1, n do\n            local row = grid[i]\n            if row[col] == 1 then\n                filled
  = filled + 1\n            end\n        end\n        return min(filled, capacity)\n
  \   end\n    local function fill_row(grid, capacity, row)\n        local n = #grid\n
  \       local m = #grid[1]\n        local filled = 0\n        local row = grid[row]\n
  \       for j = 1, m do\n            if row[j] == 1 then\n                filled
  = filled + 1\n            end\n        end\n        return min(filled, capacity)\n
  \   end\n    local function fill_row_col(grid, capacity, row, col)\n        local
  n = #grid\n        local m = #grid[1]\n        local filled = 0\n        local row
  = grid[row]\n        if row[col] == 1 then\n            filled = filled + 1\n        end\n
  \       return min(filled, capacity)\n    end\n    local n = #grid\n    local m
  = #grid[1]\n   "
- |2-
      local rows = #grid
      local cols = #grid[1]
      local max_fill = 0
      for i = 1, rows do
          for j = 1, cols do
              if grid[i][j] == 1 then
                  max_fill = max_fill + capacity
              end
          end
      end
      return max_fill
  end
- "    local function fill(grid, capacity)\n        local function fill_row(row, capacity)\n
  \           local function fill_cell(cell, capacity)\n                if cell ==
  1 then\n                    return capacity\n                else\n                    return
  0\n                end\n            end\n            return map(fill_cell, row,
  capacity)\n        end\n        return map(fill_row, grid, capacity)\n    end\n
  \   local function empty(grid, capacity)\n        local function empty_row(row,
  capacity)\n            local function empty_cell(cell, capacity)\n                if
  cell == capacity then\n                    return 0\n                else\n                    return
  cell\n                end\n            end\n            return map(empty_cell, row,
  capacity)\n        end\n        return map(empty_row, grid, capacity)\n    end\n
  \   local function count_filled(grid)\n        local function count_row(row)\n            local
  function count_cell(cell)\n                if cell > 0 then\n                    return
  1\n                else\n                    return 0\n                end\n            end\n
  \           return sum(map(count_cell, row))\n        end\n        return sum(map(count_row,
  grid))\n    end\n    local function is_empty(grid)\n        local function is_row_empty(row)\n
  \           local function is_cell_empty(cell)\n                if cell > 0 then\n
  \                   return false\n                else\n                    return
  true\n                end\n            end\n            return all(map(is_cell_empty,
  row))\n        end\n        return all(map(is_row_empty, grid))\n    end\n    local
  function fill_and_empty(grid, capacity)\n        return empty(fill(grid, capacity),
  capacity)\n    end\n    local function fill_and_empty_n_times(grid, capacity, n)\n
  \       if n == 0 then\n            return grid\n        else\n            return
  fill_and_empty_n_times(fill_and_empty(grid, capacity), capacity, n - 1)\n        end\n
  \   end\n    local function fill_and_empty_until_empty(grid, capacity)\n        local
  function fill_and_empty_until_empty_helper(grid, capacity, n)\n            if is_empty(grid)
  then\n               "
- |2-
      local function fill_bucket(bucket, well)
          local water = 0
          for i = 1, #well do
              if well[i] == 1 then
                  water = water + 1
              end
          end
          return math.min(bucket, water)
      end
- |2-
    local function fill(grid, capacity)
      local function fill_row(row, capacity)
        local function fill_cell(cell, capacity)
          if cell == 1 then
            return capacity - 1
          else
            return capacity
          end
        end
        return map(row, function(cell) return fill_cell(cell, capacity) end)
      end
      return map(grid, function(row) return fill_row(row, capacity) end)
    end
    local function empty(grid)
      local function empty_row(row)
        local function empty_cell(cell)
          if cell == 0 then
            return 1
          else
            return 0
          end
        end
        return map(row, function(cell) return empty_cell(cell) end)
      end
      return map(grid, function(row) return empty_row(row) end)
    end
    local function is_empty(grid)
      local function is_empty_row(row)
        local function is_empty_cell(cell)
          if cell == 0 then
            return true
          else
            return false
          end
        end
        return reduce(row, function(acc, cell) return acc and is_empty_cell(cell) end, true)
      end
      return reduce(grid, function(acc, row) return acc and is_empty_row(row) end, true)
    end
    local function count_fill(grid)
      local function count_fill_row(row)
        local function count_fill_cell(cell)
          if cell == 0 then
            return 1
          else
            return 0
          end
        end
        return reduce(row, function(acc, cell) return acc + count_fill_cell(cell) end, 0)
      end
      return reduce(grid, function(acc, row) return acc + count_fill_row(row) end, 0)
    end
    local function count_empty(grid)
      local function count_empty_row(row)
        local function count_empty_cell(cell)
          if cell == 1 then
            return 1
          else
            return 0
          end
        end
        return reduce(row
- |2-
    local function fill(grid, capacity)
      local function fill_row(row, capacity)
        local function fill_cell(cell, capacity)
          if cell == 1 then
            return capacity
          else
            return 0
          end
        end
        return map(row, function(cell) return fill_cell(cell, capacity) end)
      end
      return map(grid, function(row) return fill_row(row, capacity) end)
    end
    local function empty(grid, capacity)
      local function empty_row(row, capacity)
        local function empty_cell(cell, capacity)
          if cell == capacity then
            return 0
          else
            return cell
          end
        end
        return map(row, function(cell) return empty_cell(cell, capacity) end)
      end
      return map(grid, function(row) return empty_row(row, capacity) end)
    end
    local function count_filled(grid)
      local function count_filled_row(row)
        local function count_filled_cell(cell)
          if cell > 0 then
            return 1
          else
            return 0
          end
        end
        return sum(map(row, count_filled_cell))
      end
      return sum(map(grid, count_filled_row))
    end
    local function count_empty(grid)
      local function count_empty_row(row)
        local function count_empty_cell(cell)
          if cell == 0 then
            return 1
          else
            return 0
          end
        end
        return sum(map(row, count_empty_cell))
      end
      return sum(map(grid, count_empty_row))
    end
    local function count_filled_and_empty(grid)
      return count_filled(grid) + count_empty(grid)
    end
    local function count_filled_and_empty_until_empty(grid, capacity)
      local count = 0
      local filled_and_empty = count_filled_and_empty(grid)
      while filled_and_empty > 0 do
        grid = empty(grid, capacity)
        grid = fill(grid, capacity
- |2-
      local function fill(row, col)
          local sum = 0
          for i = 1, capacity do
              sum = sum + grid[row][col]
              row = row + 1
              if row > #grid then
                  break
              end
          end
          return sum
      end
      local function max_fill_row(row)
          local max = 0
          for col = 1, #grid[row] do
              local sum = fill(row, col)
              if sum > max then
                  max = sum
              end
          end
          return max
      end
      local sum = 0
      for row = 1, #grid do
          sum = sum + max_fill_row(row)
      end
      return sum
  end
- |2-
      local function fill(row, col)
          if row >= #grid or col >= #grid[1] then
              return 0
          end
          local count = 0
          if grid[row][col] == 1 then
              grid[row][col] = 0
              count = 1
          end
          return count + fill(row, col + 1) + fill(row + 1, col)
      end
      local function fill_all()
          local count = 0
          for row = 1, #grid do
              for col = 1, #grid[1] do
                  count = count + fill(row, col)
              end
          end
          return count
      end
      local count = 0
      while fill_all() > 0 do
          count = count + 1
      end
      return count
  end
- |2-
      local function fill(row, col)
          if row > #grid or col > #grid[1] then
              return 0
          end
          if grid[row][col] == 0 then
              return 0
          end
          grid[row][col] = 0
          return 1 + fill(row + 1, col) + fill(row, col + 1)
      end
      local function fill_all()
          local count = 0
          for row = 1, #grid do
              for col = 1, #grid[1] do
                  count = count + fill(row, col)
              end
          end
          return count
      end
      local count = 0
      while fill_all() > 0 do
          count = count + 1
      end
      return count
  end
- |2-
    local function fill(grid, capacity)
      local function fill_row(grid, capacity, row)
        local function fill_cell(grid, capacity, row, col)
          if grid[row][col] == 1 then
            grid[row][col] = 0
            capacity = capacity - 1
          end
          return capacity
        end
        for col = 1, #grid[row] do
          capacity = fill_cell(grid, capacity, row, col)
        end
        return capacity
      end
      for row = 1, #grid do
        capacity = fill_row(grid, capacity, row)
      end
      return capacity
    end
    local function empty(grid, capacity)
      local function empty_row(grid, capacity, row)
        local function empty_cell(grid, capacity, row, col)
          if grid[row][col] == 0 then
            grid[row][col] = 1
            capacity = capacity - 1
          end
          return capacity
        end
        for col = #grid[row], 1, -1 do
          capacity = empty_cell(grid, capacity, row, col)
        end
        return capacity
      end
      for row = #grid, 1, -1 do
        capacity = empty_row(grid, capacity, row)
      end
      return capacity
    end
    local function is_empty(grid)
      local function is_empty_row(grid, row)
        local function is_empty_cell(grid, row, col)
          return grid[row][col] == 0
        end
        for col = 1, #grid[row] do
          if not is_empty_cell(grid, row, col) then
            return false
          end
        end
        return true
      end
      for row = 1, #grid do
        if not is_empty_row(grid, row) then
          return false
        end
      end
      return true
    end
    local function is_full(grid)
      local function is_full_row(grid, row)
        local function is_full_cell(grid, row, col)
          return grid[row][col] == 1
        end
        for col = 1
- |2-
      local function fill(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_cell(cell, capacity)
                  if cell == 0 then
                      return 0
                  else
                      return capacity
                  end
              end
              return map(row, fill_cell, capacity)
          end
          return map(grid, fill_row, capacity)
      end
      local function sum_grid(grid)
          local function sum_row(row)
              local function sum_cell(cell)
                  return cell
              end
              return reduce(row, sum_cell, 0)
          end
          return reduce(grid, sum_row, 0)
      end
      local function fill_grid(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_cell(cell, capacity)
                  if cell == 0 then
                      return 0
                  else
                      return capacity
                  end
              end
              return map(row, fill_cell, capacity)
          end
          return map(grid, fill_row, capacity)
      end
      local function fill_grid_with_capacity(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_cell(cell, capacity)
                  if cell == 0 then
                      return 0
                  else
                      return capacity
                  end
              end
              return map(row, fill_cell, capacity)
          end
          return map(grid, fill_row, capacity)
      end
      local function fill_grid_with_capacity(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_cell(cell, capacity)
                  if cell == 0 then
                      return 0
                  else
                      return capacity
                  end
              end
              return map(row, fill_cell, capacity)
          end
          return map(grid, fill_row, capacity)
      end
      local function fill_grid_with_capacity(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_cell(cell, capacity)
                  if cell == 0 then
                      return 0
                  else
                      return capacity
                  end
              end
              return map(
- |2-
      local function max_fill_rec(grid, capacity, row, col, visited)
          if row < 1 or row > #grid or col < 1 or col > #grid[1] or visited[row][col] == 1 then
              return 0
          end
          local count = 0
          if grid[row][col] == 1 then
              count = 1
          end
          visited[row][col] = 1
          return count + max_fill_rec(grid, capacity, row - 1, col, visited) +
              max_fill_rec(grid, capacity, row + 1, col, visited) +
              max_fill_rec(grid, capacity, row, col - 1, visited) +
              max_fill_rec(grid, capacity, row, col + 1, visited)
      end
      local function max_fill_iter(grid, capacity)
          local count = 0
          local visited = {}
          for i = 1, #grid do
              visited[i] = {}
              for j = 1, #grid[1] do
                  visited[i][j] = 0
              end
          end
          for i = 1, #grid do
              for j = 1, #grid[1] do
                  if visited[i][j] == 0 then
                      local c = max_fill_rec(grid, capacity, i, j, visited)
                      count = count + math.ceil(c / capacity)
                  end
              end
          end
          return count
      end
      return max_fill_iter(grid, capacity)
  end
- |2-
      local function fill_bucket(bucket, row)
          local filled = 0
          for i = 1, #row do
              if row[i] == 1 then
                  filled = filled + 1
              end
          end
          return filled
      end
- |2-
      local n = #grid
      local m = #grid[1]
      local max_height = 0
      for i = 1, n do
          for j = 1, m do
              max_height = math.max(max_height, grid[i][j])
          end
      end
      local function fill(height)
          local count = 0
          for i = 1, n do
              for j = 1, m do
                  if grid[i][j] > height then
                      count = count + grid[i][j] - height
                  end
              end
          end
          return count
      end
      local function check(height)
          return fill(height) <= capacity
      end
      local l = 0
      local r = max_height
      while l < r do
          local mid = math.floor((l + r) / 2)
          if check(mid) then
              r = mid
          else
              l = mid + 1
          end
      end
      return fill(l)
  end
- |2-
      local function fill(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_cell(cell, capacity)
                  if cell == 1 then
                      return capacity - 1
                  else
                      return capacity
                  end
              end
              return map(fill_cell, row, capacity)
          end
          return map(fill_row, grid, capacity)
      end
      local function count_fill(grid)
          local function count_row(row)
              local function count_cell(cell)
                  if cell == 0 then
                      return 1
                  else
                      return 0
                  end
              end
              return sum(map(count_cell, row))
          end
          return sum(map(count_row, grid))
      end
      local function is_empty(grid)
          local function is_row_empty(row)
              local function is_cell_empty(cell)
                  return cell == 0
              end
              return all(map(is_cell_empty, row))
          end
          return all(map(is_row_empty, grid))
      end
      local function fill_and_count(grid, capacity)
          return count_fill(fill(grid, capacity))
      end
      local function fill_and_count_until_empty(grid, capacity)
          local function fill_and_count_until_empty_iter(grid, capacity, count)
              if is_empty(grid) then
                  return count
              else
                  return fill_and_count_until_empty_iter(fill(grid, capacity), capacity, count + fill_and_count(grid, capacity))
              end
          end
          return fill_and_count_until_empty_iter(grid, capacity, 0)
      end
      return fill_and_count_until_empty(grid, capacity)
  end
- |2-
      local function fill(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_cell(cell, capacity)
                  if cell == 0 then
                      return 0
                  else
                      return capacity
                  end
              end
              return map(fill_cell, row, capacity)
          end
          return map(fill_row, grid, capacity)
      end
      local function sum_grid(grid)
          local function sum_row(row)
              local function sum_cell(cell)
                  return cell
              end
              return reduce(sum_cell, row, 0)
          end
          return reduce(sum_row, grid, 0)
      end
      local function empty(grid)
          local function empty_row(row)
              local function empty_cell(cell)
                  return 0
              end
              return map(empty_cell, row)
          end
          return map(empty_row, grid)
      end
      local function max_fill_rec(grid, capacity, count)
          local filled = fill(grid, capacity)
          local sum = sum_grid(filled)
          if sum == 0 then
              return count
          else
              return max_fill_rec(empty(filled), capacity, count + 1)
          end
      end
      return max_fill_rec(grid, capacity, 0)
  end
- |2-
      local function fill(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_cell(cell, capacity)
                  if cell == 0 then
                      return 0
                  else
                      return capacity
                  end
              end
              return map(row, function(cell) return fill_cell(cell, capacity) end)
          end
          return map(grid, function(row) return fill_row(row, capacity) end)
      end
      local function sum_rows(grid)
          local function sum_row(row)
              local function sum_cell(cell, acc)
                  return acc + cell
              end
              return foldl(row, 0, sum_cell)
          end
          return foldl(grid, 0, sum_row)
      end
      local function sum_cols(grid)
          local function sum_col(grid, acc)
              local function sum_cell(cell, acc)
                  return acc + cell
              end
              return foldl(grid, acc, sum_cell)
          end
          return foldl(grid, 0, sum_col)
      end
      local function sum_grid(grid)
          local function sum_cell(cell, acc)
              return acc + cell
          end
          return foldl(grid, 0, sum_cell)
      end
      local function fill_grid(grid, capacity)
          local function fill_cell(cell, capacity)
              if cell == 0 then
                  return 0
              else
                  return capacity
              end
          end
          return map(grid, function(cell) return fill_cell(cell, capacity) end)
      end
      local function fill_row(row, capacity)
          local function fill_cell(cell, capacity)
              if cell == 0 then
                  return 0
              else
                  return capacity
              end
          end
          return map(row, function(cell) return fill_cell(cell, capacity) end)
      end
      local function fill_col(grid, capacity)
          local function fill_cell(cell, capacity)
              if cell == 0 then
                  return 0
              else
                  return capacity
              end
          end
          return map(grid, function(
- |2-
      local n = #grid
      local m = #grid[1]
      local max_height = 0
      for i = 1, n do
          for j = 1, m do
              if grid[i][j] == 1 then
                  max_height = max_height + 1
              end
          end
      end
      local max_fill = 0
      for i = 1, max_height do
          local fill = 0
          for j = 1, n do
              for k = 1, m do
                  if grid[j][k] == 1 then
                      fill = fill + 1
                      grid[j][k] = 0
                  end
              end
          end
          max_fill = max_fill + fill
          if fill < capacity then
              break
          end
      end
      return max_fill
  end
- |2-
      local function fill(row)
          local count = 0
          local i = 1
          while i <= #row do
              if row[i] == 1 then
                  local j = i
                  while j <= #row and row[j] == 1 do
                      j = j + 1
                  end
                  count = count + 1
                  i = j
              else
                  i = i + 1
              end
          end
          return count
      end
      local function fill_all(grid)
          local count = 0
          for i = 1, #grid do
              count = count + fill(grid[i])
          end
          return count
      end
      local function fill_row(row, capacity)
          local count = 0
          local i = 1
          while i <= #row do
              if row[i] == 1 then
                  local j = i
                  while j <= #row and row[j] == 1 do
                      j = j + 1
                  end
                  count = count + 1
                  i = j
              else
                  i = i + 1
              end
          end
          return count
      end
      local function fill_all_with_capacity(grid, capacity)
          local count = 0
          for i = 1, #grid do
              count = count + fill_row(grid[i], capacity)
          end
          return count
      end
      local function fill_row_with_capacity(row, capacity)
          local count = 0
          local i = 1
          while i <= #row do
              if row[i] == 1 then
                  local j = i
                  while j <= #row and row[j] == 1 do
                      j = j + 1
                  end
                  count = count + 1
                  i = j
              else
                  i = i + 1
              end
          end
          return count
      end
      local function fill_all_with_capacity(grid, capacity)
          local count = 0
          for i = 1, #grid do
              count = count + fill_row_with_capacity(grid[i], capacity)
          end
          return count
      end
      local function fill_row_with_capacity(row, capacity)
          local count
- |2-
      local function fill(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_well(well, capacity)
                  local function fill_unit(unit, capacity)
                      if unit == 1 then
                          return 1
                      else
                          return 0
                      end
                  end
                  return capacity - sum(map(fill_unit, well))
              end
              return sum(map(fill_well, row))
          end
          return sum(map(fill_row, grid))
      end
      return fill(grid, capacity)
  end
- |2-
      local function fill(row, col)
          local function fill_row(row, col)
              local function fill_col(row, col)
                  if grid[row][col] == 1 then
                      grid[row][col] = 0
                      return 1
                  end
                  return 0
              end
              local count = 0
              for i = 1, #grid[row] do
                  count = count + fill_col(row, i)
              end
              return count
          end
          local count = 0
          for i = 1, #grid do
              count = count + fill_row(i, col)
          end
          return count
      end
      local count = 0
      for i = 1, #grid[1] do
          count = count + fill(1, i)
      end
      return count * capacity
  end
- |2-
    local function fill(grid, capacity)
      local function fill_row(row, capacity)
        local function fill_cell(cell, capacity)
          if cell == 0 then
            return capacity
          else
            return 0
        end
        return fill_cell
      end
      return fill_row
    end
    return fill
  end
- |2-
      local function fill(row, col)
          if row < 1 or row > #grid or col < 1 or col > #grid[1] then
              return 0
          end
          if grid[row][col] == 0 then
              return 0
          end
          grid[row][col] = 0
          return 1 + fill(row - 1, col) + fill(row + 1, col) + fill(row, col - 1) + fill(row, col + 1)
      end
      local function fill_all()
          local count = 0
          for row = 1, #grid do
              for col = 1, #grid[1] do
                  count = count + fill(row, col)
              end
          end
          return count
      end
      local count = 0
      while fill_all() > 0 do
          count = count + 1
      end
      return count
  end
- |2-
      local function get_max_fill(grid, capacity)
          local max_fill = 0
          for i = 1, #grid do
              local row = grid[i]
              local row_fill = 0
              for j = 1, #row do
                  if row[j] == 1 then
                      row_fill = row_fill + 1
                  end
              end
              if row_fill > max_fill then
                  max_fill = row_fill
              end
          end
          return max_fill
      end
      local max_fill = get_max_fill(grid, capacity)
      return max_fill * capacity
  end
- "    local rows = #grid\n    local cols = #grid[1]\n    local function fill(row,
  col)\n        if row < 1 or row > rows or col < 1 or col > cols then\n            return
  0\n        end\n        if grid[row][col] == 0 then\n            return 0\n        end\n
  \       grid[row][col] = 0\n        return 1 + fill(row - 1, col) + fill(row + 1,
  col) + fill(row, col - 1) + fill(row, col + 1)\n    end\n    local function fill_all()\n
  \       local count = 0\n        for row = 1, rows do\n            for col = 1,
  cols do\n                count = count + fill(row, col)\n            end\n        end\n
  \       return count\n    end\n    local function fill_one()\n        local count
  = 0\n        for row = 1, rows do\n            for col = 1, cols do\n                if
  grid[row][col] == 1 then\n                    grid[row][col] = 0\n                    count
  = count + 1\n                    break\n                end\n            end\n        end\n
  \       return count\n    end\n    local function fill_many()\n        local count
  = 0\n        for row = 1, rows do\n            for col = 1, cols do\n                if
  grid[row][col] == 1 then\n                    grid[row][col] = 0\n                    count
  = count + 1\n                    break\n                end\n            end\n        end\n
  \       return count\n    end\n    local function fill_all_but_one()\n        local
  count = 0\n        for row = 1, rows do\n            for col = 1, cols do\n                if
  grid[row][col] == 1 then\n                    grid[row][col] = 0\n                    count
  = count + 1\n                    break\n                end\n            end\n        end\n
  \       return count\n    end\n    local function fill_all_but_many()\n        local
  count = 0\n        for row = 1, rows do\n            for col = 1, cols do\n                if
  grid[row][col] == 1 then\n                    grid[row][col] = 0\n                    count
  = count + 1\n                    break\n                end\n            end\n        end\n
  \      "
- |2-
      local function fill(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_well(well, capacity)
                  local function fill_unit(unit, capacity)
                      if unit == 1 then
                          return capacity - 1
                      else
                          return capacity
                      end
                  end
                  local function fill_well_helper(well, capacity, i)
                      if i > #well then
                          return capacity
                      else
                          return fill_well_helper(well, fill_unit(well[i], capacity), i + 1)
                      end
                  end
                  return fill_well_helper(well, capacity, 1)
              end
              local function fill_row_helper(row, capacity, i)
                  if i > #row then
                      return capacity
                  else
                      return fill_row_helper(row, fill_well(row[i], capacity), i + 1)
                  end
              end
              return fill_row_helper(row, capacity, 1)
          end
          local function fill_grid_helper(grid, capacity, i)
              if i > #grid then
                  return capacity
              else
                  return fill_grid_helper(grid, fill_row(grid[i], capacity), i + 1)
              end
          end
          return fill_grid_helper(grid, capacity, 1)
      end
      local function max_fill_helper(grid, capacity, count)
          local new_capacity = fill(grid, capacity)
          if new_capacity == capacity then
              return count
          else
              return max_fill_helper(grid, new_capacity, count + 1)
          end
      end
      return max_fill_helper(grid, capacity, 0)
  end
- |2-
    local function fill(grid, capacity)
      local function fill_row(row, capacity)
        local function fill_cell(cell, capacity)
          if cell == 0 then
            return 0
          else
            return capacity
          end
        end
        return map(row, function(cell) return fill_cell(cell, capacity) end)
      end
      return map(grid, function(row) return fill_row(row, capacity) end)
    end
    local function count_water(grid)
      local function count_row(row)
        local function count_cell(cell)
          if cell == 0 then
            return 0
          else
            return 1
          end
        end
        return reduce(row, function(acc, cell) return acc + count_cell(cell) end, 0)
      end
      return reduce(grid, function(acc, row) return acc + count_row(row) end, 0)
    end
    local function empty(grid)
      local function empty_row(row)
        local function empty_cell(cell)
          if cell == 0 then
            return 0
          else
            return 1
          end
        end
        return map(row, function(cell) return empty_cell(cell) end)
      end
      return map(grid, function(row) return empty_row(row) end)
    end
    local function count_empties(grid)
      local function count_row(row)
        local function count_cell(cell)
          if cell == 0 then
            return 0
          else
            return 1
          end
        end
        return reduce(row, function(acc, cell) return acc + count_cell(cell) end, 0)
      end
      return reduce(grid, function(acc, row) return acc + count_row(row) end, 0)
    end
    local function is_empty(grid)
      local function is_row_empty(row)
        local function is_cell_empty(cell)
          if cell == 0 then
            return true
          else
            return false
          end
        end
        return reduce(row, function(acc, cell) return acc and is_cell_empty(cell
- |2-
      local function max_fill_helper(grid, capacity, row, col, count)
          if row == #grid then
              return count
          end
          local max_count = count
          for i = 1, #grid[row] do
              if grid[row][i] == 1 then
                  grid[row][i] = 0
                  max_count = math.max(max_count, max_fill_helper(grid, capacity, row + 1, i, count + 1))
                  grid[row][i] = 1
              end
          end
          return max_count
      end
      return max_fill_helper(grid, capacity, 1, 1, 0)
  end
- |2-
      local function fill(row)
          local count = 0
          local filled = 0
          for i = 1, #row do
              if row[i] == 1 then
                  filled = filled + 1
                  if filled == capacity then
                      filled = 0
                      count = count + 1
                  end
              else
                  filled = 0
              end
          end
          return count
      end
      local count = 0
      for i = 1, #grid do
          count = count + fill(grid[i])
      end
      return count
  end
- |2-
      local function fill_bucket(bucket, row)
          local i = 1
          while i <= #row do
              if row[i] == 1 then
                  bucket = bucket - 1
                  row[i] = 0
              end
              i = i + 1
          end
          return bucket
      end
      local function fill_wells(grid, capacity)
          local i = 1
          local count = 0
          while i <= #grid do
              local bucket = capacity
              bucket = fill_bucket(bucket, grid[i])
              if bucket < capacity then
                  count = count + 1
              end
              i = i + 1
          end
          return count
      end
      local function fill_wells_reverse(grid, capacity)
          local i = #grid
          local count = 0
          while i >= 1 do
              local bucket = capacity
              bucket = fill_bucket(bucket, grid[i])
              if bucket < capacity then
                  count = count + 1
              end
              i = i - 1
          end
          return count
      end
      return math.min(fill_wells(grid, capacity), fill_wells_reverse(grid, capacity))
  end
- |2-
      local rows = #grid
      local cols = #grid[1]
      local max_height = 0
      for row = 1, rows do
          for col = 1, cols do
              if grid[row][col] == 1 then
                  max_height = max_height + 1
              end
          end
      end
      local max_water = capacity * max_height
      local water = 0
      local count = 0
      while water < max_water do
          for row = 1, rows do
              for col = 1, cols do
                  if grid[row][col] == 1 then
                      water = water + 1
                      grid[row][col] = 0
                      if water == max_water then
                          return count
                      end
                  end
              end
          end
          count = count + 1
      end
      return count
  end
- |2-
      local function fill(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_cell(cell, capacity)
                  if cell == 0 then
                      return 0
                  else
                      return capacity
                  end
              end
              return map(row, function(cell) return fill_cell(cell, capacity) end)
          end
          return map(grid, function(row) return fill_row(row, capacity) end)
      end
      local function sum_grid(grid)
          local function sum_row(row)
              local function sum_cell(cell)
                  return cell
              end
              return reduce(row, function(acc, cell) return acc + sum_cell(cell) end, 0)
          end
          return reduce(grid, function(acc, row) return acc + sum_row(row) end, 0)
      end
      local function sum_grid_rows(grid)
          local function sum_row(row)
              local function sum_cell(cell)
                  return cell
              end
              return reduce(row, function(acc, cell) return acc + sum_cell(cell) end, 0)
          end
          return map(grid, function(row) return sum_row(row) end)
      end
      local function subtract_grid_rows(grid, row_sums)
          local function subtract_row(row, row_sum)
              local function subtract_cell(cell, row_sum)
                  return cell - row_sum
              end
              return map(row, function(cell) return subtract_cell(cell, row_sum) end)
          end
          return map(grid, function(row, row_sum) return subtract_row(row, row_sum) end, row_sums)
      end
      local function sum_grid_cols(grid)
          local function sum_col(grid, col_index)
              local function sum_cell(cell)
                  return cell
              end
              return reduce(grid, function(acc, row) return acc + sum_cell(row[col_index]) end, 0)
          end
          local col_count = #grid[1]
          return map(grid, function(row
- |2-
    local function fill(grid, capacity)
      local function fill_row(row, capacity)
        local function fill_cell(cell, capacity)
          if cell == 1 then
            return capacity - 1
          else
            return capacity
          end
        end
        return foldl(fill_cell, capacity, row)
      end
      return foldl(fill_row, capacity, grid)
    end
    return foldl(fill, capacity, grid)
  end
- |2-
    local function fill(grid, capacity)
      local function fill_row(row, capacity)
        local function fill_cell(cell, capacity)
          if cell == 1 then
            return capacity
          else
            return 0
          end
        end
        return map(fill_cell, row, capacity)
      end
      return map(fill_row, grid, capacity)
    end
    local function sum_grid(grid)
      local function sum_row(row)
        local function sum_cell(cell)
          return cell
        end
        return reduce(sum_cell, row, 0)
      end
      return reduce(sum_row, grid, 0)
    end
    local function empty(grid)
      local function empty_row(row)
        local function empty_cell(cell)
          return 0
        end
        return map(empty_cell, row)
      end
      return map(empty_row, grid)
    end
    local function max_fill_rec(grid, capacity, count)
      if sum_grid(grid) == 0 then
        return count
      else
        return max_fill_rec(empty(grid), capacity, count + 1)
      end
    end
    return max_fill_rec(fill(grid, capacity), capacity, 0)
  end
- |2-
      local function fill(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_cell(cell, capacity)
                  if cell == 0 then
                      return 0
                  else
                      return capacity
                  end
              end
              return map(fill_cell, row, capacity)
          end
          return map(fill_row, grid, capacity)
      end
      local function sum_grid(grid)
          local function sum_row(row)
              local function sum_cell(cell)
                  return cell
              end
              return reduce(sum_cell, row, 0)
          end
          return reduce(sum_row, grid, 0)
      end
      local function empty(grid)
          local function empty_row(row)
              local function empty_cell(cell)
                  return 0
              end
              return map(empty_cell, row)
          end
          return map(empty_row, grid)
      end
      local function fill_and_empty(grid, capacity)
          local filled = fill(grid, capacity)
          local emptied = empty(filled)
          return emptied
      end
      local function fill_and_empty_n(grid, capacity, n)
          local function fill_and_empty_n_iter(grid, capacity, n)
              if n == 0 then
                  return grid
              else
                  return fill_and_empty_n_iter(fill_and_empty(grid, capacity), capacity, n - 1)
              end
          end
          return fill_and_empty_n_iter(grid, capacity, n)
      end
      local function fill_and_empty_until_empty(grid, capacity)
          local function fill_and_empty_until_empty_iter(grid, capacity, n)
              local filled = fill_and_empty(grid, capacity)
              local filled_sum = sum_grid(filled)
              if filled_sum == 0 then
                  return n
              else
                  return fill_and_empty_until_empty_iter(filled, capacity, n + 1)
              end
          end
          return fill_and_empty_until_empty_iter(grid, capacity, 0)
      end
      return
- |2-
    local function fill(grid, capacity)
      local function fill_row(row, capacity)
        local function fill_cell(cell, capacity)
          if cell == 1 then
            return capacity - 1
          else
            return capacity
          end
        end
        local function fill_row_helper(row, capacity, i)
          if i > #row then
            return capacity
          else
            return fill_row_helper(row, fill_cell(row[i], capacity), i + 1)
          end
        end
        return fill_row_helper(row, capacity, 1)
      end
      local function fill_grid_helper(grid, capacity, i)
        if i > #grid then
          return capacity
        else
          return fill_grid_helper(grid, fill_row(grid[i], capacity), i + 1)
        end
      end
      return fill_grid_helper(grid, capacity, 1)
    end
    local function fill_helper(grid, capacity, i)
      if fill(grid, capacity) == 0 then
        return i
      else
        return fill_helper(grid, fill(grid, capacity), i + 1)
      end
    end
    return fill_helper(grid, capacity, 0)
  end
- |2-
      local function fill(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_cell(cell, capacity)
                  if cell == 0 then
                      return 0
                  else
                      return capacity
                  end
              end
              return map(row, function(cell) return fill_cell(cell, capacity) end)
          end
          return map(grid, function(row) return fill_row(row, capacity) end)
      end
      local function sum_grid(grid)
          local function sum_row(row)
              local function sum_cell(cell)
                  return cell
              end
              return foldl(row, 0, function(acc, cell) return acc + sum_cell(cell) end)
          end
          return foldl(grid, 0, function(acc, row) return acc + sum_row(row) end)
      end
      local function is_empty(grid)
          local function is_empty_row(row)
              local function is_empty_cell(cell)
                  return cell == 0
              end
              return all(row, is_empty_cell)
          end
          return all(grid, is_empty_row)
      end
      local function drop(grid)
          local function drop_row(row)
              local function drop_cell(cell)
                  if cell == 0 then
                      return 0
                  else
                      return cell - 1
                  end
              end
              return map(row, function(cell) return drop_cell(cell) end)
          end
          return map(grid, function(row) return drop_row(row) end)
      end
      local function fill_and_drop(grid, capacity)
          return drop(fill(grid, capacity))
      end
      local function fill_and_drop_n(grid, capacity, n)
          local function fill_and_drop_n_iter(grid, capacity, n, acc)
              if n == 0 then
                  return acc
              else
                  return fill_and_drop_n_iter(fill_and_drop(grid, capacity), capacity, n - 1, acc + 1)
              end
          end
          return fill_and_drop_n_
- |2-
    local function fill(grid, capacity)
      local function fill_row(row, capacity)
        local function fill_cell(cell, capacity)
          if cell == 1 then
            return capacity - 1
          else
            return capacity
          end
        end
        return map(row, function(cell) return fill_cell(cell, capacity) end)
      end
      return map(grid, function(row) return fill_row(row, capacity) end)
    end
    local function count_empties(grid)
      local function count_empties_row(row)
        local function count_empties_cell(cell)
          if cell == 0 then
            return 1
          else
            return 0
          end
        end
        return reduce(row, function(acc, cell) return acc + count_empties_cell(cell) end, 0)
      end
      return reduce(grid, function(acc, row) return acc + count_empties_row(row) end, 0)
    end
    local function is_empty(grid)
      local function is_empty_row(row)
        local function is_empty_cell(cell)
          if cell == 0 then
            return false
          else
            return true
          end
        end
        return reduce(row, function(acc, cell) return acc and is_empty_cell(cell) end, true)
      end
      return reduce(grid, function(acc, row) return acc and is_empty_row(row) end, true)
    end
    local function max_fill_iter(grid, capacity, count)
      if is_empty(grid) then
        return count
      else
        return max_fill_iter(fill(grid, capacity), capacity, count + 1)
      end
    end
    return max_fill_iter(grid, capacity, 0)
  end
- |2-
      local rows = #grid
      local cols = #grid[1]
      local max_height = 0
      for i = 1, rows do
          for j = 1, cols do
              max_height = math.max(max_height, grid[i][j])
          end
      end
      local function fill(height)
          local count = 0
          for i = 1, rows do
              for j = 1, cols do
                  if grid[i][j] >= height then
                      count = count + 1
                  end
              end
          end
          return count
      end
      local function bsearch(lo, hi)
          if lo == hi then
              return lo
          end
          local mid = math.floor((lo + hi) / 2)
          if fill(mid) > capacity then
              return bsearch(mid + 1, hi)
          else
              return bsearch(lo, mid)
          end
      end
      return bsearch(1, max_height)
  end
- |2-
      local function fill(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_column(column, capacity)
                  if capacity == 0 then
                      return 0
                  end
                  if column > #row then
                      return capacity
                  end
                  if row[column] == 1 then
                      row[column] = 0
                      return fill_column(column + 1, capacity - 1)
                  end
                  return fill_column(column + 1, capacity)
              end
              return fill_column(1, capacity)
          end
          local function fill_grid(grid, capacity)
              if #grid == 0 then
                  return capacity
              end
              local row = table.remove(grid, 1)
              local remaining = fill_row(row, capacity)
              return fill_grid(grid, remaining)
          end
          return fill_grid(grid, capacity)
      end
      local function count_fills(grid, capacity)
          local function count_fills_row(row, capacity)
              local function count_fills_column(column, capacity)
                  if capacity == 0 then
                      return 0
                  end
                  if column > #row then
                      return capacity
                  end
                  if row[column] == 1 then
                      return 1 + count_fills_column(column + 1, capacity - 1)
                  end
                  return count_fills_column(column + 1, capacity)
              end
              return count_fills_column(1, capacity)
          end
          local function count_fills_grid(grid, capacity)
              if #grid == 0 then
                  return capacity
              end
              local row = table.remove(grid, 1)
              local remaining = count_fills_row(row, capacity)
              return remaining + count_fills_grid(grid, capacity)
          end
          return count_fills_grid(grid, capacity)
      end
      local remaining = fill(grid, capacity)
      return count_fills(grid, capacity) - remaining
  end
- |2-
    local function fill(grid, capacity)
      local function fill_row(row, capacity)
        local function fill_well(well, capacity)
          if well == 0 then
            return capacity
          else
            return 0
          end
        end
        local function fill_wells(wells, capacity)
          if #wells == 0 then
            return capacity
          else
            return fill_wells(tail(wells), fill_well(head(wells), capacity))
          end
        end
        return fill_wells(row, capacity)
      end
      local function fill_rows(grid, capacity)
        if #grid == 0 then
          return capacity
        else
          return fill_rows(tail(grid), fill_row(head(grid), capacity))
        end
      end
      return fill_rows(grid, capacity)
    end
    local function fill_grid(grid, capacity)
      if capacity == 0 then
        return 0
      else
        return 1 + fill_grid(grid, fill(grid, capacity))
      end
    end
    return fill_grid(grid, capacity)
  end
- |2-
      local function fill_row(row, capacity)
          local count = 0
          local i = 1
          while i <= #row do
              if row[i] == 1 then
                  count = count + 1
                  i = i + capacity
              else
                  i = i + 1
              end
          end
          return count
      end
      local count = 0
      for i = 1, #grid do
          count = count + fill_row(grid[i], capacity)
      end
      return count
  end
- |2-
      local function fill(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_cell(cell, capacity)
                  if cell == 0 then
                      return 0
                  else
                      return capacity
                  end
              end
              return map(fill_cell, row, capacity)
          end
          return map(fill_row, grid, capacity)
      end
      local function sum_grid(grid)
          local function sum_row(row)
              local function sum_cell(cell)
                  return cell
              end
              return reduce(sum_cell, row, 0)
          end
          return reduce(sum_row, grid, 0)
      end
      local function subtract_grid(grid, capacity)
          local function subtract_row(row, capacity)
              local function subtract_cell(cell, capacity)
                  if cell < capacity then
                      return 0
                  else
                      return cell - capacity
                  end
              end
              return map(subtract_cell, row, capacity)
          end
          return map(subtract_row, grid, capacity)
      end
      local function is_empty(grid)
          local function is_empty_row(row)
              local function is_empty_cell(cell)
                  return cell == 0
              end
              return all(is_empty_cell, row)
          end
          return all(is_empty_row, grid)
      end
      local function max_fill_iter(grid, capacity, count)
          if is_empty(grid) then
              return count
          else
              return max_fill_iter(subtract_grid(grid, capacity), capacity, count + sum_grid(fill(grid, capacity)))
          end
      end
      return max_fill_iter(grid, capacity, 0)
  end
- |2-
    local count = 0
    local row_count = #grid
    local col_count = #grid[1]
    local row_index = 1
    local col_index = 1
    while row_index <= row_count do
      while col_index <= col_count do
        if grid[row_index][col_index] == 1 then
          count = count + 1
          local row_index_copy = row_index
          while row_index_copy <= row_count and capacity > 0 do
            local col_index_copy = col_index
            while col_index_copy <= col_count and capacity > 0 do
              if grid[row_index_copy][col_index_copy] == 1 then
                grid[row_index_copy][col_index_copy] = 0
                capacity = capacity - 1
              end
              col_index_copy = col_index_copy + 1
            end
            row_index_copy = row_index_copy + 1
          end
        end
        col_index = col_index + 1
      end
      row_index = row_index + 1
    end
    return count
  end
- |2-
      local function fill(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_cell(cell, capacity)
                  if cell == 0 then
                      return 0
                  else
                      return capacity
                  end
              end
              return map(fill_cell, row, capacity)
          end
          return map(fill_row, grid, capacity)
      end
      local function sum_grid(grid)
          local function sum_row(row)
              local function sum_cell(cell)
                  return cell
              end
              return reduce(sum_cell, row, 0)
          end
          return reduce(sum_row, grid, 0)
      end
      local function empty(grid)
          local function empty_row(row)
              local function empty_cell(cell)
                  return 0
              end
              return map(empty_cell, row)
          end
          return map(empty_row, grid)
      end
      local function max_fill_iter(grid, capacity, count)
          local filled = fill(grid, capacity)
          local sum = sum_grid(filled)
          if sum == 0 then
              return count
          else
              return max_fill_iter(empty(filled), capacity, count + 1)
          end
      end
      return max_fill_iter(grid, capacity, 0)
  end
- |2-
    local function fill_row(row)
      local filled = 0
      for i = 1, #row do
        if row[i] == 1 then
          filled = filled + 1
        end
      end
      return filled
    end
    local function fill_col(grid, col)
      local filled = 0
      for i = 1, #grid do
        if grid[i][col] == 1 then
          filled = filled + 1
        end
      end
      return filled
    end
    local function fill_grid(grid, capacity)
      local filled = 0
      for i = 1, #grid do
        filled = filled + fill_row(grid[i])
      end
      for i = 1, #grid[1] do
        filled = filled + fill_col(grid, i)
      end
      return filled * capacity
    end
    return fill_grid(grid, capacity)
  end
- |2-
    local function fill_row(row, capacity)
      local count = 0
      local filled = 0
      for i = 1, #row do
        if row[i] == 1 then
          if filled < capacity then
            filled = capacity
            count = count + 1
          else
            filled = filled - 1
          end
        else
          filled = filled - 1
        end
      end
      return count
    end
    local count = 0
    for i = 1, #grid do
      count = count + fill_row(grid[i], capacity)
    end
    return count
  end
- |2-
      local function get_max_fill_count(grid, capacity)
          local max_fill_count = 0
          local row_count = #grid
          local column_count = #grid[1]
          local row_index = 1
          local column_index = 1
          while row_index <= row_count do
              column_index = 1
              while column_index <= column_count do
                  if grid[row_index][column_index] == 1 then
                      local fill_count = 0
                      local row_index_copy = row_index
                      while row_index_copy <= row_count and fill_count < capacity do
                          if grid[row_index_copy][column_index] == 1 then
                              fill_count = fill_count + 1
                              grid[row_index_copy][column_index] = 0
                          end
                          row_index_copy = row_index_copy + 1
                      end
                      max_fill_count = max_fill_count + 1
                  end
                  column_index = column_index + 1
              end
              row_index = row_index + 1
          end
          return max_fill_count
      end
      return get_max_fill_count(grid, capacity)
  end
- |2-
      local function fill(grid, capacity)
          local filled = 0
          for i = 1, #grid do
              local row = grid[i]
              local row_filled = 0
              for j = 1, #row do
                  local cell = row[j]
                  if cell == 1 then
                      row_filled = row_filled + 1
                  end
              end
              if row_filled > capacity then
                  filled = filled + capacity
              else
                  filled = filled + row_filled
              end
          end
          return filled
      end
      local function fill_with_capacity(grid, capacity)
          local filled = fill(grid, capacity)
          local new_grid = {}
          for i = 1, #grid do
              local row = grid[i]
              local new_row = {}
              for j = 1, #row do
                  local cell = row[j]
                  if cell == 1 then
                      if capacity > 0 then
                          new_row[j] = 0
                          capacity = capacity - 1
                      else
                          new_row[j] = 1
                      end
                  else
                      new_row[j] = 0
                  end
              end
              new_grid[i] = new_row
          end
          return filled, new_grid
      end
      local filled = 0
      local grid_copy = {}
      for i = 1, #grid do
          grid_copy[i] = {}
          for j = 1, #grid[i] do
              grid_copy[i][j] = grid[i][j]
          end
      end
      while true do
          local new_filled, new_grid = fill_with_capacity(grid_copy, capacity)
          if new_filled == filled then
              break
          end
          filled = new_filled
          grid_copy = new_grid
      end
      return filled
  end
- |2-
      local n = #grid
      local m = #grid[1]
      local function fill(i, j)
          if i > n or j > m then
              return 0
          end
          if grid[i][j] == 0 then
              return fill(i, j + 1)
          end
          local c = capacity
          while c > 0 and i <= n and j <= m do
              if grid[i][j] == 1 then
                  grid[i][j] = 0
                  c = c - 1
              end
              i = i + 1
              j = j + 1
          end
          return 1 + fill(i, j)
      end
      return fill(1, 1)
  end
- |2-
      local function get_max_fill(grid, capacity)
          local max_fill = 0
          for i = 1, #grid do
              local row = grid[i]
              local fill = 0
              for j = 1, #row do
                  if row[j] == 1 then
                      fill = fill + 1
                  end
              end
              if fill > max_fill then
                  max_fill = fill
              end
          end
          return max_fill
      end
      local function get_max_fill_per_bucket(grid, capacity)
          local max_fill = 0
          for i = 1, #grid do
              local row = grid[i]
              local fill = 0
              for j = 1, #row do
                  if row[j] == 1 then
                      fill = fill + 1
                  end
                  if fill == capacity then
                      fill = 0
                  end
              end
              if fill > max_fill then
                  max_fill = fill
              end
          end
          return max_fill
      end
      local max_fill = get_max_fill(grid, capacity)
      local max_fill_per_bucket = get_max_fill_per_bucket(grid, capacity)
      return max_fill + max_fill_per_bucket
  end
- |2-
      local function fill(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_cell(cell, capacity)
                  if cell == 0 then
                      return 0
                  else
                      return capacity
                  end
              end
              return map(fill_cell, row, capacity)
          end
          return map(fill_row, grid, capacity)
      end
      local function sum_grid(grid)
          local function sum_row(row)
              local function sum_cell(cell)
                  return cell
              end
              return reduce(sum_cell, row, 0)
          end
          return reduce(sum_row, grid, 0)
      end
      local function empty(grid)
          local function empty_row(row)
              local function empty_cell(cell)
                  return 0
              end
              return map(empty_cell, row)
          end
          return map(empty_row, grid)
      end
      local function count_empties(grid)
          local function count_empties_row(row)
              local function count_empties_cell(cell)
                  if cell == 0 then
                      return 1
                  else
                      return 0
                  end
              end
              return reduce(count_empties_cell, row, 0)
          end
          return reduce(count_empties_row, grid, 0)
      end
      local function count_fills(grid)
          local function count_fills_row(row)
              local function count_fills_cell(cell)
                  if cell == capacity then
                      return 1
                  else
                      return 0
                  end
              end
              return reduce(count_fills_cell, row, 0)
          end
          return reduce(count_fills_row, grid, 0)
      end
      local function count_empties_and_fills(grid)
          local function count_empties_and_fills_row(row)
              local function count_empties_and_fills_cell(cell)
                  if cell == 0 or cell == capacity then
                      return 1
                  else
                      return 0
                  end
              end
              return reduce(count_empties_and_
- |2-
      local function fill_bucket(bucket, row)
          local count = 0
          for i = 1, #row do
              if row[i] == 1 then
                  count = count + 1
                  row[i] = 0
              end
          end
          return count
      end
- |2-
    local function fill(grid, capacity)
      local function fill_row(row, capacity)
        local function fill_cell(cell, capacity)
          if cell == 0 then
            return 0
          else
            local fill = math.min(capacity, cell)
            return fill
          end
        end
        local filled = 0
        for i = 1, #row do
          filled = filled + fill_cell(row[i], capacity)
        end
        return filled
      end
      local filled = 0
      for i = 1, #grid do
        filled = filled + fill_row(grid[i], capacity)
      end
      return filled
    end
    local function empty(grid, capacity)
      local function empty_row(row, capacity)
        local function empty_cell(cell, capacity)
          if cell == 0 then
            return 0
          else
            local empty = math.min(capacity, cell)
            return empty
          end
        end
        local emptied = 0
        for i = #row, 1, -1 do
          emptied = emptied + empty_cell(row[i], capacity)
        end
        return emptied
      end
      local emptied = 0
      for i = #grid, 1, -1 do
        emptied = emptied + empty_row(grid[i], capacity)
      end
      return emptied
    end
    local function fill_and_empty(grid, capacity)
      local filled = fill(grid, capacity)
      local emptied = empty(grid, capacity)
      return filled, emptied
    end
    local function fill_and_empty_until_empty(grid, capacity)
      local filled = 0
      local emptied = 0
      local filled_last_time = 0
      local emptied_last_time = 0
      repeat
        filled_last_time, emptied_last_time = fill_and_empty(grid, capacity)
        filled = filled + filled_last_time
        emptied = emptied + emptied_last_time
      until emptied_last_time == 0
      return filled, emptied
    end
    local filled, emptied = fill_and_empty_until_empty(grid, capacity)
    return filled
  end
- |2-
      local function fill(grid, capacity)
          local function get_max_row(grid)
              local max_row = {}
              local max_sum = 0
              for i = 1, #grid do
                  local sum = 0
                  for j = 1, #grid[i] do
                      sum = sum + grid[i][j]
                  end
                  if sum > max_sum then
                      max_row = grid[i]
                      max_sum = sum
                  end
              end
              return max_row
          end
          local function fill_row(row, capacity)
              local function fill_cell(cell, capacity)
                  if cell == 1 then
                      return capacity
                  else
                      return 0
                  end
              end
              local filled_row = {}
              for i = 1, #row do
                  filled_row[i] = fill_cell(row[i], capacity)
              end
              return filled_row
          end
          local function get_filled_grid(grid, capacity)
              local filled_grid = {}
              for i = 1, #grid do
                  filled_grid[i] = fill_row(grid[i], capacity)
              end
              return filled_grid
          end
          local function get_filled_row(grid, capacity)
              local filled_grid = get_filled_grid(grid, capacity)
              return get_max_row(filled_grid)
          end
          local function get_filled_grid_sum(grid, capacity)
              local filled_grid = get_filled_grid(grid, capacity)
              local sum = 0
              for i = 1, #filled_grid do
                  for j = 1, #filled_grid[i] do
                      sum = sum + filled_grid[i][j]
                  end
              end
              return sum
          end
          local function get_filled_row_sum(grid, capacity)
              local filled_row = get_filled_row(grid, capacity)
              local sum = 0
              for i = 1, #filled_row do
                  sum = sum + filled_row[i]
              end
              return sum
          end
          local function get_filled_grid_max_sum(grid,
- |2-
    local function fill(grid, capacity)
      local function fill_row(row, capacity)
        local function fill_cell(cell, capacity)
          if cell == 1 then
            return capacity - 1
          else
            return capacity
          end
        end
        local function fill_row_helper(row, capacity, index)
          if index > #row then
            return capacity
          else
            return fill_row_helper(row, fill_cell(row[index], capacity), index + 1)
          end
        end
        return fill_row_helper(row, capacity, 1)
      end
      local function fill_grid_helper(grid, capacity, index)
        if index > #grid then
          return capacity
        else
          return fill_grid_helper(grid, fill_row(grid[index], capacity), index + 1)
        end
      end
      return fill_grid_helper(grid, capacity, 1)
    end
    local function fill_helper(grid, capacity, count)
      local new_capacity = fill(grid, capacity)
      if new_capacity == capacity then
        return count
      else
        return fill_helper(grid, new_capacity, count + 1)
      end
    end
    return fill_helper(grid, capacity, 0)
  end
- |2-
      local rows = #grid
      local cols = #grid[1]
      local count = 0
      for i = 1, rows do
          local row = grid[i]
          for j = 1, cols do
              local cell = row[j]
              if cell == 1 then
                  count = count + 1
                  local k = i
                  while k <= rows and capacity > 0 do
                      grid[k][j] = 0
                      capacity = capacity - 1
                      k = k + 1
                  end
              end
          end
      end
      return count
  end
- |2-
      local function get_max_fill(grid, capacity)
          local max_fill = 0
          for i = 1, #grid do
              local row = grid[i]
              local fill = 0
              for j = 1, #row do
                  if row[j] == 1 then
                      fill = fill + 1
                  end
              end
              if fill > max_fill then
                  max_fill = fill
              end
          end
          return max_fill
      end
      local function fill_row(grid, capacity, row_index)
          local row = grid[row_index]
          local fill = 0
          for j = 1, #row do
              if row[j] == 1 then
                  fill = fill + 1
              end
          end
          if fill > capacity then
              for j = 1, #row do
                  if row[j] == 1 then
                      row[j] = 0
                  end
              end
              return capacity
          else
              for j = 1, #row do
                  if row[j] == 1 then
                      row[j] = 0
                  end
              end
              return fill
          end
      end
      local function fill_grid(grid, capacity)
          local fill_count = 0
          local max_fill = get_max_fill(grid, capacity)
          while max_fill > 0 do
              for i = 1, #grid do
                  local row = grid[i]
                  local fill = 0
                  for j = 1, #row do
                      if row[j] == 1 then
                          fill = fill + 1
                      end
                  end
                  if fill > 0 then
                      local fill_amount = fill_row(grid, capacity, i)
                      fill_count = fill_count + fill_amount
                      max_fill = get_max_fill(grid, capacity)
                      break
                  end
              end
          end
          return fill_count
      end
      return fill_grid(grid, capacity)
  end
- |2-
    local function fill(grid, capacity)
      local filled = 0
      for i = 1, #grid do
        local row = grid[i]
        for j = 1, #row do
          local cell = row[j]
          if cell == 1 then
            filled = filled + 1
            row[j] = 0
          end
        end
      end
      return filled
    end
    local function drain(grid, capacity)
      local drained = 0
      for i = #grid, 1, -1 do
        local row = grid[i]
        for j = #row, 1, -1 do
          local cell = row[j]
          if cell == 0 then
            drained = drained + 1
            row[j] = 1
          end
        end
      end
      return drained
    end
    local function count(grid)
      local count = 0
      for i = 1, #grid do
        local row = grid[i]
        for j = 1, #row do
          local cell = row[j]
          if cell == 1 then
            count = count + 1
          end
        end
      end
      return count
    end
    local function fill_and_drain(grid, capacity)
      local filled = fill(grid, capacity)
      local drained = drain(grid, capacity)
      return filled, drained
    end
    local function fill_and_drain_until_empty(grid, capacity)
      local filled = 0
      local drained = 0
      local count = count(grid)
      while count > 0 do
        local f, d = fill_and_drain(grid, capacity)
        filled = filled + f
        drained = drained + d
        count = count(grid)
      end
      return filled, drained
    end
    local filled, drained = fill_and_drain_until_empty(grid, capacity)
    return filled + drained
  end
- |2-
    local n = #grid
    local m = #grid[1]
    local max_height = 0
    for i=1,n do
      for j=1,m do
        if grid[i][j] == 1 then
          max_height = max_height + 1
        end
      end
    end
    local max_fill = 0
    for i=1,n do
      for j=1,m do
        if grid[i][j] == 1 then
          max_fill = max_fill + 1
        end
      end
    end
    local min_fill = 0
    for i=1,n do
      for j=1,m do
        if grid[i][j] == 1 then
          min_fill = min_fill + 1
        end
      end
    end
    local function is_valid(fill)
      local buckets = {}
      for i=1,n do
        buckets[i] = 0
      end
      for i=1,n do
        for j=1,m do
          if grid[i][j] == 1 then
            buckets[i] = buckets[i] + 1
          end
        end
      end
      for i=1,n do
        if buckets[i] > fill then
          return false
        end
      end
      return true
    end
    local function binary_search(min_fill, max_fill)
      if min_fill == max_fill then
        return min_fill
      end
      local mid = math.floor((min_fill + max_fill) / 2)
      if is_valid(mid) then
        return binary_search(min_fill, mid)
      else
        return binary_search(mid + 1, max_fill)
      end
    end
    return binary_search(min_fill, max_fill)
  end
- |2-
      local function fill(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_cell(cell, capacity)
                  if cell == 1 then
                      return capacity - 1
                  else
                      return capacity
                  end
              end
              local filled = 0
              for i, cell in ipairs(row) do
                  capacity = fill_cell(cell, capacity)
                  if capacity == 0 then
                      filled = filled + 1
                      capacity = capacity + 1
                  end
              end
              return filled
          end
          local filled = 0
          for i, row in ipairs(grid) do
              filled = filled + fill_row(row, capacity)
          end
          return filled
      end
      local filled = 0
      for i, row in ipairs(grid) do
          filled = filled + fill(row, capacity)
      end
      return filled
  end
- |2-
      local rows = #grid
      local cols = #grid[1]
      local max_water = 0
      local water = 0
      local function max_water_in_row(row)
          local max_water_in_row = 0
          local water_in_row = 0
          for i = 1, cols do
              if row[i] == 1 then
                  water_in_row = water_in_row + 1
              else
                  if water_in_row > max_water_in_row then
                      max_water_in_row = water_in_row
                  end
                  water_in_row = 0
              end
          end
          if water_in_row > max_water_in_row then
              max_water_in_row = water_in_row
          end
          return max_water_in_row
      end
      for i = 1, rows do
          local max_water_in_row = max_water_in_row(grid[i])
          if max_water_in_row > max_water then
              max_water = max_water_in_row
          end
      end
      water = max_water * capacity
      return water
  end
- |2-
      -- TODO: implement
  end
- |2-
    local function fill(grid, capacity)
      local function fill_row(row, capacity)
        local function fill_cell(cell, capacity)
          if cell == 1 then
            return capacity
          else
            return 0
          end
        end
        return map(fill_cell, row, capacity)
      end
      return map(fill_row, grid, capacity)
    end
    local function sum_grid(grid)
      local function sum_row(row)
        local function sum_cell(cell)
          return cell
        end
        return reduce(sum_cell, row, 0)
      end
      return reduce(sum_row, grid, 0)
    end
    local function sum_rows(grid)
      local function sum_row(row)
        local function sum_cell(cell)
          return cell
        end
        return reduce(sum_cell, row, 0)
      end
      return map(sum_row, grid)
    end
    local function sum_cols(grid)
      local function sum_col(col)
        local function sum_cell(cell)
          return cell
        end
        return reduce(sum_cell, col, 0)
      end
      return map(sum_col, transpose(grid))
    end
    local function max_row(grid)
      local function max_row(row)
        local function max_cell(cell)
          return cell
        end
        return reduce(max_cell, row, 0)
      end
      return reduce(max_row, grid, 0)
    end
    local function max_col(grid)
      local function max_col(col)
        local function max_cell(cell)
          return cell
        end
        return reduce(max_cell, col, 0)
      end
      return reduce(max_col, transpose(grid), 0)
    end
    local function max_fill_row(grid, capacity)
      local function max_fill_cell(cell, capacity)
        if cell == 1 then
          return capacity
        else
          return 0
        end
      end
      return map(max_fill_cell, grid, capacity)
    end
    local function
- |2-
      local function fill(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_well(well, capacity)
                  if well == 0 then
                      return 0
                  else
                      return capacity
                  end
              end
              return map(fill_well, row)
          end
          return map(fill_row, grid)
      end
      local function reduce(grid, capacity)
          local function reduce_row(row, capacity)
              local function reduce_well(well, capacity)
                  if well > capacity then
                      return capacity
                  else
                      return well
                  end
              end
              return map(reduce_well, row)
          end
          return map(reduce_row, grid)
      end
      local function sum(grid)
          local function sum_row(row)
              local function sum_well(well)
                  return well
              end
              return reduce(sum_well, row)
          end
          return reduce(sum_row, grid)
      end
      local function fill_and_reduce(grid, capacity)
          return reduce(fill(grid, capacity), capacity)
      end
      local function fill_and_reduce_until_empty(grid, capacity)
          local function is_empty(grid)
              local function is_empty_row(row)
                  local function is_empty_well(well)
                      return well == 0
                  end
                  return all(is_empty_well, row)
              end
              return all(is_empty_row, grid)
          end
          local function fill_and_reduce_until_empty_helper(grid, capacity, count)
              if is_empty(grid) then
                  return count
              else
                  return fill_and_reduce_until_empty_helper(fill_and_reduce(grid, capacity), capacity, count + 1)
              end
          end
          return fill_and_reduce_until_empty_helper(grid, capacity, 0)
      end
      return sum(fill_and_reduce_until_empty(grid, capacity))
  end
- |2-
      local function fill(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_cell(cell, capacity)
                  if cell == 0 then
                      return 0
                  else
                      return capacity
                  end
              end
              return map(fill_cell, row, capacity)
          end
          return map(fill_row, grid, capacity)
      end
      local function sum_grid(grid)
          local function sum_row(row)
              local function sum_cell(cell)
                  return cell
              end
              return reduce(sum_cell, row, 0)
          end
          return reduce(sum_row, grid, 0)
      end
      local function empty(grid)
          local function empty_row(row)
              local function empty_cell(cell)
                  return 0
              end
              return map(empty_cell, row)
          end
          return map(empty_row, grid)
      end
      local function max_fill_iter(grid, capacity, acc)
          if sum_grid(grid) == 0 then
              return acc
          else
              return max_fill_iter(empty(grid), capacity, acc + 1)
          end
      end
      return max_fill_iter(fill(grid, capacity), capacity, 0)
  end
- |2-
      local function get_max_fill(grid, capacity)
          local max_fill = 0
          for i = 1, #grid do
              local row = grid[i]
              local row_fill = 0
              for j = 1, #row do
                  local cell = row[j]
                  if cell == 1 then
                      row_fill = row_fill + 1
                  end
              end
              if row_fill > max_fill then
                  max_fill = row_fill
              end
          end
          return max_fill
      end
      local max_fill = get_max_fill(grid, capacity)
      return max_fill * capacity
  end
- |2-
      local function fill(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_cell(cell, capacity)
                  if cell == 0 then
                      return 0
                  else
                      return capacity
                  end
              end
              return map(fill_cell, row, capacity)
          end
          return map(fill_row, grid, capacity)
      end
      local function sum_grid(grid)
          local function sum_row(row)
              local function sum_cell(cell)
                  return cell
              end
              return reduce(sum_cell, row, 0)
          end
          return reduce(sum_row, grid, 0)
      end
      local function empty(grid)
          local function empty_row(row)
              local function empty_cell(cell)
                  return 0
              end
              return map(empty_cell, row)
          end
          return map(empty_row, grid)
      end
      local function fill_and_empty(grid, capacity)
          local filled = fill(grid, capacity)
          local emptied = empty(filled)
          return filled, emptied
      end
      local function fill_and_empty_n(grid, capacity, n)
          local function fill_and_empty_n_iter(grid, capacity, n, acc)
              if n == 0 then
                  return acc
              else
                  local filled, emptied = fill_and_empty(grid, capacity)
                  return fill_and_empty_n_iter(emptied, capacity, n - 1, acc + sum_grid(filled))
              end
          end
          return fill_and_empty_n_iter(grid, capacity, n, 0)
      end
      local function max_fill_iter(grid, capacity, acc)
          local filled, emptied = fill_and_empty(grid, capacity)
          local sum = sum_grid(filled)
          if sum == 0 then
              return acc
          else
              return max_fill_iter(emptied, capacity, acc + sum)
          end
      end
      return max_fill_iter(grid, capacity, 0)
  end
- |2-
      local function fill(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_cell(cell, capacity)
                  if cell == 0 then
                      return 0
                  else
                      return capacity
                  end
              end
              return map(fill_cell, row, capacity)
          end
          return map(fill_row, grid, capacity)
      end
      local function sum_grid(grid)
          local function sum_row(row)
              local function sum_cell(cell)
                  return cell
              end
              return reduce(sum_cell, row, 0)
          end
          return reduce(sum_row, grid, 0)
      end
      local function empty(grid)
          local function empty_row(row)
              local function empty_cell(cell)
                  return 0
              end
              return map(empty_cell, row)
          end
          return map(empty_row, grid)
      end
      local function is_empty(grid)
          local function is_empty_row(row)
              local function is_empty_cell(cell)
                  return cell == 0
              end
              return all(is_empty_cell, row)
          end
          return all(is_empty_row, grid)
      end
      local function fill_and_empty(grid, capacity)
          local filled = fill(grid, capacity)
          return sum_grid(filled), empty(filled)
      end
      local function fill_and_empty_until_empty(grid, capacity)
          local function fill_and_empty_until_empty_iter(grid, capacity, acc)
              if is_empty(grid) then
                  return acc
              else
                  local filled, empty = fill_and_empty(grid, capacity)
                  return fill_and_empty_until_empty_iter(empty, capacity, acc + filled)
              end
          end
          return fill_and_empty_until_empty_iter(grid, capacity, 0)
      end
      return fill_and_empty_until_empty(grid, capacity)
  end
- |2-
      local function fill(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_cell(cell, capacity)
                  if cell == 0 then
                      return 0
                  else
                      return capacity
                  end
              end
              return map(fill_cell, row, capacity)
          end
          return map(fill_row, grid, capacity)
      end
      local function sum_grid(grid)
          local function sum_row(row)
              local function sum_cell(cell)
                  return cell
              end
              return reduce(sum_cell, row, 0)
          end
          return reduce(sum_row, grid, 0)
      end
      local function sum_grid_rows(grid)
          local function sum_row(row)
              local function sum_cell(cell)
                  return cell
              end
              return reduce(sum_cell, row, 0)
          end
          return map(sum_row, grid)
      end
      local function sum_grid_cols(grid)
          local function sum_col(col)
              local function sum_cell(cell)
                  return cell
              end
              return reduce(sum_cell, col, 0)
          end
          return map(sum_col, zip(grid))
      end
      local function max_grid_row(grid)
          local function max_row(row)
              local function max_cell(cell)
                  return cell
              end
              return reduce(max_cell, row, 0)
          end
          return reduce(max_row, grid, 0)
      end
      local function max_grid_col(grid)
          local function max_col(col)
              local function max_cell(cell)
                  return cell
              end
              return reduce(max_cell, col, 0)
          end
          return reduce(max_col, zip(grid), 0)
      end
      local function fill_grid_rows(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_cell(cell, capacity)
                  if cell == 0 then
                      return 0
                  else
                      return capacity
                  end
              end
              return map(fill
- |2-
      local function fill_bucket(row, col)
          local water = 0
          for i = 1, row do
              water = water + grid[i][col]
          end
          return water
      end
- |2-
    local function fill(grid, capacity)
      local function fill_row(row, capacity)
        local function fill_cell(cell, capacity)
          if cell == 0 then
            return 0
          else
            return capacity
          end
        end
        return map(fill_cell, row, capacity)
      end
      return map(fill_row, grid, capacity)
    end
    local function sum_rows(grid)
      local function sum_row(row)
        return reduce(function(a, b) return a + b end, row, 0)
      end
      return map(sum_row, grid)
    end
    local function sum_grid(grid)
      return reduce(function(a, b) return a + b end, grid, 0)
    end
    return sum_grid(sum_rows(fill(grid, capacity)))
  end
- |2-
      local function fill(grid, capacity)
          local function fill_row(row, capacity)
              local filled = 0
              for i = 1, #row do
                  if row[i] == 1 then
                      filled = filled + 1
                      row[i] = 0
                  end
              end
              return filled
          end
          local filled = 0
          for i = 1, #grid do
              filled = filled + fill_row(grid[i], capacity)
          end
          return filled
      end
      local filled = 0
      while true do
          local new_filled = fill(grid, capacity)
          if new_filled == 0 then
              break
          end
          filled = filled + new_filled
      end
      return filled
  end
- |2
      local function fill(row, col)
          if row < 1 or row > #grid or col < 1 or col > #grid[1] then
              return 0
          end
          if grid[row][col] == 0 then
              return 0
          end
          grid[row][col] = 0
          return 1 + fill(row + 1, col) + fill(row - 1, col) + fill(row, col + 1) + fill(row, col - 1)
      end
      local function fill_row(row)
          local count = 0
          for col = 1, #grid[1] do
              if grid[row][col] == 1 then
                  count = count + 1
              end
          end
          return count
      end
      local function fill_col(col)
          local count = 0
          for row = 1, #grid do
              if grid[row][col] == 1 then
                  count = count + 1
              end
          end
          return count
      end
      local function fill_grid()
          local count = 0
          for row = 1, #grid do
              for col = 1, #grid[1] do
                  if grid[row][col] == 1 then
                      count = count + fill(row, col)
                  end
              end
          end
          return count
      end
      local function fill_row_col()
          local count = 0
          for row = 1, #grid do
              count = count + fill_row(row)
          end
          for col = 1, #grid[1] do
              count = count + fill_col(col)
          end
          return count
      end
      local function fill_row_col_grid()
          local count = 0
          for row = 1, #grid do
              count = count + fill_row(row)
          end
          for col = 1, #grid[1] do
              count = count + fill_col(col)
          end
          count = count + fill_grid()
          return count
      end
      local function fill_row_grid()
          local count = 0
          for row = 1, #grid do
              count = count + fill_row(row)
- |2-
    local function fill_bucket(row, col)
      if grid[row][col] == 1 then
        grid[row][col] = 0
        return 1
      end
      return 0
    end
    local function fill_row(row)
      local filled = 0
      for col = 1, #grid[row] do
        filled = filled + fill_bucket(row, col)
      end
      return filled
    end
    local function fill_grid()
      local filled = 0
      for row = 1, #grid do
        filled = filled + fill_row(row)
      end
      return filled
    end
    local function fill_wells()
      local filled = 0
      while fill_grid() > 0 do
        filled = filled + 1
      end
      return filled
    end
    local function fill_wells_with_capacity()
      local filled = 0
      for i = 1, capacity do
        filled = filled + fill_wells()
      end
      return filled
    end
    return fill_wells_with_capacity()
  end
- |2-
      local function get_max_fill(grid, capacity)
          local max_fill = 0
          for i = 1, #grid do
              local row = grid[i]
              local fill = 0
              for j = 1, #row do
                  if row[j] == 1 then
                      fill = fill + 1
                  end
              end
              if fill > max_fill then
                  max_fill = fill
              end
          end
          return max_fill
      end
      local max_fill = get_max_fill(grid, capacity)
      local drops = 0
      while max_fill > 0 do
          for i = 1, #grid do
              local row = grid[i]
              for j = 1, #row do
                  if row[j] == 1 then
                      row[j] = 0
                      max_fill = max_fill - 1
                  end
              end
          end
          drops = drops + 1
      end
      return drops
  end
- |2-
      local function fill(grid, capacity)
          local function fill_row(row, capacity)
              local i = 1
              local n = #row
              local count = 0
              while i <= n do
                  if row[i] == 1 then
                      local j = i + 1
                      local c = capacity
                      while j <= n and c > 0 do
                          if row[j] == 1 then
                              row[j] = 0
                              c = c - 1
                          end
                          j = j + 1
                      end
                      count = count + 1
                  end
                  i = i + 1
              end
              return count
          end
          local count = 0
          for _, row in ipairs(grid) do
              count = count + fill_row(row, capacity)
          end
          return count
      end
      local count = 0
      while true do
          local c = fill(grid, capacity)
          if c == 0 then
              break
          end
          count = count + c
      end
      return count
  end
- |2-
    local rows = #grid
    local cols = #grid[1]
    local max_water = 0
    local max_water_count = 0
    for i = 1, rows do
      for j = 1, cols do
        if grid[i][j] == 1 then
          max_water = max_water + capacity
        end
      end
    end
    local function get_water(i, j)
      if i < 1 or i > rows or j < 1 or j > cols then
        return 0
      end
      if grid[i][j] == 1 then
        grid[i][j] = 0
        return capacity
      end
      return 0
    end
    local function get_water_count(i, j)
      local water = get_water(i, j)
      if water > 0 then
        max_water_count = max_water_count + 1
        water = water + get_water(i - 1, j)
        water = water + get_water(i + 1, j)
        water = water + get_water(i, j - 1)
        water = water + get_water(i, j + 1)
        if water > max_water then
          max_water = water
        end
      end
    end
    for i = 1, rows do
      for j = 1, cols do
        get_water_count(i, j)
      end
    end
    return max_water_count
  end
- |2-
      local rows = #grid
      local cols = #grid[1]
      local max_height = 0
      for i = 1, rows do
          for j = 1, cols do
              if grid[i][j] == 1 then
                  max_height = max_height + 1
              end
          end
      end
      local function fill(height)
          local count = 0
          for i = 1, rows do
              for j = 1, cols do
                  if grid[i][j] == 1 then
                      count = count + 1
                  end
              end
          end
          return count
      end
      local function is_filled(height)
          for i = 1, rows do
              for j = 1, cols do
                  if grid[i][j] == 1 then
                      return false
                  end
              end
          end
          return true
      end
      local function lower(height)
          for i = 1, rows do
              for j = 1, cols do
                  if grid[i][j] == 1 then
                      grid[i][j] = 0
                  end
              end
          end
      end
      local function raise(height)
          for i = 1, rows do
              for j = 1, cols do
                  if grid[i][j] == 0 then
                      grid[i][j] = 1
                  end
              end
          end
      end
      local function binary_search(low, high)
          if low == high then
              return low
          end
          local mid = math.floor((low + high) / 2)
          if is_filled(mid) then
              return binary_search(low, mid)
          else
              return binary_search(mid + 1, high)
          end
      end
      return binary_search(0, max_height)
  end
- |2-
    local function fill_bucket(row, col)
      local bucket = capacity
      local i = row
      while i > 0 and bucket > 0 do
        if grid[i][col] == 1 then
          grid[i][col] = 0
          bucket = bucket - 1
        end
        i = i - 1
      end
    end
    local function fill_wells(row)
      for col = 1, #grid[row] do
        if grid[row][col] == 1 then
          fill_bucket(row, col)
        end
      end
    end
    local function count_fill()
      local count = 0
      for row = 1, #grid do
        for col = 1, #grid[row] do
          if grid[row][col] == 1 then
            count = count + 1
          end
        end
      end
      return count
    end
    local function fill_all()
      local count = 0
      while count_fill() > 0 do
        for row = 1, #grid do
          fill_wells(row)
        end
        count = count + 1
      end
      return count
    end
    return fill_all()
  end
- |2-
      local max_fill = 0
      local row_count = #grid
      local col_count = #grid[1]
      local row_fill = {}
      local col_fill = {}
      for i = 1, row_count do
          row_fill[i] = 0
          for j = 1, col_count do
              if grid[i][j] == 1 then
                  row_fill[i] = row_fill[i] + 1
              end
          end
      end
      for j = 1, col_count do
          col_fill[j] = 0
          for i = 1, row_count do
              if grid[i][j] == 1 then
                  col_fill[j] = col_fill[j] + 1
              end
          end
      end
      for i = 1, row_count do
          max_fill = max_fill + math.ceil(row_fill[i] / capacity)
      end
      for j = 1, col_count do
          max_fill = max_fill + math.ceil(col_fill[j] / capacity)
      end
      return max_fill
  end
- |2-
    local function fill_well(row, col)
      local water = 0
      for i = 1, capacity do
        if grid[row][col] == 1 then
          water = water + 1
          grid[row][col] = 0
        end
        row = row + 1
      end
      return water
    end
    local function fill_wells(col)
      local water = 0
      for row = 1, #grid do
        water = water + fill_well(row, col)
      end
      return water
    end
    local water = 0
    for col = 1, #grid[1] do
      water = water + fill_wells(col)
    end
    return water
  end
- |2-
      local function fill(row, col)
          if row == #grid or grid[row][col] == 0 then
              return 0
          end
          grid[row][col] = 0
          return 1 + fill(row + 1, col)
      end
      local function fill_row(row)
          local count = 0
          for i = 1, #grid[row] do
              if grid[row][i] == 1 then
                  count = count + fill(row, i)
              end
          end
          return count
      end
      local count = 0
      for i = 1, #grid do
          count = count + fill_row(i)
      end
      return count
  end
- |2-
      local function fill_bucket(bucket, row)
          local count = 0
          for i = 1, #row do
              if row[i] == 1 then
                  row[i] = 0
                  count = count + 1
              end
          end
          return count
      end
- |2-
    local function fill(row, col)
      if row < 1 or row > #grid or col < 1 or col > #grid[1] then
        return 0
      end
      if grid[row][col] == 0 then
        return 0
      end
      grid[row][col] = 0
      return 1 + fill(row - 1, col) + fill(row + 1, col) + fill(row, col - 1) + fill(row, col + 1)
    end
    local function count_fill(row, col)
      if row < 1 or row > #grid or col < 1 or col > #grid[1] then
        return 0
      end
      if grid[row][col] == 0 then
        return 0
      end
      return 1 + count_fill(row - 1, col) + count_fill(row + 1, col) + count_fill(row, col - 1) + count_fill(row, col + 1)
    end
    local function fill_all(row, col)
      local count = count_fill(row, col)
      if count > capacity then
        fill(row, col)
        return 1 + fill_all(row - 1, col) + fill_all(row + 1, col) + fill_all(row, col - 1) + fill_all(row, col + 1)
      end
      return 0
    end
    local function find_first_non_empty()
      for row = 1, #grid do
        for col = 1, #grid[1] do
          if grid[row][col] == 1 then
            return row, col
          end
        end
      end
      return nil
    end
    local row, col = find_first_non_empty()
    if row == nil then
      return 0
    end
    return fill_all(row, col)
  end
- |2-
    local function fill(grid, capacity)
      local function fill_row(row, capacity)
        local count = 0
        for i = 1, #row do
          if row[i] == 1 then
            row[i] = 0
            count = count + 1
          end
        end
        return count
      end
      local count = 0
      for i = 1, #grid do
        count = count + fill_row(grid[i], capacity)
      end
      return count
    end
    local count = 0
    while fill(grid, capacity) > 0 do
      count = count + 1
    end
    return count
  end
- |2-
      local function fill(i, j)
          if i >= #grid or j >= #grid[1] then
              return 0
          end
          local count = 0
          if grid[i][j] == 1 then
              grid[i][j] = 0
              count = 1
          end
          return count + fill(i, j + 1) + fill(i + 1, j)
      end
      local count = 0
      for i = 1, #grid do
          for j = 1, #grid[1] do
              count = count + fill(i, j)
          end
      end
      return math.ceil(count / capacity)
  end
- |2-
      local function fill(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_cell(cell, capacity)
                  if cell == 0 then
                      return capacity
                  else
                      return 0
                  end
              end
              return map(row, function(cell) return fill_cell(cell, capacity) end)
          end
          return map(grid, function(row) return fill_row(row, capacity) end)
      end
      local function count_filled(grid)
          local function count_filled_row(row)
              local function count_filled_cell(cell)
                  if cell > 0 then
                      return 1
                  else
                      return 0
                  end
              end
              return reduce(row, function(acc, cell) return acc + count_filled_cell(cell) end, 0)
          end
          return reduce(grid, function(acc, row) return acc + count_filled_row(row) end, 0)
      end
      local function count_filled_times(grid, capacity)
          local filled_times = 0
          local filled_grid = grid
          while count_filled(filled_grid) > 0 do
              filled_times = filled_times + 1
              filled_grid = fill(filled_grid, capacity)
          end
          return filled_times
      end
      return count_filled_times(grid, capacity)
  end
- |2-
      local rows = #grid
      local cols = #grid[1]
      local total = 0
      local max_height = 0
      for i = 1, rows do
          for j = 1, cols do
              if grid[i][j] == 1 then
                  total = total + 1
              end
              max_height = math.max(max_height, i)
          end
      end
      local function fill(grid, capacity, height)
          if height > max_height then
              return 0
          end
          local rows = #grid
          local cols = #grid[1]
          local filled = 0
          for i = 1, rows do
              for j = 1, cols do
                  if grid[i][j] == 1 then
                      filled = filled + 1
                  end
              end
          end
          if filled == 0 then
              return 0
          end
          local count = 0
          for i = 1, rows do
              for j = 1, cols do
                  if grid[i][j] == 1 then
                      local water = math.min(capacity, height - i + 1)
                      grid[i][j] = water
                      count = count + 1
                  end
              end
          end
          for i = 1, rows do
              for j = 1, cols do
                  if grid[i][j] > 0 then
                      grid[i][j] = grid[i][j] - 1
                  end
              end
          end
          return count + fill(grid, capacity, height + 1)
      end
      return fill(grid, capacity, 1)
  end
- |2-
      local function fill(grid, capacity)
          local max = 0
          for i = 1, #grid do
              local row = grid[i]
              local count = 0
              for j = 1, #row do
                  if row[j] == 1 then
                      count = count + 1
                  end
              end
              if count > max then
                  max = count
              end
          end
          return math.ceil(max / capacity)
      end
      return fill(grid, capacity)
  end
- |2-
    local function fill(grid, capacity)
      local function fill_row(row, capacity)
        local function fill_well(well, capacity)
          if well == 1 then
            return capacity
          else
            return 0
          end
        end
        local filled = 0
        for i, well in ipairs(row) do
          filled = filled + fill_well(well, capacity)
        end
        return filled
      end
      local filled = 0
      for i, row in ipairs(grid) do
        filled = filled + fill_row(row, capacity)
      end
      return filled
    end
    local function empty(grid, capacity)
      local function empty_row(row, capacity)
        local function empty_well(well, capacity)
          if well == 1 then
            return 1
          else
            return 0
          end
        end
        local emptied = 0
        for i, well in ipairs(row) do
          emptied = emptied + empty_well(well, capacity)
        end
        return emptied
      end
      local emptied = 0
      for i, row in ipairs(grid) do
        emptied = emptied + empty_row(row, capacity)
      end
      return emptied
    end
    local filled = fill(grid, capacity)
    local emptied = empty(grid, capacity)
    return filled + emptied
  end
- |2-
    local function fill(grid, capacity)
      local function fill_row(row, capacity)
        local function fill_cell(cell, capacity)
          if cell == 0 then
            return 0
          else
            return capacity
          end
        end
        return map(row, function(cell) return fill_cell(cell, capacity) end)
      end
      return map(grid, function(row) return fill_row(row, capacity) end)
    end
    local function sum_grid(grid)
      local function sum_row(row)
        local function sum_cell(cell)
          return cell
        end
        return reduce(row, function(a, b) return a + b end, 0)
      end
      return reduce(grid, function(a, b) return a + b end, 0)
    end
    local function empty(grid)
      local function empty_row(row)
        local function empty_cell(cell)
          return 0
        end
        return map(row, function(cell) return empty_cell(cell) end)
      end
      return map(grid, function(row) return empty_row(row) end)
    end
    local function fill_and_empty(grid, capacity)
      local filled = fill(grid, capacity)
      local emptied = empty(filled)
      return emptied
    end
    local function fill_and_empty_n(grid, capacity, n)
      local function fill_and_empty_n_iter(grid, capacity, n)
        if n == 0 then
          return grid
        else
          return fill_and_empty_n_iter(fill_and_empty(grid, capacity), capacity, n - 1)
        end
      end
      return fill_and_empty_n_iter(grid, capacity, n)
    end
    local function count_fill_and_empty(grid, capacity)
      local function count_fill_and_empty_iter(grid, capacity, n)
        local filled = fill(grid, capacity)
        local emptied = empty(filled)
        if grid == emptied then
          return n
        else
          return count_fill_and_empty_iter(emptied, capacity,
- |2-
      local function fill(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_cell(cell, capacity)
                  if cell == 0 then
                      return 0
                  else
                      return capacity
                  end
              end
              return map(fill_cell, row, capacity)
          end
          return map(fill_row, grid, capacity)
      end
      local function count_water(grid)
          local function count_row(row)
              local function count_cell(cell)
                  if cell == 0 then
                      return 0
                  else
                      return 1
                  end
              end
              return reduce(add, map(count_cell, row))
          end
          return reduce(add, map(count_row, grid))
      end
      local function empty(grid)
          local function empty_row(row)
              local function empty_cell(cell)
                  if cell == 0 then
                      return 0
                  else
                      return 1
                  end
              end
              return map(empty_cell, row)
          end
          return map(empty_row, grid)
      end
      local function is_empty(grid)
          local function is_row_empty(row)
              local function is_cell_empty(cell)
                  if cell == 0 then
                      return true
                  else
                      return false
                  end
              end
              return reduce(and, map(is_cell_empty, row))
          end
          return reduce(and, map(is_row_empty, grid))
      end
      local function max_fill_rec(grid, capacity, count)
          if is_empty(grid) then
              return count
          else
              return max_fill_rec(empty(grid), capacity, count + count_water(fill(grid, capacity)))
          end
      end
      return max_fill_rec(grid, capacity, 0)
  end
- |2-
      local function fill(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_cell(cell, capacity)
                  if cell == 0 then
                      return 0
                  else
                      return capacity
                  end
              end
              return map(fill_cell, row, capacity)
          end
          return map(fill_row, grid, capacity)
      end
      local function sum_grid(grid)
          local function sum_row(row)
              local function sum_cell(cell)
                  return cell
              end
              return reduce(sum_cell, row, 0)
          end
          return reduce(sum_row, grid, 0)
      end
      local function empty(grid)
          local function empty_row(row)
              local function empty_cell(cell)
                  return 0
              end
              return map(empty_cell, row)
          end
          return map(empty_row, grid)
      end
      local function max_fill_iter(grid, capacity, count)
          local filled = fill(grid, capacity)
          local sum = sum_grid(filled)
          if sum == 0 then
              return count
          else
              return max_fill_iter(empty(filled), capacity, count + 1)
          end
      end
      return max_fill_iter(grid, capacity, 0)
  end
- |2-
    local function fill(i, j)
      if i < 1 or i > #grid or j < 1 or j > #grid[1] or grid[i][j] == 0 then
        return 0
      end
      grid[i][j] = 0
      return 1 + fill(i - 1, j) + fill(i + 1, j) + fill(i, j - 1) + fill(i, j + 1)
    end
    local function empty(i, j)
      if i < 1 or i > #grid or j < 1 or j > #grid[1] or grid[i][j] == 1 then
        return 0
      end
      grid[i][j] = 1
      return 1 + empty(i - 1, j) + empty(i + 1, j) + empty(i, j - 1) + empty(i, j + 1)
    end
    local function fill_all()
      local count = 0
      for i = 1, #grid do
        for j = 1, #grid[1] do
          count = count + fill(i, j)
        end
      end
      return count
    end
    local function empty_all()
      local count = 0
      for i = 1, #grid do
        for j = 1, #grid[1] do
          count = count + empty(i, j)
        end
      end
      return count
    end
    local function fill_one()
      local count = 0
      for i = 1, #grid do
        for j = 1, #grid[1] do
          count = count + fill(i, j)
          if count >= capacity then
            return count
          end
        end
      end
      return count
    end
    local function empty_one()
      local count = 0
      for i = 1, #grid do
        for j = 1, #grid[1] do
          count = count + empty(i, j)
          if count >= capacity then
            return count
          end
        end
      end
      return count
    end
    local count = 0
    while fill_all() > 0 do
      count = count + 1
      if fill_one()
- |2-
    local function fill(grid, capacity)
      local function fill_row(row, capacity)
        local function fill_cell(cell, capacity)
          if cell == 1 then
            return capacity
          else
            return 0
          end
        end
        return map(row, function(cell) return fill_cell(cell, capacity) end)
      end
      return map(grid, function(row) return fill_row(row, capacity) end)
    end
    local function empty(grid, capacity)
      local function empty_row(row, capacity)
        local function empty_cell(cell, capacity)
          if cell == capacity then
            return 0
          else
            return cell
          end
        end
        return map(row, function(cell) return empty_cell(cell, capacity) end)
      end
      return map(grid, function(row) return empty_row(row, capacity) end)
    end
    local function count_filled(grid)
      local function count_filled_row(row)
        local function count_filled_cell(cell)
          if cell > 0 then
            return 1
          else
            return 0
          end
        end
        return reduce(row, function(acc, cell) return acc + count_filled_cell(cell) end, 0)
      end
      return reduce(grid, function(acc, row) return acc + count_filled_row(row) end, 0)
    end
    local function count_emptied(grid)
      local function count_emptied_row(row)
        local function count_emptied_cell(cell)
          if cell == 0 then
            return 1
          else
            return 0
          end
        end
        return reduce(row, function(acc, cell) return acc + count_emptied_cell(cell) end, 0)
      end
      return reduce(grid, function(acc, row) return acc + count_emptied_row(row) end, 0)
    end
    local function is_empty(grid)
      local function is_empty_row(row)
        local function is_empty_cell(cell)
          if cell == 0 then
            return true
          else
            return
- |2-
      local function fill_well(grid, capacity, row, col)
          local function fill_bucket(grid, capacity, row, col)
              local function fill_cell(grid, capacity, row, col)
                  if row < 1 or row > #grid or col < 1 or col > #grid[1] then
                      return 0
                  end
                  if grid[row][col] == 0 then
                      return 0
                  end
                  grid[row][col] = 0
                  return 1
              end
              local water = 0
              for i = row, 1, -1 do
                  water = water + fill_cell(grid, capacity, i, col)
                  if water == capacity then
                      return
                  end
              end
          end
          for i = 1, capacity do
              fill_bucket(grid, capacity, row, col)
          end
      end
      local function is_well_empty(grid, row, col)
          for i = 1, #grid[1] do
              if grid[row][i] == 1 then
                  return false
              end
          end
          return true
      end
      local function is_grid_empty(grid)
          for i = 1, #grid do
              for j = 1, #grid[1] do
                  if grid[i][j] == 1 then
                      return false
                  end
              end
          end
          return true
      end
      local function fill_grid(grid, capacity)
          local count = 0
          for i = 1, #grid do
              for j = 1, #grid[1] do
                  if grid[i][j] == 1 then
                      fill_well(grid, capacity, i, j)
                      count = count + 1
                  end
              end
          end
          return count
      end
      local function fill_grid_optimized(grid, capacity)
          local count = 0
          for i = 1, #grid do
              if not is_well_empty(grid, i, 1) then
                  fill_well(grid, capacity, i, 1)
                  count = count + 1
              end
          end
          return count
      end
      local function fill_grid_optimized_2(grid
- |2-
      local function max_fill_rec(grid, capacity, row, col, count)
          if row == #grid then
              return count
          end
          local next_row = row + 1
          local next_col = col + 1
          if next_col > #grid[next_row] then
              next_col = 1
          end
          if grid[row][col] == 1 then
              grid[row][col] = 0
              count = count + 1
          end
          if grid[next_row][next_col] == 1 then
              grid[next_row][next_col] = 0
              count = count + 1
          end
          return max_fill_rec(grid, capacity, next_row, next_col, count)
      end
      return max_fill_rec(grid, capacity, 1, 1, 0)
  end
- |2-
      local function fill(grid, capacity)
          local n = #grid
          local m = #grid[1]
          local function fill_row(row, capacity)
              local function fill_well(well, capacity)
                  if well == 0 then
                      return 0
                  else
                      return capacity
                  end
              end
              local function fill_wells(wells, capacity)
                  local function fill_wells_acc(wells, capacity, acc)
                      if #wells == 0 then
                          return acc
                      else
                          local well = table.remove(wells, 1)
                          local filled = fill_well(well, capacity)
                          return fill_wells_acc(wells, capacity, acc + filled)
                      end
                  end
                  return fill_wells_acc(wells, capacity, 0)
              end
              return fill_wells(row, capacity)
          end
          local function fill_rows(grid, capacity)
              local function fill_rows_acc(grid, capacity, acc)
                  if #grid == 0 then
                      return acc
                  else
                      local row = table.remove(grid, 1)
                      local filled = fill_row(row, capacity)
                      return fill_rows_acc(grid, capacity, acc + filled)
                  end
              end
              return fill_rows_acc(grid, capacity, 0)
          end
          return fill_rows(grid, capacity)
      end
      local function empty(grid, capacity)
          local n = #grid
          local m = #grid[1]
          local function empty_row(row, capacity)
              local function empty_well(well, capacity)
                  if well == 0 then
                      return 0
                  else
                      return capacity
                  end
              end
              local function empty_wells(wells, capacity)
                  local function empty_wells_acc(wells, capacity, acc)
                      if #wells == 0 then
                          return acc
                      else
                          local well = table.remove(wells, 1)
                          local emptied = empty_well(well, capacity)
                          return empty_wells_acc(wells, capacity, acc + emptied)
                      end
                  end
                  return
- |2-
    local function fill(row, col)
      if row < 1 or row > #grid or col < 1 or col > #grid[1] then
        return 0
      end
      if grid[row][col] == 0 then
        return 0
      end
      grid[row][col] = 0
      return 1 + fill(row - 1, col) + fill(row + 1, col) + fill(row, col - 1) + fill(row, col + 1)
    end
    local count = 0
    for row = 1, #grid do
      for col = 1, #grid[1] do
        if grid[row][col] == 1 then
          local filled = fill(row, col)
          count = count + math.ceil(filled / capacity)
        end
      end
    end
    return count
  end
- |2-
      local function fill(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_cell(cell, capacity)
                  if cell == 0 then
                      return 0
                  else
                      return capacity
                  end
              end
              return map(fill_cell, row, capacity)
          end
          return map(fill_row, grid, capacity)
      end
      local function count_water(grid)
          local function count_row(row)
              local function count_cell(cell)
                  if cell > 0 then
                      return 1
                  else
                      return 0
                  end
              end
              return sum(map(count_cell, row))
          end
          return sum(map(count_row, grid))
      end
      local function drain(grid)
          local function drain_row(row)
              local function drain_cell(cell)
                  if cell > 0 then
                      return cell - 1
                  else
                      return 0
                  end
              end
              return map(drain_cell, row)
          end
          return map(drain_row, grid)
      end
      local function is_empty(grid)
          local function is_empty_row(row)
              local function is_empty_cell(cell)
                  if cell > 0 then
                      return false
                  else
                      return true
                  end
              end
              return all(map(is_empty_cell, row))
          end
          return all(map(is_empty_row, grid))
      end
      local function count_fills(grid, capacity)
          local count = 0
          while not is_empty(grid) do
              grid = fill(grid, capacity)
              grid = drain(grid)
              count = count + 1
          end
          return count
      end
      return count_fills(grid, capacity)
  end
- |2-
      local max_fill = 0
      local row_count = #grid
      local col_count = #grid[1]
      local row_fill = {}
      for row_index = 1, row_count do
          local row = grid[row_index]
          local row_fill_count = 0
          for col_index = 1, col_count do
              local cell = row[col_index]
              if cell == 1 then
                  row_fill_count = row_fill_count + 1
              end
          end
          row_fill[row_index] = row_fill_count
      end
      local col_fill = {}
      for col_index = 1, col_count do
          local col_fill_count = 0
          for row_index = 1, row_count do
              local cell = grid[row_index][col_index]
              if cell == 1 then
                  col_fill_count = col_fill_count + 1
              end
          end
          col_fill[col_index] = col_fill_count
      end
      for row_index = 1, row_count do
          local row_fill_count = row_fill[row_index]
          if row_fill_count > 0 then
              local row_fill_count_per_bucket = math.ceil(row_fill_count / capacity)
              max_fill = max_fill + row_fill_count_per_bucket
          end
      end
      for col_index = 1, col_count do
          local col_fill_count = col_fill[col_index]
          if col_fill_count > 0 then
              local col_fill_count_per_bucket = math.ceil(col_fill_count / capacity)
              max_fill = max_fill + col_fill_count_per_bucket
          end
      end
      return max_fill
  end
- |2-
      local rows = #grid
      local cols = #grid[1]
      local result = 0
      for i = 1, rows do
          for j = 1, cols do
              if grid[i][j] == 1 then
                  result = result + capacity
              else
                  result = result + 1
              end
          end
      end
      return result
  end
- |2-
      local rows = #grid
      local cols = #grid[1]
      local max_row_sum = 0
      for i = 1, rows do
          local row_sum = 0
          for j = 1, cols do
              row_sum = row_sum + grid[i][j]
          end
          max_row_sum = math.max(max_row_sum, row_sum)
      end
      return max_row_sum * capacity
  end
- |2-
      local function fill(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_cell(cell, capacity)
                  if cell == 0 then
                      return 0
                  else
                      return capacity
                  end
              end
              return map(row, function(cell) return fill_cell(cell, capacity) end)
          end
          return map(grid, function(row) return fill_row(row, capacity) end)
      end
      local function sum_grid(grid)
          local function sum_row(row)
              local function sum_cell(cell)
                  return cell
              end
              return reduce(row, function(acc, cell) return acc + sum_cell(cell) end, 0)
          end
          return reduce(grid, function(acc, row) return acc + sum_row(row) end, 0)
      end
      local function max_grid(grid)
          local function max_row(row)
              local function max_cell(cell)
                  return cell
              end
              return reduce(row, function(acc, cell) return math.max(acc, max_cell(cell)) end, 0)
          end
          return reduce(grid, function(acc, row) return math.max(acc, max_row(row)) end, 0)
      end
      local function fill_grid(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_cell(cell, capacity)
                  if cell == 0 then
                      return 0
                  else
                      return capacity
                  end
              end
              return map(row, function(cell) return fill_cell(cell, capacity) end)
          end
          return map(grid, function(row) return fill_row(row, capacity) end)
      end
      local function fill_grid_with_max(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_cell(cell, capacity)
                  if cell == 0 then
                      return 0
                  else
                      return capacity
                  end
              end
              return map(row, function(cell) return fill_cell(cell, capacity) end)
          end
          return map(grid,
- |2-
      local function fill(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_cell(cell, capacity)
                  if cell == 0 then
                      return 0
                  else
                      return capacity
                  end
              end
              return map(row, function(cell) return fill_cell(cell, capacity) end)
          end
          return map(grid, function(row) return fill_row(row, capacity) end)
      end
      local function max_fill_row(row)
          local function max_fill_cell(cell)
              if cell == 0 then
                  return 0
              else
                  return 1
              end
          end
          return sum(map(row, function(cell) return max_fill_cell(cell, capacity) end))
      end
      local function max_fill_grid(grid)
          return sum(map(grid, function(row) return max_fill_row(row) end))
      end
      return max_fill_grid(fill(grid, capacity))
  end
- |2-
      local function get_max_fill(grid, capacity)
          local max_fill = 0
          for i = 1, #grid do
              local row = grid[i]
              local fill = 0
              for j = 1, #row do
                  local cell = row[j]
                  if cell == 1 then
                      fill = fill + 1
                  else
                      if fill > 0 then
                          max_fill = max_fill + 1
                          fill = 0
                      end
                  end
              end
              if fill > 0 then
                  max_fill = max_fill + 1
              end
          end
          return max_fill
      end
      local function get_max_fill_optimized(grid, capacity)
          local max_fill = 0
          for i = 1, #grid do
              local row = grid[i]
              local fill = 0
              for j = 1, #row do
                  local cell = row[j]
                  if cell == 1 then
                      fill = fill + 1
                  else
                      if fill > 0 then
                          max_fill = max_fill + 1
                          fill = 0
                      end
                  end
              end
              if fill > 0 then
                  max_fill = max_fill + 1
              end
          end
          return max_fill
      end
      return get_max_fill_optimized(grid, capacity)
  end
- |2-
      local function fill(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_cell(cell, capacity)
                  if cell == 0 then
                      return 0
                  else
                      return capacity
                  end
              end
              return map(fill_cell, row, capacity)
          end
          return map(fill_row, grid, capacity)
      end
      local function sum_grid(grid)
          local function sum_row(row)
              local function sum_cell(cell)
                  return cell
              end
              return reduce(sum_cell, row, 0)
          end
          return reduce(sum_row, grid, 0)
      end
      local function empty(grid)
          local function empty_row(row)
              local function empty_cell(cell)
                  return 0
              end
              return map(empty_cell, row)
          end
          return map(empty_row, grid)
      end
      local function fill_and_empty(grid, capacity)
          local filled = fill(grid, capacity)
          local emptied = empty(filled)
          return filled, emptied
      end
      local function fill_and_empty_n(grid, capacity, n)
          local function fill_and_empty_n_iter(grid, capacity, n, acc)
              if n == 0 then
                  return acc
              else
                  local filled, emptied = fill_and_empty(grid, capacity)
                  return fill_and_empty_n_iter(emptied, capacity, n - 1, acc + sum_grid(filled))
              end
          end
          return fill_and_empty_n_iter(grid, capacity, n, 0)
      end
      local function max_fill_iter(grid, capacity, acc)
          local filled, emptied = fill_and_empty(grid, capacity)
          local filled_sum = sum_grid(filled)
          if filled_sum == 0 then
              return acc
          else
              return max_fill_iter(emptied, capacity, acc + filled_sum)
          end
      end
      return max_fill_iter(grid, capacity, 0)
  end
- |2-
      local function max_fill_rec(grid, capacity, i, j)
          if i == #grid then
              return 0
          end
          if j == #grid[i] then
              return max_fill_rec(grid, capacity, i + 1, 1)
          end
          if grid[i][j] == 0 then
              return max_fill_rec(grid, capacity, i, j + 1)
          end
          local res = 0
          for k = 1, capacity do
              grid[i][j] = grid[i][j] - 1
              res = res + 1
              if grid[i][j] == 0 then
                  break
              end
          end
          return res + max_fill_rec(grid, capacity, i, j + 1)
      end
      return max_fill_rec(grid, capacity, 1, 1)
  end
- |2-
      local function fill(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_cell(cell, capacity)
                  if cell == 0 then
                      return 0
                  else
                      return capacity
                  end
              end
              return map(fill_cell, row, capacity)
          end
          return map(fill_row, grid, capacity)
      end
      local function sum_grid(grid)
          local function sum_row(row)
              local function sum_cell(cell)
                  return cell
              end
              return reduce(sum_cell, row, 0)
          end
          return reduce(sum_row, grid, 0)
      end
      local function empty(grid)
          local function empty_row(row)
              local function empty_cell(cell)
                  return 0
              end
              return map(empty_cell, row)
          end
          return map(empty_row, grid)
      end
      local function fill_and_empty(grid, capacity)
          local filled = fill(grid, capacity)
          local emptied = empty(filled)
          return emptied
      end
      local function fill_and_empty_n(grid, capacity, n)
          local function fill_and_empty_n_iter(grid, capacity, n)
              if n == 0 then
                  return grid
              else
                  return fill_and_empty_n_iter(fill_and_empty(grid, capacity), capacity, n - 1)
              end
          end
          return fill_and_empty_n_iter(grid, capacity, n)
      end
      local function fill_and_empty_until_empty(grid, capacity)
          local function fill_and_empty_until_empty_iter(grid, capacity, n)
              local filled = fill_and_empty(grid, capacity)
              if sum_grid(filled) == 0 then
                  return n
              else
                  return fill_and_empty_until_empty_iter(filled, capacity, n + 1)
              end
          end
          return fill_and_empty_until_empty_iter(grid, capacity, 0)
      end
      return fill_and_empty_until_empty(
- |2-
      local function fill(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_cell(cell, capacity)
                  if cell == 0 then
                      return 0
                  else
                      return capacity
                  end
              end
              return map(fill_cell, row, capacity)
          end
          return map(fill_row, grid, capacity)
      end
      local function sum_grid(grid)
          local function sum_row(row)
              local function sum_cell(cell)
                  return cell
              end
              return reduce(sum_cell, row, 0)
          end
          return reduce(sum_row, grid, 0)
      end
      local function empty(grid)
          local function empty_row(row)
              local function empty_cell(cell)
                  return 0
              end
              return map(empty_cell, row)
          end
          return map(empty_row, grid)
      end
      local function fill_and_empty(grid, capacity)
          return empty(fill(grid, capacity))
      end
      local function fill_and_empty_n_times(grid, capacity, n)
          local function fill_and_empty_n_times_helper(grid, capacity, n)
              if n == 0 then
                  return grid
              else
                  return fill_and_empty_n_times_helper(fill_and_empty(grid, capacity), capacity, n - 1)
              end
          end
          return fill_and_empty_n_times_helper(grid, capacity, n)
      end
      local function find_n(grid, capacity)
          local function find_n_helper(grid, capacity, n)
              if sum_grid(fill_and_empty_n_times(grid, capacity, n)) == 0 then
                  return n
              else
                  return find_n_helper(grid, capacity, n + 1)
              end
          end
          return find_n_helper(grid, capacity, 0)
      end
      return find_n(grid, capacity)
  end
- |2-
      local n = #grid
      local m = #grid[1]
      local count = 0
      local function fill(i, j)
          if i > n or j > m then
              return
          end
          if grid[i][j] == 1 then
              grid[i][j] = 0
              count = count + 1
              fill(i, j + 1)
              fill(i + 1, j)
          end
      end
      for i = 1, n do
          for j = 1, m do
              if grid[i][j] == 1 then
                  fill(i, j)
              end
          end
      end
      return count
  end
- |2-
      local function fill(grid, capacity)
          local max_fill = 0
          for i = 1, #grid do
              local fill = 0
              for j = 1, #grid[i] do
                  if grid[i][j] == 1 then
                      fill = fill + 1
                  end
              end
              if fill > max_fill then
                  max_fill = fill
              end
          end
          return math.ceil(max_fill / capacity)
      end
      return fill(grid, capacity)
  end
- |2-
      local function fill(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_cell(cell, capacity)
                  if cell == 0 then
                      return 0
                  else
                      return capacity
                  end
              end
              return map(fill_cell, row, capacity)
          end
          return map(fill_row, grid, capacity)
      end
      local function sum_grid(grid)
          local function sum_row(row)
              local function sum_cell(cell)
                  return cell
              end
              return reduce(sum_cell, row, 0)
          end
          return reduce(sum_row, grid, 0)
      end
      return sum_grid(fill(grid, capacity))
  end
- |2-
      local rows = #grid
      local cols = #grid[1]
      local count = 0
      local function fill(row, col)
          if row < 1 or row > rows or col < 1 or col > cols then
              return
          end
          if grid[row][col] == 1 then
              grid[row][col] = 0
              count = count + 1
              fill(row - 1, col)
              fill(row + 1, col)
              fill(row, col - 1)
              fill(row, col + 1)
          end
      end
      for row = 1, rows do
          for col = 1, cols do
              if grid[row][col] == 1 then
                  fill(row, col)
              end
          end
      end
      return count
  end
- |2-
      local rows = #grid
      local cols = #grid[1]
      local total_water = 0
      local buckets = 0
      local i = 1
      local j = 1
      while i <= rows do
          while j <= cols do
              if grid[i][j] == 1 then
                  total_water = total_water + 1
                  grid[i][j] = 0
              end
              j = j + 1
          end
          j = 1
          i = i + 1
      end
      buckets = math.ceil(total_water / capacity)
      return buckets
  end
- "    local function fill(grid, capacity)\n        local function fill_row(row, capacity)\n
  \           local function fill_cell(cell, capacity)\n                if cell ==
  0 then\n                    return 0\n                else\n                    return
  capacity\n                end\n            end\n            return table.map(row,
  fill_cell, capacity)\n        end\n        return table.map(grid, fill_row, capacity)\n
  \   end\n    local function sum_grid(grid)\n        local function sum_row(row)\n
  \           return table.reduce(row, function(a, b) return a + b end, 0)\n        end\n
  \       return table.reduce(grid, sum_row, 0)\n    end\n    local function fill_grid(grid,
  capacity)\n        local function fill_row(row, capacity)\n            local function
  fill_cell(cell, capacity)\n                if cell == 0 then\n                    return
  0\n                else\n                    if capacity >= cell then\n                        return
  0\n                    else\n                        return cell - capacity\n                    end\n
  \               end\n            end\n            return table.map(row, fill_cell,
  capacity)\n        end\n        return table.map(grid, fill_row, capacity)\n    end\n
  \   local function fill_grid_with_capacity(grid, capacity)\n        local function
  fill_row(row, capacity)\n            local function fill_cell(cell, capacity)\n
  \               if cell == 0 then\n                    return 0\n                else\n
  \                   if capacity >= cell then\n                        return 0\n
  \                   else\n                        return cell - capacity\n                    end\n
  \               end\n            end\n            return table.map(row, fill_cell,
  capacity)\n        end\n        return table.map(grid, fill_row, capacity)\n    end\n
  \   local function fill_grid_with_capacity(grid, capacity)\n        local function
  fill_row(row, capacity)\n            local function fill_cell(cell, capacity)\n
  \               if cell == 0 then\n                    return 0\n                else\n
  \                   if capacity >= cell then\n                        return 0\n
  \                   else\n                        return cell - capacity\n                    end\n
  \               end\n            end\n            return table.map(row, fill_cell,
  capacity)\n        end\n        return table.map(grid, fill_row, capacity)\n   "
- |2-
      local function fill(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_cell(cell, capacity)
                  if cell == 0 then
                      return 0
                  else
                      return capacity
                  end
              end
              return map(fill_cell, row, capacity)
          end
          return map(fill_row, grid, capacity)
      end
      local function sum_grid(grid)
          local function sum_row(row)
              local function sum_cell(cell)
                  return cell
              end
              return reduce(sum_cell, row, 0)
          end
          return reduce(sum_row, grid, 0)
      end
      local function empty(grid)
          local function empty_row(row)
              local function empty_cell(cell)
                  return 0
              end
              return map(empty_cell, row)
          end
          return map(empty_row, grid)
      end
      local function max_fill_rec(grid, capacity, count)
          local filled = fill(grid, capacity)
          local filled_sum = sum_grid(filled)
          if filled_sum == 0 then
              return count
          else
              return max_fill_rec(empty(filled), capacity, count + filled_sum)
          end
      end
      return max_fill_rec(grid, capacity, 0)
  end
- |2-
    local function fill(grid, capacity)
      local function fill_row(row, capacity)
        local function fill_cell(cell, capacity)
          if cell == 1 then
            return capacity - 1
          else
            return capacity
          end
        end
        return map(row, function(cell) return fill_cell(cell, capacity) end)
      end
      return map(grid, function(row) return fill_row(row, capacity) end)
    end
    local function count_empties(grid)
      local function count_empties_row(row)
        local function count_empties_cell(cell)
          if cell == 0 then
            return 1
          else
            return 0
          end
        end
        return sum(map(row, function(cell) return count_empties_cell(cell) end))
      end
      return sum(map(grid, function(row) return count_empties_row(row) end))
    end
    local function is_empty(grid)
      local function is_empty_row(row)
        local function is_empty_cell(cell)
          if cell == 0 then
            return false
          else
            return true
          end
        end
        return all(map(row, function(cell) return is_empty_cell(cell) end))
      end
      return all(map(grid, function(row) return is_empty_row(row) end))
    end
    local function max_fill_rec(grid, capacity, count)
      if is_empty(grid) then
        return count
      else
        return max_fill_rec(fill(grid, capacity), capacity, count + 1)
      end
    end
    return max_fill_rec(grid, capacity, 0)
  end
- |2-
      local function fill(grid, capacity)
          local n = #grid
          local m = #grid[1]
          local count = 0
          for i = 1, n do
              for j = 1, m do
                  if grid[i][j] == 1 then
                      grid[i][j] = 0
                      count = count + 1
                      local k = i
                      while k <= n and capacity > 0 do
                          if grid[k][j] == 1 then
                              grid[k][j] = 0
                              capacity = capacity - 1
                          end
                          k = k + 1
                      end
                  end
              end
          end
          return count
      end
      local count = 0
      while fill(grid, capacity) > 0 do
          count = count + 1
      end
      return count
  end
- |2-
      local n = #grid
      local m = #grid[1]
      local function fill(i, j)
          local c = 0
          if grid[i][j] == 1 then
              grid[i][j] = 0
              c = 1
          end
          if i < n then
              c = c + fill(i + 1, j)
          end
          if j < m then
              c = c + fill(i, j + 1)
          end
          return c
      end
      local function fill_all()
          local c = 0
          for i = 1, n do
              for j = 1, m do
                  c = c + fill(i, j)
              end
          end
          return c
      end
      local c = 0
      while fill_all() > 0 do
          c = c + 1
      end
      return c
  end
- |2-
      local function fill(row, col)
          if row < 1 or row > #grid or col < 1 or col > #grid[1] then
              return 0
          end
          if grid[row][col] == 0 then
              return 0
          end
          grid[row][col] = 0
          return 1 + fill(row + 1, col) + fill(row - 1, col) + fill(row, col + 1) + fill(row, col - 1)
      end
      local function fill_all()
          local count = 0
          for row = 1, #grid do
              for col = 1, #grid[1] do
                  if grid[row][col] == 1 then
                      local filled = fill(row, col)
                      if filled > 0 then
                          count = count + 1
                      end
                  end
              end
          end
          return count
      end
      return fill_all()
  end
- "    local function fill(grid, capacity)\n        local function fill_row(row, capacity)\n
  \           local function fill_cell(cell, capacity)\n                if cell ==
  0 then\n                    return 0\n                else\n                    return
  capacity\n                end\n            end\n            return map(row, function(cell)
  return fill_cell(cell, capacity) end)\n        end\n        return map(grid, function(row)
  return fill_row(row, capacity) end)\n    end\n    local function sum_grid(grid)\n
  \       local function sum_row(row)\n            local function sum_cell(cell)\n
  \               return cell\n            end\n            return reduce(row, function(acc,
  cell) return acc + sum_cell(cell) end, 0)\n        end\n        return reduce(grid,
  function(acc, row) return acc + sum_row(row) end, 0)\n    end\n    local function
  sum_grid_rows(grid)\n        local function sum_row(row)\n            local function
  sum_cell(cell)\n                return cell\n            end\n            return
  reduce(row, function(acc, cell) return acc + sum_cell(cell) end, 0)\n        end\n
  \       return map(grid, function(row) return sum_row(row) end)\n    end\n    local
  function sum_grid_cols(grid)\n        local function sum_col(grid, col)\n            local
  function sum_cell(cell)\n                return cell\n            end\n            return
  reduce(map(grid, function(row) return row[col] end), function(acc, cell) return
  acc + sum_cell(cell) end, 0)\n        end\n        return map(grid[1], function(cell,
  col) return sum_col(grid, col) end)\n    end\n    local function max_grid(grid)\n
  \       local function max_row(row)\n            local function max_cell(cell)\n
  \               return cell\n            end\n            return reduce(row, function(acc,
  cell) return math.max(acc, max_cell(cell)) end, 0)\n        end\n        return
  reduce(grid, function(acc, row) return math.max(acc, max_row(row)) end, 0)\n    end\n
  \  "
- |2
    local function fill(grid, capacity)
      local function fill_row(row, capacity)
        local function fill_cell(cell, capacity)
          if cell == 1 then
            return capacity
          else
            return 0
          end
        end
        return map(fill_cell, row, capacity)
      end
      return map(fill_row, grid, capacity)
    end
    local function empty(grid, capacity)
      local function empty_row(row, capacity)
        local function empty_cell(cell, capacity)
          if cell == capacity then
            return 0
          else
            return cell
          end
        end
        return map(empty_cell, row, capacity)
      end
      return map(empty_row, grid, capacity)
    end
    local function count_fill(grid, capacity)
      local function count_fill_row(row, capacity)
        local function count_fill_cell(cell, capacity)
          if cell == capacity then
            return 1
          else
            return 0
          end
        end
        return sum(map(count_fill_cell, row, capacity))
      end
      return sum(map(count_fill_row, grid, capacity))
    end
    local function count_empty(grid, capacity)
      local function count_empty_row(row, capacity)
        local function count_empty_cell(cell, capacity)
          if cell == 0 then
            return 1
          else
            return 0
          end
        end
        return sum(map(count_empty_cell, row, capacity))
      end
      return sum(map(count_empty_row, grid, capacity))
    end
    local function count_fill_and_empty(grid, capacity)
      return count_fill(grid, capacity) + count_empty(grid, capacity)
    end
    local function is_empty(grid, capacity)
      local function is_empty_row(row, capacity)
        local function is_empty_cell(cell, capacity)
          if cell == 0 then
            return true
          else
            return false
          end
        end
        return all(map(is_empty_cell, row, capacity))
      end
- |2-
      local function fill(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_cell(cell, capacity)
                  if cell == 0 then
                      return 0
                  else
                      return capacity
                  end
              end
              return map(fill_cell, row, capacity)
          end
          return map(fill_row, grid, capacity)
      end
      local function sum_grid(grid)
          local function sum_row(row)
              local function sum_cell(cell)
                  return cell
              end
              return reduce(sum_cell, row, 0)
          end
          return reduce(sum_row, grid, 0)
      end
      local function empty(grid)
          local function empty_row(row)
              local function empty_cell(cell)
                  return 0
              end
              return map(empty_cell, row)
          end
          return map(empty_row, grid)
      end
      local function max_fill_rec(grid, capacity, count)
          local filled = fill(grid, capacity)
          local sum = sum_grid(filled)
          if sum == 0 then
              return count
          else
              return max_fill_rec(empty(filled), capacity, count + 1)
          end
      end
      return max_fill_rec(grid, capacity, 0)
  end
- |2-
      local function fill(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_cell(cell, capacity)
                  if cell == 0 then
                      return 0
                  else
                      return capacity
                  end
              end
              return map(fill_cell, row, capacity)
          end
          return map(fill_row, grid, capacity)
      end
      local function sum_grid(grid)
          local function sum_row(row)
              local function sum_cell(cell)
                  return cell
              end
              return reduce(sum_cell, row, 0)
          end
          return reduce(sum_row, grid, 0)
      end
      local function empty(grid)
          local function empty_row(row)
              local function empty_cell(cell)
                  return 0
              end
              return map(empty_cell, row)
          end
          return map(empty_row, grid)
      end
      local function max_fill_iter(grid, capacity, count)
          if sum_grid(grid) == 0 then
              return count
          else
              return max_fill_iter(empty(grid), capacity, count + 1)
          end
      end
      return max_fill_iter(fill(grid, capacity), capacity, 0)
  end
- "    local function fill(grid, capacity)\n        local function fill_row(row, capacity)\n
  \           local function fill_cell(cell, capacity)\n                if cell ==
  0 then\n                    return 0\n                else\n                    return
  capacity\n                end\n            end\n            return map(row, function(cell)
  return fill_cell(cell, capacity) end)\n        end\n        return map(grid, function(row)
  return fill_row(row, capacity) end)\n    end\n    local function sum_grid(grid)\n
  \       local function sum_row(row)\n            local function sum_cell(cell)\n
  \               return cell\n            end\n            return reduce(row, function(acc,
  cell) return acc + sum_cell(cell) end, 0)\n        end\n        return reduce(grid,
  function(acc, row) return acc + sum_row(row) end, 0)\n    end\n    local function
  empty(grid)\n        local function empty_row(row)\n            local function empty_cell(cell)\n
  \               return 0\n            end\n            return map(row, function(cell)
  return empty_cell(cell) end)\n        end\n        return map(grid, function(row)
  return empty_row(row) end)\n    end\n    local function fill_and_empty(grid, capacity)\n
  \       local filled = fill(grid, capacity)\n        local emptied = empty(filled)\n
  \       return emptied\n    end\n    local function fill_and_empty_n_times(grid,
  capacity, n)\n        local function fill_and_empty_n_times_iter(grid, capacity,
  n, acc)\n            if n == 0 then\n                return acc\n            else\n
  \               local filled_and_emptied = fill_and_empty(grid, capacity)\n                return
  fill_and_empty_n_times_iter(filled_and_emptied, capacity, n - 1, acc + sum_grid(filled_and_emptied))\n
  \           end\n        end\n        return fill_and_empty_n_times_iter(grid, capacity,
  n, 0)\n    end\n    local function find_max_fill(grid, capacity)\n        local
  function find_max_fill_iter(grid, capacity, n, acc)\n           "
- |2-
      local function fill(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_cell(cell, capacity)
                  if cell == 0 then
                      return 0
                  else
                      return capacity
                  end
              end
              return map(fill_cell, row, capacity)
          end
          return map(fill_row, grid, capacity)
      end
      local function sum_grid(grid)
          local function sum_row(row)
              local function sum_cell(cell)
                  return cell
              end
              return reduce(sum_cell, row, 0)
          end
          return reduce(sum_row, grid, 0)
      end
      local function empty(grid)
          local function empty_row(row)
              local function empty_cell(cell)
                  return 0
              end
              return map(empty_cell, row)
          end
          return map(empty_row, grid)
      end
      local function max_fill_iter(grid, capacity, count)
          local filled = fill(grid, capacity)
          local filled_sum = sum_grid(filled)
          if filled_sum == 0 then
              return count
          else
              return max_fill_iter(empty(filled), capacity, count + filled_sum)
          end
      end
      return max_fill_iter(grid, capacity, 0)
  end
- |2-
      local function fill(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_cell(cell, capacity)
                  if cell == 0 then
                      return 0
                  else
                      return capacity
                  end
              end
              return map(fill_cell, row, capacity)
          end
          return map(fill_row, grid, capacity)
      end
      local function sum_grid(grid)
          local function sum_row(row)
              local function sum_cell(cell)
                  return cell
              end
              return reduce(sum_cell, row, 0)
          end
          return reduce(sum_row, grid, 0)
      end
      local function empty(grid)
          local function empty_row(row)
              local function empty_cell(cell)
                  return 0
              end
              return map(empty_cell, row)
          end
          return map(empty_row, grid)
      end
      local function sum_grid_and_empty(grid, capacity)
          return sum_grid(grid), empty(grid)
      end
      local function sum_grid_and_fill(grid, capacity)
          return sum_grid(grid), fill(grid, capacity)
      end
      local function sum_grid_and_fill_and_empty(grid, capacity)
          return sum_grid(grid), fill(grid, capacity), empty(grid)
      end
      local function sum_grid_and_fill_and_fill_and_empty(grid, capacity)
          return sum_grid(grid), fill(grid, capacity), fill(grid, capacity), empty(grid)
      end
      local function sum_grid_and_fill_and_fill_and_fill_and_empty(grid, capacity)
          return sum_grid(grid), fill(grid, capacity), fill(grid, capacity), fill(grid, capacity), empty(grid)
      end
      local function sum_grid_and_fill_and_fill_and_fill_and_fill_and_empty(grid, capacity)
          return sum_grid(grid), fill(grid, capacity), fill(grid, capacity), fill(grid, capacity), fill(grid, capacity), empty(grid
- |2-
      local function fill(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_cell(cell, capacity)
                  if cell == 0 then
                      return 0
                  else
                      return capacity
                  end
              end
              return map(fill_cell, row, capacity)
          end
          return map(fill_row, grid, capacity)
      end
      local function sum_rows(grid)
          local function sum_row(row)
              local function sum_cell(cell)
                  return cell
              end
              return reduce(sum_cell, row, 0)
          end
          return map(sum_row, grid)
      end
      local function sum_grid(grid)
          local function sum_row(acc, row)
              return acc + row
          end
          return reduce(sum_row, grid, 0)
      end
      return sum_grid(sum_rows(fill(grid, capacity)))
  end
- |2-
      local function fill(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_well(well, capacity)
                  if well == 1 then
                      return capacity
                  else
                      return 0
                  end
              end
              local function fill_wells(wells, capacity)
                  local function fill_wells_helper(wells, capacity, acc)
                      if #wells == 0 then
                          return acc
                      else
                          local well = table.remove(wells, 1)
                          local filled = fill_well(well, capacity)
                          return fill_wells_helper(wells, capacity, acc + filled)
                      end
                  end
                  return fill_wells_helper(wells, capacity, 0)
              end
              return fill_wells(row, capacity)
          end
          local function fill_rows(grid, capacity)
              local function fill_rows_helper(grid, capacity, acc)
                  if #grid == 0 then
                      return acc
                  else
                      local row = table.remove(grid, 1)
                      local filled = fill_row(row, capacity)
                      return fill_rows_helper(grid, capacity, acc + filled)
                  end
              end
              return fill_rows_helper(grid, capacity, 0)
          end
          return fill_rows(grid, capacity)
      end
      local function fill_until_empty(grid, capacity)
          local function fill_until_empty_helper(grid, capacity, acc)
              local filled = fill(grid, capacity)
              if filled == 0 then
                  return acc
              else
                  return fill_until_empty_helper(grid, capacity, acc + 1)
              end
          end
          return fill_until_empty_helper(grid, capacity, 0)
      end
      return fill_until_empty(grid, capacity)
  end
- |2-
    local function fill(grid, capacity)
      local function fill_row(row, capacity)
        local function fill_cell(cell, capacity)
          if cell == 0 then
            return 0
          else
            return capacity
          end
        end
        return map(row, function(cell) return fill_cell(cell, capacity) end)
      end
      return map(grid, function(row) return fill_row(row, capacity) end)
    end
    local function sum_grid(grid)
      local function sum_row(row)
        local function sum_cell(cell)
          return cell
        end
        return reduce(row, function(acc, cell) return acc + sum_cell(cell) end, 0)
      end
      return reduce(grid, function(acc, row) return acc + sum_row(row) end, 0)
    end
    local function fill_grid(grid, capacity)
      local function fill_row(row, capacity)
        local function fill_cell(cell, capacity)
          if cell == 0 then
            return 0
          else
            if capacity >= cell then
              return 0
            else
              return cell - capacity
            end
          end
        end
        return map(row, function(cell) return fill_cell(cell, capacity) end)
      end
      return map(grid, function(row) return fill_row(row, capacity) end)
    end
    local function fill_grid_rec(grid, capacity)
      local filled_grid = fill_grid(grid, capacity)
      local sum = sum_grid(filled_grid)
      if sum == 0 then
        return 0
      else
        return 1 + fill_grid_rec(filled_grid, capacity)
      end
    end
    return fill_grid_rec(fill(grid, capacity), capacity)
  end
- |2-
      local rows = #grid
      local cols = #grid[1]
      local buckets = {}
      local max_bucket = 0
      for i = 1, rows do
          buckets[i] = 0
          for j = 1, cols do
              if grid[i][j] == 1 then
                  buckets[i] = buckets[i] + 1
              end
          end
          max_bucket = math.max(max_bucket, buckets[i])
      end
      local max_bucket_count = math.ceil(max_bucket / capacity)
      local max_bucket_count_per_row = math.ceil(max_bucket_count / rows)
      local max_bucket_count_per_row_per_col = math.ceil(max_bucket_count_per_row / cols)
      local max_bucket_count_per_row_per_col_per_row = math.ceil(max_bucket_count_per_row_per_col / rows)
      return max_bucket_count_per_row_per_col_per_row
  end
- |2-
      local function fill(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_cell(cell, capacity)
                  if cell == 1 then
                      return math.min(capacity, 1)
                  else
                      return 0
                  end
              end
              return map(fill_cell, row, capacity)
          end
          return map(fill_row, grid, capacity)
      end
      local function empty(grid, capacity)
          local function empty_row(row, capacity)
              local function empty_cell(cell, capacity)
                  if cell == 0 then
                      return math.min(capacity, 1)
                  else
                      return 0
                  end
              end
              return map(empty_cell, row, capacity)
          end
          return map(empty_row, grid, capacity)
      end
      local function count(grid)
          local function count_row(row)
              local function count_cell(cell)
                  if cell == 1 then
                      return 1
                  else
                      return 0
                  end
              end
              return reduce(count_cell, row, 0)
          end
          return reduce(count_row, grid, 0)
      end
      local function is_empty(grid)
          local function is_empty_row(row)
              local function is_empty_cell(cell)
                  if cell == 0 then
                      return true
                  else
                      return false
                  end
              end
              return reduce(is_empty_cell, row, true)
          end
          return reduce(is_empty_row, grid, true)
      end
      local function is_full(grid)
          local function is_full_row(row)
              local function is_full_cell(cell)
                  if cell == 1 then
                      return true
                  else
                      return false
                  end
              end
              return reduce(is_full_cell, row, true)
          end
          return reduce(is_full_row, grid, true)
      end
      local function fill_and_empty(grid, capacity)
          local filled = fill(grid, capacity)
          local emptied = empty(filled, capacity)
          return emptied
      end
      local
- |2-
      local function get_max_fill(grid, capacity)
          local max_fill = 0
          for i, row in ipairs(grid) do
              local fill = 0
              for j, col in ipairs(row) do
                  if col == 1 then
                      fill = fill + 1
                  else
                      if fill > max_fill then
                          max_fill = fill
                      end
                      fill = 0
                  end
              end
              if fill > max_fill then
                  max_fill = fill
              end
          end
          return max_fill
      end
      local max_fill = get_max_fill(grid, capacity)
      return max_fill > capacity and max_fill or 0
  end
- |2-
      local function fill(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_column(column, capacity)
                  if column > #row then
                      return 0
                  end
                  if row[column] == 1 then
                      if capacity > 0 then
                          row[column] = 0
                          return 1 + fill_column(column + 1, capacity - 1)
                      else
                          return 0
                      end
                  else
                      return fill_column(column + 1, capacity)
                  end
              end
              return fill_column(1, capacity)
          end
          if #grid == 0 then
              return 0
          end
          return fill_row(grid[1], capacity) + fill(grid, capacity)
      end
      return fill(grid, capacity)
  end
- |2-
      local function fill(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_cell(cell, capacity)
                  if cell == 1 then
                      return capacity - 1
                  else
                      return capacity
                  end
              end
              local function fill_row_helper(row, capacity, index)
                  if index > #row then
                      return capacity
                  else
                      return fill_row_helper(row, fill_cell(row[index], capacity), index + 1)
                  end
              end
              return fill_row_helper(row, capacity, 1)
          end
          local function fill_grid_helper(grid, capacity, index)
              if index > #grid then
                  return capacity
              else
                  return fill_grid_helper(grid, fill_row(grid[index], capacity), index + 1)
              end
          end
          return fill_grid_helper(grid, capacity, 1)
      end
      local function fill_helper(grid, capacity, index)
          if fill(grid, capacity) == 0 then
              return index
          else
              return fill_helper(grid, capacity, index + 1)
          end
      end
      return fill_helper(grid, capacity, 0)
  end
- |2-
      local function fill(grid, capacity)
          local max_fill = 0
          for i = 1, #grid do
              local fill = 0
              for j = 1, #grid[i] do
                  if grid[i][j] == 1 then
                      fill = fill + 1
                  end
              end
              if fill > max_fill then
                  max_fill = fill
              end
          end
          return math.ceil(max_fill / capacity)
      end
      return fill(grid, capacity)
  end
- |2-
    local function fill(grid, capacity)
      local function fill_row(row, capacity)
        local function fill_cell(cell, capacity)
          if cell == 0 then
            return 0
          else
            return capacity
          end
        end
        return map(fill_cell, row, capacity)
      end
      return map(fill_row, grid, capacity)
    end
    local function sum_grid(grid)
      local function sum_row(row)
        local function sum_cell(cell)
          return cell
        end
        return reduce(sum_cell, row, 0)
      end
      return reduce(sum_row, grid, 0)
    end
    local function max_fill_iter(grid, capacity, count)
      local filled_grid = fill(grid, capacity)
      local filled_count = sum_grid(filled_grid)
      if filled_count == 0 then
        return count
      else
        return max_fill_iter(filled_grid, capacity, count + 1)
      end
    end
    return max_fill_iter(grid, capacity, 0)
  end
- |2-
      local function fill(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_well(well, capacity)
                  local function fill_bucket(bucket, capacity)
                      if bucket == 1 then
                          return capacity
                      else
                          return 0
                      end
                  end
                  local function fill_well_from_bucket(well, bucket)
                      if well == 1 then
                          return bucket
                      else
                          return 0
                      end
                  end
                  local bucket = fill_bucket(well, capacity)
                  return fill_well_from_bucket(well, bucket)
              end
              local function fill_row_from_well(row, well)
                  return row + well
              end
              local well = fill_well(row, capacity)
              return fill_row_from_well(row, well)
          end
          local function fill_grid_from_row(grid, row)
              local function fill_grid_from_well(grid, well)
                  local function fill_grid_from_bucket(grid, bucket)
                      if bucket == capacity then
                          return grid - 1
                      else
                          return grid
                      end
                  end
                  local bucket = fill_grid_from_bucket(grid, well)
                  return bucket
              end
              local well = fill_grid_from_well(grid, row)
              return well
          end
          local row = fill_row(grid, capacity)
          return fill_grid_from_row(grid, row)
      end
      local function max_fill_from_grid(grid, capacity)
          local function max_fill_from_row(grid, capacity)
              local function max_fill_from_well(grid, capacity)
                  local function max_fill_from_bucket(grid, capacity)
                      if grid == 0 then
                          return capacity
                      else
                          return 0
                      end
                  end
                  local bucket = max_fill_from_bucket(grid, capacity)
                  return bucket
              end
              local well = max_fill_from_well(grid, capacity)
              return well
          end
          local row = max_fill_from_row(grid, capacity)
- |2-
      local function fill(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_cell(cell, capacity)
                  if cell == 1 then
                      return capacity - 1
                  else
                      return capacity
                  end
              end
              return List.foldl(row, capacity, fill_cell)
          end
          return List.foldl(grid, capacity, fill_row)
      end
      local function count_fill(grid, capacity)
          local function count_fill_row(row, capacity)
              local function count_fill_cell(cell, capacity)
                  if cell == 1 then
                      return capacity + 1
                  else
                      return capacity
                  end
              end
              return List.foldl(row, capacity, count_fill_cell)
          end
          return List.foldl(grid, capacity, count_fill_row)
      end
      local function count_fill_all(grid, capacity)
          local function count_fill_all_row(row, capacity)
              local function count_fill_all_cell(cell, capacity)
                  if cell == 1 then
                      return capacity + 1
                  else
                      return capacity
                  end
              end
              return List.foldl(row, capacity, count_fill_all_cell)
          end
          return List.foldl(grid, capacity, count_fill_all_row)
      end
      local function count_fill_all_rows(grid, capacity)
          local function count_fill_all_rows_row(row, capacity)
              local function count_fill_all_rows_cell(cell, capacity)
                  if cell == 1 then
                      return capacity + 1
                  else
                      return capacity
                  end
              end
              return List.foldl(row, capacity, count_fill_all_rows_cell)
          end
          return List.foldl(grid, capacity, count_fill_all_rows_row)
      end
      local function count_fill_all_rows_cols(grid, capacity)
          local function count_fill_all_rows_cols_row(row, capacity)
              local function count_fill_all_rows_cols_cell(cell, capacity
- |2-
      local function fill(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_well(well, capacity)
                  if well == 0 then
                      return 0
                  else
                      return capacity
                  end
              end
              return table.map(fill_well, row)
          end
          return table.map(fill_row, grid)
      end
      local function drain(grid, capacity)
          local function drain_row(row, capacity)
              local function drain_well(well, capacity)
                  if well == 0 then
                      return 0
                  else
                      return capacity
                  end
              end
              return table.map(drain_well, row)
          end
          return table.map(drain_row, grid)
      end
      local function count(grid)
          local function count_row(row)
              local function count_well(well)
                  if well == 0 then
                      return 0
                  else
                      return 1
                  end
              end
              return table.reduce(count_well, row, 0)
          end
          return table.reduce(count_row, grid, 0)
      end
      local function is_empty(grid)
          local function is_empty_row(row)
              local function is_empty_well(well)
                  if well == 0 then
                      return true
                  else
                      return false
                  end
              end
              return table.reduce(is_empty_well, row, true)
          end
          return table.reduce(is_empty_row, grid, true)
      end
      local function fill_and_drain(grid, capacity)
          return drain(fill(grid, capacity), capacity)
      end
      local function fill_and_drain_until_empty(grid, capacity)
          local function fill_and_drain_until_empty_rec(grid, capacity, count)
              if is_empty(grid) then
                  return count
              else
                  return fill_and_drain_until_empty_rec(fill_and_drain(grid, capacity), capacity, count + 1)
              end
          end
          return fill_and_drain_until
- |2-
    local function fill_row(row, capacity)
      local count = 0
      local i = 1
      while i <= #row do
        if row[i] == 1 then
          count = count + 1
          i = i + capacity
        else
          i = i + 1
        end
      end
      return count
    end
    local count = 0
    for _, row in ipairs(grid) do
      count = count + fill_row(row, capacity)
    end
    return count
  end
- |2-
    local function fill(grid, capacity)
      local function fill_row(row, capacity)
        local function fill_cell(cell, capacity)
          if cell == 0 then
            return 0
          else
            return capacity
          end
        end
        return map(row, fill_cell, capacity)
      end
      return map(grid, fill_row, capacity)
    end
    local function sum_grid(grid)
      local function sum_row(row)
        return reduce(row, add, 0)
      end
      return reduce(grid, add, 0)
    end
    local function sum_grid_fill(grid, capacity)
      return sum_grid(fill(grid, capacity))
    end
    return sum_grid_fill(grid, capacity)
  end
- |2-
      local function fill(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_cell(cell, capacity)
                  if cell == 0 then
                      return 0
                  else
                      return capacity
                  end
              end
              return map(fill_cell, row, capacity)
          end
          return map(fill_row, grid, capacity)
      end
      local function sum_grid(grid)
          local function sum_row(row)
              local function sum_cell(cell)
                  return cell
              end
              return reduce(sum_cell, row, 0)
          end
          return reduce(sum_row, grid, 0)
      end
      local function empty(grid)
          local function empty_row(row)
              local function empty_cell(cell)
                  return 0
              end
              return map(empty_cell, row)
          end
          return map(empty_row, grid)
      end
      local function fill_and_empty(grid, capacity)
          return empty(fill(grid, capacity))
      end
      local function fill_and_empty_n_times(grid, capacity, n)
          local function fill_and_empty_n_times_iter(grid, capacity, n)
              if n == 0 then
                  return grid
              else
                  return fill_and_empty_n_times_iter(fill_and_empty(grid, capacity), capacity, n - 1)
              end
          end
          return fill_and_empty_n_times_iter(grid, capacity, n)
      end
      local function fill_and_empty_until_empty(grid, capacity)
          local function fill_and_empty_until_empty_iter(grid, capacity, n)
              if sum_grid(grid) == 0 then
                  return n
              else
                  return fill_and_empty_until_empty_iter(fill_and_empty(grid, capacity), capacity, n + 1)
              end
          end
          return fill_and_empty_until_empty_iter(grid, capacity, 0)
      end
      return fill_and_empty_until_empty(grid, capacity)
  end
- |2-
      local function fill(row, col)
          local count = 0
          for i = 1, #grid do
              if grid[i][col] == 1 then
                  grid[i][col] = 0
                  count = count + 1
              end
          end
          return count
      end
      local function empty(row, col)
          local count = 0
          for i = 1, capacity do
              if row + i <= #grid and grid[row + i][col] == 0 then
                  grid[row + i][col] = 1
                  count = count + 1
              end
          end
          return count
      end
      local function find_max_col()
          local max_col = 1
          local max_count = 0
          for i = 1, #grid[1] do
              local count = 0
              for j = 1, #grid do
                  if grid[j][i] == 1 then
                      count = count + 1
                  end
              end
              if count > max_count then
                  max_count = count
                  max_col = i
              end
          end
          return max_col
      end
      local function find_min_row()
          local min_row = 1
          local min_count = #grid
          for i = 1, #grid do
              local count = 0
              for j = 1, #grid[1] do
                  if grid[i][j] == 1 then
                      count = count + 1
                  end
              end
              if count < min_count then
                  min_count = count
                  min_row = i
              end
          end
          return min_row
      end
      local count = 0
      while true do
          local max_col = find_max_col()
          local min_row = find_min_row()
          local filled = fill(min_row, max_col)
          if filled == 0 then
              break
          end
          count = count + filled
          local emptyed = empty(min_row, max_col)
          count = count + emptyed
      end
      return count
  end
- |2-
      -- TODO: implement
  end
- |2-
      local function fill(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_column(column, capacity)
                  if column > #row then
                      return capacity
                  end
                  if row[column] == 1 then
                      if capacity == 0 then
                          return 0
                      else
                          return fill_column(column + 1, capacity - 1)
                      end
                  else
                      return fill_column(column + 1, capacity)
                  end
              end
              return fill_column(1, capacity)
          end
          if #grid == 0 then
              return 0
          end
          local row = table.remove(grid, 1)
          local filled = fill_row(row, capacity)
          return filled + fill(grid, capacity)
      end
      return fill(grid, capacity)
  end
- |2-
      local function fill(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_cell(cell, capacity)
                  if capacity == 0 then
                      return 0
                  elseif cell == 0 then
                      return 0
                  else
                      return 1
                  end
              end
              local function fill_row_helper(row, capacity, index)
                  if index == #row + 1 then
                      return 0
                  else
                      local cell = row[index]
                      local filled = fill_cell(cell, capacity)
                      local remaining = capacity - filled
                      return filled + fill_row_helper(row, remaining, index + 1)
                  end
              end
              return fill_row_helper(row, capacity, 1)
          end
          local function fill_grid_helper(grid, capacity, index)
              if index == #grid + 1 then
                  return 0
              else
                  local row = grid[index]
                  local filled = fill_row(row, capacity)
                  local remaining = capacity - filled
                  return filled + fill_grid_helper(grid, remaining, index + 1)
              end
          end
          return fill_grid_helper(grid, capacity, 1)
      end
      local function fill_grid(grid, capacity)
          local function fill_grid_helper(grid, capacity, index)
              if index == #grid + 1 then
                  return 0
              else
                  local row = grid[index]
                  local filled = fill(row, capacity)
                  local remaining = capacity - filled
                  return filled + fill_grid_helper(grid, remaining, index + 1)
              end
          end
          return fill_grid_helper(grid, capacity, 1)
      end
      return fill_grid(grid, capacity)
  end
- |2-
      local function max_fill_row(row, capacity)
          local count = 0
          local i = 1
          while i <= #row do
              if row[i] == 1 then
                  count = count + 1
                  i = i + capacity
              else
                  i = i + 1
              end
          end
          return count
      end
      local count = 0
      for i = 1, #grid do
          count = count + max_fill_row(grid[i], capacity)
      end
      return count
  end
- |2-
      local function fill(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_cell(cell, capacity)
                  if cell == 0 then
                      return 0
                  else
                      return capacity
                  end
              end
              return map(row, function(cell) return fill_cell(cell, capacity) end)
          end
          return map(grid, function(row) return fill_row(row, capacity) end)
      end
      local function sum_grid(grid)
          local function sum_row(row)
              local function sum_cell(cell)
                  return cell
              end
              return reduce(row, function(a, b) return a + b end, 0)
          end
          return reduce(grid, function(a, b) return a + b end, 0)
      end
      local function max_grid(grid)
          local function max_row(row)
              local function max_cell(cell)
                  return cell
              end
              return reduce(row, function(a, b) return math.max(a, b) end, 0)
          end
          return reduce(grid, function(a, b) return math.max(a, b) end, 0)
      end
      local function fill_grid(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_cell(cell, capacity)
                  if cell == 0 then
                      return 0
                  else
                      return capacity
                  end
              end
              return map(row, function(cell) return fill_cell(cell, capacity) end)
          end
          return map(grid, function(row) return fill_row(row, capacity) end)
      end
      local function fill_grid_with_water(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_cell(cell, capacity)
                  if cell == 0 then
                      return capacity
                  else
                      return 0
                  end
              end
              return map(row, function(cell) return fill_cell(cell, capacity) end)
          end
          return map(grid, function(row) return fill_row(row, capacity) end)
      end
- |2-
      local max_fill = 0
      local row_count = #grid
      local col_count = #grid[1]
      local row_sum = {}
      local col_sum = {}
      for i = 1, row_count do
          row_sum[i] = 0
          for j = 1, col_count do
              row_sum[i] = row_sum[i] + grid[i][j]
          end
      end
      for j = 1, col_count do
          col_sum[j] = 0
          for i = 1, row_count do
              col_sum[j] = col_sum[j] + grid[i][j]
          end
      end
      local function get_max_fill(row_sum, col_sum, row_count, col_count, capacity)
          local max_fill = 0
          for i = 1, row_count do
              max_fill = max_fill + math.floor(row_sum[i] / capacity)
          end
          for j = 1, col_count do
              max_fill = max_fill + math.floor(col_sum[j] / capacity)
          end
          return max_fill
      end
      max_fill = get_max_fill(row_sum, col_sum, row_count, col_count, capacity)
      for i = 1, row_count do
          for j = 1, col_count do
              if grid[i][j] == 1 then
                  row_sum[i] = row_sum[i] - 1
                  col_sum[j] = col_sum[j] - 1
                  local max_fill_tmp = get_max_fill(row_sum, col_sum, row_count, col_count, capacity)
                  if max_fill_tmp < max_fill then
                      max_fill = max_fill_tmp
                  end
                  row_sum[i] = row_sum[i] + 1
                  col_sum[j] = col_sum[j] + 1
              end
          end
      end
      return max_fill
  end
- |2-
    local function fill(grid, capacity)
      local function fill_row(row, capacity)
        local function fill_well(well, capacity)
          if well == 0 then
            return 0
          else
            return capacity
          end
        end
        return map(row, fill_well, capacity)
      end
      return map(grid, fill_row, capacity)
    end
    local function sum_grid(grid)
      local function sum_row(row)
        local function sum_well(well)
          return well
        end
        return reduce(row, sum_well, 0)
      end
      return reduce(grid, sum_row, 0)
    end
    local function empty(grid)
      local function empty_row(row)
        local function empty_well(well)
          return 0
        end
        return map(row, empty_well)
      end
      return map(grid, empty_row)
    end
    local function max_fill_helper(grid, capacity, count)
      local filled_grid = fill(grid, capacity)
      local filled_sum = sum_grid(filled_grid)
      if filled_sum == 0 then
        return count
      else
        return max_fill_helper(empty(filled_grid), capacity, count + filled_sum)
      end
    end
    return max_fill_helper(grid, capacity, 0)
  end
- |2-
    local function fill_bucket(bucket, row)
      local count = 0
      for i = 1, #row do
        if row[i] == 1 then
          bucket = bucket - 1
          row[i] = 0
          count = count + 1
        end
        if bucket == 0 then
          return count
        end
      end
      return count
    end
    local count = 0
    for i = 1, #grid do
      local bucket = capacity
      count = count + fill_bucket(bucket, grid[i])
    end
    return count
  end
- |2-
    local function fill(grid, capacity)
      local function fill_row(row, capacity)
        local function fill_cell(cell, capacity)
          if cell == 1 then
            return capacity - 1
          else
            return capacity
          end
        end
        return map(row, function(cell) return fill_cell(cell, capacity) end)
      end
      return map(grid, function(row) return fill_row(row, capacity) end)
    end
    local function is_empty(grid)
      local function is_empty_row(row)
        local function is_empty_cell(cell)
          return cell == 0
        end
        return all(row, is_empty_cell)
      end
      return all(grid, is_empty_row)
    end
    local function count_water(grid)
      local function count_water_row(row)
        local function count_water_cell(cell)
          if cell > 0 then
            return 1
          else
            return 0
          end
        end
        return sum(row, count_water_cell)
      end
      return sum(grid, count_water_row)
    end
    local function count_water_in_row(row)
      local function count_water_in_cell(cell)
        if cell > 0 then
          return 1
        else
          return 0
        end
      end
      return sum(row, count_water_in_cell)
    end
    local function count_water_in_grid(grid)
      local function count_water_in_row(row)
        local function count_water_in_cell(cell)
          if cell > 0 then
            return 1
          else
            return 0
          end
        end
        return sum(row, count_water_in_cell)
      end
      return sum(grid, count_water_in_row)
    end
    local function count_water_in_column(grid, column)
      local function count_water_in_cell(row)
        return row[column]
      end
      return sum(grid, count_water_in_cell)
    end
    local function count_water
- |2-
      local function fill(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_cell(cell, capacity)
                  if cell == 0 then
                      return 0
                  else
                      return capacity
                  end
              end
              return map(row, function(cell) return fill_cell(cell, capacity) end)
          end
          return map(grid, function(row) return fill_row(row, capacity) end)
      end
      local function sum_grid(grid)
          local function sum_row(row)
              local function sum_cell(cell)
                  return cell
              end
              return foldl(row, 0, function(acc, cell) return acc + sum_cell(cell) end)
          end
          return foldl(grid, 0, function(acc, row) return acc + sum_row(row) end)
      end
      local function max_row(grid)
          local function max_cell(row)
              local function max_cell(acc, cell)
                  if cell > acc then
                      return cell
                  else
                      return acc
                  end
              end
              return foldl(row, 0, max_cell)
          end
          return foldl(grid, 0, function(acc, row) return max_cell(row) end)
      end
      local function remove_max_row(grid)
          local function remove_max_cell(row)
              local function remove_max_cell(acc, cell)
                  if cell == max_cell(row) then
                      return acc
                  else
                      return acc + cell
                  end
              end
              return foldl(row, 0, remove_max_cell)
          end
          return map(grid, function(row) return remove_max_cell(row) end)
      end
      local function fill_max_row(grid, capacity)
          local function fill_max_cell(row, capacity)
              local function fill_max_cell(acc, cell)
                  if cell == max_cell(row) then
                      return acc + capacity
                  else
                      return acc + cell
                  end
              end
              return foldl(row, 0, function(acc, cell) return fill
- |2-
    local function fill(grid, capacity)
      local function fill_row(row, capacity)
        local function fill_cell(cell, capacity)
          if cell == 0 then
            return 0
          else
            return capacity
          end
        end
        return map(fill_cell, row, capacity)
      end
      return map(fill_row, grid, capacity)
    end
    local function sum_grid(grid)
      local function sum_row(row)
        local function sum_cell(cell)
          return cell
        end
        return reduce(sum_cell, row, 0)
      end
      return reduce(sum_row, grid, 0)
    end
    return sum_grid(fill(grid, capacity))
  end
- |2-
    local function fill(i, j)
      if i < 1 or i > #grid or j < 1 or j > #grid[1] or grid[i][j] == 0 then
        return 0
      end
      grid[i][j] = 0
      return 1 + fill(i - 1, j) + fill(i + 1, j) + fill(i, j - 1) + fill(i, j + 1)
    end
    local function fill_all()
      local count = 0
      for i = 1, #grid do
        for j = 1, #grid[1] do
          count = count + fill(i, j)
        end
      end
      return count
    end
    local count = 0
    while fill_all() > 0 do
      count = count + 1
    end
    return count
  end
- |2-
      local function fill(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_cell(cell, capacity)
                  if capacity == 0 then
                      return 0
                  elseif cell == 0 then
                      return capacity
                  else
                      return 0
                  end
              end
              local function fill_row_iter(row, capacity, i)
                  if i > #row then
                      return capacity
                  else
                      return fill_row_iter(row, fill_cell(row[i], capacity), i + 1)
                  end
              end
              return fill_row_iter(row, capacity, 1)
          end
          local function fill_grid_iter(grid, capacity, i)
              if i > #grid then
                  return capacity
              else
                  return fill_grid_iter(grid, fill_row(grid[i], capacity), i + 1)
              end
          end
          return fill_grid_iter(grid, capacity, 1)
      end
      local function fill_iter(grid, capacity, i)
          if fill(grid, capacity) == 0 then
              return i
          else
              return fill_iter(grid, fill(grid, capacity), i + 1)
          end
      end
      return fill_iter(grid, capacity, 0)
  end
- |2-
      local function max_fill_row(row, capacity)
          local count = 0
          local current_capacity = capacity
          for i = 1, #row do
              if row[i] == 1 then
                  if current_capacity == 0 then
                      current_capacity = capacity
                      count = count + 1
                  end
                  current_capacity = current_capacity - 1
              end
          end
          return count
      end
      local count = 0
      for i = 1, #grid do
          count = count + max_fill_row(grid[i], capacity)
      end
      return count
  end
- |2-
    local function fill(grid, capacity)
      local function fill_row(row, capacity)
        local function fill_cell(cell, capacity)
          if cell == 0 then
            return 0
          else
            return capacity
          end
        end
        return map(row, function(cell) return fill_cell(cell, capacity) end)
      end
      return map(grid, function(row) return fill_row(row, capacity) end)
    end
    local function empty(grid)
      local function empty_row(row)
        local function empty_cell(cell)
          if cell == 0 then
            return 0
          else
            return 1
          end
        end
        return map(row, function(cell) return empty_cell(cell) end)
      end
      return map(grid, function(row) return empty_row(row) end)
    end
    local function count(grid)
      local function count_row(row)
        local function count_cell(cell)
          if cell == 0 then
            return 0
          else
            return 1
          end
        end
        return reduce(row, function(acc, cell) return acc + count_cell(cell) end, 0)
      end
      return reduce(grid, function(acc, row) return acc + count_row(row) end, 0)
    end
    local function max_fill_rec(grid, capacity)
      if count(grid) == 0 then
        return 0
      else
        return 1 + max_fill_rec(empty(fill(grid, capacity)), capacity)
      end
    end
    return max_fill_rec(grid, capacity)
  end
- |2-
      local function fill(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_cell(cell, capacity)
                  if cell == 1 then
                      return capacity - 1
                  else
                      return capacity
                  end
              end
              local function fill_row_helper(row, capacity, result)
                  if #row == 0 then
                      return result
                  else
                      local cell = table.remove(row, 1)
                      local new_capacity = fill_cell(cell, capacity)
                      if new_capacity == 0 then
                          return fill_row_helper(row, capacity, result + 1)
                      else
                          return fill_row_helper(row, new_capacity, result)
                      end
                  end
              end
              return fill_row_helper(row, capacity, 0)
          end
          local function fill_grid_helper(grid, capacity, result)
              if #grid == 0 then
                  return result
              else
                  local row = table.remove(grid, 1)
                  local new_capacity = fill_row(row, capacity)
                  return fill_grid_helper(grid, new_capacity, result + 1)
              end
          end
          return fill_grid_helper(grid, capacity, 0)
      end
      return fill(grid, capacity)
  end
- |2-
      local function fill(grid, capacity)
          local function fill_row(row, capacity)
              local function fill_cell(cell, capacity)
                  if cell == 1 then
                      return capacity - 1
                  else
                      return capacity
                  end
              end
              return map(row, function(cell) return fill_cell(cell, capacity) end)
          end
          return map(grid, function(row) return fill_row(row, capacity) end)
      end
      local function count_fill(grid)
          local function count_row(row)
              local function count_cell(cell)
                  if cell == 0 then
                      return 1
                  else
                      return 0
                  end
              end
              return sum(map(row, count_cell))
          end
          return sum(map(grid, count_row))
      end
      local function is_filled(grid)
          local function is_row_filled(row)
              return all(row, function(cell) return cell == 0 end)
          end
          return all(grid, is_row_filled)
      end
      local function remove_filled_rows(grid)
          local function remove_filled_row(row)
              return not is_filled(row)
          end
          return filter(grid, remove_filled_row)
      end
      local function fill_grid(grid, capacity)
          local function fill_grid_iter(grid, capacity, count)
              if is_filled(grid) then
                  return count
              else
                  return fill_grid_iter(remove_filled_rows(fill(grid, capacity)), capacity, count + count_fill(grid))
              end
          end
          return fill_grid_iter(grid, capacity, 0)
      end
      return fill_grid(grid, capacity)
  end
- |2-
      local function fill(grid, capacity)
          local max_height = 0
          for i = 1, #grid do
              local height = 0
              for j = 1, #grid[i] do
                  if grid[i][j] == 1 then
                      height = height + 1
                  end
              end
              if height > max_height then
                  max_height = height
              end
          end
          local count = 0
          for i = 1, #grid do
              local height = 0
              for j = 1, #grid[i] do
                  if grid[i][j] == 1 then
                      height = height + 1
                  end
              end
              if height < max_height then
                  count = count + max_height - height
              end
          end
          return count
      end
      return fill(grid, capacity)
  end
- |2-
      local function max_fill_rec(grid, capacity, row, col, count)
          if row > #grid then
              return count
          end
          if col > #grid[1] then
              return max_fill_rec(grid, capacity, row + 1, 1, count)
          end
          if grid[row][col] == 1 then
              grid[row][col] = 0
              return max_fill_rec(grid, capacity, row, col + 1, count + 1)
          end
          return max_fill_rec(grid, capacity, row, col + 1, count)
      end
      return max_fill_rec(grid, capacity, 1, 1, 0)
  end
stop_tokens:
- |2-

  local
- |2-

  function
- |2-

  --
- "\n\n"
