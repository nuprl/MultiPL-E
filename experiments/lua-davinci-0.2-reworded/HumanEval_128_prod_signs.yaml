---
name: HumanEval_128_prod_signs
language: lua
prompt: |
  -- You are given a table arr of integers and you need to return
  -- sum of magnitudes of integers multiplied by product of all signs
  -- of each number in the table, represented by 1, -1 or 0.
  -- Note: return None for empty arr.
  -- Example:
  -- >>> prod_signs({1, 2, 2, -4})
  -- 9
  -- >>> prod_signs({0, 1})
  -- 0
  -- >>> prod_signs({})
  -- None
  local function prod_signs(arr)
tests: |-
  lu = require('luaunit')

  function test_humaneval()
  local candidate = prod_signs
      lu.assertEquals(candidate({1, 2, 2, -4}), -9)
      lu.assertEquals(candidate({0, 1}), 0)
      lu.assertEquals(candidate({1, 1, 1, 2, 3, -1, 1}), -10)
      lu.assertEquals(candidate({}), None)
      lu.assertEquals(candidate({2, 4, 1, 2, -1, -1, 9}), 20)
      lu.assertEquals(candidate({-1, 1, -1, 1}), 4)
      lu.assertEquals(candidate({-1, 1, 1, 1}), -4)
      lu.assertEquals(candidate({-1, 1, 1, 0}), 0)
  end

  os.exit(lu.LuaUnit.run())
completions:
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
      if #arr == 0 then return nil end
      local sum = 0
      local prod = 1
      for _, v in ipairs(arr) do
          if v > 0 then
              sum = sum + v
          elseif v < 0 then
              sum = sum - v
              prod = prod * -1
          end
      end
      return sum * prod
  end
- |2-
    local prod = 1
    local sum = 0
    for _, v in ipairs(arr) do
      if v > 0 then
        prod = prod * 1
        sum = sum + v
      elseif v < 0 then
        prod = prod * -1
        sum = sum + -v
      else
        prod = prod * 0
        sum = sum + 0
      end
    end
    return prod * sum
  end
- |2-
    if #arr == 0 then return nil end
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      sum = sum + math.abs(v)
      if v > 0 then prod = prod * 1
      elseif v < 0 then prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local prod = 1
    local sum = 0
    for _, v in ipairs(arr) do
      if v > 0 then
        prod = prod * 1
        sum = sum + v
      elseif v < 0 then
        prod = prod * -1
        sum = sum + math.abs(v)
      else
        prod = prod * 0
      end
    end
    return prod * sum
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      sum = sum + math.abs(v)
      if v < 0 then
        prod = prod * -1
      elseif v > 0 then
        prod = prod * 1
      else
        prod = prod * 0
      end
    end
    return prod * sum
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    if #arr == 0 then return nil end
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      local sign = v > 0 and 1 or v < 0 and -1 or 0
      sum = sum + math.abs(v)
      prod = prod * sign
    end
    return prod == 0 and nil or sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      sum = sum + math.abs(v)
      if v > 0 then
        prod = prod * 1
      elseif v < 0 then
        prod = prod * -1
      else
        prod = prod * 0
      end
    end
    return sum * prod
  end
- |2-
    local prod = 1
    local sum = 0
    for _, v in ipairs(arr) do
      if v > 0 then
        prod = prod * 1
        sum = sum + v
      elseif v < 0 then
        prod = prod * -1
        sum = sum + math.abs(v)
      else
        prod = prod * 0
      end
    end
    return prod * sum
  end
- |2-
    if #arr == 0 then return nil end
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      sum = sum + math.abs(v)
      if v > 0 then prod = prod * 1
      elseif v < 0 then prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    if #arr == 0 then return nil end
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      sum = sum + math.abs(v)
      if v > 0 then prod = prod * 1
      elseif v < 0 then prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      local sign = v > 0 and 1 or v < 0 and -1 or 0
      sum = sum + math.abs(v)
      prod = prod * sign
    end
    return prod == 0 and nil or sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local prod = 1
    local sum = 0
    for _, v in ipairs(arr) do
      if v > 0 then
        prod = prod * 1
        sum = sum + v
      elseif v < 0 then
        prod = prod * -1
        sum = sum + -v
      else
        prod = prod * 0
        sum = sum + 0
      end
    end
    return prod * sum
  end
- |2-
    if #arr == 0 then return nil end
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      sum = sum + math.abs(v)
      prod = prod * (v == 0 and 1 or (v > 0 and 1 or -1))
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    if #arr == 0 then return nil end
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local prod = 1
    local sum = 0
    for _, v in ipairs(arr) do
      if v > 0 then
        prod = prod * 1
        sum = sum + v
      elseif v < 0 then
        prod = prod * -1
        sum = sum + -v
      else
        prod = prod * 0
        sum = sum + 0
      end
    end
    return prod * sum
  end
- |2-
    if #arr == 0 then return nil end
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      sum = sum + math.abs(v)
      if v > 0 then prod = prod * 1
      elseif v < 0 then prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum, prod = 0, 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      local sign = (v > 0 and 1) or (v < 0 and -1) or 0
      sum = sum + math.abs(v)
      prod = prod * sign
    end
    return sum * prod
  end
- |2-
      local prod = 1
      local sum = 0
      for _, v in ipairs(arr) do
          if v > 0 then
              prod = prod * 1
          elseif v < 0 then
              prod = prod * -1
          else
              prod = prod * 0
          end
          sum = sum + math.abs(v)
      end
      return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local prod = 1
    local sum = 0
    for _, v in ipairs(arr) do
      if v > 0 then
        prod = prod * 1
        sum = sum + v
      elseif v < 0 then
        prod = prod * -1
        sum = sum + -v
      else
        prod = prod * 0
        sum = sum + 0
      end
    end
    return prod * sum
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local prod = 1
    local sum = 0
    for _, v in ipairs(arr) do
      if v > 0 then
        prod = prod * 1
        sum = sum + v
      elseif v < 0 then
        prod = prod * -1
        sum = sum + v
      else
        prod = prod * 0
      end
    end
    return prod * sum
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      local sign = v > 0 and 1 or v < 0 and -1 or 0
      sum = sum + math.abs(v)
      prod = prod * sign
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    if #arr == 0 then return nil end
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      sum = sum + math.abs(v)
      if v > 0 then prod = prod * 1
      elseif v < 0 then prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum, prod = 0, 1
    for _, v in ipairs(arr) do
      if v == 0 then
        prod = 0
      elseif v > 0 then
        sum = sum + v
      else
        sum = sum - v
        prod = prod * -1
      end
    end
    return prod * sum
  end
- |2-
    if #arr == 0 then return nil end
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      sum = sum + math.abs(v)
      if v > 0 then prod = prod * 1
      elseif v < 0 then prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    if #arr == 0 then return nil end
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      sum = sum + math.abs(v)
      if v > 0 then prod = prod * 1
      elseif v < 0 then prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local prod = 1
    local sum = 0
    for _, v in ipairs(arr) do
      if v > 0 then
        prod = prod * 1
        sum = sum + v
      elseif v < 0 then
        prod = prod * -1
        sum = sum + math.abs(v)
      else
        prod = prod * 0
      end
    end
    return prod * sum
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local prod = 1
    local sum = 0
    for _, v in ipairs(arr) do
      if v > 0 then
        prod = prod * 1
        sum = sum + v
      elseif v < 0 then
        prod = prod * -1
        sum = sum + v
      else
        prod = prod * 0
      end
    end
    return prod * sum
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      sum = sum + math.abs(v)
      if v > 0 then
        prod = prod * 1
      elseif v < 0 then
        prod = prod * -1
      else
        prod = prod * 0
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      local sign = v > 0 and 1 or v < 0 and -1 or 0
      sum = sum + math.abs(v)
      prod = prod * sign
    end
    return prod == 0 and nil or sum * prod
  end
- |2-
    if #arr == 0 then return nil end
    local sum, prod = 0, 1
    for _, v in ipairs(arr) do
      sum = sum + math.abs(v)
      prod = prod * (v > 0 and 1 or v < 0 and -1 or 0)
    end
    return sum * prod
  end
- |2-
    local prod = 1
    local sum = 0
    for _, v in ipairs(arr) do
      if v > 0 then
        prod = prod * 1
        sum = sum + v
      elseif v < 0 then
        prod = prod * -1
        sum = sum + math.abs(v)
      else
        prod = prod * 0
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      sum = sum + math.abs(v)
      if v > 0 then
        prod = prod * 1
      elseif v < 0 then
        prod = prod * -1
      else
        prod = prod * 0
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local res = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        res = res * 1
      elseif v < 0 then
        res = res * -1
      else
        res = res * 0
      end
    end
    local sum = 0
    for _, v in ipairs(arr) do
      sum = sum + math.abs(v)
    end
    return res * sum
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local prod = 1
    local sum = 0
    for _, v in ipairs(arr) do
      if v > 0 then
        prod = prod * 1
        sum = sum + v
      elseif v < 0 then
        prod = prod * -1
        sum = sum + math.abs(v)
      else
        prod = prod * 0
      end
    end
    if sum == 0 then
      return nil
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    if #arr == 0 then return nil end
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      local sign = v > 0 and 1 or v < 0 and -1 or 0
      sum = sum + math.abs(v)
      prod = prod * sign
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    if #arr == 0 then return nil end
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum, prod = 0, 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local prod = 1
    local sum = 0
    for _, v in ipairs(arr) do
      if v > 0 then
        prod = prod * 1
        sum = sum + v
      elseif v < 0 then
        prod = prod * -1
        sum = sum + math.abs(v)
      else
        prod = prod * 0
      end
    end
    return prod * sum
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    if #arr == 0 then return nil end
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      sum = sum + math.abs(v)
      if v > 0 then prod = prod * 1
      elseif v < 0 then prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      local sign = v > 0 and 1 or v < 0 and -1 or 0
      sum = sum + math.abs(v)
      prod = prod * sign
    end
    return prod == 0 and nil or sum * prod
  end
- |2-
      local sum = 0
      local prod = 1
      for _, v in ipairs(arr) do
          if v > 0 then
              sum = sum + v
              prod = prod * 1
          elseif v < 0 then
              sum = sum + v
              prod = prod * -1
          else
              prod = prod * 0
          end
      end
      return prod * sum
  end
- |2-
    if #arr == 0 then return nil end
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      sum = sum + math.abs(v)
      if v > 0 then prod = prod * 1
      elseif v < 0 then prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    if #arr == 0 then return nil end
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      sum = sum + math.abs(v)
      if v > 0 then prod = prod * 1
      elseif v < 0 then prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local prod = 1
    local sum = 0
    for _, v in ipairs(arr) do
      local sign = v > 0 and 1 or v < 0 and -1 or 0
      prod = prod * sign
      sum = sum + math.abs(v)
    end
    return prod == 0 and nil or prod * sum
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
      local sum = 0
      local prod = 1
      for _, v in ipairs(arr) do
          sum = sum + math.abs(v)
          if v > 0 then
              prod = prod * 1
          elseif v < 0 then
              prod = prod * -1
          else
              prod = prod * 0
          end
      end
      return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    if #arr == 0 then return nil end
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local prod = 1
    local sum = 0
    for _, v in ipairs(arr) do
      if v > 0 then
        prod = prod * 1
        sum = sum + v
      elseif v < 0 then
        prod = prod * -1
        sum = sum + math.abs(v)
      else
        prod = prod * 0
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local prod = 1
    local sum = 0
    for _, v in ipairs(arr) do
      if v > 0 then
        prod = prod * 1
        sum = sum + v
      elseif v < 0 then
        prod = prod * -1
        sum = sum + math.abs(v)
      else
        prod = prod * 0
      end
    end
    return prod * sum
  end
- |2-
      local sum, prod = 0, 1
      for _, v in ipairs(arr) do
          local sign = v > 0 and 1 or v < 0 and -1 or 0
          sum = sum + math.abs(v)
          prod = prod * sign
      end
      return sum * prod
  end
- |2-
    local sum, prod = 0, 1
    for _, v in ipairs(arr) do
      sum = sum + math.abs(v)
      prod = prod * (v < 0 and -1 or v > 0 and 1 or 0)
    end
    return prod == 0 and nil or sum * prod
  end
- |2-
    if #arr == 0 then return nil end
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      local sign = v > 0 and 1 or (v < 0 and -1 or 0)
      sum = sum + math.abs(v)
      prod = prod * sign
    end
    return sum * prod
  end
- |2-
    local prod = 1
    local sum = 0
    for _, v in ipairs(arr) do
      if v > 0 then
        prod = prod * 1
        sum = sum + v
      elseif v < 0 then
        prod = prod * -1
        sum = sum + math.abs(v)
      else
        prod = prod * 0
      end
    end
    return prod * sum
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local prod = 1
    local sum = 0
    for _, v in ipairs(arr) do
      if v > 0 then
        prod = prod * 1
        sum = sum + v
      elseif v < 0 then
        prod = prod * -1
        sum = sum + -v
      else
        prod = prod * 0
        sum = sum + 0
      end
    end
    return prod * sum
  end
- |2-
    if #arr == 0 then return nil end
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      sum = sum + math.abs(v)
      prod = prod * (v == 0 and 1 or v / math.abs(v))
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    if #arr == 0 then return nil end
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local prod = 1
    local sum = 0
    for _, v in ipairs(arr) do
      if v > 0 then
        prod = prod * 1
        sum = sum + v
      elseif v < 0 then
        prod = prod * -1
        sum = sum + v
      else
        prod = prod * 0
      end
    end
    return prod * sum
  end
- |2-
    local prod = 1
    local sum = 0
    for i = 1, #arr do
      if arr[i] > 0 then
        prod = prod * 1
        sum = sum + arr[i]
      elseif arr[i] < 0 then
        prod = prod * -1
        sum = sum + arr[i] * -1
      else
        prod = prod * 0
      end
    end
    return prod * sum
  end
- |2-
      local sum = 0
      local prod = 1
      for _, v in ipairs(arr) do
          if v > 0 then
              sum = sum + v
              prod = prod * 1
          elseif v < 0 then
              sum = sum + v
              prod = prod * -1
          else
              prod = prod * 0
          end
      end
      return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local prod = 1
    local sum = 0
    for _, v in ipairs(arr) do
      if v > 0 then
        prod = prod * 1
        sum = sum + v
      elseif v < 0 then
        prod = prod * -1
        sum = sum + -v
      else
        prod = prod * 0
        sum = sum + 0
      end
    end
    return prod * sum
  end
- |2-
    if #arr == 0 then return nil end
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      local sign = v > 0 and 1 or v < 0 and -1 or 0
      sum = sum + math.abs(v)
      prod = prod * sign
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for i = 1, #arr do
      local x = arr[i]
      if x > 0 then
        sum = sum + x
      elseif x < 0 then
        sum = sum - x
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum, prod = 0, 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    if #arr == 0 then return nil end
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      sum = sum + math.abs(v)
      if v > 0 then prod = prod * 1
      elseif v < 0 then prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
      local sum, prod = 0, 1
      for _, v in ipairs(arr) do
          if v < 0 then
              prod = prod * -1
          elseif v > 0 then
              prod = prod * 1
          else
              prod = prod * 0
          end
          sum = sum + math.abs(v)
      end
      return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v == 0 then
        prod = 0
      else
        sum = sum + math.abs(v)
        prod = prod * (v > 0 and 1 or -1)
      end
    end
    return prod * sum
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for i = 1, #arr do
      local sign = arr[i] > 0 and 1 or arr[i] < 0 and -1 or 0
      sum = sum + math.abs(arr[i])
      prod = prod * sign
    end
    return sum * prod
  end
- |2-
      local sum = 0
      local prod = 1
      for _, v in ipairs(arr) do
          if v > 0 then
              sum = sum + v
          elseif v < 0 then
              sum = sum - v
              prod = prod * -1
          end
      end
      return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local prod = 1
    local sum = 0
    for _, v in ipairs(arr) do
      if v > 0 then
        prod = prod * 1
        sum = sum + v
      elseif v < 0 then
        prod = prod * -1
        sum = sum + -v
      else
        prod = prod * 0
        sum = sum + 0
      end
    end
    return prod * sum
  end
- |2-
    local prod = 1
    local sum = 0
    for _, v in ipairs(arr) do
      if v > 0 then
        prod = prod * 1
        sum = sum + v
      elseif v < 0 then
        prod = prod * -1
        sum = sum + v
      else
        prod = prod * 0
      end
    end
    return sum * prod
  end
- |2-
    local prod = 1
    local sum = 0
    for _, v in ipairs(arr) do
      if v < 0 then
        prod = prod * -1
        sum = sum + v * -1
      elseif v > 0 then
        sum = sum + v
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum, prod = 0, 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    if #arr == 0 then return nil end
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      sum = sum + math.abs(v)
      if v > 0 then prod = prod * 1
      elseif v < 0 then prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      sum = sum + math.abs(v)
      if v > 0 then
        prod = prod * 1
      elseif v < 0 then
        prod = prod * -1
      else
        prod = prod * 0
      end
    end
    return sum * prod
  end
- |2-
    if #arr == 0 then return nil end
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      local sign = v > 0 and 1 or v < 0 and -1 or 0
      sum = sum + math.abs(v)
      prod = prod * sign
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      local sign = v > 0 and 1 or v < 0 and -1 or 0
      sum = sum + math.abs(v)
      prod = prod * sign
    end
    return sum * prod
  end
- |2-
    local prod = 1
    local sum = 0
    for _, v in ipairs(arr) do
      if v > 0 then
        prod = prod * 1
        sum = sum + v
      elseif v < 0 then
        prod = prod * -1
        sum = sum + v
      else
        prod = prod * 0
      end
    end
    return sum * prod
  end
- |2-
    local prod = 1
    local sum = 0
    for _, v in ipairs(arr) do
      if v > 0 then
        prod = prod * 1
        sum = sum + v
      elseif v < 0 then
        prod = prod * -1
        sum = sum + v
      else
        prod = prod * 0
      end
    end
    return prod * sum
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      local sign = v > 0 and 1 or v < 0 and -1 or 0
      prod = prod * sign
      sum = sum + math.abs(v)
    end
    return prod == 0 and nil or sum * prod
  end
- |2-
      if #arr == 0 then return nil end
      local sum = 0
      local prod = 1
      for _, v in ipairs(arr) do
          sum = sum + math.abs(v)
          prod = prod * (v == 0 and 1 or v / math.abs(v))
      end
      return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum, prod = 0, 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local prod = 1
    local sum = 0
    for _, v in ipairs(arr) do
      if v > 0 then
        prod = prod * 1
        sum = sum + v
      elseif v < 0 then
        prod = prod * -1
        sum = sum + -v
      else
        prod = prod * 0
        sum = sum + 0
      end
    end
    return prod * sum
  end
- |2-
    local sum = 0
    local prod = 1
    for i = 1, #arr do
      local n = arr[i]
      if n > 0 then
        sum = sum + n
      elseif n < 0 then
        sum = sum - n
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
      local prod = 1
      local sum = 0
      for _, v in ipairs(arr) do
          if v > 0 then
              prod = prod * 1
              sum = sum + v
          elseif v < 0 then
              prod = prod * -1
              sum = sum + v
          else
              prod = prod * 0
          end
      end
      return prod * sum
  end
- |2-
    if #arr == 0 then return nil end
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      sum = sum + math.abs(v)
      if v > 0 then prod = prod * 1
      elseif v < 0 then prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      sum = sum + math.abs(v)
      if v > 0 then
        prod = prod * 1
      elseif v < 0 then
        prod = prod * -1
      else
        prod = prod * 0
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
      local sum = 0
      local prod = 1
      for _, v in ipairs(arr) do
          local sign = v > 0 and 1 or v < 0 and -1 or 0
          sum = sum + math.abs(v)
          prod = prod * sign
      end
      return sum * prod
  end
- |2-
      local sum = 0
      local prod = 1
      for _, v in ipairs(arr) do
          if v > 0 then
              sum = sum + v
              prod = prod * 1
          elseif v < 0 then
              sum = sum + v
              prod = prod * -1
          else
              prod = prod * 0
          end
      end
      return sum * prod
  end
- |2-
    if #arr == 0 then return nil end
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      sum = sum + math.abs(v)
      if v > 0 then prod = prod * 1
      elseif v < 0 then prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      sum = sum + math.abs(v)
      if v > 0 then
        prod = prod * 1
      elseif v < 0 then
        prod = prod * -1
      else
        prod = prod * 0
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      sum = sum + math.abs(v)
      if v > 0 then
        prod = prod * 1
      elseif v < 0 then
        prod = prod * -1
      else
        prod = prod * 0
      end
    end
    return sum * prod
  end
- |2-
      local sum = 0
      local prod = 1
      for _, v in ipairs(arr) do
          if v > 0 then
              sum = sum + v
              prod = prod * 1
          elseif v < 0 then
              sum = sum + v
              prod = prod * -1
          else
              prod = prod * 0
          end
      end
      return sum * prod
  end
- |2-
      local sum = 0
      local prod = 1
      for _, v in ipairs(arr) do
          if v > 0 then
              sum = sum + v
              prod = prod * 1
          elseif v < 0 then
              sum = sum + v
              prod = prod * -1
          else
              prod = prod * 0
          end
      end
      return prod * sum
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      sum = sum + math.abs(v)
      if v > 0 then
        prod = prod * 1
      elseif v < 0 then
        prod = prod * -1
      else
        prod = prod * 0
      end
    end
    return sum * prod
  end
- |2-
    if #arr == 0 then return nil end
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      sum = sum + math.abs(v)
      if v > 0 then prod = prod * 1
      elseif v < 0 then prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      sum = sum + math.abs(v)
      if v > 0 then
        prod = prod * 1
      elseif v < 0 then
        prod = prod * -1
      else
        prod = prod * 0
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v == 0 then
        prod = 0
      else
        sum = sum + math.abs(v)
        prod = prod * (v > 0 and 1 or -1)
      end
    end
    return prod * sum
  end
- |2-
    local prod = 1
    local sum = 0
    for _, v in ipairs(arr) do
      if v > 0 then
        prod = prod * 1
        sum = sum + v
      elseif v < 0 then
        prod = prod * -1
        sum = sum + v
      else
        prod = prod * 0
      end
    end
    return prod * sum
  end
- |2-
    local prod = 1
    local sum = 0
    for _, v in ipairs(arr) do
      if v > 0 then
        prod = prod * 1
        sum = sum + v
      elseif v < 0 then
        prod = prod * -1
        sum = sum + math.abs(v)
      else
        sum = sum + 0
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for i = 1, #arr do
      local n = arr[i]
      if n > 0 then
        sum = sum + n
      elseif n < 0 then
        sum = sum - n
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local prod = 1
    local sum = 0
    for _, v in ipairs(arr) do
      if v > 0 then
        prod = prod * 1
        sum = sum + v
      elseif v < 0 then
        prod = prod * -1
        sum = sum + v
      else
        prod = prod * 0
      end
    end
    return prod * sum
  end
- |2-
    if #arr == 0 then return nil end
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      sum = sum + math.abs(v)
      prod = prod * (v < 0 and -1 or v > 0 and 1 or 0)
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      local sign = v > 0 and 1 or v < 0 and -1 or 0
      sum = sum + math.abs(v)
      prod = prod * sign
    end
    return sum * prod
  end
- |2-
    local prod = 1
    local sum = 0
    for _, v in ipairs(arr) do
      if v > 0 then
        prod = prod * 1
        sum = sum + v
      elseif v < 0 then
        prod = prod * -1
        sum = sum + math.abs(v)
      else
        prod = prod * 0
      end
    end
    return prod * sum
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    if #arr == 0 then return nil end
    local sum, prod = 0, 1
    for _, v in ipairs(arr) do
      sum = sum + math.abs(v)
      prod = prod * (v == 0 and 1 or v / math.abs(v))
    end
    return sum * prod
  end
- |2-
      if #arr == 0 then return nil end
      local sum = 0
      local prod = 1
      for _, v in ipairs(arr) do
          sum = sum + math.abs(v)
          if v > 0 then prod = prod * 1
          elseif v < 0 then prod = prod * -1
          end
      end
      return sum * prod
  end
- |2-
    local prod = 1
    local sum = 0
    for _, v in ipairs(arr) do
      if v > 0 then
        prod = prod * 1
        sum = sum + v
      elseif v < 0 then
        prod = prod * -1
        sum = sum + v
      else
        prod = prod * 0
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      local sign = v > 0 and 1 or v < 0 and -1 or 0
      sum = sum + math.abs(v)
      prod = prod * sign
    end
    return sum * prod
  end
- |2-
    local prod = 1
    local sum = 0
    for _, v in ipairs(arr) do
      if v > 0 then
        prod = prod * 1
        sum = sum + v
      elseif v < 0 then
        prod = prod * -1
        sum = sum + -v
      else
        prod = prod * 0
        sum = sum + 0
      end
    end
    if sum == 0 then
      return nil
    end
    return prod * sum
  end
- |2-
    if #arr == 0 then return nil end
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      sum = sum + math.abs(v)
      if v > 0 then prod = prod * 1
      elseif v < 0 then prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
      local sum = 0
      local prod = 1
      for _, v in ipairs(arr) do
          if v == 0 then
              prod = 0
          elseif v > 0 then
              prod = prod * 1
          else
              prod = prod * -1
          end
          sum = sum + math.abs(v)
      end
      return sum * prod
  end
- |2-
    if #arr == 0 then return nil end
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      sum = sum + math.abs(v)
      if v > 0 then prod = prod * 1
      elseif v < 0 then prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
      local sum = 0
      local prod = 1
      for _, v in ipairs(arr) do
          if v > 0 then
              sum = sum + v
              prod = prod * 1
          elseif v < 0 then
              sum = sum + -v
              prod = prod * -1
          else
              prod = prod * 0
          end
      end
      if prod == 0 then
          return nil
      end
      return sum * prod
  end
- |2-
    local prod = 1
    local sum = 0
    for _, v in ipairs(arr) do
      if v > 0 then
        prod = prod * 1
        sum = sum + v
      elseif v < 0 then
        prod = prod * -1
        sum = sum + math.abs(v)
      else
        prod = prod * 0
      end
    end
    return prod * sum
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
- |2-
    if #arr == 0 then return nil end
    local prod = 1
    local sum = 0
    for _, v in ipairs(arr) do
      if v > 0 then
        prod = prod * 1
        sum = sum + v
      elseif v < 0 then
        prod = prod * -1
        sum = sum + -v
      end
    end
    return sum * prod
  end
- |2-
    local sum = 0
    local prod = 1
    for _, v in ipairs(arr) do
      if v > 0 then
        sum = sum + v
      elseif v < 0 then
        sum = sum - v
        prod = prod * -1
      end
    end
    return sum * prod
  end
stop_tokens:
- |2-

  local
- |2-

  function
- |2-

  --
- "\n\n"
