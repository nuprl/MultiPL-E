name: HumanEval_127_intersection
language: go_test.go
prompt: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
  // You are given two intervals,\n// where each interval is a pair of integers. For\
  \ example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
  \ which means that the interval (start, end)\n// includes both start and end.\n\
  // For each given interval, it is assumed that its start is less or equal its end.\n\
  // Your task is to determine whether the length of intersection of these two \n\
  // intervals is a prime number.\n// Example, the intersection of the intervals (1,\
  \ 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n//\
  \ If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
  \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output]\
  \ samples:\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
  \ string {\n"
tests: "func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype\
  \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
  \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
  \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
  \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
  \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
  \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
  \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
  \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
  \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
  \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
  test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
  \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
  , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    var result string\n    \n    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1); i++\
    \ {\n        if interval1[i].([]interface{})[0] != interval2[i].([]interface{})[0]\
    \ {\n            result = \"NO\"\n            break\n        }\n    }\n    \n\
    \    if result == \"NO\" {\n        return \"NO\"\n    }\n    \n    if result\
    \ == \"YES\" {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n",
  "    var result string\n    \n    if len(interval1) != len(interval2) {\n      \
    \  return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1); i++ {\n   \
    \     if interval1[i].(float64) < interval2[i].(float64) {\n            result\
    \ = \"NO\"\n            break\n        }\n    }\n    \n    if result == \"NO\"\
    \ {\n        return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1); i++\
    \ {\n        if interval1[i].(float64) >= interval2[i].(float64) {\n         \
    \   result = \"NO\"\n            break\n        }\n    }\n    \n    if result\
    \ == \"NO\" {\n        return \"NO\"\n    }\n    \n    if result == \"YES\" {\n\
    \        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n", "    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n", "    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n    \n    interval1Start := interval1[0].(float64)\n\
    \    interval1End := interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n\
    \    interval2End := interval2[1].(float64)\n    \n    if interval1Start > interval2End\
    \ {\n        return \"NO\"\n    }\n    \n    if interval1End < interval2Start\
    \ {\n        return \"NO\"\n    }\n    \n    intersection := interval1Start <=\
    \ interval2Start && interval1End >= interval2End\n    \n    if intersection {\n\
    \        intersection := interval1Start <= interval2End && interval1End >= interval2Start\n\
    \        \n        if intersection {\n            intersection := interval1Start\
    \ <= interval2Start && interval1End >= interval2End\n            \n          \
    \  if intersection {\n                intersection := interval1Start <= interval2End\
    \ && interval1End >= interval2Start\n                \n                if intersection\
    \ {\n                    intersection := interval1Start <= interval2End && interval1End\
    \ >= interval2Start\n                    \n                    if intersection\
    \ {\n                        intersection := interval1Start <= interval2End &&\
    \ interval1End >= interval2Start\n                        \n                 \
    \       if intersection {\n                            intersection := interval1Start\
    \ <= interval2End && interval1End >= interval2Start\n                        \
    \    \n                            if intersection {\n                       \
    \         intersection := interval1Start <= interval2End && interval1End >= interval2Start\n\
    \                                \n                                if intersection\
    \ {\n                                    intersection := interval1Start <= interval2End\
    \ && interval1End >= interval2Start\n                                    \n  \
    \                                  if intersection {\n                       \
    \                 intersection := interval1Start <= interval2End && interval1End\
    \ >= interval2Start\n                                        \n              \
    \                          if intersection {\n                               \
    \             intersection := interval1Start <= interval2End && interval1End >=\
    \ interval2Start\n                                            \n             \
    \                               if intersection {\n                          \
    \                      intersection := interval1Start <= interval2End && interval1End\
    \ >= interval2Start\n                                                \n      \
    \                                          if intersection {\n               \
    \                                     intersection := interval1Start <= interval2End\
    \ && interval1End >= interval2Start\n                                        \
    \            \n                                                    if intersection\
    \ {\n                                                        intersection := interval1Start\
    \ <= interval2End && interval1End >= interval2Start\n                        \
    \                                \n                                          \
    \              if intersection {\n                                           \
    \                 intersection := interval1Start <= interval2End && interval1End\
    \ >= interval2Start\n                                                        \
    \    \n                                                            if intersection\
    \ {\n                                                                intersection\
    \ := interval1Start <= interval2End && interval1End >= interval", "    if len(interval1)\
    \ != len(interval2) {\n        return \"NO\"\n    }\n    \n    interval1Start\
    \ := interval1[0].(float64)\n    interval1End := interval1[1].(float64)\n    interval2Start\
    \ := interval2[0].(float64)\n    interval2End := interval2[1].(float64)\n    \n\
    \    intersectionStart := interval1Start\n    intersectionEnd := interval1End\n\
    \    \n    for interval1Start <= interval1End && interval2Start <= interval2End\
    \ {\n        if interval1Start <= interval2Start {\n            intersectionStart\
    \ = interval1Start\n            intersectionEnd = interval1End\n        } else\
    \ {\n            intersectionStart = interval2Start\n            intersectionEnd\
    \ = interval2End\n        }\n    }\n    \n    if intersectionStart <= intersectionEnd\
    \ {\n        if intersectionStart <= interval1End {\n            if intersectionEnd\
    \ <= interval2End {\n                return \"YES\"\n            }\n         \
    \   return \"NO\"\n        }\n        return \"NO\"\n    }\n    return \"NO\"\n\
    }\n", "    var interval1Start, interval1End int\n    var interval2Start, interval2End\
    \ int\n    var isIntersecting bool\n\n    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n\n    for i := 0; i < len(interval1); i++ {\n\
    \        interval1Start = interval1[i].(int)\n        interval1End = interval1Start\
    \ + interval1[i].(int)\n    }\n\n    for i := 0; i < len(interval2); i++ {\n \
    \       interval2Start = interval2[i].(int)\n        interval2End = interval2Start\
    \ + interval2[i].(int)\n    }\n\n    isIntersecting = interval1Start <= interval2End\
    \ && interval2Start <= interval1End\n\n    if isIntersecting {\n        if interval1Start\
    \ <= interval2Start && interval1End >= interval2End {\n            return \"YES\"\
    \n        } else {\n            return \"NO\"\n        }\n    } else {\n     \
    \   return \"NO\"\n    }\n}\n", "    \n    // Your code here\n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    ", "    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    result := make([]interface{}, 0)\n    \n   \
    \ for _, v := range interval1 {\n        if v == interval2[0] {\n            result\
    \ = append(result, v)\n        }\n    }\n    \n    for _, v := range interval2\
    \ {\n        if v == interval1[1] {\n            result = append(result, v)\n\
    \        }\n    }\n    \n    if len(result) == 0 {\n        return \"NO\"\n  \
    \  }\n    \n    if len(result) == 1 {\n        return \"YES\"\n    }\n    \n \
    \   if len(result) == 2 {\n        if result[0] == result[1] {\n            return\
    \ \"YES\"\n        }\n    }\n    \n    return \"NO\"\n}\n", "    if len(interval1)\
    \ != len(interval2) {\n        return \"NO\"\n    }\n\n    interval1 := interval1[0]\n\
    \    interval2 := interval2[0]\n\n    if interval1.(float64) < interval2.(float64)\
    \ {\n        interval1, interval2 = interval2, interval1\n    }\n\n    start :=\
    \ interval1.(float64)\n    end := interval2.(float64)\n\n    start += 0.5\n  \
    \  end += 0.5\n\n    if start > end {\n        start, end = end, start\n    }\n\
    \n    start += 0.5\n    end += 0.5\n\n    if start > end {\n        start, end\
    \ = end, start\n    }\n\n    start += 0.5\n    end += 0.5\n\n    if start > end\
    \ {\n        start, end = end, start\n    }\n\n    start += 0.5\n    end += 0.5\n\
    \n    if start > end {\n        start, end = end, start\n    }\n\n    start +=\
    \ 0.5\n    end += 0.5\n\n    if start > end {\n        start, end = end, start\n\
    \    }\n\n    start += 0.5\n    end += 0.5\n\n    if start > end {\n        start,\
    \ end = end, start\n    }\n\n    start += 0.5\n    end += 0.5\n\n    if start\
    \ > end {\n        start, end = end, start\n    }\n\n    start += 0.5\n    end\
    \ += 0.5\n\n    if start > end {\n        start, end = end, start\n    }\n\n \
    \   start += 0.5\n    end += 0.5\n\n    if start > end {\n        start, end =\
    \ end, start\n    }\n\n    start += 0.5\n    end += 0.5\n\n    if start > end\
    \ {\n        start, end = end, start\n    }\n\n    start += 0.5\n    end += 0.5\n\
    \n    if start > end {\n        start, end = end, start\n    }\n\n    start +=\
    \ 0.5\n    end += 0.5\n\n    if start > end {\n        start, end = end, start\n\
    \    }\n\n    start += 0.5\n    end += 0.5\n\n    if start > end {\n        start,\
    \ end = end, start\n    }\n\n    start += 0.5\n    end += 0.5\n\n    if start\
    \ > end {\n        start, end = end, start\n    }\n\n    start += 0.5\n    end\
    \ += 0.5\n\n    if start > end {\n        start, end = end, start\n    }\n\n \
    \   start += 0.5\n    end += 0.5\n\n    if start > end {\n        start, end =\
    \ end, start\n    }\n\n    start += 0.5\n    end += 0.5\n\n    if start > end\
    \ {\n        start, end = end, start\n    }\n\n    start += 0.5\n    end += 0.5\n\
    \n    if start > end {\n        start, end = end, start\n    }\n\n    start +=\
    \ 0.5\n    end += 0.5\n\n", "    var result string\n    var isIntersecting bool\n\
    \    var length int\n    var start1 int\n    var end1 int\n    var start2 int\n\
    \    var end2 int\n    var isPrime bool\n    \n    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1); i++\
    \ {\n        start1 = interval1[i].(float64)\n        end1 = interval1[i].(float64)\n\
    \        start2 = interval2[i].(float64)\n        end2 = interval2[i].(float64)\n\
    \        \n        if start1 < end2 {\n            if start2 < end1 {\n      \
    \          isIntersecting = true\n                length = end1 - start2\n   \
    \         } else {\n                isIntersecting = false\n                length\
    \ = end2 - start1\n            }\n        } else {\n            if start2 < end1\
    \ {\n                isIntersecting = false\n                length = end1 - start2\n\
    \            } else {\n                isIntersecting = true\n               \
    \ length = end2 - start1\n            }\n        }\n        \n        if isIntersecting\
    \ {\n            if isPrime {\n                result = \"YES\"\n            \
    \    break\n            } else {\n                result = \"NO\"\n          \
    \      break\n            }\n        }\n        \n        isPrime = true\n   \
    \ }\n    \n    return result\n}\n", "    var result string\n    if len(interval1)\
    \ != len(interval2) {\n        return \"NO\"\n    }\n    for i := 0; i < len(interval1);\
    \ i++ {\n        start := interval1[i].(float64)\n        end := interval2[i].(float64)\n\
    \        if start > end {\n            start, end = end, start\n        }\n  \
    \      if start > end {\n            continue\n        }\n        if start < end\
    \ {\n            result += \"YES\"\n            break\n        }\n    }\n    if\
    \ result == \"YES\" {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n",
  "    var result string\n    \n    if len(interval1) != len(interval2) {\n      \
    \  return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1); i++ {\n   \
    \     if interval1[i].([]interface{})[0].(int) <= interval2[i].([]interface{})[0].(int)\
    \ {\n            if interval1[i].([]interface{})[0].(int) >= interval2[i].([]interface{})[1].(int)\
    \ {\n                result += fmt.Sprintf(\"%v\", interval1[i].([]interface{})[1].(int))\n\
    \            } else {\n                result += fmt.Sprintf(\"%v\", interval1[i].([]interface{})[0].(int))\n\
    \            }\n        } else {\n            if interval1[i].([]interface{})[0].(int)\
    \ >= interval2[i].([]interface{})[1].(int) {\n                result += fmt.Sprintf(\"\
    %v\", interval1[i].([]interface{})[1].(int))\n            } else {\n         \
    \       result += fmt.Sprintf(\"%v\", interval1[i].([]interface{})[0].(int))\n\
    \            }\n        }\n    }\n    \n    if result == \"NO\" {\n        return\
    \ \"NO\"\n    }\n    \n    if result == \"YES\" {\n        return \"YES\"\n  \
    \  }\n    \n    return result\n}\n", "    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n    \n    result := make([]interface{}, 0)\n\
    \    for _, v := range interval1 {\n        if v == nil {\n            continue\n\
    \        }\n        \n        if v[0] < v[1] {\n            result := append(result,\
    \ v)\n        }\n    }\n    \n    for _, v := range interval2 {\n        if v\
    \ == nil {\n            continue\n        }\n        \n        if v[0] < v[1]\
    \ {\n            result := append(result, v)\n        }\n    }\n    \n    if len(result)\
    \ == 0 {\n        return \"NO\"\n    }\n    \n    if len(result) == 1 {\n    \
    \    return \"YES\"\n    }\n    \n    result := make([]interface{}, 0)\n    \n\
    \    for _, v := range result {\n        if v[0] > v[1] {\n            result\
    \ := append(result, v)\n        }\n    }\n    \n    if len(result) == 1 {\n  \
    \      return \"YES\"\n    }\n    \n    result := make([]interface{}, 0)\n   \
    \ \n    for _, v := range result {\n        if v[0] > v[1] {\n            result\
    \ := append(result, v)\n        }\n    }\n    \n    if len(result) == 1 {\n  \
    \      return \"YES\"\n    }\n    \n    result := make([]interface{}, 0)\n   \
    \ \n    for _, v := range result {\n        if v[0] > v[1] {\n            result\
    \ := append(result, v)\n        }\n    }\n    \n    if len(result) == 1 {\n  \
    \      return \"YES\"\n    }\n    \n    result := make([]interface{}, 0)\n   \
    \ \n    for _, v := range result {\n        if v[0] > v[1] {\n            result\
    \ := append(result, v)\n        }\n    }\n    \n    if len(result) == 1 {\n  \
    \      return \"YES\"\n    }\n    \n    result := make([]interface{}, 0)\n   \
    \ \n    for _, v := range result {\n        if v[0] > v[1] {\n            result\
    \ := append(result, v)\n        }\n    }\n    \n    if len(result) == 1 {\n  \
    \      return \"YES\"\n    }\n    \n    result := make([]interface{}, 0)\n   \
    \ \n    for _, v := range result {\n        if v[0] > v[1] {\n            result\
    \ := append(result, v)\n        }\n    }\n    \n    if len(result) == 1 {\n  \
    \      return \"YES\"\n    }\n    \n    result := make([]interface{}, 0)\n   \
    \ \n    for _, v := range result {\n        if v[0] > v[1] {\n            result\
    \ := append(result, v)\n        }\n    }\n    \n    if len(result) == 1 {\n  \
    \      return \"YES\"\n    }\n    \n    result ", "    var result string\n   \
    \ \n    if len(interval1) != len(interval2) {\n        return \"NO\"\n    }\n\
    \    \n    for i := 0; i < len(interval1); i++ {\n        if interval1[i].([]interface{})[0]\
    \ != interval2[i].([]interface{})[0] {\n            result = \"NO\"\n        \
    \    break\n        }\n    }\n    \n    if result == \"NO\" {\n        return\
    \ \"NO\"\n    }\n    \n    if result == \"YES\" {\n        for i := 0; i < len(interval1);\
    \ i++ {\n            if interval1[i].([]interface{})[1] > interval2[i].([]interface{})[1]\
    \ {\n                result = \"NO\"\n                break\n            }\n \
    \       }\n    }\n    \n    if result == \"NO\" {\n        return \"NO\"\n   \
    \ }\n    \n    if result == \"YES\" {\n        for i := 0; i < len(interval1);\
    \ i++ {\n            if interval1[i].([]interface{})[1] < interval2[i].([]interface{})[1]\
    \ {\n                result = \"NO\"\n                break\n            }\n \
    \       }\n    }\n    \n    if result == \"NO\" {\n        return \"NO\"\n   \
    \ }\n    \n    if result == \"YES\" {\n        for i := 0; i < len(interval1);\
    \ i++ {\n            if interval1[i].([]interface{})[1] == interval2[i].([]interface{})[1]\
    \ {\n                result = \"YES\"\n                break\n            }\n\
    \        }\n    }\n    \n    if result == \"NO\" {\n        return \"NO\"\n  \
    \  }\n    \n    if result == \"YES\" {\n        for i := 0; i < len(interval1);\
    \ i++ {\n            if interval1[i].([]interface{})[1] > interval2[i].([]interface{})[1]\
    \ {\n                result = \"NO\"\n                break\n            }\n \
    \       }\n    }\n    \n    if result == \"NO\" {\n        return \"NO\"\n   \
    \ }\n    \n    if result == \"YES\" {\n        for i := 0; i < len(interval1);\
    \ i++ {\n            if interval1[i].([]interface{})[1] < interval2[i].([]interface{})[1]\
    \ {\n                result = \"NO\"\n                break\n            }\n \
    \       }\n    }\n    \n    if result == \"NO\" {\n        return \"NO\"\n   \
    \ }\n    \n    if result == \"YES\" {\n        for i := 0; i < len(interval1);\
    \ i++ {\n            if interval1[i].([]interface{})[1] == interval2[i].([]interface{})[1]\
    \ {\n                result = \"YES\"\n                break\n            }\n\
    \        }\n    }\n    \n    if result == \"NO\" {\n        return \"NO\"\n  \
    \  }\n    \n    if result == \"YES\" {\n        for i := 0; i < len(interval1);\
    \ i++ ", "    var result string\n    \n    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1); i++\
    \ {\n        if interval1[i].(float64) < interval2[i].(float64) {\n          \
    \  result = \"NO\"\n            break\n        }\n    }\n    \n    if result ==\
    \ \"NO\" {\n        return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1);\
    \ i++ {\n        if interval1[i].(float64) >= interval2[i].(float64) {\n     \
    \       result = \"NO\"\n            break\n        }\n    }\n    \n    if result\
    \ == \"NO\" {\n        return \"NO\"\n    }\n    \n    if result == \"YES\" {\n\
    \        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n", "    if len(interval1)\
    \ != len(interval2) {\n        return \"NO\"\n    }\n    \n    interval1Start\
    \ := interval1[0].(int)\n    interval1End := interval1[1].(int)\n    interval2Start\
    \ := interval2[0].(int)\n    interval2End := interval2[1].(int)\n\n    intersectionStart\
    \ := interval1Start\n    intersectionEnd := interval1End\n\n    for intersectionStart\
    \ <= interval2End {\n        if interval1Start < intersectionStart && intersectionStart\
    \ < interval2End {\n            intersectionEnd = intersectionStart\n        }\n\
    \        intersectionStart = intersectionStart + 1\n    }\n    \n    if intersectionEnd\
    \ < interval2End {\n        return \"NO\"\n    }\n    \n    if intersectionStart\
    \ <= interval2Start {\n        return \"NO\"\n    }\n    \n    if intersectionEnd\
    \ <= interval2End {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n\
    }\n", "    if len(interval1) != len(interval2) {\n        return \"NO\"\n    }\n\
    \n    result := make(map[int]bool)\n    for _, v := range interval1 {\n      \
    \  result[v] = true\n    }\n\n    for _, v := range interval2 {\n        if _,\
    \ ok := result[v]; !ok {\n            return \"NO\"\n        }\n    }\n\n    for\
    \ _, v := range interval1 {\n        if _, ok := result[v]; !ok {\n          \
    \  return \"NO\"\n        }\n    }\n\n    if len(interval1) > len(interval2) {\n\
    \        return \"NO\"\n    }\n\n    for _, v := range interval1 {\n        if\
    \ _, ok := result[v]; !ok {\n            return \"NO\"\n        }\n    }\n\n \
    \   return \"YES\"\n}\n", "    var result string\n    var interval1Start int\n\
    \    var interval1End int\n    var interval2Start int\n    var interval2End int\n\
    \n    if len(interval1) != len(interval2) {\n        return \"NO\"\n    }\n\n\
    \    for i := 0; i < len(interval1); i++ {\n        interval1Start = interval1[i].([]interface{})[0].(int)\n\
    \        interval1End = interval1[i].([]interface{})[1].(int)\n        interval2Start\
    \ = interval2[i].([]interface{})[0].(int)\n        interval2End = interval2[i].([]interface{})[1].(int)\n\
    \n        if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n            result = result + \"(\" + fmt.Sprint(interval1Start) + \", \"\
    \ + fmt.Sprint(interval1End) + \")\"\n        }\n    }\n\n    if result != \"\"\
    \ {\n        return \"YES\"\n    }\n\n    return \"NO\"\n}\n", "    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n", "    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n    \n    interval1Start := interval1[0].(int)\n\
    \    interval1End := interval1[1].(int)\n    interval2Start := interval2[0].(int)\n\
    \    interval2End := interval2[1].(int)\n    \n    if interval1Start > interval1End\
    \ {\n        interval1Start, interval1End = interval1End, interval1Start\n   \
    \ }\n    if interval2Start > interval2End {\n        interval2Start, interval2End\
    \ = interval2End, interval2Start\n    }\n    \n    if interval1Start <= interval2End\
    \ {\n        if interval1End <= interval2Start {\n            return \"NO\"\n\
    \        }\n        \n        interval1Length := interval1End - interval1Start\n\
    \        interval2Length := interval2End - interval2Start\n        \n        if\
    \ interval1Length == interval2Length {\n            \n            if interval1Start\
    \ <= interval2Start {\n                return \"YES\"\n            }\n       \
    \     \n            interval1Start := interval1Start + interval2Length\n     \
    \       interval1End := interval1End + interval2Length\n            \n       \
    \     if interval1Start > interval1End {\n                return \"NO\"\n    \
    \        }\n            \n            interval1Length := interval1End - interval1Start\n\
    \            \n            if interval1Length == 1 {\n                return \"\
    YES\"\n            }\n            \n            if interval1Length == 2 || interval1Length\
    \ == 3 {\n                return \"YES\"\n            }\n            \n      \
    \      if interval1Length == 4 || interval1Length == 5 {\n                return\
    \ \"YES\"\n            }\n            \n            if interval1Length == 6 ||\
    \ interval1Length == 7 {\n                return \"YES\"\n            }\n    \
    \        \n            if interval1Length == 8 || interval1Length == 9 {\n   \
    \             return \"YES\"\n            }\n            \n            if interval1Length\
    \ == 10 || interval1Length == 11 {\n                return \"YES\"\n         \
    \   }\n            \n            if interval1Length == 12 || interval1Length ==\
    \ 13 {\n                return \"YES\"\n            }\n            \n        \
    \    if interval1Length == 14 || interval1Length == 15 {\n                return\
    \ \"YES\"\n            }\n            \n            if interval1Length == 16 ||\
    \ interval1Length == 17 {\n                return \"YES\"\n            }\n   \
    \         \n            if interval1Length == 18 || interval1Length == 19 {\n\
    \                return \"YES\"\n            }\n            \n            if interval1Length\
    \ == 20 || interval1Length == 21 {\n                return \"YES\"\n         \
    \   }\n            \n            if interval1Length == 22 || interval1Length ==\
    \ 23", "    \n    var result string\n    \n    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1); i++\
    \ {\n        if interval1[i].(float64) < interval2[i].(float64) {\n          \
    \  result = \"NO\"\n            break\n        }\n    }\n    \n    if result ==\
    \ \"NO\" {\n        return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1);\
    \ i++ {\n        if interval1[i].(float64) >= interval2[i].(float64) {\n     \
    \       result = \"NO\"\n            break\n        }\n    }\n    \n    if result\
    \ == \"NO\" {\n        return \"NO\"\n    }\n    \n    if result == \"YES\" {\n\
    \        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n", "    var result\
    \ string\n    \n    interval1Start, interval1End := interval1[0].(int), interval1[1].(int)\n\
    \    interval2Start, interval2End := interval2[0].(int), interval2[1].(int)\n\
    \    \n    if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n        result += \"YES\"\n    } else {\n        result += \"NO\"\n    }\n\
    \    \n    return result\n}\n", "    if len(interval1) != len(interval2) {\n \
    \       return \"NO\"\n    }\n    \n    interval1 := make([]int, len(interval1))\n\
    \    interval2 := make([]int, len(interval2))\n    \n    for i := 0; i < len(interval1);\
    \ i++ {\n        interval1[i] = interval1[i].(int)\n    }\n    for i := 0; i <\
    \ len(interval2); i++ {\n        interval2[i] = interval2[i].(int)\n    }\n  \
    \  \n    result := make([]int, len(interval1))\n    \n    for i := 0; i < len(interval1);\
    \ i++ {\n        if interval1[i] > interval2[i] {\n            result[i] = interval1[i]\n\
    \        } else {\n            result[i] = interval2[i]\n        }\n    }\n  \
    \  \n    result := make([]int, len(result))\n    \n    for i := 0; i < len(result);\
    \ i++ {\n        if result[i] == 0 {\n            result[i] = 1\n        }\n \
    \   }\n    \n    result := make([]int, len(result))\n    \n    for i := 0; i <\
    \ len(result); i++ {\n        if result[i] == 1 {\n            return \"NO\"\n\
    \        }\n    }\n    \n    return \"YES\"\n}\n", "    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n    \n    interval1 := interval1[0]\n    interval2\
    \ := interval2[0]\n    \n    start := interval1.([]interface{})[1]\n    end :=\
    \ interval2.([]interface{})[1]\n    \n    if start > end {\n        return \"\
    NO\"\n    }\n    \n    start := start.(int)\n    end := end.(int)\n    \n    result\
    \ := make([]int, 0, end-start)\n    \n    for i := start; i < end; i++ {\n   \
    \     result = append(result, i)\n    }\n    \n    result := result[:len(result)/2]\n\
    \    \n    if len(result) == 1 {\n        return \"YES\"\n    }\n    \n    result\
    \ := result[:len(result)/2]\n    \n    for _, i := range result {\n        if\
    \ result[len(result)-1] != i {\n            result := append(result, i)\n    \
    \    }\n    }\n    \n    result := result[:len(result)/2]\n    \n    for _, i\
    \ := range result {\n        if result[len(result)-1] != i {\n            result\
    \ := append(result, i)\n        }\n    }\n    \n    result := result[:len(result)/2]\n\
    \    \n    for _, i := range result {\n        if result[len(result)-1] != i {\n\
    \            result := append(result, i)\n        }\n    }\n    \n    result :=\
    \ result[:len(result)/2]\n    \n    for _, i := range result {\n        if result[len(result)-1]\
    \ != i {\n            result := append(result, i)\n        }\n    }\n    \n  \
    \  result := result[:len(result)/2]\n    \n    for _, i := range result {\n  \
    \      if result[len(result)-1] != i {\n            result := append(result, i)\n\
    \        }\n    }\n    \n    result := result[:len(result)/2]\n    \n    for _,\
    \ i := range result {\n        if result[len(result)-1] != i {\n            result\
    \ := append(result, i)\n        }\n    }\n    \n    result := result[:len(result)/2]\n\
    \    \n    for _, i := range result {\n        if result[len(result)-1] != i {\n\
    \            result := append(result, i)\n        }\n    }\n    \n    result :=\
    \ result[:len(result)/2]\n    \n    for _, i := range result {\n        if result[len(result)-1]\
    \ != i {\n            result := append(result, i)\n        }\n    }\n    \n  \
    \  result := result[:len(result)/2]\n    \n    for _, i := range result {\n  \
    \      if result[len(result)-1] != i {\n            result := append(", "    if\
    \ len(interval1) != len(interval2) {\n        return \"NO\"\n    }\n    \n   \
    \ result := make([]interface{}, 0)\n    \n    for _, interval := range interval1\
    \ {\n        if interval[0] < interval[1] {\n            result = append(result,\
    \ interval)\n        }\n    }\n    \n    for _, interval := range interval2 {\n\
    \        if interval[0] < interval[1] {\n            result = append(result, interval)\n\
    \        }\n    }\n    \n    if len(result) == 0 {\n        return \"NO\"\n  \
    \  }\n    \n    result := result[0]\n    \n    if result[0] > result[1] {\n  \
    \      return \"NO\"\n    }\n    \n    if result[1] < result[0] {\n        return\
    \ \"NO\"\n    }\n    \n    if result[0] < result[1] {\n        return \"YES\"\n\
    \    }\n    \n    if result[0] > result[1] {\n        return \"YES\"\n    }\n\
    \    \n    if result[0] > result[1] {\n        return \"YES\"\n    }\n    \n \
    \   return \"YES\"\n}\n", "    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    interval1Start := interval1[0].(float64)\n \
    \   interval1End := interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n\
    \    interval2End := interval2[1].(float64)\n    \n    if interval1Start > interval2End\
    \ {\n        return \"NO\"\n    }\n    if interval1End < interval2Start {\n  \
    \      return \"NO\"\n    }\n    \n    intersection := interval1Start + interval1End\
    \ - interval2Start - interval2End\n    if intersection <= 0 {\n        return\
    \ \"NO\"\n    }\n    if intersection <= 1 {\n        return \"YES\"\n    }\n \
    \   \n    if isPrime(intersection) {\n        return \"YES\"\n    }\n    return\
    \ \"NO\"\n}\n", "    \n    // Your code here\n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    ", "    if len(interval1) != len(interval2) {\n        return \"NO\"\n  \
    \  }\n    \n    interval1Map := make(map[int]bool)\n    interval2Map := make(map[int]bool)\n\
    \    \n    for _, v := range interval1 {\n        interval1Map[v.(int)]=true\n\
    \    }\n    for _, v := range interval2 {\n        interval2Map[v.(int)]=true\n\
    \    }\n    \n    result := make([]interface{}, 0)\n    for k := range interval1Map\
    \ {\n        if interval2Map[k]==true {\n            result = append(result, k)\n\
    \        }\n    }\n    if len(result)==0 {\n        return \"NO\"\n    }\n   \
    \ \n    if len(result)==1 {\n        return \"YES\"\n    }\n    \n    length :=\
    \ len(result)\n    if length%2==0 {\n        return \"NO\"\n    }\n    \n    result\
    \ := make([]interface{}, 0)\n    for i := 0; i < length/2; i++ {\n        if interval1Map[result[i]]==true\
    \ {\n            result = append(result, result[i+1])\n        }\n    }\n    \n\
    \    if len(result)==1 {\n        return \"YES\"\n    }\n    \n    return \"NO\"\
    \n}\n", "    var result string\n    var start int\n    var end int\n    var length\
    \ int\n    var intersection []interface{}\n    \n    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1); i++\
    \ {\n        start = interval1[i].(int)\n        end = interval2[i].(int)\n  \
    \      \n        if start > end {\n            start = interval1[i].(int)\n  \
    \          end = interval2[i].(int)\n        }\n        \n        length = end\
    \ - start\n        \n        if length == 0 {\n            continue\n        }\n\
    \        \n        intersection = append(intersection, start)\n        intersection\
    \ = append(intersection, end)\n    }\n    \n    if len(intersection) == 0 {\n\
    \        return \"NO\"\n    }\n    \n    for i := 0; i < len(intersection); i++\
    \ {\n        if intersection[i] > intersection[i+1] {\n            intersection[i],\
    \ intersection[i+1] = intersection[i+1], intersection[i]\n        }\n    }\n \
    \   \n    for i := 0; i < len(intersection); i++ {\n        if intersection[i]\
    \ == intersection[i+1] {\n            continue\n        }\n        \n        if\
    \ isPrime(intersection[i], intersection[i+1]) {\n            result = \"YES\"\n\
    \            break\n        }\n    }\n    \n    return result\n}\n", "    var\
    \ result string\n    \n    if len(interval1) != len(interval2) {\n        return\
    \ \"NO\"\n    }\n    \n    for i := 0; i < len(interval1); i++ {\n        result\
    \ += \"(\"\n        result += fmt.Sprintf(\"%d\", interval1[i].(float64))\n  \
    \      result += \", \"\n        result += fmt.Sprintf(\"%d\", interval2[i].(float64))\n\
    \        result += \")\"\n    }\n    \n    if result == \"\" {\n        return\
    \ \"NO\"\n    }\n    \n    result += \"\\n\"\n    \n    result += \"The length\
    \ of intersection of these two intervals is: \"\n    result += \"\\n\"\n    result\
    \ += \"The length of intersection of these two intervals is: \"\n    result +=\
    \ \"\\n\"\n    result += \"The length of intersection of these two intervals is:\
    \ \"\n    result += \"\\n\"\n    result += \"The length of intersection of these\
    \ two intervals is: \"\n    result += \"\\n\"\n    result += \"The length of intersection\
    \ of these two intervals is: \"\n    result += \"\\n\"\n    result += \"The length\
    \ of intersection of these two intervals is: \"\n    result += \"\\n\"\n    result\
    \ += \"The length of intersection of these two intervals is: \"\n    result +=\
    \ \"\\n\"\n    result += \"The length of intersection of these two intervals is:\
    \ \"\n    result += \"\\n\"\n    result += \"The length of intersection of these\
    \ two intervals is: \"\n    result += \"\\n\"\n    result += \"The length of intersection\
    \ of these two intervals is: \"\n    result += \"\\n\"\n    result += \"The length\
    \ of intersection of these two intervals is: \"\n    result += \"\\n\"\n    result\
    \ += \"The length of intersection of these two intervals is: \"\n    result +=\
    \ \"\\n\"\n    result += \"The length of intersection of these two intervals is:\
    \ \"\n    result += \"\\n\"\n    result += \"The length of intersection of these\
    \ two intervals is: \"\n    result += \"\\n\"\n    result += \"The length of intersection\
    \ of these two intervals is: \"\n    result += \"\\n\"\n    result += \"The length\
    \ of intersection of these two intervals is: \"\n    result += \"\\n\"\n    result\
    \ += \"The length of intersection of these two intervals is: \"\n    result +=\
    \ \"\\n\"\n    result += \"The length of intersection of these two intervals is:\
    \ \"\n    result += \"\\n\"\n    result += \"The length of intersection of these\
    \ two intervals is: \"\n    result += \"\\n\"\n    result += \"The length of intersection\
    \ of these two intervals is: \"\n    result += \"\\n\"\n    result += \"The length\
    \ of intersection of these two intervals is: \"\n    result += \"\\n\"\n    result\
    \ += \"The length of intersection of these two intervals is: \"", "    if len(interval1)\
    \ != len(interval2) {\n        return \"NO\"\n    }\n    \n    interval1 := make([]int,\
    \ len(interval1))\n    interval2 := make([]int, len(interval2))\n    \n    for\
    \ i, v := range interval1 {\n        interval1[i] = v.(int)\n    }\n    for i,\
    \ v := range interval2 {\n        interval2[i] = v.(int)\n    }\n    \n    result\
    \ := make([]int, len(interval1))\n    \n    for i, v := range interval1 {\n  \
    \      for j, w := range interval2 {\n            if v >= w {\n              \
    \  result[i] = v\n                break\n            }\n        }\n    }\n   \
    \ \n    if len(result) == 0 {\n        return \"NO\"\n    }\n    \n    length\
    \ := len(result)\n    \n    if length == 1 {\n        return \"YES\"\n    }\n\
    \    \n    if length == 2 {\n        if result[0] == result[1] {\n           \
    \ return \"YES\"\n        }\n        return \"NO\"\n    }\n    \n    if length\
    \ == 3 {\n        if result[0] == result[1] && result[1] == result[2] {\n    \
    \        return \"YES\"\n        }\n        return \"NO\"\n    }\n    \n    if\
    \ length == 4 {\n        if result[0] == result[1] && result[1] == result[2] &&\
    \ result[2] == result[3] {\n            return \"YES\"\n        }\n        return\
    \ \"NO\"\n    }\n    \n    if length == 5 {\n        if result[0] == result[1]\
    \ && result[1] == result[2] && result[2] == result[3] && result[3] == result[4]\
    \ {\n            return \"YES\"\n        }\n        return \"NO\"\n    }\n   \
    \ \n    if length == 6 {\n        if result[0] == result[1] && result[1] == result[2]\
    \ && result[2] == result[3] && result[3] == result[4] && result[4] == result[5]\
    \ {\n            return \"YES\"\n        }\n        return \"NO\"\n    }\n   \
    \ \n    if length == 7 {\n        if result[0] == result[1] && result[1] == result[2]\
    \ && result[2] == result[3] && result[3] == result[4] && result[4] == result[5]\
    \ && result[5] == result[6] {\n            return \"YES\"\n        }\n       \
    \ return \"NO\"\n    }\n    \n    if length == 8 {\n        if result[0] == result[1]\
    \ && result[1] == result[2] && result[2] == result[3] && result[3] == result[4]\
    \ && result[4] == result[5] && result[5] == result[6] && result[6] == result[7]\
    \ {\n            return \"YES\"\n        }\n        return \"NO\"\n    }\n   \
    \ \n    if length == 9 {\n        if result[0] == result[1] && result[1] == result[2]\
    \ && result[2] == result[3] && result[3] == result[4] && result[4] == result[5]\
    \ && result[5] == result[6] && result[6] == result[7] && result[7] == result[8]\
    \ {", "    if len(interval1) != len(interval2) {\n        return \"NO\"\n    }\n\
    \    \n    interval1Start := interval1[0].(float64)\n    interval1End := interval1[1].(float64)\n\
    \    interval2Start := interval2[0].(float64)\n    interval2End := interval2[1].(float64)\n\
    \    \n    if interval1Start > interval2End {\n        return \"NO\"\n    }\n\
    \    if interval1End < interval2Start {\n        return \"NO\"\n    }\n    \n\
    \    intersectionLength := interval1End - interval1Start\n    \n    if intersectionLength\
    \ == 0 {\n        return \"NO\"\n    }\n    \n    if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n        return \"YES\"\n    }\n    if interval1Start\
    \ <= interval2End && interval1End >= interval2Start {\n        return \"YES\"\n\
    \    }\n    if interval1Start >= interval2Start && interval1End <= interval2End\
    \ {\n        return \"YES\"\n    }\n    if interval1Start >= interval2End && interval1End\
    \ <= interval2Start {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n\
    }\n", "    if len(interval1) != len(interval2) {\n        return \"NO\"\n    }\n\
    \    \n    result := make([]interface{}, 0)\n    \n    for _, interval := range\
    \ interval1 {\n        if interval == nil {\n            continue\n        }\n\
    \        \n        start, end := interval.([]interface{})\n        \n        if\
    \ start > end {\n            continue\n        }\n        \n        result :=\
    \ append(result, interval)\n    }\n    \n    for _, interval := range interval2\
    \ {\n        if interval == nil {\n            continue\n        }\n        \n\
    \        start, end := interval.([]interface{})\n        \n        if start >\
    \ end {\n            continue\n        }\n        \n        result := append(result,\
    \ interval)\n    }\n    \n    if len(result) == 0 {\n        return \"NO\"\n \
    \   }\n    \n    sort.Slice(result, func(i, j int) bool {\n        return result[i].([]interface{})[1]\
    \ < result[j].([]interface{})[1]\n    })\n    \n    length := 0\n    \n    for\
    \ _, interval := range result {\n        start, end := interval.([]interface{})\n\
    \        \n        if start > end {\n            continue\n        }\n       \
    \ \n        length = length + 1\n    }\n    \n    if length == 1 {\n        return\
    \ \"YES\"\n    }\n    \n    if length == 2 && result[0].([]interface{})[1] > result[1].([]interface{})[1]\
    \ {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n", "    var result\
    \ string\n    var interval1Start int\n    var interval1End int\n    var interval2Start\
    \ int\n    var interval2End int\n    \n    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1); i++\
    \ {\n        interval1Start = interval1[i].(float64)\n        interval1End = interval1[i].(float64)\n\
    \        \n        for j := 0; j < len(interval2); j++ {\n            interval2Start\
    \ = interval2[j].(float64)\n            interval2End = interval2[j].(float64)\n\
    \            \n            if interval1Start <= interval2Start && interval1End\
    \ >= interval2End {\n                \n                if interval1Start <= interval2End\
    \ {\n                    result = result + \"(\" + fmt.Sprint(interval1Start)\
    \ + \", \" + fmt.Sprint(interval1End) + \")\"\n                }\n           \
    \     \n                if interval1End >= interval2Start {\n                \
    \    result = result + \"(\" + fmt.Sprint(interval1End) + \", \" + fmt.Sprint(interval1Start)\
    \ + \")\"\n                }\n                \n                break\n      \
    \      }\n        }\n    }\n    \n    if result == \"NO\" {\n        return \"\
    NO\"\n    }\n    \n    if result == \"YES\" {\n        return \"YES\"\n    }\n\
    \    \n    return \"NO\"\n}\n", "    if len(interval1) != len(interval2) {\n \
    \       return \"NO\"\n    }\n    \n    interval1 := interval1.([]interface{})\n\
    \    interval2 := interval2.([]interface{})\n    \n    result := make([]interface{},\
    \ 0)\n    \n    for _, v := range interval1 {\n        if v >= interval2[0] {\n\
    \            result = append(result, v)\n        }\n    }\n    \n    for _, v\
    \ := range interval2 {\n        if v >= interval1[0] {\n            result = append(result,\
    \ v)\n        }\n    }\n    \n    if len(result) == 0 {\n        return \"NO\"\
    \n    }\n    \n    result := result.([]interface{})\n    \n    if len(result)\
    \ == 1 {\n        if result[0] == result[1] {\n            return \"YES\"\n  \
    \      }\n        return \"NO\"\n    }\n    \n    result := result.([]interface{})\n\
    \    \n    if len(result) == 2 {\n        if result[0] == result[1] {\n      \
    \      return \"YES\"\n        }\n        return \"NO\"\n    }\n    \n    result\
    \ := result.([]interface{})\n    \n    if len(result) == 3 {\n        if result[0]\
    \ == result[1] && result[1] == result[2] {\n            return \"YES\"\n     \
    \   }\n        return \"NO\"\n    }\n    \n    result := result.([]interface{})\n\
    \    \n    if len(result) == 4 {\n        if result[0] == result[1] && result[1]\
    \ == result[2] && result[2] == result[3] {\n            return \"YES\"\n     \
    \   }\n        return \"NO\"\n    }\n    \n    result := result.([]interface{})\n\
    \    \n    if len(result) == 5 {\n        if result[0] == result[1] && result[1]\
    \ == result[2] && result[2] == result[3] && result[3] == result[4] {\n       \
    \     return \"YES\"\n        }\n        return \"NO\"\n    }\n    \n    result\
    \ := result.([]interface{})\n    \n    if len(result) == 6 {\n        if result[0]\
    \ == result[1] && result[1] == result[2] && result[2] == result[3] && result[3]\
    \ == result[4] && result[4] == result[5] {\n            return \"YES\"\n     \
    \   }\n        return \"NO\"\n    }\n    \n    result := result.([]interface{})\n\
    \    \n    if len(result) == 7 {\n        if result[0] == result[1] && result[1]\
    \ == result[2] && result[2] == result[3] && result[3] == result[4] && result[4]\
    \ == result[5] && result[5] == result[6] {\n            return \"YES\"\n     \
    \   }\n        return \"NO\"\n    }\n    \n    result := result.([]interface{})\n\
    \    \n    if len(result) == 8 {\n        if result[0] == result[1] && result[1]\
    \ == result[2] && result[2] == result[3] && result[3] == result[4] && result[4]\
    \ == result[5] && ", "    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n",
  "    var result string\n    \n    interval1Start := interval1[0].(int)\n    interval1End\
    \ := interval1[1].(int)\n    interval2Start := interval2[0].(int)\n    interval2End\
    \ := interval2[1].(int)\n    \n    if interval1Start <= interval1End && interval2Start\
    \ <= interval2End {\n        if interval1Start <= interval2Start && interval1End\
    \ >= interval2End {\n            if interval1Start <= interval2End {\n       \
    \         result = fmt.Sprintf(\"YES\")\n            } else {\n              \
    \  result = fmt.Sprintf(\"NO\")\n            }\n        } else {\n           \
    \ result = fmt.Sprintf(\"NO\")\n        }\n    } else {\n        result = fmt.Sprintf(\"\
    NO\")\n    }\n    \n    return result\n}\n", "    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n", "    var result string\n    \n    if len(interval1)\
    \ != len(interval2) {\n        return \"NO\"\n    }\n    \n    for _, v := range\
    \ interval1 {\n        if v == nil {\n            continue\n        }\n      \
    \  \n        if interval2[0] == nil {\n            result = \"NO\"\n         \
    \   break\n        }\n        \n        if v == interval2[0].(type) {\n      \
    \      if interval1[1] == nil {\n                result = \"NO\"\n           \
    \     break\n            }\n            \n            if v == interval1[1].(type)\
    \ {\n                if interval2[1] == nil {\n                    result = \"\
    NO\"\n                    break\n                }\n                \n       \
    \         if v == interval2[1].(type) {\n                    if interval1[0].(int)\
    \ <= interval2[0].(int) && interval1[1].(int) >= interval2[1].(int) {\n      \
    \                  result = \"YES\"\n                        break\n         \
    \           }\n                }\n            }\n        }\n    }\n    \n    return\
    \ result\n}\n", "    if len(interval1) != len(interval2) {\n        return \"\
    NO\"\n    }\n    \n    interval1Map := make(map[int]bool)\n    interval2Map :=\
    \ make(map[int]bool)\n    \n    for _, v := range interval1 {\n        interval1Map[v.(int)]=true\n\
    \    }\n    for _, v := range interval2 {\n        interval2Map[v.(int)]=true\n\
    \    }\n    \n    result := make([]interface{}, 0)\n    for _, v := range interval1Map\
    \ {\n        if interval2Map[v] {\n            result = append(result, v)\n  \
    \      }\n    }\n    \n    if len(result) == 0 {\n        return \"NO\"\n    }\n\
    \    \n    length := len(result)\n    if length == 1 {\n        return \"YES\"\
    \n    }\n    \n    if length == 2 && result[0] == result[1] {\n        return\
    \ \"YES\"\n    }\n    \n    if length == 2 && result[0] < result[1] {\n      \
    \  return \"NO\"\n    }\n    \n    if length == 2 && result[0] > result[1] {\n\
    \        return \"NO\"\n    }\n    \n    if length == 3 && result[0] == result[1]\
    \ && result[2] == result[1] {\n        return \"YES\"\n    }\n    \n    if length\
    \ == 3 && result[0] < result[1] && result[2] < result[1] {\n        return \"\
    NO\"\n    }\n    \n    if length == 3 && result[0] > result[1] && result[2] >\
    \ result[1] {\n        return \"NO\"\n    }\n    \n    if length == 4 && result[0]\
    \ == result[1] && result[2] == result[1] && result[3] == result[1] {\n       \
    \ return \"YES\"\n    }\n    \n    if length == 4 && result[0] < result[1] &&\
    \ result[2] < result[1] && result[3] < result[1] {\n        return \"NO\"\n  \
    \  }\n    \n    if length == 4 && result[0] > result[1] && result[2] > result[1]\
    \ && result[3] > result[1] {\n        return \"NO\"\n    }\n    \n    if length\
    \ == 5 && result[0] == result[1] && result[2] == result[1] && result[3] == result[1]\
    \ && result[4] == result[1] {\n        return \"YES\"\n    }\n    \n    if length\
    \ == 5 && result[0] < result[1] && result[2] < result[1] && result[3] < result[1]\
    \ && result[4] < result[1] {\n        return \"NO\"\n    }\n    \n    if length\
    \ == 5 && result[0] > result[1] && result[2] > result[1] && result[3] > result[1]\
    \ && result[4] > result[1] {\n        return \"NO\"\n    }\n    \n    if length\
    \ == 6 && result[0] == result[1] && result[2] == result[1] && result[3] == result[1]\
    \ && result[4] == result[1] && result", "    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n\n    interval1Start, interval1End := interval1[0].(int),\
    \ interval1[1].(int)\n    interval2Start, interval2End := interval2[0].(int),\
    \ interval2[1].(int)\n\n    if interval1Start > interval2End {\n        return\
    \ \"NO\"\n    }\n\n    if interval1End < interval2Start {\n        return \"NO\"\
    \n    }\n\n    if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n        return \"YES\"\n    }\n\n    if interval1Start >= interval2Start\
    \ && interval1End <= interval2End {\n        return \"YES\"\n    }\n\n    if interval1Start\
    \ <= interval2Start && interval1End >= interval2End {\n        return \"YES\"\n\
    \    }\n\n    if interval1Start >= interval2Start && interval1End <= interval2End\
    \ {\n        return \"YES\"\n    }\n\n    if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n        return \"YES\"\n    }\n\n    if interval1Start\
    \ >= interval2Start && interval1End <= interval2End {\n        return \"YES\"\n\
    \    }\n\n    if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n        return \"YES\"\n    }\n\n    if interval1Start >= interval2Start\
    \ && interval1End <= interval2End {\n        return \"YES\"\n    }\n\n    if interval1Start\
    \ <= interval2Start && interval1End >= interval2End {\n        return \"YES\"\n\
    \    }\n\n    return \"NO\"\n}\n", "    var result string\n    \n    if len(interval1)\
    \ != len(interval2) {\n        return \"NO\"\n    }\n    \n    for i := 0; i <\
    \ len(interval1); i++ {\n        if interval1[i].(float64) < interval2[i].(float64)\
    \ {\n            result += \"NO\"\n            break\n        }\n    }\n    \n\
    \    if result == \"NO\" {\n        return \"NO\"\n    }\n    \n    for i := 0;\
    \ i < len(interval1); i++ {\n        if interval1[i].(float64) > interval2[i].(float64)\
    \ {\n            result += \"NO\"\n            break\n        }\n    }\n    \n\
    \    if result == \"NO\" {\n        return \"NO\"\n    }\n    \n    if result\
    \ == \"YES\" {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n",
  "    \n    var result string\n    \n    if len(interval1) != len(interval2) {\n\
    \        return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1); i++ {\n\
    \        if interval1[i].(float64) >= interval2[i].(float64) {\n            result\
    \ = \"NO\"\n            break\n        }\n    }\n    \n    if result == \"NO\"\
    \ {\n        return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1); i++\
    \ {\n        if interval1[i].(float64) <= interval2[i].(float64) {\n         \
    \   result = \"NO\"\n            break\n        }\n    }\n    \n    if result\
    \ == \"NO\" {\n        return \"NO\"\n    }\n    \n    if result == \"YES\" {\n\
    \        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n", "    var result\
    \ string\n    var interval1Start int\n    var interval1End int\n    var interval2Start\
    \ int\n    var interval2End int\n    var interval1Length int\n    var interval2Length\
    \ int\n    var isIntersecting bool\n\n    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n\n    for i := 0; i < len(interval1); i++ {\n\
    \        interval1Start = interval1[i].(float64)\n        interval1End = interval1[i].(float64)\n\
    \        interval1Length = interval1End - interval1Start\n\n        interval2Start\
    \ = interval2[i].(float64)\n        interval2End = interval2[i].(float64)\n  \
    \      interval2Length = interval2End - interval2Start\n\n        if interval1Start\
    \ <= interval2Start && interval1End >= interval2End {\n            isIntersecting\
    \ = true\n        } else {\n            isIntersecting = false\n        }\n\n\
    \        if isIntersecting {\n            if interval1Length == interval2Length\
    \ {\n                result = \"YES\"\n            } else {\n                result\
    \ = \"NO\"\n            }\n        } else {\n            result = \"NO\"\n   \
    \     }\n    }\n\n    return result\n}\n", "    var interval1Start, interval1End\
    \ int\n    var interval2Start, interval2End int\n    var lengthOfIntersection\
    \ int\n    var isPrime bool\n\n    interval1Start, interval1End = interval1[0].(int),\
    \ interval1[1].(int)\n    interval2Start, interval2End = interval2[0].(int), interval2[1].(int)\n\
    \n    if interval1Start > interval1End {\n        fmt.Println(\"interval1Start\
    \ > interval1End\")\n        return \"NO\"\n    }\n    if interval2Start > interval2End\
    \ {\n        fmt.Println(\"interval2Start > interval2End\")\n        return \"\
    NO\"\n    }\n\n    if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n        fmt.Println(\"interval1Start <= interval2Start && interval1End >=\
    \ interval2End\")\n        return \"NO\"\n    }\n\n    if interval1Start <= interval2End\
    \ && interval1End >= interval2Start {\n        fmt.Println(\"interval1Start <=\
    \ interval2End && interval1End >= interval2Start\")\n        return \"NO\"\n \
    \   }\n\n    if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n        fmt.Println(\"interval1Start <= interval2Start && interval1End >=\
    \ interval2End\")\n        return \"NO\"\n    }\n\n    if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n        fmt.Println(\"interval1Start <= interval2Start\
    \ && interval1End >= interval2End\")\n        return \"NO\"\n    }\n\n    if interval1Start\
    \ <= interval2Start && interval1End >= interval2End {\n        fmt.Println(\"\
    interval1Start <= interval2Start && interval1End >= interval2End\")\n        return\
    \ \"NO\"\n    }\n\n    if interval1Start <= interval2Start && interval1End >=\
    \ interval2End {\n        fmt.Println(\"interval1Start <= interval2Start && interval1End\
    \ >= interval2End\")\n        return \"NO\"\n    }\n\n    if interval1Start <=\
    \ interval2Start && interval1End >= interval2End {\n        fmt.Println(\"interval1Start\
    \ <= interval2Start && interval1End >= interval2End\")\n        return \"NO\"\n\
    \    }\n\n    if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n        fmt.Println(\"interval1Start <= interval2Start && interval1End >=\
    \ interval2End\")\n        return \"NO\"\n    }\n\n    if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n        fmt.Println(\"interval1Start <= interval2Start ",
  "    var result string\n    var length1 int\n    var length2 int\n    var isIntersecting\
    \ bool\n    \n    length1 = len(interval1)\n    length2 = len(interval2)\n   \
    \ \n    if length1 == 0 || length2 == 0 {\n        result = \"NO\"\n    } else\
    \ {\n        isIntersecting = true\n        for i := 0; i < length1; i++ {\n \
    \           if interval1[i].(float64) <= interval2[i].(float64) {\n          \
    \      isIntersecting = false\n                break\n            }\n        }\n\
    \    }\n    \n    if isIntersecting {\n        result = \"YES\"\n    } else {\n\
    \        result = \"NO\"\n    }\n    \n    return result\n}\n", "    if len(interval1)\
    \ != len(interval2) {\n        return \"NO\"\n    }\n    \n    interval1Start\
    \ := interval1[0].(int)\n    interval1End := interval1[1].(int)\n    interval2Start\
    \ := interval2[0].(int)\n    interval2End := interval2[1].(int)\n    \n    if\
    \ interval1Start > interval2End {\n        return \"NO\"\n    }\n    if interval1End\
    \ < interval2Start {\n        return \"NO\"\n    }\n    \n    interval1Length\
    \ := interval1End - interval1Start\n    interval2Length := interval2End - interval2Start\n\
    \    \n    if interval1Length == 0 || interval2Length == 0 {\n        return \"\
    NO\"\n    }\n    \n    if interval1Length == interval2Length {\n        return\
    \ fmt.Sprintf(\"YES\")\n    }\n    \n    if interval1Length > interval2Length\
    \ {\n        interval1Length -= interval2Length\n    }\n    \n    if interval1Length\
    \ == 0 {\n        return \"NO\"\n    }\n    \n    if interval2Length == 0 {\n\
    \        return \"NO\"\n    }\n    \n    if interval1Length == interval2Length\
    \ {\n        return fmt.Sprintf(\"YES\")\n    }\n    \n    if interval1Length\
    \ == interval2Length {\n        return fmt.Sprintf(\"YES\")\n    }\n    \n   \
    \ if interval1Length > interval2Length {\n        interval1Length -= interval2Length\n\
    \    }\n    \n    if interval1Length == 0 {\n        return \"NO\"\n    }\n  \
    \  \n    if interval2Length == 0 {\n        return \"NO\"\n    }\n    \n    if\
    \ interval1Length == interval2Length {\n        return fmt.Sprintf(\"YES\")\n\
    \    }\n    \n    if interval1Length == interval2Length {\n        return fmt.Sprintf(\"\
    YES\")\n    }\n    \n    if interval1Length > interval2Length {\n        interval1Length\
    \ -= interval2Length\n    }\n    \n    if interval1Length == 0 {\n        return\
    \ \"NO\"\n    }\n    \n    if interval2Length == 0 {\n        return \"NO\"\n\
    \    }\n    \n    if interval1Length == interval2Length {\n        return fmt.Sprintf(\"\
    YES\")\n    }\n    \n    if interval1Length == interval2Length {\n        return\
    \ fmt.Sprintf(\"YES\")\n    }\n    \n    if interval1Length > interval2Length\
    \ {\n        interval1Length -= interval2Length\n    }\n    \n    if interval1Length\
    \ == 0 {\n        return \"NO\"\n    }\n    \n    if interval2Length == 0 {\n\
    \        return \"NO\"\n    }\n    \n    if interval1Length == interval2Length\
    \ {\n        return ", "    var result string\n    var interval1Start int\n  \
    \  var interval1End int\n    var interval2Start int\n    var interval2End int\n\
    \n    if len(interval1) != len(interval2) {\n        return \"NO\"\n    }\n\n\
    \    for i := 0; i < len(interval1); i++ {\n        interval1Start, interval1End\
    \ = interval1[i].(int64)\n        interval2Start, interval2End = interval2[i].(int64)\n\
    \n        if interval1Start <= interval2End && interval1End >= interval2Start\
    \ {\n            result += \"YES\"\n        } else {\n            result += \"\
    NO\"\n        }\n    }\n\n    return result\n}\n", "    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n    \n    interval1 := make([]int, len(interval1))\n\
    \    interval2 := make([]int, len(interval2))\n    \n    for i := 0; i < len(interval1);\
    \ i++ {\n        interval1[i] = interval1[i].(int)\n    }\n    for i := 0; i <\
    \ len(interval2); i++ {\n        interval2[i] = interval2[i].(int)\n    }\n  \
    \  \n    result := make([]int, len(interval1))\n    \n    for i := 0; i < len(interval1);\
    \ i++ {\n        if interval1[i] > interval2[i] {\n            result[i] = interval1[i]\n\
    \        } else {\n            result[i] = interval2[i]\n        }\n    }\n  \
    \  \n    length := 0\n    for i := 0; i < len(result); i++ {\n        if result[i]\
    \ != result[i+1] {\n            length++\n        }\n    }\n    \n    if length\
    \ == 1 {\n        return \"YES\"\n    }\n    \n    if length == 2 && result[0]\
    \ == result[1] {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n",
  "    if len(interval1) != len(interval2) {\n        return \"NO\"\n    }\n    \n\
    \    interval1 := interval1[0]\n    interval2 := interval2[0]\n    \n    start\
    \ := interval1.([]interface{})[0]\n    end := interval1.([]interface{})[1]\n \
    \   \n    start := start.(int)\n    end := end.(int)\n    \n    start := start\
    \ + 1\n    end := end + 1\n    \n    start := start - 1\n    end := end - 1\n\
    \    \n    start := start - 1\n    end := end - 1\n    \n    start := start -\
    \ 1\n    end := end - 1\n    \n    start := start - 1\n    end := end - 1\n  \
    \  \n    start := start - 1\n    end := end - 1\n    \n    start := start - 1\n\
    \    end := end - 1\n    \n    start := start - 1\n    end := end - 1\n    \n\
    \    start := start - 1\n    end := end - 1\n    \n    start := start - 1\n  \
    \  end := end - 1\n    \n    start := start - 1\n    end := end - 1\n    \n  \
    \  start := start - 1\n    end := end - 1\n    \n    start := start - 1\n    end\
    \ := end - 1\n    \n    start := start - 1\n    end := end - 1\n    \n    start\
    \ := start - 1\n    end := end - 1\n    \n    start := start - 1\n    end := end\
    \ - 1\n    \n    start := start - 1\n    end := end - 1\n    \n    start := start\
    \ - 1\n    end := end - 1\n    \n    start := start - 1\n    end := end - 1\n\
    \    \n    start := start - 1\n    end := end - 1\n    \n    start := start -\
    \ 1\n    end := end - 1\n    \n    start := start - 1\n    end := end - 1\n  \
    \  \n    start := start - 1\n    end := end - 1\n    \n    start := start - 1\n\
    \    end := end - 1\n    \n    start := start - 1\n    end := end - 1\n    \n\
    \    start := start - 1\n    end := end - 1\n    \n    start := start - 1\n  \
    \  end := end - 1\n    \n    start := start - 1\n    end := end - 1\n    \n  \
    \  start := start - 1\n    end := end - 1\n    \n    start := start - 1\n    end\
    \ := end - 1\n    \n    start := start - 1\n    end := end - 1\n    \n    start\
    \ := start - 1\n", "    if len(interval1) != len(interval2) {\n        return\
    \ \"NO\"\n    }\n    \n    interval1 := make([]int, len(interval1))\n    interval2\
    \ := make([]int, len(interval2))\n    \n    for i := 0; i < len(interval1); i++\
    \ {\n        interval1[i] = interval1[i].(int)\n    }\n    for i := 0; i < len(interval2);\
    \ i++ {\n        interval2[i] = interval2[i].(int)\n    }\n    \n    result :=\
    \ make([]int, len(interval1))\n    \n    for i := 0; i < len(interval1); i++ {\n\
    \        if interval1[i] > interval2[i] {\n            result[i] = interval1[i]\n\
    \        } else {\n            result[i] = interval2[i]\n        }\n    }\n  \
    \  \n    length := 0\n    for i := 0; i < len(result); i++ {\n        if result[i]\
    \ != result[i+1] {\n            length++\n        }\n    }\n    \n    if length\
    \ == 1 {\n        return \"YES\"\n    }\n    \n    if length == 2 && result[0]\
    \ == result[1] {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n",
  "    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n", "    if len(interval1)\
    \ != len(interval2) {\n        return \"NO\"\n    }\n    \n    result := make([]interface{},\
    \ 0)\n    \n    for _, interval := range interval1 {\n        start := interval.([]interface{})[0].(int)\n\
    \        end := interval.([]interface{})[1].(int)\n        \n        for _, interval2\
    \ := range interval2 {\n            interval2 := interval2.([]interface{})\n \
    \           \n            if start >= interval2[0] && end <= interval2[1] {\n\
    \                fmt.Println(start, end)\n                fmt.Println(interval2[0],\
    \ interval2[1])\n                fmt.Println(start, end)\n                fmt.Println(interval2[0],\
    \ interval2[1])\n                fmt.Println(start, end)\n                fmt.Println(interval2[0],\
    \ interval2[1])\n                fmt.Println(start, end)\n                fmt.Println(interval2[0],\
    \ interval2[1])\n                fmt.Println(start, end)\n                fmt.Println(interval2[0],\
    \ interval2[1])\n                fmt.Println(start, end)\n                fmt.Println(interval2[0],\
    \ interval2[1])\n                fmt.Println(start, end)\n                fmt.Println(interval2[0],\
    \ interval2[1])\n                fmt.Println(start, end)\n                fmt.Println(interval2[0],\
    \ interval2[1])\n                fmt.Println(start, end)\n                fmt.Println(interval2[0],\
    \ interval2[1])\n                fmt.Println(start, end)\n                fmt.Println(interval2[0],\
    \ interval2[1])\n                fmt.Println(start, end)\n                fmt.Println(interval2[0],\
    \ interval2[1])\n                fmt.Println(start, end)\n                fmt.Println(interval2[0],\
    \ interval2[1])\n                fmt.Println(start, end)\n                fmt.Println(interval2[0],\
    \ interval2[1])\n                fmt.Println(start, end)\n                fmt.Println(interval2[0],\
    \ interval2[1])\n                fmt.Println(start, end)\n                fmt.Println(interval2[0],\
    \ interval2[1])\n                fmt.Println(start, end)\n                fmt.Println(interval2[0],\
    \ interval2[1])\n                fmt.Println(start, end)\n                fmt.Println(interval2[0],\
    \ interval2[1])\n                fmt.Println(start, end)\n                fmt.Println(interval2[0],\
    \ interval2[1])\n                fmt.Println(start, end)\n                fmt.Println(interval2[0],\
    \ interval2[1])\n                fmt.Println(start, end)\n                fmt.Println(interval2[0],\
    \ interval2[1])\n                fmt.Println(start, end)\n                fmt.Println(interval2[0],\
    \ interval2[1])\n                fmt.Println(start, end)\n                fmt.Println(interval2[0],\
    \ interval2[1])\n                fmt.Println(start, end)\n                fmt.Println(interval2[0],\
    \ interval2[1])\n                fmt.", "    var result string\n    \n    if len(interval1)\
    \ != len(interval2) {\n        return \"NO\"\n    }\n    \n    for i := 0; i <\
    \ len(interval1); i++ {\n        if interval1[i].(float64) < interval2[i].(float64)\
    \ {\n            result = \"NO\"\n            break\n        }\n    }\n    \n\
    \    if result == \"NO\" {\n        return \"NO\"\n    }\n    \n    for i := 0;\
    \ i < len(interval1); i++ {\n        if interval1[i].(float64) >= interval2[i].(float64)\
    \ {\n            result = \"NO\"\n            break\n        }\n    }\n    \n\
    \    if result == \"NO\" {\n        return \"NO\"\n    }\n    \n    if result\
    \ == \"YES\" {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n",
  "    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n", "    var result string\n\
    \    var interval1Start int\n    var interval1End int\n    var interval2Start\
    \ int\n    var interval2End int\n\n    if len(interval1) != len(interval2) {\n\
    \        return \"NO\"\n    }\n\n    for i := 0; i < len(interval1); i++ {\n \
    \       interval1Start = interval1[i].(float64)\n        interval1End = interval1[i].(float64)\n\
    \    }\n\n    for i := 0; i < len(interval2); i++ {\n        interval2Start =\
    \ interval2[i].(float64)\n        interval2End = interval2[i].(float64)\n    }\n\
    \n    if interval1Start <= interval2Start && interval1End >= interval2End {\n\
    \        if interval1Start <= interval2End {\n            result = fmt.Sprintf(\"\
    YES\")\n        } else {\n            result = fmt.Sprintf(\"NO\")\n        }\n\
    \    } else {\n        if interval1Start <= interval2Start {\n            result\
    \ = fmt.Sprintf(\"YES\")\n        } else {\n            result = fmt.Sprintf(\"\
    NO\")\n        }\n    }\n\n    return result\n}\n", "    if len(interval1) ==\
    \ 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    interval1_start\
    \ := interval1[0].(float64)\n    interval1_end := interval1[1].(float64)\n   \
    \ interval2_start := interval2[0].(float64)\n    interval2_end := interval2[1].(float64)\n\
    \    \n    interval1_length := interval1_end - interval1_start\n    interval2_length\
    \ := interval2_end - interval2_start\n    \n    if interval1_length == 0 || interval2_length\
    \ == 0 {\n        return \"NO\"\n    }\n    \n    interval1_start += interval1_length\
    \ / 2\n    interval1_end -= interval1_length / 2\n    interval2_start += interval2_length\
    \ / 2\n    interval2_end -= interval2_length / 2\n    \n    if interval1_start\
    \ > interval2_end {\n        return \"NO\"\n    }\n    \n    if interval1_end\
    \ < interval2_start {\n        return \"NO\"\n    }\n    \n    if interval1_start\
    \ == interval2_start {\n        if interval1_end == interval2_end {\n        \
    \    return \"YES\"\n        }\n        return \"NO\"\n    }\n    \n    if interval1_start\
    \ < interval2_start {\n        return \"NO\"\n    }\n    \n    if interval1_end\
    \ > interval2_end {\n        return \"NO\"\n    }\n    \n    if interval1_start\
    \ == interval2_start {\n        if interval1_end == interval2_end {\n        \
    \    return \"YES\"\n        }\n        return \"NO\"\n    }\n    \n    if interval1_start\
    \ > interval2_start {\n        return \"NO\"\n    }\n    \n    if interval1_end\
    \ < interval2_end {\n        return \"NO\"\n    }\n    \n    if interval1_start\
    \ == interval2_start {\n        if interval1_end == interval2_end {\n        \
    \    return \"YES\"\n        }\n        return \"NO\"\n    }\n    \n    if interval1_start\
    \ < interval2_start {\n        return \"NO\"\n    }\n    \n    if interval1_end\
    \ > interval2_end {\n        return \"NO\"\n    }\n    \n    if interval1_start\
    \ == interval2_start {\n        if interval1_end == interval2_end {\n        \
    \    return \"YES\"\n        }\n        return \"NO\"\n    }\n    \n    if interval1_start\
    \ > interval2_start {\n        return \"NO\"\n    }\n    \n    if interval1_end\
    \ < interval2_end {\n        return \"NO\"\n    }\n    \n    if interval1_start\
    \ == interval2_start {\n        if interval1_end == interval2_end {\n        \
    \    return \"YES\"\n        }\n        return \"NO\"\n    }\n    \n    if interval1_start\
    \ < interval", "    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n", " \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n", "    var result string\n\
    \    var interval1Start, interval1End int\n    var interval2Start, interval2End\
    \ int\n    var isIntersecting bool\n\n    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n\n    for i := 0; i < len(interval1); i++ {\n\
    \        interval1Start, interval1End = interval1[i].(int)\n        interval2Start,\
    \ interval2End = interval2[i].(int)\n        isIntersecting = interval1Start <=\
    \ interval2End && interval2Start <= interval1End\n\n        if !isIntersecting\
    \ {\n            return \"NO\"\n        }\n    }\n\n    return \"YES\"\n}\n",
  "    if len(interval1) != len(interval2) {\n        return \"NO\"\n    }\n    \n\
    \    interval1Start := interval1[0].(int)\n    interval1End := interval1[1].(int)\n\
    \    interval2Start := interval2[0].(int)\n    interval2End := interval2[1].(int)\n\
    \    \n    if interval1Start > interval2End {\n        return \"NO\"\n    }\n\
    \    \n    if interval1End < interval2Start {\n        return \"NO\"\n    }\n\
    \    \n    if interval1Start >= interval2Start && interval1End <= interval2End\
    \ {\n        return \"YES\"\n    }\n    \n    if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n        return \"YES\"\n    }\n    \n   \
    \ if interval1Start <= interval2Start && interval1End >= interval2End {\n    \
    \    return \"YES\"\n    }\n    \n    if interval1Start >= interval2Start && interval1End\
    \ <= interval2End {\n        return \"YES\"\n    }\n    \n    if interval1Start\
    \ >= interval2Start && interval1End >= interval2End {\n        return \"YES\"\n\
    \    }\n    \n    return \"NO\"\n}\n", "    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n", "    var result string\n    \n    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1); i++\
    \ {\n        start := interval1[i].(float64)\n        end := interval2[i].(float64)\n\
    \        \n        if start > end {\n            start, end = end, start\n   \
    \     }\n        \n        if start <= end {\n            result += \"YES\"\n\
    \        } else {\n            result += \"NO\"\n        }\n    }\n    \n    return\
    \ result\n}\n", "    if len(interval1) != len(interval2) {\n        return \"\
    NO\"\n    }\n    \n    interval1Start := interval1[0].(int)\n    interval1End\
    \ := interval1[1].(int)\n    interval2Start := interval2[0].(int)\n    interval2End\
    \ := interval2[1].(int)\n    \n    if interval1Start > interval2End {\n      \
    \  return \"NO\"\n    }\n    if interval1End < interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    result := make([]interface{}, 0)\n    \n    for i :=\
    \ interval1Start; i <= interval1End; i++ {\n        for j := interval2Start; j\
    \ <= interval2End; j++ {\n            if i == j {\n                continue\n\
    \            }\n            if j%i == 0 {\n                result := append(result,\
    \ j)\n            }\n        }\n    }\n    \n    if len(result) == 0 {\n     \
    \   return \"NO\"\n    }\n    \n    if len(result) == 1 {\n        return \"YES\"\
    \n    }\n    \n    length := len(result)\n    \n    if length == 2 {\n       \
    \ if result[0] == result[1] {\n            return \"YES\"\n        }\n    }\n\
    \    \n    if length == 3 {\n        if result[0] == result[1] && result[1] ==\
    \ result[2] {\n            return \"YES\"\n        }\n    }\n    \n    if length\
    \ == 4 {\n        if result[0] == result[1] && result[1] == result[2] && result[2]\
    \ == result[3] {\n            return \"YES\"\n        }\n    }\n    \n    if length\
    \ == 5 {\n        if result[0] == result[1] && result[1] == result[2] && result[2]\
    \ == result[3] && result[3] == result[4] {\n            return \"YES\"\n     \
    \   }\n    }\n    \n    if length == 6 {\n        if result[0] == result[1] &&\
    \ result[1] == result[2] && result[2] == result[3] && result[3] == result[4] &&\
    \ result[4] == result[5] {\n            return \"YES\"\n        }\n    }\n   \
    \ \n    if length == 7 {\n        if result[0] == result[1] && result[1] == result[2]\
    \ && result[2] == result[3] && result[3] == result[4] && result[4] == result[5]\
    \ && result[5] == result[6] {\n            return \"YES\"\n        }\n    }\n\
    \    \n    if length == 8 {\n        if result[0] == result[1] && result[1] ==\
    \ result[2] && result[2] == result[3] && result[3] == result[4] && result[4] ==\
    \ result[5] && result[5] == result[6] && result[6] == result[7] {\n          \
    \  return \"YES\"\n        }\n    }\n    \n    if length == 9 {\n        if result[0]\
    \ == result[1] && result[1] == result[2] && result[2] == result[3] && result[3]\
    \ == result[4] && result[4] == result[5] && result[5] == result[6] && ", "   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n", "    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n", "    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n    \n    interval1 := interval1[0]\n    interval2\
    \ := interval2[0]\n    \n    if interval1[0] > interval2[1] {\n        interval1\
    \ = interval1[1:]\n    }\n    if interval1[1] < interval2[0] {\n        interval1\
    \ = interval1[:1]\n    }\n    \n    if interval1[1] < interval2[1] {\n       \
    \ interval1 = interval1[:1]\n    }\n    \n    if interval1[1] > interval2[1] {\n\
    \        interval1 = interval1[:1]\n    }\n    \n    result := \"\"\n    \n  \
    \  for _, v := range interval1 {\n        if v == interval2[0] {\n           \
    \ result += \"YES\"\n            break\n        }\n    }\n    \n    if result\
    \ != \"\" {\n        return result\n    }\n    \n    for _, v := range interval2\
    \ {\n        if v == interval1[0] {\n            result += \"YES\"\n         \
    \   break\n        }\n    }\n    \n    if result != \"\" {\n        return result\n\
    \    }\n    \n    return \"NO\"\n}\n", "    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n    \n    interval1Start := interval1[0].(float64)\n\
    \    interval1End := interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n\
    \    interval2End := interval2[1].(float64)\n    \n    if interval1Start > interval2End\
    \ {\n        return \"NO\"\n    }\n    if interval1End < interval2Start {\n  \
    \      return \"NO\"\n    }\n    \n    intersectionStart := interval1Start\n \
    \   intersectionEnd := interval1End\n    \n    for i := 1; i < len(interval1);\
    \ i++ {\n        interval1Start := interval1[i].(float64)\n        interval1End\
    \ := interval1[i+1].(float64)\n        \n        if interval1Start > interval1End\
    \ {\n            return \"NO\"\n        }\n        if interval1End < interval1Start\
    \ {\n            return \"NO\"\n        }\n        \n        if interval1Start\
    \ > intersectionEnd {\n            intersectionEnd = interval1End\n        }\n\
    \        if interval1End < intersectionStart {\n            intersectionStart\
    \ = interval1End\n        }\n    }\n    \n    if intersectionEnd > interval2End\
    \ {\n        return \"NO\"\n    }\n    if intersectionEnd < interval2Start {\n\
    \        return \"NO\"\n    }\n    \n    if intersectionStart > interval2End {\n\
    \        return \"NO\"\n    }\n    if intersectionStart < interval2Start {\n \
    \       return \"NO\"\n    }\n    \n    if intersectionStart > intersectionEnd\
    \ {\n        return \"NO\"\n    }\n    if intersectionEnd < intersectionStart\
    \ {\n        return \"NO\"\n    }\n    \n    if intersectionStart <= intersectionEnd\
    \ {\n        intersectionLength := intersectionEnd - intersectionStart\n     \
    \   if isPrime(intersectionLength) {\n            return \"YES\"\n        }\n\
    \    }\n    return \"NO\"\n}\n", "    \n    var result string\n    \n    if len(interval1)\
    \ != len(interval2) {\n        return \"NO\"\n    }\n    \n    for i := 0; i <\
    \ len(interval1); i++ {\n        \n        if interval1[i].(float64) < interval2[i].(float64)\
    \ {\n            \n            if interval1[i].(float64) > interval2[i].(float64)\
    \ {\n                \n                interval1[i], interval2[i] = interval2[i],\
    \ interval1[i]\n            }\n            \n            result = result + \"\
    YES\"\n        }\n    }\n    \n    if result == \"NO\" {\n        return \"NO\"\
    \n    }\n    \n    if result == \"YES\" {\n        return \"YES\"\n    }\n   \
    \ \n    return \"NO\"\n}\n", "    \n    var result string\n    \n    if len(interval1)\
    \ != len(interval2) {\n        return \"NO\"\n    }\n    \n    for i := 0; i <\
    \ len(interval1); i++ {\n        \n        if interval1[i].(float64) < interval2[i].(float64)\
    \ {\n            \n            if result == \"NO\" {\n                result =\
    \ \"YES\"\n            }\n            \n            break\n        }\n       \
    \ \n        if interval1[i].(float64) > interval2[i].(float64) {\n           \
    \ \n            if result == \"YES\" {\n                result = \"NO\"\n    \
    \        }\n            \n            break\n        }\n    }\n    \n    return\
    \ result\n}\n", "    if len(interval1) != len(interval2) {\n        return \"\
    NO\"\n    }\n    \n    result := make(map[int]bool)\n    for _, v := range interval1\
    \ {\n        result[v] = true\n    }\n    for _, v := range interval2 {\n    \
    \    if _, ok := result[v]; !ok {\n            return \"NO\"\n        }\n    }\n\
    \    \n    if len(result) == 0 {\n        return \"NO\"\n    }\n    \n    length\
    \ := 0\n    for _, v := range result {\n        length = length + v\n    }\n \
    \   if length == 1 {\n        return \"YES\"\n    }\n    if length == 2 && result[1]\
    \ && result[2] {\n        return \"YES\"\n    }\n    if length == 2 && !result[1]\
    \ {\n        return \"NO\"\n    }\n    if length == 3 && result[1] && result[2]\
    \ && result[3] {\n        return \"YES\"\n    }\n    if length == 3 && !result[1]\
    \ && result[2] {\n        return \"NO\"\n    }\n    if length == 4 && result[1]\
    \ && result[2] && result[3] && result[4] {\n        return \"YES\"\n    }\n  \
    \  if length == 4 && !result[1] && result[2] && !result[3] {\n        return \"\
    NO\"\n    }\n    if length == 5 && result[1] && result[2] && result[3] && result[4]\
    \ && result[5] {\n        return \"YES\"\n    }\n    if length == 5 && !result[1]\
    \ && result[2] && !result[3] && result[4] {\n        return \"NO\"\n    }\n  \
    \  if length == 6 && result[1] && result[2] && result[3] && result[4] && result[5]\
    \ && result[6] {\n        return \"YES\"\n    }\n    if length == 6 && !result[1]\
    \ && result[2] && !result[3] && result[4] && result[5] {\n        return \"NO\"\
    \n    }\n    if length == 7 && result[1] && result[2] && result[3] && result[4]\
    \ && result[5] && result[6] && result[7] {\n        return \"YES\"\n    }\n  \
    \  if length == 7 && !result[1] && result[2] && !result[3] && result[4] && result[5]\
    \ && result[6] {\n        return \"NO\"\n    }\n    if length == 8 && result[1]\
    \ && result[2] && result[3] && result[4] && result[5] && result[6] && result[7]\
    \ && result[8] {\n        return \"YES\"\n    }\n    if length == 8 && !result[1]\
    \ && result[2] && !result[3] && result[4] && result[5] && result[6] && result[7]\
    \ {\n        return \"NO\"\n    }\n    if length == 9 && result[1] && result[2]\
    \ && result[3] && result[4] && result[5] && result[6] && result[7] && result[8]\
    \ && result[9] {\n        return \"YES\"\n    }\n    if length == 9 && !result[1]\
    \ && result[2] && !result[3] && result[4", "    var result string\n    var start1\
    \ int\n    var end1 int\n    var start2 int\n    var end2 int\n    var length1\
    \ int\n    var length2 int\n    var isPrime bool\n    \n    start1 = interval1[0].(int)\n\
    \    end1 = interval1[1].(int)\n    start2 = interval2[0].(int)\n    end2 = interval2[1].(int)\n\
    \    \n    length1 = end1 - start1\n    length2 = end2 - start2\n    \n    isPrime\
    \ = true\n    \n    if length1 == 0 || length2 == 0 {\n        result = \"NO\"\
    \n    } else {\n        if length1 == length2 {\n            if start1 < start2\
    \ {\n                start1 = start1 + 1\n                end1 = end1 + 1\n  \
    \          } else {\n                start2 = start2 + 1\n                end2\
    \ = end2 + 1\n            }\n        }\n        \n        if length1 > length2\
    \ {\n            length1 = length1 - length2\n            isPrime = false\n  \
    \      } else {\n            length2 = length2 - length1\n            isPrime\
    \ = false\n        }\n        \n        if length1 == 1 {\n            if start1\
    \ < start2 {\n                start1 = start1 + 1\n                end1 = end1\
    \ + 1\n            } else {\n                start2 = start2 + 1\n           \
    \     end2 = end2 + 1\n            }\n        }\n        \n        if length2\
    \ == 1 {\n            if start1 < start2 {\n                start1 = start1 +\
    \ 1\n                end1 = end1 + 1\n            } else {\n                start2\
    \ = start2 + 1\n                end2 = end2 + 1\n            }\n        }\n  \
    \      \n        if start1 < start2 {\n            start1 = start1 + 1\n     \
    \       end1 = end1 + 1\n        } else {\n            start2 = start2 + 1\n \
    \           end2 = end2 + 1\n        }\n        \n        if end1 > end2 {\n \
    \           end1 = end1 - 1\n            isPrime = false\n        } else {\n \
    \           end2 = end2 - 1\n            isPrime = false\n        }\n        \n\
    \        if start1 > end2 {\n            start1 = start1 - 1\n            isPrime\
    \ = false\n        } else {\n            start2 = start2 - 1\n            isPrime\
    \ = false\n        }\n        \n        if end1 < end2 {\n            end1 = end1\
    \ - 1\n            isPrime = false\n        } else {\n            end2 = end2\
    \ - 1\n            isPrime = false\n        }\n        \n        if start1 ==\
    \ end1 {\n            result = \"YES\"\n        } else {\n            if start1\
    \ == start2 {\n                result = \"YES\"\n            } else {\n      \
    \          if start1 < start2 {\n                    result = \"NO\"\n       \
    \         } else {\n                    result = \"NO\"\n                }\n \
    \           }\n        }\n    }\n    \n    return result\n}\n", "    var result\
    \ string\n    \n    if len(interval1) != len(interval2) {\n        return \"NO\"\
    \n    }\n    \n    for i := 0; i < len(interval1); i++ {\n        if interval1[i].([]interface{})[0].(int)\
    \ <= interval2[i].([]interface{})[0].(int) {\n            if interval1[i].([]interface{})[0].(int)\
    \ >= interval2[i].([]interface{})[1].(int) {\n                result += fmt.Sprintf(\"\
    %v\", interval1[i].([]interface{})[1].(int))\n            } else {\n         \
    \       result += fmt.Sprintf(\"%v\", interval1[i].([]interface{})[0].(int))\n\
    \            }\n        } else {\n            if interval1[i].([]interface{})[1].(int)\
    \ >= interval2[i].([]interface{})[0].(int) {\n                result += fmt.Sprintf(\"\
    %v\", interval1[i].([]interface{})[1].(int))\n            } else {\n         \
    \       result += fmt.Sprintf(\"%v\", interval1[i].([]interface{})[0].(int))\n\
    \            }\n        }\n    }\n    \n    if result == \"NO\" {\n        return\
    \ \"NO\"\n    }\n    \n    if result == \"YES\" {\n        return \"YES\"\n  \
    \  }\n    \n    return result\n}\n", "    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n    \n    interval1Start, interval1End := interval1[0].([]interface{})[0],\
    \ interval1[0].([]interface{})[1]\n    interval2Start, interval2End := interval2[0].([]interface{})[0],\
    \ interval2[0].([]interface{})[1]\n    \n    if interval1Start > interval2End\
    \ {\n        return \"NO\"\n    }\n    if interval1End < interval2Start {\n  \
    \      return \"NO\"\n    }\n    \n    intersectionLength := interval1End - interval1Start\n\
    \    \n    if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n        return \"YES\"\n    }\n    if interval1Start <= interval2End && interval1End\
    \ >= interval2Start {\n        return \"YES\"\n    }\n    if interval1Start >=\
    \ interval2Start && interval1End <= interval2End {\n        return \"YES\"\n \
    \   }\n    \n    if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n        return \"YES\"\n    }\n    if interval1Start >= interval2Start &&\
    \ interval1End <= interval2End {\n        return \"YES\"\n    }\n    \n    if\
    \ interval1Start <= interval2Start && interval1End >= interval2End {\n       \
    \ return \"YES\"\n    }\n    if interval1Start >= interval2Start && interval1End\
    \ <= interval2End {\n        return \"YES\"\n    }\n    \n    if interval1Start\
    \ <= interval2Start && interval1End >= interval2End {\n        return \"YES\"\n\
    \    }\n    if interval1Start >= interval2Start && interval1End <= interval2End\
    \ {\n        return \"YES\"\n    }\n    \n    if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n        return \"YES\"\n    }\n    if interval1Start\
    \ >= interval2Start && interval1End <= interval2End {\n        return \"YES\"\n\
    \    }\n    \n    if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n        return \"YES\"\n    }\n    if interval1Start >= interval2Start &&\
    \ interval1End <= interval2End {\n        return \"YES\"\n    }\n    \n    if\
    \ interval1Start <= interval2Start && interval1End >= interval2End {\n       \
    \ return \"YES\"\n    }\n    if interval1Start >= interval2Start && interval1End\
    \ <= interval2End {\n        return \"YES\"\n    }\n    \n    if interval1Start\
    \ <= interval2Start && interval1End >= interval2End {\n        return \"YES\"",
  "    \n    // Write your code here\n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    ", "  \
    \  if len(interval1) != len(interval2) {\n        return \"NO\"\n    }\n    \n\
    \    result := make([]interface{}, 0)\n    \n    for _, interval1 := range interval1\
    \ {\n        for _, interval2 := range interval2 {\n            if interval1.(float64)\
    \ >= interval2.(float64) {\n                continue\n            }\n        \
    \    \n            result := append(result, interval1)\n            result :=\
    \ append(result, interval2)\n        }\n    }\n    \n    if len(result) == 0 {\n\
    \        return \"NO\"\n    }\n    \n    result := make([]interface{}, 0)\n  \
    \  \n    for _, interval := range result {\n        if isPrime(interval.(float64))\
    \ {\n            return \"YES\"\n        }\n    }\n    \n    return \"NO\"\n}\n",
  "    if len(interval1) != len(interval2) {\n        return \"NO\"\n    }\n\n   \
    \ interval1Start, interval1End := interval1[0].(int), interval1[1].(int)\n   \
    \ interval2Start, interval2End := interval2[0].(int), interval2[1].(int)\n\n \
    \   if interval1Start > interval2End {\n        return \"NO\"\n    }\n\n    if\
    \ interval1End < interval2Start {\n        return \"NO\"\n    }\n\n    if interval1Start\
    \ <= interval2Start && interval1End >= interval2End {\n        return \"YES\"\n\
    \    }\n\n    if interval1Start <= interval2End && interval1End >= interval2Start\
    \ {\n        return \"YES\"\n    }\n\n    if interval1Start > interval2Start &&\
    \ interval1Start <= interval2End {\n        return \"YES\"\n    }\n\n    if interval1End\
    \ > interval2Start && interval1End <= interval2End {\n        return \"YES\"\n\
    \    }\n\n    if interval1Start <= interval2Start && interval1End > interval2End\
    \ {\n        return \"YES\"\n    }\n\n    if interval1Start > interval2Start &&\
    \ interval1End > interval2End {\n        return \"YES\"\n    }\n\n    return \"\
    NO\"\n}\n", "    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n\n    interval1Start := interval1[0].(float64)\n    interval1End := interval1[1].(float64)\n\
    \    interval2Start := interval2[0].(float64)\n    interval2End := interval2[1].(float64)\n\
    \n    intersectionStart := interval1Start\n    intersectionEnd := interval1End\n\
    \n    for interval1Start <= interval1End && interval2Start <= interval2End {\n\
    \        if interval1Start <= interval2Start {\n            intersectionStart\
    \ = interval1Start\n            intersectionEnd = interval1End\n        } else\
    \ {\n            intersectionStart = interval2Start\n            intersectionEnd\
    \ = interval2End\n        }\n    }\n\n    if intersectionStart <= intersectionEnd\
    \ {\n        intersectionLength := intersectionEnd - intersectionStart\n     \
    \   if isPrime(intersectionLength) {\n            return \"YES\"\n        }\n\
    \    }\n    return \"NO\"\n}\n", "    if len(interval1) != len(interval2) {\n\
    \        return \"NO\"\n    }\n    \n    interval1 := interval1[0].([]interface{})\n\
    \    interval2 := interval2[0].([]interface{})\n    \n    result := make([]interface{},\
    \ 0)\n    \n    for i := 0; i < len(interval1); i++ {\n        if interval1[i]\
    \ > interval2[i] {\n            interval1[i], interval2[i] = interval2[i], interval1[i]\n\
    \        }\n    }\n    \n    for i := 0; i < len(interval1); i++ {\n        if\
    \ interval1[i] <= interval2[i] {\n            result = append(result, interval1[i])\n\
    \        }\n    }\n    \n    if len(result) == 0 {\n        return \"NO\"\n  \
    \  }\n    \n    result := result[0].([]interface{})\n    \n    if len(result)\
    \ == 1 {\n        return \"YES\"\n    }\n    \n    if isPrime(result[0]) {\n \
    \       return \"YES\"\n    }\n    \n    return \"NO\"\n}\n", "    if len(interval1)\
    \ == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    interval1Start,\
    \ interval1End := interval1[0].([]interface{})[0], interval1[0].([]interface{})[1]\n\
    \    interval2Start, interval2End := interval2[0].([]interface{})[0], interval2[0].([]interface{})[1]\n\
    \    \n    if interval1Start > interval1End {\n        interval1Start, interval1End\
    \ = interval1End, interval1Start\n    }\n    if interval2Start > interval2End\
    \ {\n        interval2Start, interval2End = interval2End, interval2Start\n   \
    \ }\n    \n    if interval1Start > interval2End {\n        return \"NO\"\n   \
    \ }\n    \n    if interval1End < interval2Start {\n        return \"NO\"\n   \
    \ }\n    \n    if interval1Start <= interval2Start {\n        interval1Start,\
    \ interval2Start = interval2Start, interval1Start\n    }\n    \n    if interval1End\
    \ >= interval2End {\n        interval1End, interval2End = interval2End, interval1End\n\
    \    }\n    \n    if interval1Start > interval2End {\n        return \"NO\"\n\
    \    }\n    \n    if interval1Start <= interval2Start {\n        interval1Start,\
    \ interval2Start = interval2Start, interval1Start\n    }\n    \n    if interval1End\
    \ >= interval2End {\n        interval1End, interval2End = interval2End, interval1End\n\
    \    }\n    \n    if interval1Start > interval2End {\n        return \"NO\"\n\
    \    }\n    \n    if interval1Start <= interval2Start {\n        interval1Start,\
    \ interval2Start = interval2Start, interval1Start\n    }\n    \n    if interval1End\
    \ >= interval2End {\n        interval1End, interval2End = interval2End, interval1End\n\
    \    }\n    \n    if interval1Start > interval2End {\n        return \"NO\"\n\
    \    }\n    \n    if interval1Start <= interval2Start {\n        interval1Start,\
    \ interval2Start = interval2Start, interval1Start\n    }\n    \n    if interval1End\
    \ >= interval2End {\n        interval1End, interval2End = interval2End, interval1End\n\
    \    }\n    \n    if interval1Start > interval2End {\n        return \"NO\"\n\
    \    }\n    \n    if interval1Start <= interval2Start {\n        interval1Start,\
    \ interval2Start = interval2Start, interval1Start\n    }\n    \n    if interval1End\
    \ >= interval2End {\n        interval1End, interval2End = ", "    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n", "    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n    \n    result := make([]interface{}, 0)\n\
    \    \n    for _, interval1 := range interval1 {\n        start := interval1.([]interface{})[0]\n\
    \        end := interval1.([]interface{})[1]\n        \n        for _, interval2\
    \ := range interval2 {\n            interval2 := interval2.([]interface{})\n \
    \           \n            if start <= interval2[0] && end >= interval2[1] {\n\
    \                fmt.Println(start, end)\n                \n                fmt.Println(interval1)\n\
    \                fmt.Println(interval2)\n                \n                fmt.Println(result)\n\
    \                \n                fmt.Println(result)\n                \n   \
    \             fmt.Println(result)\n                \n                fmt.Println(result)\n\
    \                \n                fmt.Println(result)\n                \n   \
    \             fmt.Println(result)\n                \n                fmt.Println(result)\n\
    \                \n                fmt.Println(result)\n                \n   \
    \             fmt.Println(result)\n                \n                fmt.Println(result)\n\
    \                \n                fmt.Println(result)\n                \n   \
    \             fmt.Println(result)\n                \n                fmt.Println(result)\n\
    \                \n                fmt.Println(result)\n                \n   \
    \             fmt.Println(result)\n                \n                fmt.Println(result)\n\
    \                \n                fmt.Println(result)\n                \n   \
    \             fmt.Println(result)\n                \n                fmt.Println(result)\n\
    \                \n                fmt.Println(result)\n                \n   \
    \             fmt.Println(result)\n                \n                fmt.Println(result)\n\
    \                \n                fmt.Println(result)\n                \n   \
    \             fmt.Println(result)\n                \n                fmt.Println(result)\n\
    \                \n                fmt.Println(result)\n                \n   \
    \             fmt.Println(result)\n                \n                fmt.Println(result)\n\
    \                \n                fmt.Println(result)\n                \n   \
    \             fmt.Println(result)\n                \n                fmt.Println(result)\n\
    \                \n                fmt.Println(result)\n                \n   \
    \             fmt.Println(result)\n                \n                fmt.Println(result)\n\
    \                \n                fmt.Println(result)\n                \n   \
    \             fmt.Println(result)\n                \n                fmt.Println(result)\n\
    \                \n                fmt.Println(result)\n                \n   \
    \             fmt.Println(result)\n                \n                fmt.Println(result)\n\
    \                \n                fmt.Println(result)\n                \n   \
    \             fmt.Println(result)\n                \n                fmt.Println(result)\n\
    \                \n                fmt.Println(result)\n                \n   \
    \             fmt.Println(result)\n                \n                fmt.Println(result)\n\
    \                \n                fmt.Println(result)\n                \n   \
    \             fmt.Println(result)\n                \n                fmt.Println(result)\n",
  "    var result string\n    if len(interval1) != len(interval2) {\n        return\
    \ \"NO\"\n    }\n    for i := 0; i < len(interval1); i++ {\n        result +=\
    \ \"YES\"\n    }\n    return result\n}\n", "    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n", "    \n    // Write your code here\n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    ", "    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    interval1 := make([]int, len(interval1))\n \
    \   interval2 := make([]int, len(interval2))\n    \n    for i := 0; i < len(interval1);\
    \ i++ {\n        interval1[i] = interval1[i].(int)\n    }\n    for i := 0; i <\
    \ len(interval2); i++ {\n        interval2[i] = interval2[i].(int)\n    }\n  \
    \  \n    result := make([]int, len(interval1))\n    \n    for i := 0; i < len(interval1);\
    \ i++ {\n        if interval1[i] > interval2[i] {\n            result[i] = interval1[i]\n\
    \        } else {\n            result[i] = interval2[i]\n        }\n    }\n  \
    \  \n    result := make([]int, len(result))\n    \n    for i := 0; i < len(result);\
    \ i++ {\n        if result[i] == 0 {\n            return \"NO\"\n        }\n \
    \   }\n    \n    result := make([]int, len(result))\n    \n    for i := 0; i <\
    \ len(result); i++ {\n        if result[i] == 1 {\n            return \"YES\"\n\
    \        }\n    }\n    \n    return \"NO\"\n}\n", "    var result string\n   \
    \ \n    if len(interval1) != len(interval2) {\n        return \"NO\"\n    }\n\
    \    \n    for i := 0; i < len(interval1); i++ {\n        if interval1[i].(float64)\
    \ >= interval2[i].(float64) {\n            result = \"NO\"\n            break\n\
    \        }\n    }\n    \n    if result == \"NO\" {\n        return \"NO\"\n  \
    \  }\n    \n    if result == \"YES\" {\n        for i := 0; i < len(interval1);\
    \ i++ {\n            if interval1[i].(float64) >= interval2[i].(float64) {\n \
    \               return \"NO\"\n            }\n        }\n        return \"YES\"\
    \n    }\n    \n    return \"NO\"\n}\n", "    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n    \n    interval1 := make([]int, len(interval1))\n\
    \    interval2 := make([]int, len(interval2))\n    \n    for i, v := range interval1\
    \ {\n        interval1[i] = v.(int)\n    }\n    for i, v := range interval2 {\n\
    \        interval2[i] = v.(int)\n    }\n    \n    result := make([]int, len(interval1))\n\
    \    \n    for i, v := range interval1 {\n        for j, w := range interval2\
    \ {\n            if v < w {\n                break\n            }\n          \
    \  if v == w {\n                result[i] = v\n            }\n        }\n    }\n\
    \    \n    if len(result) == 0 {\n        return \"NO\"\n    }\n    \n    length\
    \ := len(result)\n    \n    if length == 1 {\n        return \"YES\"\n    }\n\
    \    \n    if length == 2 && result[0] == result[1] {\n        return \"YES\"\n\
    \    }\n    \n    if length == 2 && result[0] == result[1] {\n        return \"\
    NO\"\n    }\n    \n    if length == 3 && result[0] == result[1] && result[1] ==\
    \ result[2] {\n        return \"YES\"\n    }\n    \n    if length == 3 && result[0]\
    \ == result[1] && result[1] == result[2] {\n        return \"NO\"\n    }\n   \
    \ \n    if length == 4 && result[0] == result[1] && result[1] == result[2] &&\
    \ result[2] == result[3] {\n        return \"YES\"\n    }\n    \n    if length\
    \ == 4 && result[0] == result[1] && result[1] == result[2] && result[2] == result[3]\
    \ {\n        return \"NO\"\n    }\n    \n    if length == 5 && result[0] == result[1]\
    \ && result[1] == result[2] && result[2] == result[3] && result[3] == result[4]\
    \ {\n        return \"YES\"\n    }\n    \n    if length == 5 && result[0] == result[1]\
    \ && result[1] == result[2] && result[2] == result[3] && result[3] == result[4]\
    \ {\n        return \"NO\"\n    }\n    \n    if length == 6 && result[0] == result[1]\
    \ && result[1] == result[2] && result[2] == result[3] && result[3] == result[4]\
    \ && result[4] == result[5] {\n        return \"YES\"\n    }\n    \n    if length\
    \ == 6 && result[0] == result[1] && result[1] == result[2] && result[2] == result[3]\
    \ && result[3] == result[4] && result[4] == result[5] {\n        return \"NO\"\
    \n    }\n    \n    if length == 7 && result[0] == result[1] && result[1] == result[2]\
    \ && result[2] == result[3] && result[3] == result[4] && result[4] == result[5]\
    \ && result[5] == result[6] {\n        return \"YES\"\n    }\n    \n    if length\
    \ == 7 && result[0] == result", "    \n    \n    \n    \n    \n    \n    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n", "    if len(interval1) != len(interval2) {\n        return \"\
    NO\"\n    }\n    \n    result := make([]interface{}, 0)\n    \n    for _, interval\
    \ := range interval1 {\n        if interval == nil {\n            continue\n \
    \       }\n        \n        start, end := interval.([]interface{})\n        \n\
    \        for _, interval2 := range interval2 {\n            if interval2 == nil\
    \ {\n                continue\n            }\n            \n            start,\
    \ end := interval2.([]interface{})\n            \n            if start > end {\n\
    \                start, end = end, start\n            }\n            \n      \
    \      if start < end {\n                result := append(result, []interface{}{start,\
    \ end})\n            }\n        }\n    }\n    \n    if len(result) == 0 {\n  \
    \      return \"NO\"\n    }\n    \n    length := len(result)\n    \n    if length\
    \ == 1 {\n        return \"YES\"\n    }\n    \n    for i := 2; i < length; i++\
    \ {\n        if length%i == 0 {\n            return \"NO\"\n        }\n    }\n\
    \    \n    return \"YES\"\n}\n", "    if len(interval1) != len(interval2) {\n\
    \        return \"NO\"\n    }\n    \n    interval1 := interval1[0].([]interface{})\n\
    \    interval2 := interval2[0].([]interface{})\n    \n    result := make([]interface{},\
    \ 0)\n    \n    for _, interval := range interval1 {\n        if interval[0] >=\
    \ interval[1] {\n            continue\n        }\n        \n        for _, interval2\
    \ := range interval2 {\n            if interval2[0] >= interval2[1] {\n      \
    \          continue\n            }\n            \n            if interval[0] ==\
    \ interval2[0] && interval[1] == interval2[1] {\n                result = append(result,\
    \ interval)\n            }\n        }\n    }\n    \n    if len(result) == 0 {\n\
    \        return \"NO\"\n    }\n    \n    if len(result) == 1 {\n        return\
    \ \"YES\"\n    }\n    \n    result := result[0].([]interface{})\n    \n    if\
    \ len(result) == 2 {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n\
    }\n", "    \n    // Write your code here\n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    ",
  "    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n", "    var result string\n\
    \    \n    if len(interval1) != len(interval2) {\n        return \"NO\"\n    }\n\
    \    \n    for _, interval := range interval1 {\n        if interval == nil {\n\
    \            continue\n        }\n        \n        if interval2 != nil {\n  \
    \          interval2 := interval2.([]interface{})\n            \n            if\
    \ interval[0] == interval2[0] {\n                result += \"YES\"\n         \
    \       continue\n            }\n            \n            if interval[1] < interval2[1]\
    \ {\n                result += \"NO\"\n                continue\n            }\n\
    \            \n            if interval[1] > interval2[1] {\n                result\
    \ += \"NO\"\n                continue\n            }\n        }\n        \n  \
    \      if interval[1] < interval[0] {\n            result += \"NO\"\n        \
    \    continue\n        }\n        \n        if interval[1] > interval[0] {\n \
    \           result += \"NO\"\n            continue\n        }\n    }\n    \n \
    \   return result\n}\n", "    var result string\n    \n    if len(interval1) !=\
    \ len(interval2) {\n        return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1);\
    \ i++ {\n        if interval1[i].(float64) <= interval2[i].(float64) {\n     \
    \       result += \"YES\"\n        } else {\n            result += \"NO\"\n  \
    \      }\n    }\n    \n    return result\n}\n", "    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n    \n    interval1Map := make(map[int]bool)\n\
    \    interval2Map := make(map[int]bool)\n    \n    for _, v := range interval1\
    \ {\n        interval1Map[v] = true\n    }\n    for _, v := range interval2 {\n\
    \        interval2Map[v] = true\n    }\n    \n    result := make([]int, 0)\n \
    \   for k := range interval1Map {\n        if interval2Map[k] {\n            result\
    \ = append(result, k)\n        }\n    }\n    \n    if len(result) == 0 {\n   \
    \     return \"NO\"\n    }\n    \n    length := len(result)\n    if length ==\
    \ 1 {\n        return \"YES\"\n    }\n    \n    if length == 2 && interval1Map[result[0]]\
    \ && interval2Map[result[1]] {\n        return \"YES\"\n    }\n    \n    if length\
    \ == 2 && !interval1Map[result[0]] && !interval2Map[result[1]] {\n        return\
    \ \"NO\"\n    }\n    \n    if length == 3 && interval1Map[result[0]] && interval2Map[result[1]]\
    \ && interval1Map[result[2]] && interval2Map[result[3]] {\n        return \"YES\"\
    \n    }\n    \n    if length == 3 && !interval1Map[result[0]] && !interval2Map[result[1]]\
    \ && !interval1Map[result[2]] && !interval2Map[result[3]] {\n        return \"\
    NO\"\n    }\n    \n    if length == 4 && interval1Map[result[0]] && interval2Map[result[1]]\
    \ && interval1Map[result[2]] && interval2Map[result[3]] && interval1Map[result[4]]\
    \ && interval2Map[result[5]] {\n        return \"YES\"\n    }\n    \n    if length\
    \ == 4 && !interval1Map[result[0]] && !interval2Map[result[1]] && !interval1Map[result[2]]\
    \ && !interval2Map[result[3]] && !interval1Map[result[4]] && !interval2Map[result[5]]\
    \ {\n        return \"NO\"\n    }\n    \n    if length == 5 && interval1Map[result[0]]\
    \ && interval2Map[result[1]] && interval1Map[result[2]] && interval2Map[result[3]]\
    \ && interval1Map[result[4]] && interval2Map[result[5]] && interval1Map[result[6]]\
    \ && interval2Map[result[7]] {\n        return \"YES\"\n    }\n    \n    if length\
    \ == 5 && !interval1Map[result[0]] && !interval2Map[result[1]] && !interval1Map[result[2]]\
    \ && !interval2Map[result[3]] && !interval1Map[result[4]] && !interval2Map[result[5]]\
    \ && !interval1Map[result[6]] && !interval2Map[result[7]] {\n        return \"\
    NO\"\n    }\n    \n    if length", "    if len(interval1) != len(interval2) {\n\
    \        return \"NO\"\n    }\n    \n    interval1Start := interval1[0].(int)\n\
    \    interval1End := interval1[1].(int)\n    interval2Start := interval2[0].(int)\n\
    \    interval2End := interval2[1].(int)\n    \n    if interval1Start > interval1End\
    \ || interval2Start > interval2End {\n        return \"NO\"\n    }\n    \n   \
    \ intersection := interval1Start <= interval2End && interval2Start <= interval1End\n\
    \    \n    if intersection {\n        intersection := interval1End - interval1Start\
    \ <= interval2End - interval2Start\n    }\n    \n    if intersection {\n     \
    \   intersection := interval1Start <= interval2Start && interval2Start <= interval1End\n\
    \    }\n    \n    if intersection {\n        intersection := interval1End - interval1Start\
    \ <= interval2End - interval2Start\n    }\n    \n    if intersection {\n     \
    \   intersection := interval1Start <= interval2Start && interval2Start <= interval1End\n\
    \    }\n    \n    if intersection {\n        intersection := interval1End - interval1Start\
    \ <= interval2End - interval2Start\n    }\n    \n    if intersection {\n     \
    \   intersection := interval1Start <= interval2Start && interval2Start <= interval1End\n\
    \    }\n    \n    if intersection {\n        intersection := interval1End - interval1Start\
    \ <= interval2End - interval2Start\n    }\n    \n    if intersection {\n     \
    \   intersection := interval1Start <= interval2Start && interval2Start <= interval1End\n\
    \    }\n    \n    if intersection {\n        intersection := interval1End - interval1Start\
    \ <= interval2End - interval2Start\n    }\n    \n    if intersection {\n     \
    \   intersection := interval1Start <= interval2Start && interval2Start <= interval1End\n\
    \    }\n    \n    if intersection {\n        intersection := interval1End - interval1Start\
    \ <= interval2End - interval2Start\n    }\n    \n    if intersection {\n     \
    \   intersection := interval1Start <= interval2Start && interval2Start <= interval1End\n\
    \    }\n    \n    if intersection {\n        intersection := interval1End - interval1Start\
    \ <= interval2End - interval2Start\n    }\n    \n    if intersection {\n     \
    \   intersection := interval1Start <= interval2Start && interval2Start <= interval1End\n\
    \    }\n    \n    if intersection {\n        intersection := interval1End - interval1",
  "    var result string\n    \n    interval1Start := interval1[0].(float64)\n   \
    \ interval1End := interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n\
    \    interval2End := interval2[1].(float64)\n    \n    if interval1Start <= interval2End\
    \ && interval1End <= interval2Start {\n        result += \"YES\"\n    } else {\n\
    \        result += \"NO\"\n    }\n    \n    return result\n}\n", "    if len(interval1)\
    \ != len(interval2) {\n        return \"NO\"\n    }\n    \n    result := make([]interface{},\
    \ 0)\n    \n    for _, v := range interval1 {\n        if v == nil {\n       \
    \     continue\n        }\n        \n        if v > interval2[0] {\n         \
    \   continue\n        }\n        \n        if v < interval2[1] {\n           \
    \ continue\n        }\n        \n        result = append(result, v)\n    }\n \
    \   \n    if len(result) == 0 {\n        return \"NO\"\n    }\n    \n    if len(result)\
    \ == 1 {\n        return result[0].(string)\n    }\n    \n    if len(result) ==\
    \ 2 {\n        return result[0].(string) + \"-\" + result[1].(string)\n    }\n\
    \    \n    if len(result) > 2 {\n        return \"NO\"\n    }\n    \n    return\
    \ \"YES\"\n}\n", "    if len(interval1) != len(interval2) {\n        return \"\
    NO\"\n    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End\
    \ := interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n  \
    \  interval2End := interval2[1].(float64)\n    \n    if interval1Start > interval2End\
    \ {\n        return \"NO\"\n    }\n    if interval1End < interval2Start {\n  \
    \      return \"NO\"\n    }\n    \n    interval1Length := interval1End - interval1Start\n\
    \    interval2Length := interval2End - interval2Start\n    \n    if interval1Length\
    \ == 0 || interval2Length == 0 {\n        return \"NO\"\n    }\n    \n    intersectionLength\
    \ := interval1Length * interval2Length\n    \n    if intersectionLength == 0 {\n\
    \        return \"NO\"\n    }\n    \n    if isPrime(intersectionLength) {\n  \
    \      return \"YES\"\n    }\n    \n    return \"NO\"\n}\n", "    var interval1Start,\
    \ interval1End int\n    var interval2Start, interval2End int\n    var intersectionLength\
    \ int\n\n    if len(interval1) != len(interval2) {\n        return \"NO\"\n  \
    \  }\n\n    for i := 0; i < len(interval1); i++ {\n        interval1Start, interval1End\
    \ = interval1[i].(int64)\n        interval2Start, interval2End = interval2[i].(int64)\n\
    \        if interval1Start <= interval2End && interval1End <= interval2Start {\n\
    \            intersectionLength = interval1End - interval1Start\n        } else\
    \ {\n            intersectionLength = interval2End - interval2Start\n        }\n\
    \        if intersectionLength == 0 {\n            return \"NO\"\n        }\n\
    \        if isPrime(intersectionLength) {\n            return \"YES\"\n      \
    \  }\n    }\n    return \"NO\"\n}\n", "    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n    \n    interval1Start := interval1[0].(int)\n\
    \    interval1End := interval1[1].(int)\n    interval2Start := interval2[0].(int)\n\
    \    interval2End := interval2[1].(int)\n    \n    if interval1Start > interval2End\
    \ {\n        return \"NO\"\n    }\n    if interval1End < interval2Start {\n  \
    \      return \"NO\"\n    }\n    \n    intersection := interval1Start + interval1End\
    \ - interval2Start - interval2End\n    if intersection == 0 {\n        return\
    \ \"NO\"\n    }\n    \n    if isPrime(intersection) {\n        return \"YES\"\n\
    \    }\n    return \"NO\"\n}\n", "    if len(interval1) != len(interval2) {\n\
    \        return \"NO\"\n    }\n    \n    interval1Start := interval1[0].(float64)\n\
    \    interval1End := interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n\
    \    interval2End := interval2[1].(float64)\n    \n    if interval1Start > interval1End\
    \ {\n        interval1Start, interval1End = interval1End, interval1Start\n   \
    \ }\n    if interval2Start > interval2End {\n        interval2Start, interval2End\
    \ = interval2End, interval2Start\n    }\n    \n    intersectionLength := interval1End\
    \ - interval1Start\n    \n    if interval2Start < interval2End {\n        interval2Start\
    \ += interval1Start\n        interval2End += interval1Start\n    }\n    \n   \
    \ if interval1Start < interval1End {\n        interval1Start += interval2Start\n\
    \        interval1End += interval2Start\n    }\n    \n    if interval1Start >\
    \ interval1End {\n        return \"NO\"\n    }\n    \n    if interval2Start >\
    \ interval2End {\n        return \"NO\"\n    }\n    \n    if interval1Start <=\
    \ interval2Start && interval1End >= interval2End {\n        return \"YES\"\n \
    \   }\n    \n    if interval2Start <= interval1Start && interval2End >= interval1End\
    \ {\n        return \"YES\"\n    }\n    \n    if interval1Start <= interval2Start\
    \ && interval1End <= interval2End {\n        return \"YES\"\n    }\n    \n   \
    \ if interval2Start <= interval1Start && interval2End <= interval1End {\n    \
    \    return \"YES\"\n    }\n    \n    if interval1Start <= interval2Start && interval1End\
    \ >= interval2End {\n        return \"YES\"\n    }\n    \n    if interval2Start\
    \ <= interval1Start && interval2End >= interval1End {\n        return \"YES\"\n\
    \    }\n    \n    if interval1Start <= interval2Start && interval1End <= interval2End\
    \ {\n        return \"YES\"\n    }\n    \n    if interval2Start <= interval1Start\
    \ && interval2End <= interval1End {\n        return \"YES\"\n    }\n    \n   \
    \ if interval1Start <= interval2Start && interval1End >= interval2End {\n    \
    \    return \"YES\"\n    }\n    \n    if interval2Start <= interval1Start && interval2End\
    \ >= interval1End {\n        return \"YES\"\n    }\n    \n    if interval1Start\
    \ <= interval2Start && interval1End <= interval2End {\n        return \"", " \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n", "    var result string\n\
    \    var start1, end1, start2, end2 int\n    var isIntersecting bool\n    var\
    \ isPrime bool\n    \n    if len(interval1) != len(interval2) {\n        return\
    \ \"NO\"\n    }\n    \n    for i := 0; i < len(interval1); i++ {\n        start1\
    \ = interval1[i].(int)\n        end1 = interval1[i].(int)\n        \n        for\
    \ j := 0; j < len(interval2); j++ {\n            start2 = interval2[j].(int)\n\
    \            end2 = interval2[j].(int)\n            \n            if start1 <\
    \ end2 {\n                if start2 < end1 {\n                    isIntersecting\
    \ = true\n                    isPrime = true\n                } else {\n     \
    \               isIntersecting = false\n                    isPrime = false\n\
    \                }\n            } else {\n                if start1 > end2 {\n\
    \                    isIntersecting = true\n                    isPrime = true\n\
    \                } else {\n                    isIntersecting = false\n      \
    \              isPrime = false\n                }\n            }\n           \
    \ \n            if isIntersecting {\n                if isPrime {\n          \
    \          result = \"YES\"\n                } else {\n                    result\
    \ = \"NO\"\n                }\n                break\n            }\n        }\n\
    \    }\n    \n    return result\n}\n", "    var result string\n    var interval1_start,\
    \ interval1_end int\n    var interval2_start, interval2_end int\n    \n    interval1_start\
    \ = interval1[0].(int)\n    interval1_end = interval1[1].(int)\n    interval2_start\
    \ = interval2[0].(int)\n    interval2_end = interval2[1].(int)\n    \n    if interval1_start\
    \ < interval2_start {\n        result = fmt.Sprintf(\"NO\")\n    } else {\n  \
    \      if interval1_end < interval2_end {\n            result = fmt.Sprintf(\"\
    NO\")\n        } else {\n            if interval1_start <= interval2_end {\n \
    \               result = fmt.Sprintf(\"YES\")\n            } else {\n        \
    \        result = fmt.Sprintf(\"NO\")\n            }\n        }\n    }\n    return\
    \ result\n}\n", "    if len(interval1) != len(interval2) {\n        return \"\
    NO\"\n    }\n    \n    result := make([]interface{}, 0)\n    \n    for _, interval1\
    \ := range interval1 {\n        for _, interval2 := range interval2 {\n      \
    \      if interval1.(float64) >= interval2.(float64) {\n                continue\n\
    \            }\n            \n            result := append(result, interval1)\n\
    \            result := append(result, interval2)\n            \n            if\
    \ len(result) == 2 {\n                break\n            }\n        }\n    }\n\
    \    \n    if len(result) == 2 {\n        return \"YES\"\n    }\n    \n    return\
    \ \"NO\"\n}\n", "    if len(interval1) != len(interval2) {\n        return \"\
    NO\"\n    }\n    \n    interval1Start, interval1End := interval1[0].(int), interval1[1].(int)\n\
    \    interval2Start, interval2End := interval2[0].(int), interval2[1].(int)\n\
    \    \n    if interval1Start > interval2End {\n        return \"NO\"\n    }\n\
    \    \n    if interval1End < interval2Start {\n        return \"NO\"\n    }\n\
    \    \n    if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n        return \"YES\"\n    }\n    \n    if interval1Start <= interval2End\
    \ && interval1End >= interval2Start {\n        return \"YES\"\n    }\n    \n \
    \   if interval1Start >= interval2Start && interval1End <= interval2End {\n  \
    \      return \"YES\"\n    }\n    \n    if interval1Start >= interval2Start &&\
    \ interval1End < interval2End {\n        return \"NO\"\n    }\n    \n    if interval1Start\
    \ < interval2Start && interval1End >= interval2End {\n        return \"NO\"\n\
    \    }\n    \n    if interval1Start < interval2Start && interval1End <= interval2End\
    \ {\n        return \"NO\"\n    }\n    \n    if interval1Start <= interval2Start\
    \ && interval1End < interval2End {\n        return \"NO\"\n    }\n    \n    if\
    \ interval1Start < interval2Start && interval1End >= interval2End {\n        return\
    \ \"NO\"\n    }\n    \n    if interval1Start >= interval2Start && interval1End\
    \ < interval2End {\n        return \"NO\"\n    }\n    \n    if interval1Start\
    \ < interval2Start && interval1End <= interval2End {\n        return \"NO\"\n\
    \    }\n    \n    if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n        return \"NO\"\n    }\n    \n    if interval1Start < interval2Start\
    \ && interval1End < interval2End {\n        return \"NO\"\n    }\n    \n    if\
    \ interval1Start >= interval2Start && interval1End >= interval2End {\n       \
    \ return \"NO\"\n    }\n    \n    if interval1Start >= interval2Start && interval1End\
    \ <= interval2End {\n        return \"NO\"\n    }\n    \n    if interval1Start\
    \ < interval2Start && interval1End >= interval2End {\n        return \"NO\"\n\
    \    }\n    \n    if interval1Start <= interval2Start && interval1End < interval2End\
    \ {\n        return \"NO\"\n    }\n    \n    if interval1Start < interval", " \
    \   if len(interval1) != len(interval2) {\n        return \"NO\"\n    }\n    \n\
    \    interval1Start := interval1[0].(int)\n    interval1End := interval1[1].(int)\n\
    \    interval2Start := interval2[0].(int)\n    interval2End := interval2[1].(int)\n\
    \    \n    if interval1Start > interval1End {\n        return \"NO\"\n    }\n\
    \    if interval2Start > interval2End {\n        return \"NO\"\n    }\n    \n\
    \    intersection := interval1Start <= interval2Start && interval1End >= interval2End\n\
    \    if intersection {\n        intersectionLength := interval1End - interval1Start\n\
    \        if isPrime(intersectionLength) {\n            return \"YES\"\n      \
    \  }\n    }\n    return \"NO\"\n}\n", "    \n    \n    \n    \n    \n    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n", "    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n",
  "    var result string\n    \n    if len(interval1) != len(interval2) {\n      \
    \  return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1); i++ {\n   \
    \     if interval1[i].([]interface{})[0] != interval2[i].([]interface{})[0] {\n\
    \            return \"NO\"\n        }\n    }\n    \n    for i := 0; i < len(interval1);\
    \ i++ {\n        if interval1[i].([]interface{})[1] > interval2[i].([]interface{})[1]\
    \ {\n            return \"NO\"\n        }\n    }\n    \n    for i := 0; i < len(interval1);\
    \ i++ {\n        if interval1[i].([]interface{})[1] < interval2[i].([]interface{})[1]\
    \ {\n            return \"NO\"\n        }\n    }\n    \n    return \"YES\"\n}\n",
  "    var interval1Start, interval1End int\n    var interval2Start, interval2End\
    \ int\n    var interval1Length, interval2Length int\n    var isIntersecting bool\n\
    \n    if len(interval1) != len(interval2) {\n        return \"NO\"\n    }\n\n\
    \    for _, interval := range interval1 {\n        interval1Start, interval1End\
    \ = interval.([]interface{})[0].(int)\n    }\n\n    for _, interval := range interval2\
    \ {\n        interval2Start, interval2End = interval.([]interface{})[0].(int)\n\
    \    }\n\n    interval1Length = interval1End - interval1Start + 1\n    interval2Length\
    \ = interval2End - interval2Start + 1\n\n    isIntersecting = interval1Start <=\
    \ interval2End && interval2Start <= interval1End\n\n    if isIntersecting {\n\
    \        if interval1Length == interval2Length {\n            if interval1Length\
    \ == 2 {\n                return \"YES\"\n            }\n            if interval1Length\
    \ == 3 {\n                return \"YES\"\n            }\n            if interval1Length\
    \ == 4 {\n                return \"YES\"\n            }\n            if interval1Length\
    \ == 5 {\n                return \"YES\"\n            }\n            if interval1Length\
    \ == 6 {\n                return \"YES\"\n            }\n            if interval1Length\
    \ == 7 {\n                return \"YES\"\n            }\n            if interval1Length\
    \ == 8 {\n                return \"YES\"\n            }\n            if interval1Length\
    \ == 9 {\n                return \"YES\"\n            }\n            if interval1Length\
    \ == 10 {\n                return \"YES\"\n            }\n            if interval1Length\
    \ == 11 {\n                return \"YES\"\n            }\n            if interval1Length\
    \ == 12 {\n                return \"YES\"\n            }\n            if interval1Length\
    \ == 13 {\n                return \"YES\"\n            }\n            if interval1Length\
    \ == 14 {\n                return \"YES\"\n            }\n            if interval1Length\
    \ == 15 {\n                return \"YES\"\n            }\n            if interval1Length\
    \ == 16 {\n                return \"YES\"\n            }\n            if interval1Length\
    \ == 17 {\n                return \"YES\"\n            }\n            if interval1Length\
    \ == 18 {\n                return \"YES\"\n            }\n            if interval1Length\
    \ == 19 {\n                return \"YES\"\n            }\n            if interval1Length\
    \ == 20 {\n                return \"YES\"\n            }\n            if interval1Length\
    \ == 21 {\n                return \"YES\"\n            }\n            if interval1Length\
    \ == 22 {\n                return \"YES\"\n            }\n            if interval1Length\
    \ == 100 {\n                return \"YES\"\n            }\n            if interval1Length\
    \ == 101 {\n                return \"YES\"\n            }\n            if interval1Length\
    \ == 102 {\n                return \"YES\"\n            }\n            if interval1",
  "    var result string\n    \n    if len(interval1) != len(interval2) {\n      \
    \  return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1); i++ {\n   \
    \     if interval1[i].([]interface{})[0].(int) <= interval2[i].([]interface{})[0].(int)\
    \ {\n            if interval1[i].([]interface{})[0].(int) >= interval2[i].([]interface{})[1].(int)\
    \ {\n                result += fmt.Sprintf(\"(%d, %d)\\n\", interval1[i].([]interface{})[0].(int),\
    \ interval2[i].([]interface{})[1].(int))\n            } else {\n             \
    \   result += fmt.Sprintf(\"(%d, %d)\\n\", interval1[i].([]interface{})[0].(int),\
    \ interval2[i].([]interface{})[0].(int))\n            }\n        } else {\n  \
    \          if interval1[i].([]interface{})[0].(int) >= interval2[i].([]interface{})[1].(int)\
    \ {\n                result += fmt.Sprintf(\"(%d, %d)\\n\", interval1[i].([]interface{})[1].(int),\
    \ interval2[i].([]interface{})[0].(int))\n            } else {\n             \
    \   result += fmt.Sprintf(\"(%d, %d)\\n\", interval1[i].([]interface{})[1].(int),\
    \ interval2[i].([]interface{})[1].(int))\n            }\n        }\n    }\n  \
    \  \n    if result == \"(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\\
    n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\\
    n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\\
    n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\\
    n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\\
    n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\\
    n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\\
    n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\\
    n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\\
    n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\n(%d, %d)\\\
    n(", "    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n", "    if len(interval1)\
    \ != len(interval2) {\n        return \"NO\"\n    }\n    \n    interval1 := interval1[0]\n\
    \    interval2 := interval2[0]\n    \n    if interval1.(float64) < interval2.(float64)\
    \ {\n        interval1, interval2 = interval2, interval1\n    }\n    \n    start\
    \ := interval1.(float64)\n    end := interval2.(float64)\n    \n    length :=\
    \ end - start\n    \n    if length == 0 {\n        return \"NO\"\n    }\n    \n\
    \    if length == 1 {\n        return \"YES\"\n    }\n    \n    if length == 2\
    \ && start == end {\n        return \"YES\"\n    }\n    \n    if length == 2 &&\
    \ start == end + 1 {\n        return \"YES\"\n    }\n    \n    if length == 2\
    \ && start == end - 1 {\n        return \"YES\"\n    }\n    \n    if length ==\
    \ 3 && start == end + 1 {\n        return \"YES\"\n    }\n    \n    if length\
    \ == 3 && start == end - 1 {\n        return \"YES\"\n    }\n    \n    if length\
    \ == 3 && start == end + 2 {\n        return \"YES\"\n    }\n    \n    if length\
    \ == 3 && start == end - 2 {\n        return \"YES\"\n    }\n    \n    if length\
    \ == 3 && start == end + 3 {\n        return \"YES\"\n    }\n    \n    if length\
    \ == 3 && start == end - 3 {\n        return \"YES\"\n    }\n    \n    if length\
    \ == 3 && start == end + 4 {\n        return \"YES\"\n    }\n    \n    if length\
    \ == 3 && start == end - 4 {\n        return \"YES\"\n    }\n    \n    if length\
    \ == 3 && start == end + 5 {\n        return \"YES\"\n    }\n    \n    if length\
    \ == 3 && start == end - 5 {\n        return \"YES\"\n    }\n    \n    if length\
    \ == 3 && start == end + 6 {\n        return \"YES\"\n    }\n    \n    if length\
    \ == 3 && start == end - 6 {\n        return \"YES\"\n    }\n    \n    if length\
    \ == 3 && start == end + 7 {\n        return \"YES\"\n    }\n    \n    if length\
    \ == 3 && start == end - 7 {\n        return \"YES\"\n    }\n    \n    if length\
    \ == 3 && start == end + 8 {\n        return \"YES\"\n    }\n    \n    if length\
    \ == 3 && start == end - 8 {\n        return \"YES\"\n    }\n    \n    if length\
    \ == 3 && start == end + 9 {\n        return \"YES\"\n    }\n    \n    if length\
    \ == 3 && start == end - 9 {\n        return \"YES\"\n    }\n    \n    if length\
    \ == 3 && start == end + 10 {\n        return \"YES\"\n    }\n    \n    if length\
    \ == 3 && ", "    if len(interval1) != len(interval2) {\n        return \"NO\"\
    \n    }\n\n    result := make([]interface{}, 0)\n    for _, interval := range\
    \ interval1 {\n        if interval == nil {\n            continue\n        }\n\
    \        start, end := interval.([]interface{})\n        if start > end {\n  \
    \          continue\n        }\n        for _, interval2 := range interval2 {\n\
    \            if interval2 == nil {\n                continue\n            }\n\
    \            start, end := interval2.([]interface{})\n            if start > end\
    \ {\n                continue\n            }\n            if start <= end {\n\
    \                result := append(result, interval)\n            }\n        }\n\
    \    }\n    if len(result) == 0 {\n        return \"NO\"\n    }\n    length :=\
    \ len(result)\n    if length == 1 {\n        return fmt.Sprintf(\"YES\")\n   \
    \ }\n    if length == 2 {\n        return fmt.Sprintf(\"YES\")\n    }\n    if\
    \ length == 3 {\n        return fmt.Sprintf(\"YES\")\n    }\n    if length ==\
    \ 4 {\n        return fmt.Sprintf(\"YES\")\n    }\n    if length == 5 {\n    \
    \    return fmt.Sprintf(\"YES\")\n    }\n    if length == 6 {\n        return\
    \ fmt.Sprintf(\"YES\")\n    }\n    if length == 7 {\n        return fmt.Sprintf(\"\
    YES\")\n    }\n    if length == 8 {\n        return fmt.Sprintf(\"YES\")\n   \
    \ }\n    if length == 9 {\n        return fmt.Sprintf(\"YES\")\n    }\n    if\
    \ length == 10 {\n        return fmt.Sprintf(\"YES\")\n    }\n    if length ==\
    \ 11 {\n        return fmt.Sprintf(\"YES\")\n    }\n    if length == 12 {\n  \
    \      return fmt.Sprintf(\"YES\")\n    }\n    if length == 13 {\n        return\
    \ fmt.Sprintf(\"YES\")\n    }\n    if length == 14 {\n        return fmt.Sprintf(\"\
    YES\")\n    }\n    if length == 15 {\n        return fmt.Sprintf(\"YES\")\n  \
    \  }\n    if length == 16 {\n        return fmt.Sprintf(\"YES\")\n    }\n    if\
    \ length == 17 {\n        return fmt.Sprintf(\"YES\")\n    }\n    if length ==\
    \ 18 {\n        return fmt.Sprintf(\"YES\")\n    }\n    if length == 19 {\n  \
    \      return fmt.Sprintf(\"YES\")\n    }\n    if length == 20 {\n        return\
    \ fmt.Sprintf(\"YES\")\n    }\n    if length == 21 {\n        return fmt.Sprintf(\"\
    YES\")\n    }\n    if length == 22 {\n        return fmt.Sprintf(\"YES\")\n  \
    \  }\n    if length == 100 {\n        return fmt.Sprintf(\"YES\")\n    }\n   \
    \ if length == 200 {\n        return fmt.Sprintf(\"YES\")\n    }\n    if length\
    \ == 300 {\n        return fmt.Sprintf(\"YES\")\n    }\n    if length == 400 {\n\
    \        return fmt.Sprintf(\"YES\")\n", "    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n    \n    interval1Start := interval1[0].(int)\n\
    \    interval1End := interval1[1].(int)\n    interval2Start := interval2[0].(int)\n\
    \    interval2End := interval2[1].(int)\n    \n    if interval1Start > interval1End\
    \ {\n        interval1Start, interval1End = interval1End, interval1Start\n   \
    \ }\n    if interval2Start > interval2End {\n        interval2Start, interval2End\
    \ = interval2End, interval2Start\n    }\n    \n    intersectionLength := interval1End\
    \ - interval1Start\n    \n    if interval2Start < interval2End {\n        interval2Start\
    \ += interval1End - interval1Start\n        interval2End += interval1End - interval1Start\n\
    \    }\n    \n    if interval1Start < interval1End {\n        interval1Start +=\
    \ interval2End - interval2Start\n        interval1End += interval2End - interval2Start\n\
    \    }\n    \n    if interval1Start > interval1End {\n        interval1Start +=\
    \ interval2End - interval2Start\n        interval1End += interval2End - interval2Start\n\
    \    }\n    \n    if interval2Start > interval2End {\n        interval2Start +=\
    \ interval1End - interval1Start\n        interval2End += interval1End - interval1Start\n\
    \    }\n    \n    if interval1Start < interval1End {\n        interval1Start +=\
    \ interval2End - interval2Start\n        interval1End += interval2End - interval2Start\n\
    \    }\n    \n    if interval1Start > interval1End {\n        interval1Start +=\
    \ interval2End - interval2Start\n        interval1End += interval2End - interval2Start\n\
    \    }\n    \n    if interval2Start > interval2End {\n        interval2Start +=\
    \ interval1End - interval1Start\n        interval2End += interval1End - interval1Start\n\
    \    }\n    \n    if interval1Start < interval1End {\n        interval1Start +=\
    \ interval2End - interval2Start\n        interval1End += interval2End - interval2Start\n\
    \    }\n    \n    if interval1Start > interval1End {\n        interval1Start +=\
    \ interval2End - interval2Start\n        interval1End += interval2End - interval2Start\n\
    \    }\n    \n    if interval2Start > interval2End {\n        interval2Start +=\
    \ interval1End - interval1Start\n", "    if len(interval1) != len(interval2) {\n\
    \        return \"NO\"\n    }\n    \n    interval1Start := interval1[0].(float64)\n\
    \    interval1End := interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n\
    \    interval2End := interval2[1].(float64)\n    \n    if interval1Start > interval1End\
    \ {\n        interval1Start, interval1End = interval1End, interval1Start\n   \
    \ }\n    if interval2Start > interval2End {\n        interval2Start, interval2End\
    \ = interval2End, interval2Start\n    }\n    \n    intersectionStart := interval1Start\n\
    \    intersectionEnd := interval1End\n    \n    for interval1End <= interval2End\
    \ {\n        if interval1End < intersectionStart {\n            intersectionStart\
    \ = interval1End\n        }\n        if interval1End < intersectionEnd {\n   \
    \         intersectionEnd = interval1End\n        }\n    }\n    \n    if intersectionStart\
    \ <= intersectionEnd {\n        intersectionLength := intersectionEnd - intersectionStart\n\
    \        if isPrime(intersectionLength) {\n            return \"YES\"\n      \
    \  }\n    }\n    return \"NO\"\n}\n", "    var result string\n    var interval1Start,\
    \ interval1End int\n    var interval2Start, interval2End int\n\n    if len(interval1)\
    \ != len(interval2) {\n        return \"NO\"\n    }\n\n    for i := 0; i < len(interval1);\
    \ i++ {\n        interval1Start = interval1[i].(int)\n        interval1End = interval1Start\
    \ + 1\n        interval2Start = interval2[i].(int)\n        interval2End = interval2Start\
    \ + 1\n\n        if interval1Start <= interval2End && interval1End >= interval2Start\
    \ {\n            if interval1Start < interval2Start {\n                interval1Start,\
    \ interval1End = interval2Start, interval1Start\n            }\n            if\
    \ interval1End > interval2End {\n                interval1End, interval1Start\
    \ = interval2End, interval1End\n            }\n            if interval1Start <=\
    \ interval1End {\n                result += fmt.Sprintf(\"%v-%v\\n\", interval1Start,\
    \ interval1End)\n            }\n        }\n    }\n    if result == \"NO\" {\n\
    \        return \"NO\"\n    }\n    if result == \"YES\" {\n        return \"YES\"\
    \n    }\n    return result\n}\n", "    if len(interval1) == 0 || len(interval2)\
    \ == 0 {\n        return \"NO\"\n    }\n    \n    interval1Start := interval1[0].(float64)\n\
    \    interval1End := interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n\
    \    interval2End := interval2[1].(float64)\n    \n    result := 0\n    \n   \
    \ if interval1Start <= interval2Start {\n        result = interval1Start <= interval2End\
    \ ? interval1End : interval2End\n    } else {\n        result = interval1Start\
    \ <= interval2End ? interval2Start : interval1Start\n    }\n    \n    if result\
    \ % 2 == 0 {\n        return \"NO\"\n    }\n    \n    if result > 100 {\n    \
    \    return \"NO\"\n    }\n    \n    if result < 100 {\n        return \"YES\"\
    \n    }\n    \n    return \"YES\"\n}\n", "    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n    \n    result := make([]interface{}, 0)\n\
    \    \n    for _, interval := range interval1 {\n        if interval[0] < interval[1]\
    \ {\n            result = append(result, interval)\n        }\n    }\n    \n \
    \   for _, interval := range interval2 {\n        if interval[0] < interval[1]\
    \ {\n            result = append(result, interval)\n        }\n    }\n    \n \
    \   if len(result) == 0 {\n        return \"NO\"\n    }\n    \n    if len(result)\
    \ == 1 {\n        return \"YES\"\n    }\n    \n    result := make([]interface{},\
    \ 0)\n    \n    for _, interval := range result {\n        if interval[0] < interval[1]\
    \ {\n            result = append(result, interval)\n        }\n    }\n    \n \
    \   if len(result) == 1 {\n        return \"YES\"\n    }\n    \n    return \"\
    NO\"\n}\n", "    var result string\n    \n    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n    \n    for _, interval := range interval1\
    \ {\n        if interval == nil {\n            continue\n        }\n        \n\
    \        start, end := interval.([]interface{})\n        \n        if start >\
    \ end {\n            continue\n        }\n        \n        for _, interval2 :=\
    \ range interval2 {\n            if interval2 == nil {\n                continue\n\
    \            }\n            \n            start2, end2 := interval2.([]interface{})\n\
    \            \n            if start2 > end2 {\n                continue\n    \
    \        }\n            \n            if start < end2 && start2 < end {\n    \
    \            result = result + \"YES\"\n                break\n            }\n\
    \        }\n    }\n    \n    if result == \"YES\" {\n        return \"YES\"\n\
    \    }\n    \n    return \"NO\"\n}\n", "    var result string\n    \n    if len(interval1)\
    \ != len(interval2) {\n        return \"NO\"\n    }\n    \n    for i := 0; i <\
    \ len(interval1); i++ {\n        if interval1[i].(float64) < interval2[i].(float64)\
    \ {\n            result = \"NO\"\n            break\n        }\n    }\n    \n\
    \    if result == \"NO\" {\n        return \"NO\"\n    }\n    \n    for i := 0;\
    \ i < len(interval1); i++ {\n        if interval1[i].(float64) > interval2[i].(float64)\
    \ {\n            result = \"NO\"\n            break\n        }\n    }\n    \n\
    \    if result == \"NO\" {\n        return \"NO\"\n    }\n    \n    if result\
    \ == \"YES\" {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n",
  "    if len(interval1) != len(interval2) {\n        return \"NO\"\n    }\n    \n\
    \    interval1Start := interval1[0].(int)\n    interval1End := interval1[1].(int)\n\
    \    interval2Start := interval2[0].(int)\n    interval2End := interval2[1].(int)\n\
    \    \n    if interval1Start > interval2End {\n        return \"NO\"\n    }\n\
    \    \n    if interval1End < interval2Start {\n        return \"NO\"\n    }\n\
    \    \n    if interval1Start <= interval2Start {\n        interval1Start += 1\n\
    \        interval1End -= 1\n    }\n    \n    if interval1End >= interval2End {\n\
    \        interval1End -= 1\n        interval1Start += 1\n    }\n    \n    result\
    \ := 0\n    \n    for i := interval1Start; i <= interval1End; i++ {\n        for\
    \ j := interval2Start; j <= interval2End; j++ {\n            result += 1\n   \
    \         if i == j {\n                continue\n            }\n            if\
    \ result % j == 0 {\n                return \"NO\"\n            }\n        }\n\
    \    }\n    \n    return \"YES\"\n}\n", "    if len(interval1) == 0 || len(interval2)\
    \ == 0 {\n        return \"NO\"\n    }\n\n    interval1_start, interval1_end :=\
    \ interval1[0].([]interface{})[0], interval1[0].([]interface{})[1]\n    interval2_start,\
    \ interval2_end := interval2[0].([]interface{})[0], interval2[0].([]interface{})[1]\n\
    \n    if interval1_end < interval2_start {\n        interval1_start, interval1_end\
    \ = interval2_start, interval2_end\n    }\n\n    if interval1_end < interval2_end\
    \ {\n        interval2_start, interval2_end = interval1_end, interval1_end\n \
    \   }\n\n    if interval1_start > interval2_end {\n        interval1_start, interval1_end\
    \ = interval2_end, interval2_end\n    }\n\n    if interval1_start > interval2_start\
    \ {\n        interval2_start, interval2_end = interval1_start, interval1_start\n\
    \    }\n\n    if interval1_start == interval1_end {\n        if interval2_start\
    \ == interval2_end {\n            return \"YES\"\n        } else {\n         \
    \   return \"NO\"\n        }\n    }\n\n    if interval1_start < interval2_start\
    \ {\n        interval1_start, interval1_end = interval2_start, interval2_end\n\
    \    }\n\n    if interval1_start < interval2_end {\n        interval2_start, interval2_end\
    \ = interval1_start, interval1_end\n    }\n\n    if interval1_start == interval1_end\
    \ {\n        if interval2_start == interval2_end {\n            return \"YES\"\
    \n        } else {\n            return \"NO\"\n        }\n    }\n\n    if interval1_start\
    \ < interval2_start {\n        interval1_start, interval1_end = interval2_start,\
    \ interval2_end\n    }\n\n    if interval1_start < interval2_end {\n        interval2_start,\
    \ interval2_end = interval1_start, interval1_end\n    }\n\n    if interval1_start\
    \ == interval1_end {\n        if interval2_start == interval2_end {\n        \
    \    return \"YES\"\n        } else {\n            return \"NO\"\n        }\n\
    \    }\n\n    if interval1_start < interval2_start {\n        interval1_start,\
    \ interval1_end = interval2_start, interval2_end\n    }\n\n    if interval1_start\
    \ < interval2_end {\n        interval2_start, interval2_end = interval1_start,\
    \ interval1_end\n    }\n\n    if interval1_start == interval1_end {\n        if\
    \ interval2_start == interval2_end {\n            return \"YES\"\n        } else\
    \ {\n            return \"NO\"\n        }\n    }\n\n    if interval1_start < interval2_start\
    \ {\n        interval1_start, interval1_end = interval2_start, interval2_end\n\
    \    }\n\n    if interval1_start < interval2_end {\n        interval2_start, interval2_end\
    \ = interval1_start, interval1_end\n", "    \n    // Your code here\n    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    ", "    if len(interval1) != len(interval2) {\n \
    \       return \"NO\"\n    }\n    \n    interval1Start := interval1[0].(float64)\n\
    \    interval1End := interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n\
    \    interval2End := interval2[1].(float64)\n    \n    intersectionStart := interval1Start\n\
    \    intersectionEnd := interval1End\n    \n    for i := 1; i < len(interval1);\
    \ i++ {\n        interval1Start := interval1[i].(float64)\n        interval1End\
    \ := interval1[i+1].(float64)\n        \n        if interval1Start > interval1End\
    \ {\n            return \"NO\"\n        }\n        \n        if interval2Start\
    \ > interval2End {\n            return \"NO\"\n        }\n        \n        if\
    \ interval1Start <= interval2Start {\n            if interval1End > intersectionEnd\
    \ {\n                intersectionEnd = interval1End\n            }\n        }\
    \ else {\n            if interval1Start < intersectionStart {\n              \
    \  intersectionStart = interval1Start\n            }\n        }\n    }\n    \n\
    \    if intersectionStart <= intersectionEnd {\n        if intersectionEnd > interval2End\
    \ {\n            return \"NO\"\n        }\n        \n        if intersectionEnd\
    \ <= interval2End {\n            if intersectionEnd > intersectionStart {\n  \
    \              intersectionEnd = intersectionEnd\n            }\n        } else\
    \ {\n            if intersectionEnd < interval2Start {\n                intersectionEnd\
    \ = interval2End\n            }\n        }\n    }\n    \n    if intersectionStart\
    \ <= intersectionEnd {\n        if intersectionEnd > interval2End {\n        \
    \    return \"NO\"\n        }\n        \n        if intersectionEnd <= interval2End\
    \ {\n            if intersectionEnd > intersectionStart {\n                intersectionEnd\
    \ = intersectionEnd\n            }\n        } else {\n            if intersectionEnd\
    \ < interval2Start {\n                intersectionEnd = interval2End\n       \
    \     }\n        }\n    }\n    \n    if intersectionStart <= intersectionEnd {\n\
    \        if intersectionEnd > interval2End {\n            return \"NO\"\n    \
    \    }\n        \n        if intersectionEnd <= interval2End {\n            if\
    \ intersectionEnd > intersectionStart {\n                intersectionEnd = intersectionEnd\n\
    \            }\n        } else {\n            if intersectionEnd < interval2Start\
    \ {\n                intersectionEnd = interval2End\n            }\n        }\n\
    \    }\n    \n    if intersectionStart <= intersectionEnd {\n        if intersectionEnd\
    \ > interval2End {\n            return \"NO\"\n        }\n        \n        if\
    \ intersectionEnd <= interval2End {\n            if intersectionEnd > intersectionStart\
    \ {\n                intersectionEnd = intersectionEnd\n            }\n      \
    \  } else {\n            if intersectionEnd < interval2Start {\n             \
    \   intersectionEnd = interval2End\n            }\n        }\n    }\n    \n  \
    \  if ", "    var result string\n    if len(interval1) > len(interval2) {\n  \
    \      interval1, interval2 = interval2, interval1\n    }\n    for i := 0; i <\
    \ len(interval1); i++ {\n        if interval1[i].(float64) >= interval2[i].(float64)\
    \ {\n            result = \"NO\"\n            break\n        }\n    }\n    if\
    \ result == \"NO\" {\n        result = \"YES\"\n    }\n    return result\n}\n",
  "    var result string\n    \n    if len(interval1) != len(interval2) {\n      \
    \  return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1); i++ {\n   \
    \     if interval1[i].(float64) >= interval2[i].(float64) {\n            result\
    \ = \"NO\"\n            break\n        }\n    }\n    \n    if result == \"NO\"\
    \ {\n        return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1); i++\
    \ {\n        if interval1[i].(float64) <= interval2[i].(float64) {\n         \
    \   result = \"NO\"\n            break\n        }\n    }\n    \n    if result\
    \ == \"NO\" {\n        return \"NO\"\n    }\n    \n    if result == \"YES\" {\n\
    \        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n", "    if len(interval1)\
    \ != len(interval2) {\n        return \"NO\"\n    }\n    \n    interval1Start\
    \ := interval1[0].(float64)\n    interval1End := interval1[1].(float64)\n    interval2Start\
    \ := interval2[0].(float64)\n    interval2End := interval2[1].(float64)\n    \n\
    \    if interval1Start > interval2End {\n        return \"NO\"\n    }\n    if\
    \ interval1End < interval2Start {\n        return \"NO\"\n    }\n    \n    intersectionStart\
    \ := interval1Start\n    intersectionEnd := interval1End\n    \n    for i := 1;\
    \ i < len(interval2); i++ {\n        interval2Start := interval2[i].(float64)\n\
    \        interval2End := interval2[i+1].(float64)\n        \n        if interval2Start\
    \ > interval2End {\n            return \"NO\"\n        }\n        if interval2End\
    \ < interval2Start {\n            return \"NO\"\n        }\n        \n       \
    \ if intersectionStart > interval2End {\n            return \"NO\"\n        }\n\
    \        if intersectionEnd < interval2Start {\n            return \"NO\"\n  \
    \      }\n        \n        if intersectionStart <= intersectionEnd {\n      \
    \      intersectionStart = interval2Start\n            intersectionEnd = interval2End\n\
    \        }\n    }\n    \n    if intersectionStart <= intersectionEnd {\n     \
    \   return \"YES\"\n    }\n    return \"NO\"\n}\n", "    if len(interval1) !=\
    \ len(interval2) {\n        return \"NO\"\n    }\n    \n    interval1Start :=\
    \ interval1[0].(float64)\n    interval1End := interval1[1].(float64)\n    interval2Start\
    \ := interval2[0].(float64)\n    interval2End := interval2[1].(float64)\n    \n\
    \    if interval1Start > interval1End {\n        interval1Start, interval1End\
    \ = interval1End, interval1Start\n    }\n    if interval2Start > interval2End\
    \ {\n        interval2Start, interval2End = interval2End, interval2Start\n   \
    \ }\n    \n    if interval1Start > interval2End {\n        return \"NO\"\n   \
    \ }\n    if interval1End < interval2Start {\n        return \"NO\"\n    }\n  \
    \  \n    intersectionLength := interval1End - interval1Start\n    \n    if intersectionLength\
    \ == 0 {\n        return \"NO\"\n    }\n    \n    if interval1Start <= interval2Start\
    \ {\n        interval1Start += interval1End - interval2Start\n        interval1End\
    \ -= interval2End - interval1Start\n    }\n    if interval1End >= interval2End\
    \ {\n        interval1End -= interval2End - interval1Start\n        interval1Start\
    \ += interval2End - interval1Start\n    }\n    \n    if interval1Start <= interval2Start\
    \ {\n        return \"NO\"\n    }\n    if interval1End >= interval2End {\n   \
    \     return \"NO\"\n    }\n    \n    if interval1Start <= interval2End {\n  \
    \      interval1Start += interval1End - interval2Start\n        interval1End -=\
    \ interval2End - interval1Start\n    }\n    if interval1End >= interval2End {\n\
    \        interval1End -= interval2End - interval1Start\n        interval1Start\
    \ += interval2End - interval1Start\n    }\n    \n    if interval1Start <= interval2End\
    \ {\n        return \"NO\"\n    }\n    if interval1End >= interval2End {\n   \
    \     return \"NO\"\n    }\n    \n    if interval1Start <= interval2End {\n  \
    \      interval1Start += interval1End - interval2Start\n        interval1End -=\
    \ interval2End - interval1Start\n    }\n    if interval1End >= interval2End {\n\
    \        interval1End -= interval2End - interval1Start\n        interval1Start\
    \ += interval2End - interval1Start\n    }\n    \n    if interval1Start <= interval2End\
    \ {\n        return \"NO\"\n    }\n    if interval1End >= interval2End {\n   \
    \     return \"NO\"", "    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n",
  "    \n    // Write your code here\n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    ", "  \
    \  if len(interval1) != len(interval2) {\n        return \"NO\"\n    }\n    \n\
    \    result := make([]interface{}, len(interval1))\n    for i, v := range interval1\
    \ {\n        result[i] = v\n    }\n    for i, v := range interval2 {\n       \
    \ if result[i] < v {\n            result[i] = v\n        }\n    }\n    \n    if\
    \ len(result) == 0 {\n        return \"NO\"\n    }\n    \n    result := make([]interface{},\
    \ len(result))\n    for i, v := range result {\n        if result[i] == v {\n\
    \            continue\n        }\n        \n        if result[i] < v {\n     \
    \       result[i] = v\n        }\n    }\n    \n    if len(result) == 0 {\n   \
    \     return \"NO\"\n    }\n    \n    result := make([]interface{}, len(result))\n\
    \    for i, v := range result {\n        if result[i] == v {\n            continue\n\
    \        }\n        \n        if result[i] > v {\n            result[i] = v\n\
    \        }\n    }\n    \n    if len(result) == 0 {\n        return \"NO\"\n  \
    \  }\n    \n    result := make([]interface{}, len(result))\n    for i, v := range\
    \ result {\n        if result[i] == v {\n            continue\n        }\n   \
    \     \n        if result[i] < v {\n            result[i] = v\n        }\n   \
    \ }\n    \n    if len(result) == 0 {\n        return \"NO\"\n    }\n    \n   \
    \ result := make([]interface{}, len(result))\n    for i, v := range result {\n\
    \        if result[i] == v {\n            continue\n        }\n        \n    \
    \    if result[i] > v {\n            result[i] = v\n        }\n    }\n    \n \
    \   if len(result) == 0 {\n        return \"NO\"\n    }\n    \n    result := make([]interface{},\
    \ len(result))\n    for i, v := range result {\n        if result[i] == v {\n\
    \            continue\n        }\n        \n        if result[i] < v {\n     \
    \       result[i] = v\n        }\n    }\n    \n    if len(result) == 0 {\n   \
    \     return \"NO\"\n    }\n    \n    result := make([]interface{}, len(result))\n\
    \    for i, v := range result {\n        if result[i] == v {\n            continue\n\
    \        }\n        \n        if result[i] > v {\n            result[i] = v\n\
    \        }\n    }\n    \n    if len(result) == 0 {\n        return \"NO\"\n  \
    \  }\n    \n    result := make([]interface{}, len(result))\n    for i, v := range\
    \ result {\n        if result[i] == v {\n            continue\n        }\n   \
    \     \n        if result[i] < v {\n            result[i] = v\n        }\n   \
    \ }\n    \n    if len(result) == 0 {\n        return \"NO\"\n    }\n    \n   \
    \ result := make([]interface", "    if len(interval1) != len(interval2) {\n  \
    \      return \"NO\"\n    }\n    \n    interval1Start := interval1[0].(float64)\n\
    \    interval1End := interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n\
    \    interval2End := interval2[1].(float64)\n    \n    if interval1Start > interval2End\
    \ {\n        return \"NO\"\n    }\n    if interval1End < interval2Start {\n  \
    \      return \"NO\"\n    }\n    \n    intersectionLength := interval1End - interval1Start\n\
    \    \n    if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n        return \"YES\"\n    }\n    if interval1Start <= interval2End && interval1End\
    \ >= interval2Start {\n        return \"YES\"\n    }\n    if interval1Start >=\
    \ interval2Start && interval1End <= interval2End {\n        return \"YES\"\n \
    \   }\n    if interval1Start >= interval2Start && interval1End < interval2End\
    \ {\n        return \"NO\"\n    }\n    if interval1Start < interval2Start && interval1End\
    \ >= interval2End {\n        return \"NO\"\n    }\n    if interval1Start < interval2Start\
    \ && interval1End <= interval2End {\n        return \"NO\"\n    }\n    if interval1Start\
    \ < interval2Start && interval1End < interval2End {\n        return \"NO\"\n \
    \   }\n    \n    if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n        return \"NO\"\n    }\n    if interval1Start <= interval2End && interval1End\
    \ >= interval2Start {\n        return \"NO\"\n    }\n    if interval1Start >=\
    \ interval2Start && interval1End <= interval2End {\n        return \"NO\"\n  \
    \  }\n    if interval1Start >= interval2Start && interval1End < interval2End {\n\
    \        return \"NO\"\n    }\n    if interval1Start < interval2Start && interval1End\
    \ >= interval2End {\n        return \"NO\"\n    }\n    if interval1Start < interval2Start\
    \ && interval1End <= interval2End {\n        return \"NO\"\n    }\n    if interval1Start\
    \ < interval2Start && interval1End < interval2End {\n        return \"NO\"\n \
    \   }\n    \n    return \"NO\"\n}\n", "    var result string\n    var interval1Start\
    \ int\n    var interval1End int\n    var interval2Start int\n    var interval2End\
    \ int\n    var isIntersecting bool\n\n    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n\n    for i := 0; i < len(interval1); i++ {\n\
    \        interval1Start = interval1[i].(int)\n        interval1End = interval1[i].(int)\n\
    \    }\n\n    for i := 0; i < len(interval2); i++ {\n        interval2Start =\
    \ interval2[i].(int)\n        interval2End = interval2[i].(int)\n    }\n\n   \
    \ isIntersecting = interval1Start <= interval2End && interval2Start <= interval1End\n\
    \n    if isIntersecting {\n        if interval1Start > interval2Start {\n    \
    \        interval1Start, interval2Start = interval2Start, interval1Start\n   \
    \     }\n\n        if interval1End < interval2End {\n            interval1End,\
    \ interval2End = interval2End, interval1End\n        }\n\n        if interval1Start\
    \ <= interval2Start {\n            interval1Start, interval2Start = interval2Start,\
    \ interval1Start\n        }\n\n        if interval1End >= interval2End {\n   \
    \         interval1End, interval2End = interval2End, interval1End\n        }\n\
    \n        if interval1Start <= interval2End {\n            interval1Start, interval2End\
    \ = interval2End, interval1End\n        }\n\n        if interval1Start <= interval2Start\
    \ {\n            interval1Start, interval2Start = interval2Start, interval1Start\n\
    \        }\n\n        if interval1End >= interval2End {\n            interval1End,\
    \ interval2End = interval2End, interval1End\n        }\n\n        if interval1Start\
    \ <= interval2End {\n            interval1Start, interval2End = interval2End,\
    \ interval1End\n        }\n\n        if interval1Start <= interval2Start {\n \
    \           interval1Start, interval2Start = interval2Start, interval1Start\n\
    \        }\n\n        if interval1End >= interval2End {\n            interval1End,\
    \ interval2End = interval2End, interval1End\n        }\n\n        if interval1Start\
    \ <= interval2End {\n            interval1Start, interval2End = interval2End,\
    \ interval1End\n        }\n\n        if interval1Start <= interval2Start {\n \
    \           interval1Start, interval2Start = interval2Start, interval1Start\n\
    \        }\n\n        if interval1End >= interval2End {\n            interval1End,\
    \ interval2End = interval2End, interval1End\n        }\n\n        if interval1Start\
    \ <= interval2Start {\n            interval1Start, interval2Start = interval2Start,\
    \ interval", "    var result string\n    \n    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1); i++\
    \ {\n        if interval1[i].(float64) <= interval2[i].(float64) {\n         \
    \   result += fmt.Sprintf(\"%v\", interval1[i])\n        } else {\n          \
    \  result += fmt.Sprintf(\"%v\", interval2[i])\n        }\n    }\n    \n    if\
    \ result == \"NO\" {\n        return \"NO\"\n    }\n    \n    if result == \"\
    YES\" {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n", "    if\
    \ len(interval1) != len(interval2) {\n        return \"NO\"\n    }\n    \n   \
    \ result := make([]interface{}, 0)\n    \n    for _, interval := range interval1\
    \ {\n        start := interval.([]interface{})[0].(int)\n        end := interval.([]interface{})[1].(int)\n\
    \        \n        if start < end {\n            result = append(result, interval)\n\
    \        }\n    }\n    \n    for _, interval := range interval2 {\n        start\
    \ := interval.([]interface{})[0].(int)\n        end := interval.([]interface{})[1].(int)\n\
    \        \n        if start < end {\n            result = append(result, interval)\n\
    \        }\n    }\n    \n    if len(result) == 0 {\n        return \"NO\"\n  \
    \  }\n    \n    result := make([]interface{}, 0)\n    \n    for _, interval :=\
    \ range result {\n        start := interval.([]interface{})[0].(int)\n       \
    \ end := interval.([]interface{})[1].(int)\n        \n        if start <= end\
    \ {\n            result = append(result, interval)\n        }\n    }\n    \n \
    \   if len(result) == 0 {\n        return \"NO\"\n    }\n    \n    result := make([]interface{},\
    \ 0)\n    \n    for _, interval := range result {\n        start := interval.([]interface{})[0].(int)\n\
    \        end := interval.([]interface{})[1].(int)\n        \n        if start\
    \ <= end {\n            result = append(result, interval)\n        }\n    }\n\
    \    \n    if len(result) == 0 {\n        return \"NO\"\n    }\n    \n    result\
    \ := make([]interface{}, 0)\n    \n    for _, interval := range result {\n   \
    \     start := interval.([]interface{})[0].(int)\n        end := interval.([]interface{})[1].(int)\n\
    \        \n        if start <= end {\n            result = append(result, interval)\n\
    \        }\n    }\n    \n    if len(result) == 0 {\n        return \"NO\"\n  \
    \  }\n    \n    result := make([]interface{}, 0)\n    \n    for _, interval :=\
    \ range result {\n        start := interval.([]interface{})[0].(int)\n       \
    \ end := interval.([]interface{})[1].(int)\n        \n        if start <= end\
    \ {\n            result = append(result, interval)\n        }\n    }\n    \n \
    \   if len(result) == 0 {\n        return \"NO\"\n    }\n    \n    result := make([]interface{},\
    \ 0)\n    \n    for _, interval := range result {\n        start := interval.([]interface{})[0].(int)\n\
    \        end := interval.([]interface{})[1].(int)\n        \n        if start\
    \ <= end {\n            result = append(result, interval)\n        }\n    }\n\
    \    \n    if len(result) == 0 {\n        return \"NO\"\n", "    if len(interval1)\
    \ != len(interval2) {\n        return \"NO\"\n    }\n\n    interval1Start, interval1End\
    \ := interval1[0].([]interface{})[0], interval1[0].([]interface{})[1]\n    interval2Start,\
    \ interval2End := interval2[0].([]interface{})[0], interval2[0].([]interface{})[1]\n\
    \n    if interval1Start > interval2End {\n        return \"NO\"\n    }\n\n   \
    \ if interval1End < interval2Start {\n        return \"NO\"\n    }\n\n    if interval1Start\
    \ > interval2Start {\n        return \"NO\"\n    }\n\n    if interval1End < interval2End\
    \ {\n        return \"NO\"\n    }\n\n    if interval1Start <= interval2Start &&\
    \ interval1End >= interval2End {\n        return \"YES\"\n    }\n\n    if interval1Start\
    \ <= interval2End && interval1End >= interval2Start {\n        return \"YES\"\n\
    \    }\n\n    if interval1Start >= interval2Start && interval1End <= interval2End\
    \ {\n        return \"YES\"\n    }\n\n    if interval1Start >= interval2End &&\
    \ interval1End <= interval2Start {\n        return \"YES\"\n    }\n\n    return\
    \ \"NO\"\n}\n", "    if len(interval1) != len(interval2) {\n        return \"\
    NO\"\n    }\n    \n    interval1Start, interval1End := interval1[0].([]interface{})[0],\
    \ interval1[0].([]interface{})[1]\n    interval2Start, interval2End := interval2[0].([]interface{})[0],\
    \ interval2[0].([]interface{})[1]\n    \n    if interval1Start > interval1End\
    \ {\n        interval1Start, interval1End = interval1End, interval1Start\n   \
    \ }\n    if interval2Start > interval2End {\n        interval2Start, interval2End\
    \ = interval2End, interval2Start\n    }\n    \n    if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n        return \"YES\"\n    }\n    if interval1Start\
    \ <= interval2End && interval1End >= interval2Start {\n        return \"NO\"\n\
    \    }\n    \n    if interval1Start <= interval2Start {\n        return \"NO\"\
    \n    }\n    if interval1End >= interval2End {\n        return \"NO\"\n    }\n\
    \    \n    return \"YES\"\n}\n", "    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n", "    if len(interval1) != len(interval2) {\n        return \"\
    NO\"\n    }\n    \n    result := make([]interface{}, 0)\n    for _, v := range\
    \ interval1 {\n        if v == nil {\n            continue\n        }\n      \
    \  \n        start := v.(int)\n        end := interval2[len(interval2)-1].(int)\n\
    \        if start > end {\n            start, end = end, start\n        }\n  \
    \      \n        if start <= end {\n            result = append(result, start)\n\
    \        }\n    }\n    \n    if len(result) == 0 {\n        return \"NO\"\n  \
    \  }\n    \n    if len(result) == 1 {\n        return \"YES\"\n    }\n    \n \
    \   result := make([]interface{}, 0)\n    for _, v := range result {\n       \
    \ if v == nil {\n            continue\n        }\n        \n        start := v.(int)\n\
    \        end := interval2[len(interval2)-1].(int)\n        if start > end {\n\
    \            start, end = end, start\n        }\n        \n        if start <=\
    \ end {\n            result = append(result, end)\n        }\n    }\n    \n  \
    \  if len(result) == 0 {\n        return \"NO\"\n    }\n    \n    if len(result)\
    \ == 1 {\n        return \"YES\"\n    }\n    \n    result := make([]interface{},\
    \ 0)\n    for _, v := range result {\n        if v == nil {\n            continue\n\
    \        }\n        \n        start := v.(int)\n        end := interval2[len(interval2)-1].(int)\n\
    \        if start > end {\n            start, end = end, start\n        }\n  \
    \      \n        if start <= end {\n            result = append(result, start)\n\
    \        }\n    }\n    \n    if len(result) == 0 {\n        return \"NO\"\n  \
    \  }\n    \n    if len(result) == 1 {\n        return \"YES\"\n    }\n    \n \
    \   result := make([]interface{}, 0)\n    for _, v := range result {\n       \
    \ if v == nil {\n            continue\n        }\n        \n        start := v.(int)\n\
    \        end := interval2[len(interval2)-1].(int)\n        if start > end {\n\
    \            start, end = end, start\n        }\n        \n        if start <=\
    \ end {\n            result = append(result, end)\n        }\n    }\n    \n  \
    \  if len(result) == 0 {\n        return \"NO\"\n    }\n    \n    if len(result)\
    \ == 1 {\n        return \"YES\"\n    }\n    \n    result := make([]interface{},\
    \ 0)\n    for _, v := range result {\n        if v == nil {\n            continue\n\
    \        }\n        \n        start := v.(int)\n        end := interval2[len(interval2)-1].(int)\n\
    \        if start > end {\n            start, end = end, start\n        }\n  \
    \      \n        if start <= end {\n            result = append(result, ", " \
    \   if len(interval1) != len(interval2) {\n        return \"NO\"\n    }\n    \n\
    \    interval1 := interval1[0].([]int)\n    interval2 := interval2[0].([]int)\n\
    \    \n    i := 0\n    for i < len(interval1) {\n        if interval1[i] > interval2[i]\
    \ {\n            break\n        }\n        i++\n    }\n    \n    j := 0\n    for\
    \ j < len(interval2) {\n        if interval2[j] > interval1[j] {\n           \
    \ break\n        }\n        j++\n    }\n    \n    if i == len(interval1) && j\
    \ == len(interval2) {\n        return \"YES\"\n    }\n    \n    if i == len(interval1)\
    \ {\n        return \"NO\"\n    }\n    \n    if j == len(interval2) {\n      \
    \  return \"NO\"\n    }\n    \n    if interval1[i] < interval2[j] {\n        return\
    \ \"NO\"\n    }\n    \n    if interval1[i] > interval2[j] {\n        return \"\
    NO\"\n    }\n    \n    if interval1[i] == interval2[j] {\n        return \"YES\"\
    \n    }\n    \n    if interval1[i] < interval2[j] {\n        return \"NO\"\n \
    \   }\n    \n    return \"YES\"\n}\n", "    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n    \n    interval1Map := make(map[int]bool)\n\
    \    interval2Map := make(map[int]bool)\n    \n    for _, v := range interval1\
    \ {\n        interval1Map[v] = true\n    }\n    for _, v := range interval2 {\n\
    \        interval2Map[v] = true\n    }\n    \n    result := make([]int, 0)\n \
    \   for k := range interval1Map {\n        if interval2Map[k] {\n            result\
    \ = append(result, k)\n        }\n    }\n    \n    if len(result) == 0 {\n   \
    \     return \"NO\"\n    }\n    \n    if len(result) == 1 {\n        return fmt.Sprintf(\"\
    YES\")\n    }\n    \n    result := make([]int, 0)\n    for _, v := range result\
    \ {\n        if isPrime(float64(len(result))) && isPrime(float64(len(result))-1)\
    \ {\n            return fmt.Sprintf(\"YES\")\n        }\n    }\n    \n    return\
    \ \"NO\"\n}\n", "    if len(interval1) != len(interval2) {\n        return \"\
    NO\"\n    }\n    \n    result := make([]interface{}, 0)\n    \n    for _, interval\
    \ := range interval1 {\n        start = interval.([]interface{})[0].(int)\n  \
    \      end = interval.([]interface{})[1].(int)\n        \n        if start <=\
    \ end {\n            result = append(result, interval)\n        }\n    }\n   \
    \ \n    for _, interval := range interval2 {\n        start = interval.([]interface{})[0].(int)\n\
    \        end = interval.([]interface{})[1].(int)\n        \n        if start <=\
    \ end {\n            result = append(result, interval)\n        }\n    }\n   \
    \ \n    if len(result) == 0 {\n        return \"NO\"\n    }\n    \n    result\
    \ := make([]interface{}, 0)\n    \n    for _, interval := range result {\n   \
    \     start = interval.([]interface{})[0].(int)\n        end = interval.([]interface{})[1].(int)\n\
    \        \n        if start <= end {\n            result = append(result, interval)\n\
    \        }\n    }\n    \n    if len(result) == 0 {\n        return \"NO\"\n  \
    \  }\n    \n    result := make([]interface{}, 0)\n    \n    for _, interval :=\
    \ range result {\n        start = interval.([]interface{})[0].(int)\n        end\
    \ = interval.([]interface{})[1].(int)\n        \n        if start <= end {\n \
    \           result = append(result, interval)\n        }\n    }\n    \n    if\
    \ len(result) == 0 {\n        return \"NO\"\n    }\n    \n    result := make([]interface{},\
    \ 0)\n    \n    for _, interval := range result {\n        start = interval.([]interface{})[0].(int)\n\
    \        end = interval.([]interface{})[1].(int)\n        \n        if start <=\
    \ end {\n            result = append(result, interval)\n        }\n    }\n   \
    \ \n    if len(result) == 0 {\n        return \"NO\"\n    }\n    \n    result\
    \ := make([]interface{}, 0)\n    \n    for _, interval := range result {\n   \
    \     start = interval.([]interface{})[0].(int)\n        end = interval.([]interface{})[1].(int)\n\
    \        \n        if start <= end {\n            result = append(result, interval)\n\
    \        }\n    }\n    \n    if len(result) == 0 {\n        return \"NO\"\n  \
    \  }\n    \n    result := make([]interface{}, 0)\n    \n    for _, interval :=\
    \ range result {\n        start = interval.([]interface{})[0].(int)\n        end\
    \ = interval.([]interface{})[1].(int)\n        \n        if start <= end {\n \
    \           result = append(result, interval)\n        }\n    }\n    \n    if\
    \ len(result) == 0 {\n        return \"NO\"\n    }\n    \n    result := make([]interface{},\
    \ 0)\n", "    if len(interval1) != len(interval2) {\n        return \"NO\"\n \
    \   }\n    \n    result := make([]interface{}, len(interval1))\n    \n    for\
    \ i := 0; i < len(interval1); i++ {\n        result[i] = interval1[i]\n    }\n\
    \    \n    for i := 0; i < len(interval2); i++ {\n        result[i] = interval2[i]\n\
    \    }\n    \n    result := append(result, interval1...)\n    result := append(result,\
    \ interval2...)\n    \n    result := append(result, interval1...)\n    result\
    \ := append(result, interval2...)\n    \n    result := append(result, interval1...)\n\
    \    result := append(result, interval2...)\n    \n    result := append(result,\
    \ interval1...)\n    result := append(result, interval2...)\n    \n    result\
    \ := append(result, interval1...)\n    result := append(result, interval2...)\n\
    \    \n    result := append(result, interval1...)\n    result := append(result,\
    \ interval2...)\n    \n    result := append(result, interval1...)\n    result\
    \ := append(result, interval2...)\n    \n    result := append(result, interval1...)\n\
    \    result := append(result, interval2...)\n    \n    result := append(result,\
    \ interval1...)\n    result := append(result, interval2...)\n    \n    result\
    \ := append(result, interval1...)\n    result := append(result, interval2...)\n\
    \    \n    result := append(result, interval1...)\n    result := append(result,\
    \ interval2...)\n    \n    result := append(result, interval1...)\n    result\
    \ := append(result, interval2...)\n    \n    result := append(result, interval1...)\n\
    \    result := append(result, interval2...)\n    \n    result := append(result,\
    \ interval1...)\n    result := append(result, interval2...)\n    \n    result\
    \ := append(result, interval1...)\n    result := append(result, interval2...)\n\
    \    \n    result := append(result, interval1...)\n    result := append(result,\
    \ interval2...)\n    \n    result := append(result, interval1...)\n    result\
    \ := append(result, interval2...)\n    \n    result := append(result, interval1...)\n\
    \    result := append(result, interval2...)\n    \n    result := append(result,\
    \ interval1...)\n    result := append(result, interval2...)\n    \n    result\
    \ := append(result, interval1...)\n    result := append(result, interval2...)\n\
    \    \n    result := append(result, interval1...)\n    result := append(result,\
    \ interval2...)\n    \n    result := append(result, interval1...)\n    result\
    \ := append(result, interval2...)\n", "    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n    \n    interval1Start := interval1[0].(float64)\n\
    \    interval1End := interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n\
    \    interval2End := interval2[1].(float64)\n    \n    if interval1Start > interval1End\
    \ {\n        interval1Start, interval1End = interval1End, interval1Start\n   \
    \ }\n    if interval2Start > interval2End {\n        interval2Start, interval2End\
    \ = interval2End, interval2Start\n    }\n    \n    intersectionStart := interval1Start\n\
    \    intersectionEnd := interval1End\n    \n    for interval1Start < interval1End\
    \ {\n        interval1End += 1\n        \n        for interval2Start < interval2End\
    \ {\n            interval2End += 1\n            \n            if interval1Start\
    \ <= interval2Start && interval1End >= interval2End {\n                intersectionStart\
    \ = interval1Start\n                intersectionEnd = interval1End\n         \
    \       break\n            }\n            if interval1Start <= interval2End &&\
    \ interval1End >= interval2Start {\n                intersectionStart = interval1End\n\
    \                intersectionEnd = interval1End\n                break\n     \
    \       }\n            if interval1Start <= interval2Start && interval1End <=\
    \ interval2End {\n                intersectionStart = interval1Start\n       \
    \         intersectionEnd = interval1End\n                break\n            }\n\
    \        }\n    }\n    \n    if intersectionStart > intersectionEnd {\n      \
    \  return \"NO\"\n    }\n    \n    if intersectionStart <= intersectionEnd {\n\
    \        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n", "    if len(interval1)\
    \ != len(interval2) {\n        return \"NO\"\n    }\n    \n    result := make(map[int]bool)\n\
    \    for _, v := range interval1 {\n        result[v] = true\n    }\n    for _,\
    \ v := range interval2 {\n        if _, ok := result[v]; !ok {\n            return\
    \ \"NO\"\n        }\n    }\n    \n    length := 0\n    for _, v := range result\
    \ {\n        if v {\n            length++\n        }\n    }\n    if length ==\
    \ 2 {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n", "    var result\
    \ string\n    var isIntersect bool\n    \n    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n    \n    for _, interval := range interval1\
    \ {\n        if interval == nil {\n            continue\n        }\n        \n\
    \        if interval2 != nil {\n            isIntersect = true\n        } else\
    \ {\n            isIntersect = false\n        }\n        \n        if interval[0]\
    \ > interval[1] {\n            interval[0], interval[1] = interval[1], interval[0]\n\
    \        }\n        \n        if isIntersect {\n            result += \"(\" +\
    \ fmt.Sprint(interval[0]) + \", \" + fmt.Sprint(interval[1]) + \")\"\n       \
    \ }\n    }\n    \n    if result != \"\" {\n        if isPrime(result) {\n    \
    \        return \"YES\"\n        } else {\n            return \"NO\"\n       \
    \ }\n    }\n    \n    return \"NO\"\n}\n", "    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n\n    result := make([]interface{}, 0)\n  \
    \  for _, interval := range interval1 {\n        if interval[0] < interval[1]\
    \ {\n            result = append(result, interval)\n        }\n    }\n\n    for\
    \ _, interval := range interval2 {\n        if interval[0] < interval[1] {\n \
    \           result = append(result, interval)\n        }\n    }\n\n    if len(result)\
    \ == 0 {\n        return \"NO\"\n    }\n\n    length := 0\n    for _, interval\
    \ := range result {\n        length = length + interval[1] - interval[0]\n   \
    \ }\n\n    if length == 1 {\n        return \"YES\"\n    }\n\n    if length ==\
    \ 2 && result[0][0] == result[1][0] {\n        return \"YES\"\n    }\n\n    if\
    \ length == 2 && result[0][0] == result[1][1] {\n        return \"YES\"\n    }\n\
    \n    if length == 2 && result[1][0] == result[0][1] {\n        return \"YES\"\
    \n    }\n\n    if length == 3 && result[0][0] == result[1][1] && result[1][0]\
    \ == result[2][1] {\n        return \"YES\"\n    }\n\n    if length == 3 && result[0][0]\
    \ == result[1][1] && result[1][1] == result[2][0] {\n        return \"YES\"\n\
    \    }\n\n    if length == 3 && result[1][0] == result[0][1] && result[1][1] ==\
    \ result[2][0] {\n        return \"YES\"\n    }\n\n    if length == 3 && result[1][0]\
    \ == result[2][0] && result[1][1] == result[0][1] {\n        return \"YES\"\n\
    \    }\n\n    if length == 3 && result[2][0] == result[0][1] && result[2][1] ==\
    \ result[1][1] {\n        return \"YES\"\n    }\n\n    if length == 3 && result[2][0]\
    \ == result[1][1] && result[2][1] == result[0][1] {\n        return \"YES\"\n\
    \    }\n\n    if length == 3 && result[2][0] == result[0][1] && result[2][1] ==\
    \ result[1][1] {\n        return \"YES\"\n    }\n\n    if length == 3 && result[0][0]\
    \ == result[1][1] && result[1][1] == result[2][1] {\n        return \"YES\"\n\
    \    }\n\n    if length == 3 && result[0][0] == result[1][1] && result[1][1] ==\
    \ result[2][1] {\n        return \"YES\"\n    }\n\n    if length == 3 && result[1][0]\
    \ == result[2][1] && result[1][1] == result[0][1] {\n        return \"YES\"\n\
    \    }\n\n    if length == 3 && result[1][0] == result[2][1] && result[1][1] ==\
    \ result[0][1] {\n        return \"YES\"\n    }\n\n    if length == 3 && result[2][0]\
    \ == result[0][1] && result[2][1] == result[1][1] {\n        return \"YES\"\n\
    \    }\n\n    if length == 3 && result[2][0] == result[1][1] && result[2][1] ==\
    \ result[0][1] {\n        return \"YES\"\n    }\n\n    if length == 3 && result[2][0]\
    \ == result[0][1] && ", "    var result string\n    \n    if len(interval1) !=\
    \ len(interval2) {\n        return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1);\
    \ i++ {\n        if interval1[i].([]interface{})[0] != interval2[i].([]interface{})[0]\
    \ {\n            result = \"NO\"\n            break\n        }\n    }\n    \n\
    \    if result == \"NO\" {\n        return \"NO\"\n    }\n    \n    if result\
    \ == \"YES\" {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n",
  "    var result string\n    \n    if len(interval1) != len(interval2) {\n      \
    \  return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1); i++ {\n   \
    \     if interval1[i].([]interface{})[0] != interval2[i].([]interface{})[0] {\n\
    \            result = \"NO\"\n            break\n        }\n    }\n    \n    if\
    \ result == \"NO\" {\n        return \"NO\"\n    }\n    \n    if isPrime(interval1[0].([]interface{})[1])\
    \ && isPrime(interval2[0].([]interface{})[1]) {\n        return \"YES\"\n    }\n\
    \    \n    return \"NO\"\n}\n", "    if len(interval1) != len(interval2) {\n \
    \       return \"NO\"\n    }\n    \n    interval1 := make([]int, len(interval1))\n\
    \    interval2 := make([]int, len(interval2))\n    \n    for i, v := range interval1\
    \ {\n        interval1[i] = v.(int)\n    }\n    for i, v := range interval2 {\n\
    \        interval2[i] = v.(int)\n    }\n    \n    result := make([]int, len(interval1))\n\
    \    \n    for i, v := range interval1 {\n        for j, w := range interval2\
    \ {\n            if v >= w {\n                result[i] = v\n                break\n\
    \            }\n        }\n    }\n    \n    if len(result) == 0 {\n        return\
    \ \"NO\"\n    }\n    \n    result := make([]int, len(result))\n    \n    for i,\
    \ v := range result {\n        if v == 0 {\n            result[i] = 1\n      \
    \  }\n    }\n    \n    result := make([]int, len(result))\n    \n    for i, v\
    \ := range result {\n        if v == 1 {\n            result[i] = 1\n        }\n\
    \    }\n    \n    result := make([]int, len(result))\n    \n    for i, v := range\
    \ result {\n        if v == 2 {\n            result[i] = 1\n        }\n    }\n\
    \    \n    result := make([]int, len(result))\n    \n    for i, v := range result\
    \ {\n        if v == 3 {\n            result[i] = 1\n        }\n    }\n    \n\
    \    result := make([]int, len(result))\n    \n    for i, v := range result {\n\
    \        if v == 4 {\n            result[i] = 1\n        }\n    }\n    \n    result\
    \ := make([]int, len(result))\n    \n    for i, v := range result {\n        if\
    \ v == 5 {\n            result[i] = 1\n        }\n    }\n    \n    result := make([]int,\
    \ len(result))\n    \n    for i, v := range result {\n        if v == 6 {\n  \
    \          result[i] = 1\n        }\n    }\n    \n    result := make([]int, len(result))\n\
    \    \n    for i, v := range result {\n        if v == 7 {\n            result[i]\
    \ = 1\n        }\n    }\n    \n    result := make([]int, len(result))\n    \n\
    \    for i, v := range result {\n        if v == 8 {\n            result[i] =\
    \ 1\n        }\n    }\n    \n    result := make([]int, len(result))\n    \n  \
    \  for i, v := range result {\n        if v == 9 {\n            result[i] = 1\n\
    \        }\n    }\n    \n    result := make([]int, len(result))\n    \n    for\
    \ i, v := range result {\n        if v == 10 {\n", "    if len(interval1) == 0\
    \ || len(interval2) == 0 {\n        return \"NO\"\n    }\n    \n    interval1Start,\
    \ interval1End := interval1[0].(int), interval1[1].(int)\n    interval2Start,\
    \ interval2End := interval2[0].(int), interval2[1].(int)\n    \n    if interval1Start\
    \ > interval2End {\n        return fmt.Sprintf(\"NO\")\n    }\n    if interval1End\
    \ < interval2Start {\n        return fmt.Sprintf(\"NO\")\n    }\n    \n    result\
    \ := 0\n    \n    for i := interval1Start; i <= interval1End; i++ {\n        if\
    \ interval2Start <= i && i <= interval2End {\n            result += i\n      \
    \  }\n    }\n    \n    if result % 2 == 0 {\n        return fmt.Sprintf(\"YES\"\
    )\n    }\n    return fmt.Sprintf(\"NO\")\n}\n", "    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n", "    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n", "    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start, interval1End := interval1[0].([]interface{})[0],\
    \ interval1[0].([]interface{})[1]\n    interval2Start, interval2End := interval2[0].([]interface{})[0],\
    \ interval2[0].([]interface{})[1]\n    \n    if interval1Start > interval2End\
    \ {\n        return \"NO\"\n    }\n    if interval1End < interval2Start {\n  \
    \      return \"NO\"\n    }\n    \n    intersectionLength := interval1End - interval1Start\n\
    \    \n    if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n        return \"YES\"\n    }\n    if interval1Start <= interval2End && interval1End\
    \ >= interval2Start {\n        return \"YES\"\n    }\n    if interval1Start >=\
    \ interval2Start && interval1End <= interval2End {\n        return \"YES\"\n \
    \   }\n    if interval1Start >= interval2End && interval1End <= interval2Start\
    \ {\n        return \"YES\"\n    }\n    \n    if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n        return \"YES\"\n    }\n    if interval1Start\
    \ <= interval2End && interval1End >= interval2Start {\n        return \"YES\"\n\
    \    }\n    if interval1Start >= interval2Start && interval1End <= interval2End\
    \ {\n        return \"YES\"\n    }\n    if interval1Start >= interval2End && interval1End\
    \ <= interval2Start {\n        return \"YES\"\n    }\n    \n    if interval1Start\
    \ <= interval2Start && interval1End >= interval2End {\n        return \"YES\"\n\
    \    }\n    if interval1Start <= interval2End && interval1End >= interval2Start\
    \ {\n        return \"YES\"\n    }\n    if interval1Start >= interval2Start &&\
    \ interval1End <= interval2End {\n        return \"YES\"\n    }\n    if interval1Start\
    \ >= interval2End && interval1End <= interval2Start {\n        return \"YES\"\n\
    \    }\n    \n    if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n        return \"YES\"\n    }\n    if interval1Start <= interval2End && interval1End\
    \ >= interval2Start {\n        return \"YES\"\n    }\n    if interval1Start >=\
    \ interval2Start && interval1End <= interval2End {\n        return \"YES\"\n \
    \   }\n    if interval1Start >= interval2End && interval1End <= interval2Start\
    \ {\n        return \"YES\"\n    }\n    \n    if interval1", "    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n", "    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n    \n    interval1Start := interval1[0].(float64)\n\
    \    interval1End := interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n\
    \    interval2End := interval2[1].(float64)\n    \n    if interval1Start > interval2End\
    \ {\n        return \"NO\"\n    }\n    if interval1End < interval2Start {\n  \
    \      return \"NO\"\n    }\n    \n    intersection := interval1Start + interval1End\
    \ - interval2Start - interval2End\n    if intersection <= 0 {\n        return\
    \ \"NO\"\n    }\n    \n    if isPrime(intersection) {\n        return \"YES\"\n\
    \    }\n    \n    return \"NO\"\n}\n", "    var result string\n    var start int\n\
    \    var end int\n    var length int\n    var isPrime bool\n    \n    if len(interval1)\
    \ != len(interval2) {\n        return \"NO\"\n    }\n    \n    for i := 0; i <\
    \ len(interval1); i++ {\n        start = interval1[i].(float64)\n        end =\
    \ interval2[i].(float64)\n        \n        if start > end {\n            fmt.Println(\"\
    start > end\")\n            return \"NO\"\n        }\n        \n        length\
    \ = end - start\n        \n        if length == 0 {\n            fmt.Println(\"\
    length == 0\")\n            return \"NO\"\n        }\n        \n        isPrime\
    \ = true\n        \n        for j := 0; j < length; j++ {\n            if j%2\
    \ == 0 {\n                isPrime = false\n                break\n           \
    \ }\n        }\n        \n        if isPrime {\n            result = \"YES\"\n\
    \            break\n        }\n    }\n    \n    return result\n}\n", "    if len(interval1)\
    \ != len(interval2) {\n        return \"NO\"\n    }\n    \n    interval1Start,\
    \ interval1End := interval1[0].(int), interval1[1].(int)\n    interval2Start,\
    \ interval2End := interval2[0].(int), interval2[1].(int)\n    \n    if interval1Start\
    \ > interval2End {\n        return \"NO\"\n    }\n    if interval1End < interval2Start\
    \ {\n        return \"NO\"\n    }\n    \n    result := 0\n    \n    for i := 0;\
    \ i < interval1End; i++ {\n        if interval1Start <= i && i <= interval2End\
    \ {\n            result += i\n        }\n    }\n    \n    if result % 2 == 0 {\n\
    \        return \"NO\"\n    }\n    \n    return \"YES\"\n}\n", "    if len(interval1)\
    \ != len(interval2) {\n        return \"NO\"\n    }\n    \n    result := make(map[int]bool)\n\
    \    for _, v := range interval1 {\n        result[v] = true\n    }\n    for _,\
    \ v := range interval2 {\n        if _, ok := result[v]; !ok {\n            return\
    \ \"NO\"\n        }\n    }\n    \n    result := make(map[int]bool)\n    for _,\
    \ v := range interval1 {\n        result[v] = true\n    }\n    for _, v := range\
    \ interval2 {\n        if _, ok := result[v]; !ok {\n            return \"NO\"\
    \n        }\n    }\n    \n    result := make(map[int]bool)\n    for _, v := range\
    \ interval1 {\n        result[v] = true\n    }\n    for _, v := range interval2\
    \ {\n        if _, ok := result[v]; !ok {\n            return \"NO\"\n       \
    \ }\n    }\n    \n    result := make(map[int]bool)\n    for _, v := range interval1\
    \ {\n        result[v] = true\n    }\n    for _, v := range interval2 {\n    \
    \    if _, ok := result[v]; !ok {\n            return \"NO\"\n        }\n    }\n\
    \    \n    result := make(map[int]bool)\n    for _, v := range interval1 {\n \
    \       result[v] = true\n    }\n    for _, v := range interval2 {\n        if\
    \ _, ok := result[v]; !ok {\n            return \"NO\"\n        }\n    }\n   \
    \ \n    result := make(map[int]bool)\n    for _, v := range interval1 {\n    \
    \    result[v] = true\n    }\n    for _, v := range interval2 {\n        if _,\
    \ ok := result[v]; !ok {\n            return \"NO\"\n        }\n    }\n    \n\
    \    result := make(map[int]bool)\n    for _, v := range interval1 {\n       \
    \ result[v] = true\n    }\n    for _, v := range interval2 {\n        if _, ok\
    \ := result[v]; !ok {\n            return \"NO\"\n        }\n    }\n    \n   \
    \ result := make(map[int]bool)\n    for _, v := range interval1 {\n        result[v]\
    \ = true\n    }\n    for _, v := range interval2 {\n        if _, ok := result[v];\
    \ !ok {\n            return \"NO\"\n        }\n    }\n    \n    result := make(map[int]bool)\n\
    \    for _, v := range interval1 {\n        result[v] = true\n    }\n    for _,\
    \ v := range interval2 {\n        if _, ok := result[v]; !ok {\n            return\
    \ \"NO\"\n        }\n    }\n    \n    result := make(map[int]bool)\n    for ",
  "    if len(interval1) != len(interval2) {\n        return \"NO\"\n    }\n    \n\
    \    interval1Start := interval1[0].(float64)\n    interval1End := interval1[1].(float64)\n\
    \    interval2Start := interval2[0].(float64)\n    interval2End := interval2[1].(float64)\n\
    \    \n    if interval1Start > interval1End {\n        interval1Start, interval1End\
    \ = interval1End, interval1Start\n    }\n    if interval2Start > interval2End\
    \ {\n        interval2Start, interval2End = interval2End, interval2Start\n   \
    \ }\n    \n    intersectionStart := interval1Start\n    intersectionEnd := interval1End\n\
    \    \n    for interval1Start < interval1End {\n        interval1End += 1\n  \
    \      \n        for interval2Start < interval2End {\n            interval2End\
    \ += 1\n            \n            if interval1Start <= interval2Start && interval1End\
    \ >= interval2End {\n                intersectionStart = interval1Start\n    \
    \            intersectionEnd = interval1End\n            }\n            if interval1Start\
    \ <= interval2End && interval1End >= interval2Start {\n                intersectionStart\
    \ = interval1End\n                intersectionEnd = interval1Start\n         \
    \   }\n            if interval1Start <= interval2Start && interval1End <= interval2End\
    \ {\n                intersectionStart = interval1Start\n                intersectionEnd\
    \ = interval1End\n            }\n            if interval1Start >= interval2Start\
    \ && interval1End <= interval2End {\n                intersectionStart = interval1End\n\
    \                intersectionEnd = interval1Start\n            }\n           \
    \ if interval1Start >= interval2Start && interval1End >= interval2End {\n    \
    \            intersectionStart = interval1Start\n                intersectionEnd\
    \ = interval1End\n            }\n        }\n    }\n    \n    if intersectionStart\
    \ <= intersectionEnd {\n        if intersectionStart % 2 == 0 {\n            return\
    \ \"YES\"\n        }\n        return \"NO\"\n    }\n    return \"NO\"\n}\n", " \
    \   if len(interval1) == 0 || len(interval2) == 0 {\n        return \"NO\"\n \
    \   }\n    \n    interval1Start, interval1End := interval1[0].([]interface{})[0],\
    \ interval1[0].([]interface{})[1]\n    interval2Start, interval2End := interval2[0].([]interface{})[0],\
    \ interval2[0].([]interface{})[1]\n    \n    if interval1Start > interval1End\
    \ {\n        interval1Start, interval1End = interval1End, interval1Start\n   \
    \ }\n    if interval2Start > interval2End {\n        interval2Start, interval2End\
    \ = interval2End, interval2Start\n    }\n    \n    if interval1Start <= interval2End\
    \ && interval2Start <= interval1End {\n        \n        if interval1Start < interval2Start\
    \ {\n            interval1Start, interval2Start = interval2Start, interval1Start\n\
    \        }\n        if interval1End > interval2End {\n            interval1End,\
    \ interval2End = interval2End, interval1End\n        }\n        \n        if interval1Start\
    \ <= interval2Start && interval1End >= interval2End {\n            \n        \
    \    if interval1Start < interval2End {\n                interval1Start, interval2End\
    \ = interval2End, interval1Start\n            }\n            if interval1End >\
    \ interval2Start {\n                interval1End, interval2Start = interval2Start,\
    \ interval1End\n            }\n            \n            if interval1Start <=\
    \ interval2Start && interval1End >= interval2End {\n                \n       \
    \         if interval1Start < interval2End {\n                    interval1Start,\
    \ interval2End = interval2End, interval1Start\n                }\n           \
    \     if interval1End > interval2Start {\n                    interval1End, interval2Start\
    \ = interval2Start, interval1End\n                }\n                \n      \
    \          if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n                    \n                    if interval1Start < interval2End\
    \ {\n                        interval1Start, interval2End = interval2End, interval1Start\n\
    \                    }\n                    if interval1End > interval2Start {\n\
    \                        interval1End, interval2Start = interval2Start, interval1End\n\
    \                    }\n                    \n                    if interval1Start\
    \ <= interval2Start && interval1End >= interval2End {\n                      \
    \  \n                        if interval1Start < interval2End {\n            \
    \                interval1Start, interval2End = interval2End, interval1Start\n\
    \                        }\n                        if interval1End > interval2Start\
    \ {\n                            interval1End, interval2Start = interval2Start,\
    \ interval1End\n                        }\n                        \n        \
    \                if interval1Start <= interval", "    var result string\n    \n\
    \    if len(interval1) != len(interval2) {\n        return \"NO\"\n    }\n   \
    \ \n    for i := 0; i < len(interval1); i++ {\n        if interval1[i].([]interface{})[0]\
    \ != interval2[i].([]interface{})[0] {\n            return \"NO\"\n        }\n\
    \    }\n    \n    for i := 0; i < len(interval1); i++ {\n        if interval1[i].([]interface{})[1]\
    \ > interval2[i].([]interface{})[1] {\n            return \"NO\"\n        }\n\
    \    }\n    \n    for i := 0; i < len(interval1); i++ {\n        if interval1[i].([]interface{})[1]\
    \ < interval2[i].([]interface{})[1] {\n            return \"NO\"\n        }\n\
    \    }\n    \n    for i := 0; i < len(interval1); i++ {\n        if interval1[i].([]interface{})[0]\
    \ == interval2[i].([]interface{})[0] {\n            result += fmt.Sprintf(\"%d\"\
    , interval1[i].([]interface{})[1])\n        }\n    }\n    \n    if result == \"\
    NO\" {\n        return \"NO\"\n    }\n    \n    if result == \"YES\" {\n     \
    \   return \"YES\"\n    }\n    \n    return \"NO\"\n}\n", "    var result string\n\
    \    \n    if len(interval1) != len(interval2) {\n        return \"NO\"\n    }\n\
    \    \n    for i := 0; i < len(interval1); i++ {\n        if interval1[i].(float64)\
    \ <= interval2[i].(float64) {\n            result += \"YES\"\n        } else {\n\
    \            result += \"NO\"\n        }\n    }\n    \n    return result\n}\n",
  "    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n", "    var result string\n\
    \    \n    if len(interval1) != len(interval2) {\n        return \"NO\"\n    }\n\
    \    \n    for i := 0; i < len(interval1); i++ {\n        if interval1[i].(float64)\
    \ >= interval2[i].(float64) {\n            result = \"NO\"\n            break\n\
    \        }\n    }\n    \n    if result == \"NO\" {\n        return \"NO\"\n  \
    \  }\n    \n    if isPrime(interval1[0].(float64)) && isPrime(interval2[0].(float64))\
    \ {\n        return \"YES\"\n    }\n    \n    return result\n}\n", "    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n", "    if len(interval1) !=\
    \ len(interval2) {\n        return \"NO\"\n    }\n    \n    interval1 := make([]int,\
    \ len(interval1))\n    interval2 := make([]int, len(interval2))\n    \n    for\
    \ i := 0; i < len(interval1); i++ {\n        interval1[i] = interval1[i].(int)\n\
    \    }\n    for i := 0; i < len(interval2); i++ {\n        interval2[i] = interval2[i].(int)\n\
    \    }\n    \n    result := make([]int, len(interval1))\n    \n    for i := 0;\
    \ i < len(interval1); i++ {\n        if interval1[i] > interval2[i] {\n      \
    \      result[i] = interval1[i]\n        } else {\n            result[i] = interval2[i]\n\
    \        }\n    }\n    \n    result := make([]int, len(result))\n    \n    for\
    \ i := 0; i < len(result); i++ {\n        if result[i] == 0 {\n            result[i]\
    \ = 1\n        }\n    }\n    \n    result := make([]int, len(result))\n    \n\
    \    for i := 0; i < len(result); i++ {\n        if result[i] == 1 {\n       \
    \     return \"NO\"\n        }\n    }\n    \n    return \"YES\"\n}\n", "    var\
    \ result string\n    \n    if len(interval1) != len(interval2) {\n        return\
    \ \"NO\"\n    }\n    \n    for i := 0; i < len(interval1); i++ {\n        if interval1[i].(float64)\
    \ >= interval2[i].(float64) {\n            result = \"NO\"\n            break\n\
    \        }\n    }\n    \n    if result == \"NO\" {\n        return \"NO\"\n  \
    \  }\n    \n    for i := 0; i < len(interval1); i++ {\n        if interval1[i].(float64)\
    \ < interval2[i].(float64) {\n            result = \"NO\"\n            break\n\
    \        }\n    }\n    \n    if result == \"NO\" {\n        return \"NO\"\n  \
    \  }\n    \n    if result == \"\" {\n        return \"YES\"\n    }\n    \n   \
    \ return result\n}\n", "    var result string\n    var i int\n    var j int\n\
    \    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n \
    \   var p int\n    var q int\n    var r int\n    var s int\n    var t int\n  \
    \  var u int\n    var v int\n    var w int\n    var x int\n    var y int\n   \
    \ var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var\
    \ e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j\
    \ int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n\
    \    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n \
    \   var u int\n    var v int\n    var w int\n    var x int\n    var y int\n  \
    \  var z int\n    var a int\n    var b int\n    var c int\n    var d int\n   \
    \ var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var\
    \ j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o\
    \ int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n\
    \    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n \
    \   var z int\n    var a int\n    var b int\n    var c int\n    var d int\n  \
    \  var e int\n    var f int\n    var g int\n    var h int\n    var i int\n   \
    \ var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var\
    \ o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t\
    \ int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n\
    \    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n \
    \   var e int\n    var f int\n    var g int\n    var h int\n    var i int\n  \
    \  var j int\n    var k int\n    var l int\n    var m int\n    var n int\n   \
    \ var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var\
    \ t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y\
    \ int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n\
    \    var e int\n", "    if len(interval1) != len(interval2) {\n        return\
    \ \"NO\"\n    }\n    \n    result := make([]interface{}, 0)\n    \n    for _,\
    \ interval := range interval1 {\n        start := interval.([]interface{})[0].(int)\n\
    \        end := interval.([]interface{})[1].(int)\n        \n        for _, interval2\
    \ := range interval2 {\n            interval2 := interval2.([]interface{})\n \
    \           \n            if start <= interval2[0] && interval2[1] <= end {\n\
    \                result := append(result, interval2)\n            }\n        }\n\
    \    }\n    \n    if len(result) == 0 {\n        return \"NO\"\n    }\n    \n\
    \    if len(result) == 1 {\n        return \"YES\"\n    }\n    \n    result :=\
    \ make([]interface{}, 0)\n    \n    for _, interval := range result {\n      \
    \  start := interval.([]interface{})[0].(int)\n        end := interval.([]interface{})[1].(int)\n\
    \        \n        if isPrime(start, end) {\n            return \"YES\"\n    \
    \    }\n    }\n    \n    return \"NO\"\n}\n", "    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n    \n    interval1Start := interval1[0].(float64)\n\
    \    interval1End := interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n\
    \    interval2End := interval2[1].(float64)\n    \n    if interval1Start > interval1End\
    \ {\n        interval1Start, interval1End = interval1End, interval1Start\n   \
    \ }\n    if interval2Start > interval2End {\n        interval2Start, interval2End\
    \ = interval2End, interval2Start\n    }\n    \n    intersectionLength := interval1End\
    \ - interval1Start\n    \n    if interval2Start < interval2End {\n        intersectionLength\
    \ += interval2End - interval2Start\n    }\n    \n    if intersectionLength ==\
    \ 0 {\n        return \"NO\"\n    }\n    \n    if intersectionLength == 1 {\n\
    \        return \"YES\"\n    }\n    \n    if isPrime(intersectionLength) {\n \
    \       return \"YES\"\n    }\n    \n    return \"NO\"\n}\n", "    var result\
    \ string\n    \n    interval1Start, interval1End := interval1[0].([]interface{})[0],\
    \ interval1[0].([]interface{})[1]\n    interval2Start, interval2End := interval2[0].([]interface{})[0],\
    \ interval2[0].([]interface{})[1]\n    \n    if interval1Start <= interval2End\
    \ && interval1End >= interval2Start {\n        \n        if interval1Start <=\
    \ interval2Start {\n            result = fmt.Sprintf(\"YES\")\n        } else\
    \ {\n            result = fmt.Sprintf(\"NO\")\n        }\n    } else {\n     \
    \   result = fmt.Sprintf(\"NO\")\n    }\n    \n    return result\n}\n", "    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n", "    \n    // Write your code\
    \ here\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    ", "    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n\n    interval1Start := interval1[0].(float64)\n\
    \    interval1End := interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n\
    \    interval2End := interval2[1].(float64)\n\n    intersectionStart := interval1Start\n\
    \    intersectionEnd := interval1End\n\n    for interval1Start <= interval1End\
    \ && interval2Start <= interval2End {\n        if interval1Start <= interval2Start\
    \ {\n            intersectionStart = interval1Start\n        }\n        if interval1End\
    \ >= interval2End {\n            intersectionEnd = interval1End\n        }\n \
    \       if intersectionStart <= intersectionEnd {\n            intersectionEnd\
    \ = interval1End\n        }\n    }\n\n    if intersectionStart <= intersectionEnd\
    \ {\n        if interval1Start <= interval2Start {\n            intersectionStart\
    \ = interval1Start\n        }\n        if interval1End >= interval2End {\n   \
    \         intersectionEnd = interval1End\n        }\n        if intersectionStart\
    \ <= intersectionEnd {\n            intersectionEnd = interval1End\n        }\n\
    \    }\n\n    if intersectionStart <= intersectionEnd {\n        if interval1Start\
    \ <= interval2Start {\n            intersectionStart = interval1Start\n      \
    \  }\n        if interval1End >= interval2End {\n            intersectionEnd =\
    \ interval1End\n        }\n        if intersectionStart <= intersectionEnd {\n\
    \            intersectionEnd = interval1End\n        }\n    }\n\n    if intersectionStart\
    \ <= intersectionEnd {\n        if interval1Start <= interval2Start {\n      \
    \      intersectionStart = interval1Start\n        }\n        if interval1End\
    \ >= interval2End {\n            intersectionEnd = interval1End\n        }\n \
    \       if intersectionStart <= intersectionEnd {\n            intersectionEnd\
    \ = interval1End\n        }\n    }\n\n    if intersectionStart <= intersectionEnd\
    \ {\n        if interval1Start <= interval2Start {\n            intersectionStart\
    \ = interval1Start\n        }\n        if interval1End >= interval2End {\n   \
    \         intersectionEnd = interval1End\n        }\n        if intersectionStart\
    \ <= intersectionEnd {\n            intersectionEnd = interval1End\n        }\n\
    \    }\n\n    if intersectionStart <= intersectionEnd {\n        if interval1Start\
    \ <= interval2Start {\n            intersectionStart = interval1Start\n      \
    \  }\n        if interval1End >= interval2End {\n            intersectionEnd =\
    \ interval1End\n        }\n        if intersectionStart <= intersectionEnd {\n\
    \            intersectionEnd = interval1End\n        }\n    }\n\n    if intersectionStart\
    \ <= intersectionEnd {\n        if interval1Start <= interval2Start {\n      \
    \      intersectionStart = interval1Start\n        }\n        if interval1End\
    \ >= interval2End {\n            ", "    \n    // Write your code here\n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    ", "    \n    var interval1Start int\n    var interval1End\
    \ int\n    var interval2Start int\n    var interval2End int\n    \n    interval1Start\
    \ = interval1[0].(int)\n    interval1End = interval1[1].(int)\n    interval2Start\
    \ = interval2[0].(int)\n    interval2End = interval2[1].(int)\n    \n    if interval1Start\
    \ > interval1End {\n        fmt.Println(\"interval1Start > interval1End\")\n \
    \       return \"NO\"\n    }\n    if interval2Start > interval2End {\n       \
    \ fmt.Println(\"interval2Start > interval2End\")\n        return \"NO\"\n    }\n\
    \    \n    if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n        fmt.Println(\"interval1Start <= interval2Start && interval1End >=\
    \ interval2End\")\n        return \"NO\"\n    }\n    \n    if interval1Start <=\
    \ interval2End && interval1End >= interval2Start {\n        fmt.Println(\"interval1Start\
    \ <= interval2End && interval1End >= interval2Start\")\n        return \"NO\"\n\
    \    }\n    \n    if interval1Start >= interval2Start && interval1End <= interval2End\
    \ {\n        fmt.Println(\"interval1Start >= interval2Start && interval1End <=\
    \ interval2End\")\n        return \"NO\"\n    }\n    \n    if interval1Start >=\
    \ interval2End && interval1End <= interval2Start {\n        fmt.Println(\"interval1Start\
    \ >= interval2End && interval1End <= interval2Start\")\n        return \"NO\"\n\
    \    }\n    \n    if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n        fmt.Println(\"interval1Start <= interval2Start && interval1End >=\
    \ interval2End\")\n        return \"NO\"\n    }\n    \n    if interval1Start <=\
    \ interval2End && interval1End >= interval2Start {\n        fmt.Println(\"interval1Start\
    \ <= interval2End && interval1End >= interval2Start\")\n        return \"NO\"\n\
    \    }\n    \n    if interval1Start >= interval2Start && interval1End <= interval2End\
    \ {\n        fmt.Println(\"interval1Start >= interval2Start && interval1End <=\
    \ interval2End\")\n        return \"NO\"\n    }\n    \n    if interval1Start >=\
    \ interval2End && interval1End <= interval2Start {\n        fmt.Println(\"interval1Start\
    \ >= interval2End && interval1End <= interval2Start\")\n        return \"NO\"\n\
    \    }\n    \n    if interval1Start <= interval2Start && interval", "    var result\
    \ string\n    var length int\n    var start int\n    var end int\n    var isPrime\
    \ bool\n    \n    if len(interval1) != len(interval2) {\n        return \"NO\"\
    \n    }\n    \n    for i := 0; i < len(interval1); i++ {\n        start = interval1[i].(float64)\n\
    \        end = interval2[i].(float64)\n        \n        if start > end {\n  \
    \          start = end\n        }\n        \n        length = end - start\n  \
    \      \n        if length == 0 {\n            continue\n        }\n        \n\
    \        isPrime = true\n        \n        for j := 1; j < length; j++ {\n   \
    \         if start%j == 0 && end%j == 0 {\n                isPrime = false\n \
    \               break\n            }\n        }\n        \n        if isPrime\
    \ {\n            result = \"YES\"\n            break\n        }\n    }\n    \n\
    \    return result\n}\n", "    \n    \n    \n    \n    \n    \n    \n    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n", "    var result string\n    if len(interval1) != len(interval2) {\n\
    \        return \"NO\"\n    }\n    for _, v := range interval1 {\n        if v\
    \ == nil {\n            continue\n        }\n        start, end := v.(int64)\n\
    \        if start > end {\n            continue\n        }\n        for _, v1\
    \ := range interval2 {\n            if v1 == nil {\n                continue\n\
    \            }\n            start1, end1 := v1.(int64)\n            if start1\
    \ > end1 {\n                continue\n            }\n            if start1 <=\
    \ end && end1 >= start {\n                result += fmt.Sprintf(\"%v\", end -\
    \ start)\n            }\n        }\n    }\n    if result == \"YES\" {\n      \
    \  return \"YES\"\n    }\n    return \"NO\"\n}\n", "    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n\n    interval1Start := interval1[0].(float64)\n\
    \    interval1End := interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n\
    \    interval2End := interval2[1].(float64)\n\n    if interval1Start > interval1End\
    \ {\n        interval1Start, interval1End = interval1End, interval1Start\n   \
    \ }\n\n    if interval2Start > interval2End {\n        interval2Start, interval2End\
    \ = interval2End, interval2Start\n    }\n\n    if interval1Start > interval2End\
    \ {\n        return \"NO\"\n    }\n\n    if interval1Start < interval2Start {\n\
    \        return \"NO\"\n    }\n\n    if interval1End < interval2End {\n      \
    \  return \"NO\"\n    }\n\n    if interval1Start <= interval2Start {\n       \
    \ if interval1End <= interval2End {\n            if interval1Start <= interval2Start\
    \ {\n                return \"YES\"\n            }\n            if interval1End\
    \ >= interval2End {\n                return \"NO\"\n            }\n        }\n\
    \    }\n\n    return \"YES\"\n}\n", "    \n    // Your code here\n    \n    return\
    \ \"\"\n}\n", "    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n  \
    \  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n", " \
    \   var result string\n    if len(interval1) != len(interval2) {\n        return\
    \ \"NO\"\n    }\n    for i := 0; i < len(interval1); i++ {\n        if interval1[i].([]interface{})[0].(int)\
    \ <= interval2[i].([]interface{})[0].(int) {\n            if interval1[i].([]interface{})[0].(int)\
    \ >= interval2[i].([]interface{})[1].(int) {\n                result += \"YES\"\
    \n            } else {\n                result += \"NO\"\n            }\n    \
    \    } else {\n            if interval1[i].([]interface{})[1].(int) >= interval2[i].([]interface{})[0].(int)\
    \ {\n                result += \"NO\"\n            } else {\n                result\
    \ += \"YES\"\n            }\n        }\n    }\n    return result\n}\n", "    var\
    \ result string\n    \n    if len(interval1) != len(interval2) {\n        return\
    \ \"NO\"\n    }\n    \n    for i := 0; i < len(interval1); i++ {\n        if interval1[i].(float64)\
    \ < interval2[i].(float64) {\n            result = \"NO\"\n            break\n\
    \        }\n    }\n    \n    if result == \"NO\" {\n        return \"NO\"\n  \
    \  }\n    \n    for i := 0; i < len(interval1); i++ {\n        if interval1[i].(float64)\
    \ >= interval2[i].(float64) {\n            result = \"NO\"\n            break\n\
    \        }\n    }\n    \n    if result == \"NO\" {\n        return \"NO\"\n  \
    \  }\n    \n    if result == \"YES\" {\n        return \"YES\"\n    }\n    \n\
    \    return \"NO\"\n}\n", "    var result string\n    \n    interval1Start :=\
    \ interval1[0].(int)\n    interval1End := interval1[1].(int)\n    interval2Start\
    \ := interval2[0].(int)\n    interval2End := interval2[1].(int)\n    \n    if\
    \ interval1Start <= interval2Start && interval1End >= interval2End {\n       \
    \ result += \"YES\"\n    } else {\n        result += \"NO\"\n    }\n    \n   \
    \ return result\n}\n", "    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n",
  "    var result string\n    var i int\n    var j int\n    var k int\n    var l int\n\
    \    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n \
    \   var r int\n    var s int\n    var t int\n    var u int\n    var v int\n  \
    \  var w int\n    var x int\n    var y int\n    var z int\n    var a int\n   \
    \ var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var\
    \ g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l\
    \ int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n\
    \    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n \
    \   var w int\n    var x int\n    var y int\n    var z int\n    var a int\n  \
    \  var b int\n    var c int\n    var d int\n    var e int\n    var f int\n   \
    \ var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var\
    \ l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q\
    \ int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n\
    \    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n \
    \   var b int\n    var c int\n    var d int\n    var e int\n    var f int\n  \
    \  var g int\n    var h int\n    var i int\n    var j int\n    var k int\n   \
    \ var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var\
    \ q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v\
    \ int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n\
    \    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n \
    \   var g int\n    var h int\n    var i int\n    var j int\n    var k int\n  \
    \  var l int\n    var m int\n    var n int\n    var o int\n    var p int\n   \
    \ var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var\
    \ v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a\
    \ int\n    var b int\n    var c int\n    var d int\n    var e int\n", "    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n", "    var result string\n \
    \   var intersection []interface{}\n    \n    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n    \n    for i := 0; i < len(interval1); i++\
    \ {\n        intersection := []interface{}{interval1[i].([]interface{})[0], interval1[i].([]interface{})[1]}\n\
    \        \n        if intersect(intersection, interval2) {\n            result\
    \ = \"YES\"\n            break\n        }\n    }\n    \n    return result\n}\n",
  "    var result string\n    if len(interval1) != len(interval2) {\n        return\
    \ \"NO\"\n    }\n    \n    for i := 0; i < len(interval1); i++ {\n        if interval1[i].(float64)\
    \ <= interval2[i].(float64) {\n            result += fmt.Sprintf(\"%v\", interval1[i])\n\
    \        }\n    }\n    \n    if result == \"NO\" {\n        return \"NO\"\n  \
    \  }\n    \n    if result == \"YES\" {\n        return \"YES\"\n    }\n    \n\
    \    return \"NO\"\n}\n", "    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    interval1Start := interval1[0].(int)\n    interval1End\
    \ := interval1[1].(int)\n    interval2Start := interval2[0].(int)\n    interval2End\
    \ := interval2[1].(int)\n    \n    if interval1Start > interval2End {\n      \
    \  return \"NO\"\n    }\n    \n    if interval1End < interval2Start {\n      \
    \  return \"NO\"\n    }\n    \n    if interval1Start <= interval2Start && interval1End\
    \ >= interval2End {\n        return \"YES\"\n    }\n    \n    if interval1Start\
    \ <= interval2End && interval1End >= interval2Start {\n        return \"YES\"\n\
    \    }\n    \n    if interval1Start > interval2Start && interval1Start <= interval2End\
    \ {\n        return \"YES\"\n    }\n    \n    if interval1Start > interval2End\
    \ && interval1End <= interval2Start {\n        return \"YES\"\n    }\n    \n \
    \   if interval1Start <= interval2Start && interval1End > interval2End {\n   \
    \     return \"YES\"\n    }\n    \n    if interval1Start > interval2Start && interval1Start\
    \ <= interval2End {\n        return \"YES\"\n    }\n    \n    if interval1Start\
    \ > interval2End && interval1End <= interval2Start {\n        return \"YES\"\n\
    \    }\n    \n    if interval1Start <= interval2Start && interval1End > interval2End\
    \ {\n        return \"YES\"\n    }\n    \n    if interval1Start > interval2Start\
    \ && interval1Start <= interval2End {\n        return \"YES\"\n    }\n    \n \
    \   if interval1Start > interval2End && interval1End <= interval2Start {\n   \
    \     return \"YES\"\n    }\n    \n    if interval1Start <= interval2Start &&\
    \ interval1End > interval2End {\n        return \"YES\"\n    }\n    \n    if interval1Start\
    \ > interval2Start && interval1Start <= interval2End {\n        return \"YES\"\
    \n    }\n    \n    if interval1Start > interval2End && interval1End <= interval2Start\
    \ {\n        return \"YES\"\n    }\n    \n    if interval1Start <= interval2Start\
    \ && interval1End > interval2End {\n        return \"YES\"\n    }\n    \n    if\
    \ interval1Start > interval2Start && interval1Start <= interval2End {\n      \
    \  return \"YES\"\n    }\n    \n    if interval1Start > interval2End && interval1End\
    \ <= interval2Start {\n        return \"YES\"\n    }\n    \n    if interval",
  "    if len(interval1) != len(interval2) {\n        return \"NO\"\n    }\n    \n\
    \    interval1Start := interval1[0].(float64)\n    interval1End := interval1[1].(float64)\n\
    \    interval2Start := interval2[0].(float64)\n    interval2End := interval2[1].(float64)\n\
    \    \n    if interval1Start > interval1End {\n        interval1Start, interval1End\
    \ = interval1End, interval1Start\n    }\n    if interval2Start > interval2End\
    \ {\n        interval2Start, interval2End = interval2End, interval2Start\n   \
    \ }\n    \n    if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n        return \"YES\"\n    }\n    if interval1Start <= interval2End && interval1End\
    \ >= interval2Start {\n        return \"NO\"\n    }\n    if interval1Start >=\
    \ interval2Start && interval1End <= interval2End {\n        return \"NO\"\n  \
    \  }\n    if interval1Start >= interval2End && interval1End <= interval2Start\
    \ {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n", "    if len(interval1)\
    \ != len(interval2) {\n        return \"NO\"\n    }\n    \n    interval1Start\
    \ := interval1[0].(float64)\n    interval1End := interval1[1].(float64)\n    interval2Start\
    \ := interval2[0].(float64)\n    interval2End := interval2[1].(float64)\n    \n\
    \    if interval1Start > interval2End {\n        return \"NO\"\n    }\n    if\
    \ interval1End < interval2Start {\n        return \"NO\"\n    }\n    \n    intersectionStart\
    \ := interval1Start\n    intersectionEnd := interval1End\n    \n    for i := 1;\
    \ i < len(interval1); i++ {\n        interval1Start := interval1[i].(float64)\n\
    \        interval1End := interval1[i+1].(float64)\n        \n        if interval1Start\
    \ > interval2End {\n            return \"NO\"\n        }\n        if interval1End\
    \ < interval2Start {\n            return \"NO\"\n        }\n        \n       \
    \ if interval1Start <= intersectionEnd && interval1End >= intersectionStart {\n\
    \            intersectionEnd = interval1End\n        } else {\n            return\
    \ \"NO\"\n        }\n    }\n    \n    if intersectionEnd <= interval2End {\n \
    \       return \"NO\"\n    }\n    \n    if intersectionEnd >= interval2Start {\n\
    \        return \"NO\"\n    }\n    \n    if intersectionEnd >= interval1Start\
    \ && intersectionEnd <= interval1End {\n        return \"YES\"\n    }\n    \n\
    \    return \"NO\"\n}\n", "    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    result := make(map[int]bool)\n    for _, v :=\
    \ range interval1 {\n        result[v] = true\n    }\n    for _, v := range interval2\
    \ {\n        if _, ok := result[v]; !ok {\n            return \"NO\"\n       \
    \ }\n    }\n    \n    length := 0\n    for _, v := range result {\n        if\
    \ v {\n            length++\n        }\n    }\n    if length == 2 {\n        return\
    \ \"YES\"\n    }\n    return \"NO\"\n}\n", "    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n    \n    result := make([]interface{}, 0)\n\
    \    \n    for _, interval := range interval1 {\n        start = interval.([]interface{})[0].(int)\n\
    \        end = interval.([]interface{})[1].(int)\n        \n        if start >\
    \ end {\n            continue\n        }\n        \n        intersection := make([]interface{},\
    \ 0)\n        for _, interval2 := range interval2 {\n            start = interval2.([]interface{})[0].(int)\n\
    \            end = interval2.([]interface{})[1].(int)\n            \n        \
    \    if start > end {\n                continue\n            }\n            \n\
    \            if start <= end {\n                intersection = append(intersection,\
    \ []interface{}{start, end})\n            }\n        }\n        \n        if len(intersection)\
    \ == 0 {\n            continue\n        }\n        \n        intersection := intersection[0].([]interface{})\n\
    \        \n        if len(intersection) == 1 {\n            result = append(result,\
    \ []interface{}{start, end})\n            continue\n        }\n        \n    \
    \    intersection := intersection[1].([]interface{})\n        \n        if len(intersection)\
    \ == 1 {\n            result = append(result, []interface{}{start, end})\n   \
    \         continue\n        }\n        \n        intersection := intersection[0].([]interface{})\n\
    \        \n        if len(intersection) == 1 {\n            result = append(result,\
    \ []interface{}{start, end})\n            continue\n        }\n        \n    \
    \    intersection := intersection[1].([]interface{})\n        \n        if len(intersection)\
    \ == 1 {\n            result = append(result, []interface{}{start, end})\n   \
    \         continue\n        }\n        \n        intersection := intersection[0].([]interface{})\n\
    \        \n        if len(intersection) == 1 {\n            result = append(result,\
    \ []interface{}{start, end})\n            continue\n        }\n        \n    \
    \    intersection := intersection[1].([]interface{})\n        \n        if len(intersection)\
    \ == 1 {\n            result = append(result, []interface{}{start, end})\n   \
    \         continue\n        }\n        \n        intersection := intersection[0].([]interface{})\n\
    \        \n        if len(intersection) == 1 {\n            result = append(result,\
    \ []interface{}{start, end})\n            continue\n        }\n        \n    \
    \    intersection := intersection[1].([]interface{})\n        \n        if len(intersection)\
    \ == 1 {\n            result = append(result, []interface{}{start, end})\n   \
    \         continue\n        }\n        \n        intersection := intersection[0].([]interface{})\n\
    \        \n        if len(intersection) == 1 {\n            result = append(result,\
    \ []interface{}{start, end})\n            continue\n        }\n        \n    \
    \    intersection := intersection[1].([]interface{})\n        \n        if len(intersection)\
    \ == 1 {\n            result = append(result, []interface{}{start, end})\n   \
    \         continue\n        }\n        \n        intersection := intersection[0].([]interface{})"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
