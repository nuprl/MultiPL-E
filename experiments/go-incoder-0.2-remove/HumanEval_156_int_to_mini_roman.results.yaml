language: go_test.go
name: HumanEval_156_int_to_mini_roman
results:
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    var roman = make([]string, 1000)\n\
    \    var i int\n    for i = 1; i <= 1000; i++ {\n        roman[i] = fmt.Sprintf(\"\
    %v\", number%i)\n        number /= i\n    }\n    return roman[number]\n}\n\nfunc\
    \ TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\npanic: runtime error: index out\
    \ of range [1000] with length 1000 [recovered]\n\tpanic: runtime error: index\
    \ out of range [1000] with length 1000\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x513640,\
    \ 0xc00016a000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513640, 0xc00016a000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.int_to_mini_roman(0x13?)\n\t/tmp/tmpfsv5rumj_test.go:16\
    \ +0x113\ncommand-line-arguments_test.TestInt_To_Mini_Roman(0x0?)\n\t/tmp/tmpfsv5rumj_test.go:29\
    \ +0x46\ntesting.tRunner(0xc000103380, 0x528f98)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075729
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := []string{\n       \
    \ \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"\
    X\", \"XI\", \"XII\",\n        \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"\
    XVIII\", \"XIX\", \"XX\", \"XXI\", \"XXII\",\n        \"XXIII\", \"XXIV\", \"\
    XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\",\n       \
    \ \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\"\
    , \"XXXIX\",\n        \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"LXXXX\", \"\
    LXXXXX\", \"LXXXXXX\", \"LXXXXXXX\",\n        \"LXXXXXV\", \"LXXXXXVI\", \"LXXXXXVII\"\
    , \"LXXXXXVIII\", \"LXXXXXIX\", \"LXXX\", \"LXXXI\",\n        \"LXXXII\", \"LXXXIII\"\
    , \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\",\n\
    \        \"LXL\", \"LX\", \"LXX\", \"LXXX\", \"LXXXX\", \"LXXXXX\", \"LXXXXXX\"\
    , \"LXXXXXXX\", \"LXXXXXV\",\n        \"LXXXXXVI\", \"LXXXXXVII\", \"LXXXXXVIII\"\
    , \"LXXXXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\",\n        \"LXXXIII\", \"LXXXIV\"\
    , \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\", \"LXL\",\n   \
    \     \"LX\", \"LXX\", \"LXXX\", \"LXXXX\", \"LXXXXX\", \"LXXXXXX\", \"LXXXXXXX\"\
    , \"LXXXXXV\",\n        \"LXXXXXVI\", \"LXXXXXVII\", \"LXXXXXVIII\", \"LXXXXXIX\"\
    , \"LXXX\", \"LXXXI\", \"LXXXII\",\n        \"LXXXIII\", \"LXXXIV\", \"LXXXV\"\
    , \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\", \"LXL\",\n        \"LX\"\
    , \"LXX\", \"LXXX\", \"LXXXX\", \"LXXXXX\", \"LXXXXXX\", \"LXXXXXXX\", \"LXXXXXV\"\
    ,\n        \"LXXXXXVI\", \"LXXXXXVII\", \"LXXXXXVII\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpeyvi_86t_test.go:28:34: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075728
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := []string{\"I\", \"\
    II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\"\
    , \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"\
    XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"\
    XXVIII\", \"XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\"\
    , \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\", \"L\", \"LI\", \"LX\"\
    , \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\"\
    , \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"\
    LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\",\
    \ \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"\
    LXXXIX\", \"XC\", \"C\", \"CI\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\"\
    , \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\", \"CXXI\", \"CXXII\"\
    , \"CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"CXXVII\", \"CXXVIII\", \"CXXIX\"\
    , \"CXXX\", \"CXXXI\", \"CXXXII\", \"CXXXIII\", \"CXXXIV\", \"CXXXV\", \"CXXXVI\"\
    , \"CXXXVII\", \"CXXXVIII\", \"CXXXIX\", \"CC\", \"CCI\", \"CCX\", \"CCXI\", \"\
    CCXII\", \"CCXIII\", \"CCXIV\", \"CCXV\", \"CCXVI\", \"CCXVII\", \"CCXVIII\",\
    \ \"CCXIX\", \"CCH\", \"CCHI\", \"CCHX\", \"CCHXI\", \"CCHXII\", \"CCHXIII\",\
    \ \"CCHXIV\", \"CCHXV\", \"CCHXVI\", \"CCHXVII\", \"CCHXVIII\", \"CCHXIX\", \"\
    CCCX\", \"CCCXI\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp424h0ava_test.go:13:1120: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075728
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := []string{\"I\", \"\
    II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\"\
    , \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"\
    XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"\
    XXVIII\", \"XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\"\
    , \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\", \"L\", \"LI\", \"LII\"\
    , \"LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\", \"LIX\", \"LX\", \"\
    LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\"\
    , \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"\
    LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\",\
    \ \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"\
    LXXXIX\", \"XC\", \"C\", \"CI\", \"CII\", \"CIV\", \"CV\", \"CVI\", \"CVII\",\
    \ \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"CXV\"\
    , \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\", \"CXXI\", \"CXXII\", \"\
    CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"CXXVII\", \"CXXVIII\", \"CXXIX\",\
    \ \"CXXX\", \"CXXXI\", \"CXXXII\", \"CXXXIII\", \"CXXXIV\", \"CXXXV\", \"CXXXVI\"\
    , \"CXXXVII\", \"CXXXVIII\", \"CXXXIX\", \"CXL\", \"CL\", \"LI\", \"LII\", \"\
    LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\", \"LIX\", \"LX\", \"LXI\"\
    , \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVII\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpewshv08s_test.go:13:1144: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075728
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_numerals := map[int]string{\n\
    \        1: \"I\",\n        5: \"V\",\n        10: \"X\",\n        50: \"L\",\n\
    \        100: \"C\",\n        500: \"D\",\n        1000: \"M\",\n    }\n    result\
    \ := \"\"\n    for num, _ := range roman_numerals {\n        if number >= num\
    \ {\n            result += roman_numerals[num]\n            number -= num\n  \
    \      }\n    }\n    return strings.ToLower(result)\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpano5q2fe_test.go:29:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075729
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := map[int]string{\n \
    \       1: \"I\",\n        5: \"V\",\n        10: \"X\",\n        50: \"L\",\n\
    \        100: \"C\",\n        500: \"D\",\n        1000: \"M\",\n    }\n    roman,\
    \ ok := romans[number]\n    if !ok {\n        fmt.Println(\"Invalid input\")\n\
    \    }\n    return roman\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Invalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid input\n\
    Invalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid\
    \ input\n--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmpcwfbu4ek_test.go:55: expected 'xix', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpcwfbu4ek_test.go:55: expected\
    \ 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n  \
    \      tmpcwfbu4ek_test.go:55: expected 'ccli', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmpcwfbu4ek_test.go:55: expected 'cdxxvi', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpcwfbu4ek_test.go:55:\
    \ expected 'd', got 'D'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n\
    \        tmpcwfbu4ek_test.go:55: expected 'i', got 'I'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6\
    \ (0.00s)\n        tmpcwfbu4ek_test.go:55: expected 'iv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmpcwfbu4ek_test.go:55: expected\
    \ 'xliii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n \
    \       tmpcwfbu4ek_test.go:55: expected 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9\
    \ (0.00s)\n        tmpcwfbu4ek_test.go:55: expected 'xciv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmpcwfbu4ek_test.go:55:\
    \ expected 'dxxxii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11\
    \ (0.00s)\n        tmpcwfbu4ek_test.go:55: expected 'cm', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpcwfbu4ek_test.go:55:\
    \ expected 'cmxciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmpcwfbu4ek_test.go:55: expected 'm', got 'M'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075729
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_num := make([]string, 1000)\n\
    \    roman_num[0] = \"\"\n    roman_num[1] = \"I\"\n    roman_num[2] = \"II\"\n\
    \    roman_num[3] = \"III\"\n    roman_num[4] = \"IV\"\n    roman_num[5] = \"\
    V\"\n    roman_num[6] = \"VI\"\n    roman_num[7] = \"VII\"\n    roman_num[8] =\
    \ \"VIII\"\n    roman_num[9] = \"IX\"\n    roman_num[10] = \"X\"\n    roman_num[11]\
    \ = \"XI\"\n    roman_num[12] = \"XII\"\n    roman_num[13] = \"XIII\"\n    roman_num[14]\
    \ = \"XIV\"\n    roman_num[15] = \"XV\"\n    roman_num[16] = \"XVI\"\n    roman_num[17]\
    \ = \"XVII\"\n    roman_num[18] = \"XVIII\"\n    roman_num[19] = \"XIX\"\n   \
    \ roman_num[20] = \"XX\"\n    roman_num[21] = \"XXI\"\n    roman_num[22] = \"\
    XXII\"\n    roman_num[23] = \"XXIII\"\n    roman_num[24] = \"XXIV\"\n    roman_num[25]\
    \ = \"XXV\"\n    roman_num[26] = \"XXVI\"\n    roman_num[27] = \"XXVII\"\n   \
    \ roman_num[28] = \"XXVIII\"\n    roman_num[29] = \"XXIX\"\n    roman_num[30]\
    \ = \"XXX\"\n    roman_num[31] = \"XXXI\"\n    roman_num[32] = \"XXXII\"\n   \
    \ roman_num[33] = \"XXXIII\"\n    roman_num[34] = \"XXXIV\"\n    roman_num[35]\
    \ = \"XXXV\"\n    roman_num[36] = \"XXXVI\"\n    roman_num[37] = \"XXXVII\"\n\
    \    roman_num[38] = \"XXXVIII\"\n    roman_num[39] = \"XXXIX\"\n    roman_num[40]\
    \ = \"XL\"\n    roman_num[41] = \"L\"\n    roman_num[42] = \"LX\"\n    roman_num[43]\
    \ = \"LXX\"\n    roman_num[44] = \"LXXX\"\n    roman_num[45] = \"LXXXX\"\n   \
    \ roman_num[\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphzo46ygg_test.go:61:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075728
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_numerals := []string{\"\
    I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\"\
    , \"XI\", \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"\
    XIX\", \"XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\"\
    , \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"\
    XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\", \"L\", \"LI\",\
    \ \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\"\
    , \"LXVIII\", \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"\
    LXXV\", \"LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"\
    LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\"\
    , \"LXXXIX\", \"XC\", \"C\", \"CI\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"\
    CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\", \"CXXI\"\
    , \"CXXII\", \"CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"CXXVII\", \"CXXVIII\"\
    , \"CXXIX\", \"CXXX\", \"CXXXI\", \"CXXXII\", \"CXXXIII\", \"CXXXIV\", \"CXXXV\"\
    , \"CXXXVI\", \"CXXXVII\", \"CXXXVIII\", \"CXXXIX\", \"CXL\", \"CL\", \"CLI\"\
    , \"CLX\", \"CLXI\", \"CLXII\", \"CLXIII\", \"CLXIV\", \"CLXV\", \"CLXVI\", \"\
    CLXVII\", \"CLXVIII\", \"CLXIX\", \"CLXX\", \"CLXXI\", \"CLXXII\", \"CLXXIII\"\
    , \"CLXXIV\", \"CLXXV\", \"CLXXVI\", \"CLXXVII\", \"CLXXVIII\", \"CLXXIX\", \"\
    CLXXX\", \"CLXXXI\", \"CLXXXII\", \"CLXXXIII\", \"CLXXX\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphcop623z_test.go:13:1154: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075728
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_numerals := map[int]string{\n\
    \        1: \"I\",\n        5: \"V\",\n        10: \"X\",\n        50: \"L\",\n\
    \        100: \"C\",\n        500: \"D\",\n        1000: \"M\",\n    }\n    result\
    \ := \"\"\n    for num, _ := range roman_numerals {\n        if number >= num\
    \ {\n            result += roman_numerals[num]\n            number -= num\n  \
    \      }\n    }\n    if number > 0 {\n        result += roman_numerals[number]\n\
    \    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n \
    \ candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmpoo0gzi3p_test.go:61: expected 'xix', got 'IVX'\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpoo0gzi3p_test.go:61:\
    \ expected 'clii', got 'LCII'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2\
    \ (0.00s)\n        tmpoo0gzi3p_test.go:61: expected 'ccli', got 'IVXLC'\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmpoo0gzi3p_test.go:61:\
    \ expected 'cdxxvi', got 'IVXLC'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4\
    \ (0.00s)\n        tmpoo0gzi3p_test.go:61: expected 'd', got 'D'\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmpoo0gzi3p_test.go:61: expected\
    \ 'i', got 'I'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n    \
    \    tmpoo0gzi3p_test.go:61: expected 'iv', got 'I'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7\
    \ (0.00s)\n        tmpoo0gzi3p_test.go:61: expected 'xliii', got 'IVX'\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmpoo0gzi3p_test.go:61:\
    \ expected 'xc', got 'XLIV'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n\
    \        tmpoo0gzi3p_test.go:61: expected 'xciv', got 'IVXL'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10\
    \ (0.00s)\n        tmpoo0gzi3p_test.go:61: expected 'dxxxii', got 'CIVXL'\n  \
    \  --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmpoo0gzi3p_test.go:61:\
    \ expected 'cm', got 'DIVXLC'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12\
    \ (0.00s)\n        tmpoo0gzi3p_test.go:61: expected 'cmxciv', got 'CDIVXL'\n \
    \   --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmpoo0gzi3p_test.go:61:\
    \ expected 'm', got 'IVXLCD'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075729
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := []string{\"I\", \"\
    II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\"\
    , \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"\
    XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"\
    XXVIII\", \"XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\"\
    , \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\", \"L\", \"LI\", \"LXI\"\
    , \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\", \"\
    LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\"\
    , \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\"\
    , \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\", \"\
    XC\", \"C\", \"CI\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\"\
    , \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\", \"CXXI\", \"CXXII\", \"CXXIII\", \"\
    CXXIV\", \"CXXV\", \"CXXVI\", \"CXXVII\", \"CXXVIII\", \"CXXIX\", \"CXXX\", \"\
    CXXXI\", \"CXXXII\", \"CXXXIII\", \"CXXXIV\", \"CXXXV\", \"CXXXVI\", \"CXXXVII\"\
    , \"CXXXVIII\", \"CXXXIX\", \"CC\", \"CCI\", \"CCXI\", \"CCXII\", \"CCXIII\",\
    \ \"CCXIV\", \"CCXV\", \"CCXVI\", \"CCXVII\", \"CCXVIII\", \"CCXIX\", \"CCH\"\
    , \"CCHI\", \"CCHII\", \"CCHIII\", \"CCHIV\", \"CCHV\", \"CCHVI\", \"CCHVII\"\
    , \"CCHVIII\", \"CCHIX\", \"CCC\", \"CCCI\", \"CCCIX\", \"CCCX\", \"CCCXI\", \"\
    CCCXII\", \"CCCXIII\", \"CCCXIV\", \"\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpw_qp17mp_test.go:13:1140: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075728
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000\
    \ {\n        fmt.Println(\"Invalid input\")\n    }\n    roman_numerals := []string{\"\
    I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\"\
    , \"XI\", \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"\
    XIX\", \"XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\"\
    , \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"\
    XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\", \"L\", \"LI\",\
    \ \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\", \"LIX\", \"\
    LX\", \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"\
    LXVIII\", \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\"\
    , \"LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\"\
    , \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"\
    LXXXIX\", \"XC\", \"C\", \"CI\", \"CII\", \"CIV\", \"CV\", \"CVI\", \"CVII\",\
    \ \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"CXV\"\
    , \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\", \"CXXI\", \"CXXII\", \"\
    CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"CXXVII\", \"CXXVIII\", \"CXXIX\",\
    \ \"CXXX\", \"CXXXI\", \"CXXXII\", \"CXXXIII\", \"CXXXIV\", \"CXXXV\", \"CXXXVI\"\
    , \"CXXXVII\", \"CXXXVIII\", \"CXXXIX\", \"CC\", \"CCI\", \"CCII\", \"CCIII\"\
    , \"CCIV\", \"CV\", \"CVI\", \"CVII\", \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"\
    CXII\", \"CXIII\", \"CXIV\", \"CX\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n\
    \  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7l8znfp6_test.go:16:1125: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075728
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := map[int]string{\n \
    \       1: \"I\",\n        5: \"V\",\n        10: \"X\",\n        50: \"L\",\n\
    \        100: \"C\",\n        500: \"D\",\n        1000: \"M\",\n    }\n    roman_number\
    \ := \"\"\n    for num, _ := range romans {\n        if number >= num {\n    \
    \        roman_number = romans[num]\n            break\n        }\n    }\n   \
    \ return strings.ToLower(roman_number)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5rouh6cd_test.go:29:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075729
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_numerals := map[int]string{\n\
    \        1: \"I\",\n        5: \"V\",\n        10: \"X\",\n        50: \"L\",\n\
    \        100: \"C\",\n        500: \"D\",\n        1000: \"M\",\n    }\n\n   \
    \ roman_numeral := \"\"\n    for _, numeral := range roman_numerals {\n      \
    \  if number >= numeral {\n            roman_numeral += numeral\n            number\
    \ -= numeral\n        }\n    }\n\n    return roman_numeral\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpv7l7kwpk_test.go:25:22: invalid operation: number >= numeral (mismatched
    types int and string)

    /tmp/tmpv7l7kwpk_test.go:27:13: invalid operation: number -= numeral (mismatched
    types int and string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075729
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    var roman = \"\"\n    switch\
    \ number {\n    case 1:\n        roman = \"I\"\n    case 2:\n        roman = \"\
    II\"\n    case 3:\n        roman = \"III\"\n    case 4:\n        roman = \"IV\"\
    \n    case 5:\n        roman = \"V\"\n    case 6:\n        roman = \"VI\"\n  \
    \  case 7:\n        roman = \"VII\"\n    case 8:\n        roman = \"VIII\"\n \
    \   case 9:\n        roman = \"IX\"\n    case 10:\n        roman = \"X\"\n   \
    \ case 11:\n        roman = \"XI\"\n    case 12:\n        roman = \"XII\"\n  \
    \  case 13:\n        roman = \"XIII\"\n    case 14:\n        roman = \"XIV\"\n\
    \    case 15:\n        roman = \"XV\"\n    case 16:\n        roman = \"XVI\"\n\
    \    case 17:\n        roman = \"XVII\"\n    case 18:\n        roman = \"XVIII\"\
    \n    case 19:\n        roman = \"XIX\"\n    case 20:\n        roman = \"XX\"\n\
    \    case 21:\n        roman = \"XXI\"\n    case 22:\n        roman = \"XXII\"\
    \n    case 23:\n        roman = \"XXIII\"\n    case 24:\n        roman = \"XXIV\"\
    \n    case 25:\n        roman = \"XXV\"\n    case 26:\n        roman = \"XXVI\"\
    \n    case 27:\n        roman = \"XXVII\"\n    case 28:\n        roman = \"XXVIII\"\
    \n    case 29:\n        roman = \"XXIX\"\n    case 30:\n        roman = \"XXX\"\
    \n    case 31:\n        roman = \"XXXI\"\n    case 32:\n        roman = \"XXXII\"\
    \n    case 33:\n        roman = \"XXXIII\"\n    case 34:\n        roman = \"XXXIV\"\
    \n    case 35:\n        roman = \"XXXV\"\n    case 36:\n        roman = \"XXXVI\"\
    \n    case 37:\n        roman = \"XXXVII\"\n    case 38:\n        roman = \"XXXVIII\"\
    \n    case 39:\n        roman = \"XXXIX\"\n    case 40:\n        roman = \"XL\"\
    \n    case 41:\n        roman = \"L\"\n    case 42:\n        roman = \"LX\"\n\
    \    case 43:\n        roman = \"LXX\"\n    case 44:\n        ro\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpic9_3wzl_test.go:103:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075728
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romanNumerals := []string{\n\
    \        \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"\
    IX\", \"X\", \"XI\", \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"\
    XVIII\", \"XIX\", \"XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"\
    XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\"\
    , \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\",\
    \ \"L\", \"LI\", \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\"\
    , \"LIX\", \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\",\
    \ \"LXVII\", \"LXVIII\", \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"\
    LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"\
    LXXXI\", \"LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\"\
    , \"LXXXVIII\", \"LXXXIX\", \"XC\", \"C\", \"CI\", \"CII\", \"CIV\", \"CV\", \"\
    CVI\", \"CVII\", \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"\
    CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\", \"CXXI\"\
    , \"CXXII\", \"CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"CXXVII\", \"CXXVIII\"\
    , \"CXXIX\", \"CXXX\", \"CXXXI\", \"CXXXII\", \"CXXXIII\", \"CXXXIV\", \"CXXXV\"\
    , \"CXXXVI\", \"CXXXVII\", \"CXXXVIII\", \"CXXXIX\", \"CXL\", \"CL\", \"LI\",\
    \ \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\", \"LIX\", \"\
    LX\", \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"\
    \nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpb2h7acg3_test.go:14:1129: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075728
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := []string{\n       \
    \ \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"\
    X\", \"XI\", \"XII\", \"XIII\",\n        \"C\", \"CC\", \"CCC\", \"CD\", \"D\"\
    , \"DC\", \"DCC\", \"DCCC\", \"CM\", \"M\", \"MM\", \"MMM\",\n    }\n    roman_number\
    \ := 0\n    for number > 0 {\n        roman_number = roman_number * 10 + romans[number%10]\n\
    \        number /= 10\n    }\n    return string(roman_number)\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmk4c2dz0_test.go:19:24: invalid operation: roman_number * 10 + romans[number
    % 10] (mismatched types int and string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075729
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_num := \"\"\n    switch\
    \ number {\n    case 1:\n        roman_num = \"I\"\n    case 2:\n        roman_num\
    \ = \"II\"\n    case 3:\n        roman_num = \"III\"\n    case 4:\n        roman_num\
    \ = \"IV\"\n    case 5:\n        roman_num = \"V\"\n    case 6:\n        roman_num\
    \ = \"VI\"\n    case 7:\n        roman_num = \"VII\"\n    case 8:\n        roman_num\
    \ = \"VIII\"\n    case 9:\n        roman_num = \"IX\"\n    case 10:\n        roman_num\
    \ = \"X\"\n    case 11:\n        roman_num = \"XI\"\n    case 12:\n        roman_num\
    \ = \"XII\"\n    case 13:\n        roman_num = \"XIII\"\n    case 14:\n      \
    \  roman_num = \"XIV\"\n    case 15:\n        roman_num = \"XV\"\n    case 16:\n\
    \        roman_num = \"XVI\"\n    case 17:\n        roman_num = \"XVII\"\n   \
    \ case 18:\n        roman_num = \"XVIII\"\n    case 19:\n        roman_num = \"\
    XIX\"\n    case 20:\n        roman_num = \"XX\"\n    case 21:\n        roman_num\
    \ = \"XXI\"\n    case 22:\n        roman_num = \"XXII\"\n    case 23:\n      \
    \  roman_num = \"XXIII\"\n    case 24:\n        roman_num = \"XXIV\"\n    case\
    \ 25:\n        roman_num = \"XXV\"\n    case 26:\n        roman_num = \"XXVI\"\
    \n    case 27:\n        roman_num = \"XXVII\"\n    case 28:\n        roman_num\
    \ = \"XXVIII\"\n    case 29:\n        roman_num = \"XXIX\"\n    case 30:\n   \
    \     roman_num = \"XXX\"\n    case 31:\n        roman_num = \"XXXI\"\n    case\
    \ 32:\n        roman_num = \"XXXII\"\n    case 33:\n        roman_num = \"XXXIII\"\
    \n    case 34:\n        roman_num = \"XXXIV\"\n    case 35:\n        roman_num\
    \ = \"XXXV\"\n    case 36:\n        roman_num = \"XXXVI\"\n    case 37:\n    \
    \    roman_num = \"XXXVII\"\n    case 38:\n        roman_num = \"XXXVIII\"\n \
    \   case 39:\n        roman_num = \"XXXIX\"\n    case 40:\n        roman_num =\
    \ \"XL\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8xvbo_2c_test.go:95:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075728
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_number := \"\"\n    switch\
    \ number {\n    case 1:\n        roman_number = \"I\"\n    case 2:\n        roman_number\
    \ = \"II\"\n    case 3:\n        roman_number = \"III\"\n    case 4:\n       \
    \ roman_number = \"IV\"\n    case 5:\n        roman_number = \"V\"\n    case 6:\n\
    \        roman_number = \"VI\"\n    case 7:\n        roman_number = \"VII\"\n\
    \    case 8:\n        roman_number = \"VIII\"\n    case 9:\n        roman_number\
    \ = \"IX\"\n    case 10:\n        roman_number = \"X\"\n    case 11:\n       \
    \ roman_number = \"XI\"\n    case 12:\n        roman_number = \"XII\"\n    case\
    \ 13:\n        roman_number = \"XIII\"\n    case 14:\n        roman_number = \"\
    XIV\"\n    case 15:\n        roman_number = \"XV\"\n    case 16:\n        roman_number\
    \ = \"XVI\"\n    case 17:\n        roman_number = \"XVII\"\n    case 18:\n   \
    \     roman_number = \"XVIII\"\n    case 19:\n        roman_number = \"XIX\"\n\
    \    case 20:\n        roman_number = \"XX\"\n    case 21:\n        roman_number\
    \ = \"XXI\"\n    case 22:\n        roman_number = \"XXII\"\n    case 23:\n   \
    \     roman_number = \"XXIII\"\n    case 24:\n        roman_number = \"XXIV\"\n\
    \    case 25:\n        roman_number = \"XXV\"\n    case 26:\n        roman_number\
    \ = \"XXVI\"\n    case 27:\n        roman_number = \"XXVII\"\n    case 28:\n \
    \       roman_number = \"XXVIII\"\n    case 29:\n        roman_number = \"XXIX\"\
    \n    case 30:\n        roman_number = \"XXX\"\n    case 31:\n        roman_number\
    \ = \"XXXI\"\n    case 32:\n        roman_number = \"XXXII\"\n    case 33:\n \
    \       roman_number = \"XXXIII\"\n    case 34:\n        roman_number = \"XXXIV\"\
    \n    case 35:\n        roman_number = \"XXXV\"\n    case 36:\n        roman_number\
    \ = \"XXXVI\"\n    case 37:\n        roman_number = \"XXXVII\"\n    case 38:\n\
    \        roman_number = \"XXXVIII\"\n    case 39:\n        roman_number = \"XXXIX\"\
    \n    case 40:\n        roman_number = \"XL\"\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7aj4t2nh_test.go:95:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075728
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_numerals := []string{\n\
    \        \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"\
    IX\", \"X\", \"XI\", \"XII\", \"XIII\",\n        \"XIV\", \"XV\", \"XVI\", \"\
    XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\",\n\
    \        \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\"\
    , \"XXXII\", \"XXXIII\", \"XXXIV\",\n        \"XXXV\", \"XXXVI\", \"XXXVII\",\
    \ \"XXXVIII\", \"XXXIX\", \"XL\", \"L\", \"LI\", \"LXI\", \"LXII\", \"LXIII\"\
    ,\n        \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\", \"LXIX\", \"LXX\"\
    , \"LXXI\", \"LXXII\", \"LXXIII\",\n        \"LXXIV\", \"LXXV\", \"LXXVI\", \"\
    LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\",\n        \"\
    LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\"\
    , \"XC\", \"C\", \"CI\",\n        \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"CXV\"\
    , \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\", \"CXXI\",\n        \"CXXII\"\
    , \"CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"CXXVII\", \"CXXVIII\", \"CXXIX\"\
    , \"CXXX\",\n        \"CXXXI\", \"CXXXII\", \"CXXXIII\", \"CXXXIV\", \"CXXXV\"\
    , \"CXXXVI\", \"CXXXVII\", \"CXXXVIII\", \"CXXXIX\",\n        \"CC\", \"CCI\"\
    , \"CCXI\", \"CCXII\", \"CCXIII\", \"CCXIV\", \"CCXV\", \"CCXVI\", \"CCXVII\"\
    , \"CCXVIII\",\n        \"CCXIX\", \"CCC\", \"CCCI\", \"CCCXI\", \"CCCXII\", \"\
    CCCXIII\", \"CCCXIV\", \"CCCXV\", \"CCCXVI\",\n        \"CCCXVII\", \"CCCXVIII\"\
    , \"CCCX\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpk9fuoujn_test.go:26:32: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075728
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := []string{\n       \
    \ \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"\
    X\", \"XI\", \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\"\
    , \"XIX\", \"XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\",\
    \ \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"\
    XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\", \"L\"\
    , \"LI\", \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\", \"\
    LX\", \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"\
    LXVIII\", \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\"\
    , \"LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\"\
    , \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"\
    LXXXIX\", \"XC\", \"C\", \"CI\", \"CII\", \"CIV\", \"CV\", \"CVI\", \"CVII\",\
    \ \"CVIII\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\"\
    , \"CXVII\", \"CXVIII\", \"CXIX\", \"CC\", \"CCI\", \"CCII\", \"CCIII\", \"CCIV\"\
    , \"CCV\", \"CCVI\", \"CCVII\", \"CCVIII\", \"CCIX\", \"CD\", \"CD\", \"CDI\"\
    , \"CDII\", \"CDIII\", \"CDIIII\", \"CDIIV\", \"CDIV\", \"CDIVI\", \"CDIVII\"\
    , \"CDIVIII\", \"CDIVIV\", \"CDIVV\", \"CDIVVI\", \"CDIVVII\", \"CDIVVIII\", \"\
    CDIIX\", \"CM\", \"CMI\", \"CMII\", \"CMIII\", \"CMIV\", \"CMV\", \"CMVI\", \"\
    CMVII\", \"CMVIII\", \"CMIX\", \"XM\", \"XM\", \"XMI\", \"XMII\", \"XMII\", \"\
    XMIII\", \"X\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpudkstcjs_test.go:14:1143: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075728
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_number := \"\"\n    switch\
    \ number {\n    case 1:\n        roman_number = \"I\"\n    case 2:\n        roman_number\
    \ = \"II\"\n    case 3:\n        roman_number = \"III\"\n    case 4:\n       \
    \ roman_number = \"IV\"\n    case 5:\n        roman_number = \"V\"\n    case 6:\n\
    \        roman_number = \"VI\"\n    case 7:\n        roman_number = \"VII\"\n\
    \    case 8:\n        roman_number = \"VIII\"\n    case 9:\n        roman_number\
    \ = \"IX\"\n    case 10:\n        roman_number = \"X\"\n    case 11:\n       \
    \ roman_number = \"XI\"\n    case 12:\n        roman_number = \"XII\"\n    case\
    \ 13:\n        roman_number = \"XIII\"\n    case 14:\n        roman_number = \"\
    XIV\"\n    case 15:\n        roman_number = \"XV\"\n    case 16:\n        roman_number\
    \ = \"XVI\"\n    case 17:\n        roman_number = \"XVII\"\n    case 18:\n   \
    \     roman_number = \"XVIII\"\n    case 19:\n        roman_number = \"XIX\"\n\
    \    case 20:\n        roman_number = \"XX\"\n    case 21:\n        roman_number\
    \ = \"XXI\"\n    case 22:\n        roman_number = \"XXII\"\n    case 23:\n   \
    \     roman_number = \"XXIII\"\n    case 24:\n        roman_number = \"XXIV\"\n\
    \    case 25:\n        roman_number = \"XXV\"\n    case 26:\n        roman_number\
    \ = \"XXVI\"\n    case 27:\n        roman_number = \"XXVII\"\n    case 28:\n \
    \       roman_number = \"XXVIII\"\n    case 29:\n        roman_number = \"XXIX\"\
    \n    case 30:\n        roman_number = \"XXX\"\n    case 31:\n        roman_number\
    \ = \"XXXI\"\n    case 32:\n        roman_number = \"XXXII\"\n    case 33:\n \
    \       roman_number = \"XXXIII\"\n    case 34:\n        roman_number = \"XXXIV\"\
    \n    case 35:\n        roman_number = \"XXXV\"\n    case 36:\n        roman_number\
    \ = \"XXXVI\"\n    case 37:\n        roman_number = \"XXXVII\"\n    case 38:\n\
    \        roman_number = \"XXXVIII\"\n    case 39:\n        roman_number = \"XXXIX\"\
    \n    case 40:\n        roman_number = \"XL\"\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7aj4t2nh_test.go:95:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075728
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_number := \"\"\n    switch\
    \ number {\n    case 1:\n        roman_number = \"I\"\n    case 2:\n        roman_number\
    \ = \"II\"\n    case 3:\n        roman_number = \"III\"\n    case 4:\n       \
    \ roman_number = \"IV\"\n    case 5:\n        roman_number = \"V\"\n    case 6:\n\
    \        roman_number = \"VI\"\n    case 7:\n        roman_number = \"VII\"\n\
    \    case 8:\n        roman_number = \"VIII\"\n    case 9:\n        roman_number\
    \ = \"IX\"\n    case 10:\n        roman_number = \"X\"\n    case 11:\n       \
    \ roman_number = \"XI\"\n    case 12:\n        roman_number = \"XII\"\n    case\
    \ 13:\n        roman_number = \"XIII\"\n    case 14:\n        roman_number = \"\
    XIV\"\n    case 15:\n        roman_number = \"XV\"\n    case 16:\n        roman_number\
    \ = \"XVI\"\n    case 17:\n        roman_number = \"XVII\"\n    case 18:\n   \
    \     roman_number = \"XVIII\"\n    case 19:\n        roman_number = \"XIX\"\n\
    \    case 20:\n        roman_number = \"XX\"\n    case 21:\n        roman_number\
    \ = \"XXI\"\n    case 22:\n        roman_number = \"XXII\"\n    case 23:\n   \
    \     roman_number = \"XXIII\"\n    case 24:\n        roman_number = \"XXIV\"\n\
    \    case 25:\n        roman_number = \"XXV\"\n    case 26:\n        roman_number\
    \ = \"XXVI\"\n    case 27:\n        roman_number = \"XXVII\"\n    case 28:\n \
    \       roman_number = \"XXVIII\"\n    case 29:\n        roman_number = \"XXIX\"\
    \n    case 30:\n        roman_number = \"XXX\"\n    case 31:\n        roman_number\
    \ = \"XXXI\"\n    case 32:\n        roman_number = \"XXXII\"\n    case 33:\n \
    \       roman_number = \"XXXIII\"\n    case 34:\n        roman_number = \"XXXIV\"\
    \n    case 35:\n        roman_number = \"XXXV\"\n    case 36:\n        roman_number\
    \ = \"XXXVI\"\n    case 37:\n        roman_number = \"XXXVII\"\n    case 38:\n\
    \        roman_number = \"XXXVIII\"\n    case 39:\n        roman_number = \"XXXIX\"\
    \n    case 40:\n        roman_number = \"XL\"\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7aj4t2nh_test.go:95:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075728
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_numerals := []string{\n\
    \        \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"\
    IX\", \"X\", \"XI\", \"XII\",\n        \"XIII\", \"XIV\", \"XV\", \"XVI\", \"\
    XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\", \"XXII\",\n        \"XXIII\", \"\
    XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\"\
    ,\n        \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\",\
    \ \"XXXVIII\", \"XXXIX\",\n        \"XL\", \"L\", \"LI\", \"LII\", \"LII\", \"\
    LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\",\n        \"LIX\", \"LX\"\
    , \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\"\
    ,\n        \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\"\
    , \"LXXVI\", \"LXXVII\",\n        \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\"\
    , \"LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\",\n        \"LXXXVI\", \"LXXXVII\"\
    , \"LXXXVIII\", \"LXXXIX\", \"XC\", \"C\", \"CI\", \"CII\", \"CII\",\n       \
    \ \"CIII\", \"CIV\", \"CV\", \"CVI\", \"CVII\", \"CVIII\", \"CIX\", \"CX\", \"\
    CXI\", \"CXII\",\n        \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"\
    CXVIII\", \"CXIX\", \"CXX\", \"CXXI\",\n        \"CXXII\", \"CXXIII\", \"CXXIV\"\
    , \"CXXV\", \"CXXVI\", \"CXXVII\", \"CXXVIII\", \"CXXIX\",\n        \"CXXX\",\
    \ \"CXXXI\", \"CXXXII\", \"CXXXIII\", \"CXXXIV\", \"CXXXV\", \"CXXXVI\", \"CXXXVII\"\
    ,\n        \"CXXXVIII\", \"CXXXIX\", \"CC\", \"CCI\", \"CCII\", \"CCIII\", \"\
    CCIV\", \"CIV\", \"CV\",\n        \"CVI\", \"CVII\", \"\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5z4623vn_test.go:28:24: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075728
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_numerals := []string{\n\
    \        \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"\
    IX\", \"X\", \"XI\", \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"\
    XVIII\", \"XIX\", \"XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"\
    XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\"\
    , \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\",\
    \ \"L\", \"LI\", \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\"\
    , \"LIX\", \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\",\
    \ \"LXVII\", \"LXVIII\", \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"\
    LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"\
    LXXXI\", \"LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\"\
    , \"LXXXVIII\", \"LXXXIX\", \"XC\", \"C\", \"CI\", \"CII\", \"CIV\", \"CV\", \"\
    CVI\", \"CVII\", \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"\
    CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CC\", \"CCI\", \"\
    CCII\", \"CCIII\", \"CCIV\", \"CCV\", \"CCVI\", \"CCVII\", \"CCVIII\", \"CCIX\"\
    , \"CD\", \"CD\", \"CDI\", \"CDII\", \"CDIII\", \"CDIIII\", \"CDIIV\", \"CDIV\"\
    , \"CDIVI\", \"CDIVII\", \"CDIVIII\", \"CDIX\", \"CM\", \"CM\", \"CMI\", \"CMII\"\
    , \"CMIII\", \"CMIV\", \"CMV\", \"CMVI\", \"CMVII\", \"CMVIII\", \"CMIX\", \"\
    XM\", \"M\", \"MI\", \"MII\", \"MIII\", \"MIV\", \"MV\", \"MVI\", \"MVII\", \"\
    MVIII\", \"MIX\", \"MM\", \"MMI\", \"MMII\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9lhikb6s_test.go:14:1155: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075728
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romanNumerals := []string{\n\
    \        \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"\
    IX\", \"X\", \"XI\", \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"\
    XVIII\", \"XIX\", \"XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"\
    XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\"\
    , \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\",\
    \ \"L\", \"LI\", \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"\
    LXVII\", \"LXVIII\", \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\"\
    , \"LXXV\", \"LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\"\
    , \"LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"\
    LXXXVIII\", \"LXXXIX\", \"XC\", \"C\", \"CI\", \"CIX\", \"CX\", \"CXI\", \"CXII\"\
    , \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"\
    CXX\", \"CXXI\", \"CXXII\", \"CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"CXXVII\"\
    , \"CXXVIII\", \"CXXIX\", \"CXXX\", \"CXXXI\", \"CXXXII\", \"CXXXIII\", \"CXXXIV\"\
    , \"CXXXV\", \"CXXXVI\", \"CXXXVII\", \"CXXXVIII\", \"CXXXIX\", \"CXL\", \"CL\"\
    , \"CLI\", \"CLX\", \"CLXI\", \"CLXII\", \"CLXIII\", \"CLXIV\", \"CLXV\", \"CLXVI\"\
    , \"CLXVII\", \"CLXVIII\", \"CLXIX\", \"CLXX\", \"CLXXI\", \"CLXXII\", \"CLXXIII\"\
    , \"CLXXIV\", \"CLXXV\", \"CLXXVI\", \"CLXXVII\", \"CLXXVIII\", \"CLXXIX\", \"\
    CLXXX\", \"CLXXXI\", \"CLXXXII\", \"CLXXXIII\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjcsndsky_test.go:14:1120: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075728
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_num := \"\"\n    switch\
    \ number {\n    case 1:\n        roman_num = \"I\"\n    case 2:\n        roman_num\
    \ = \"II\"\n    case 3:\n        roman_num = \"III\"\n    case 4:\n        roman_num\
    \ = \"IV\"\n    case 5:\n        roman_num = \"V\"\n    case 6:\n        roman_num\
    \ = \"VI\"\n    case 7:\n        roman_num = \"VII\"\n    case 8:\n        roman_num\
    \ = \"VIII\"\n    case 9:\n        roman_num = \"IX\"\n    case 10:\n        roman_num\
    \ = \"X\"\n    case 11:\n        roman_num = \"XI\"\n    case 12:\n        roman_num\
    \ = \"XII\"\n    case 13:\n        roman_num = \"XIII\"\n    case 14:\n      \
    \  roman_num = \"XIV\"\n    case 15:\n        roman_num = \"XV\"\n    case 16:\n\
    \        roman_num = \"XVI\"\n    case 17:\n        roman_num = \"XVII\"\n   \
    \ case 18:\n        roman_num = \"XVIII\"\n    case 19:\n        roman_num = \"\
    XIX\"\n    case 20:\n        roman_num = \"XX\"\n    case 21:\n        roman_num\
    \ = \"XXI\"\n    case 22:\n        roman_num = \"XXII\"\n    case 23:\n      \
    \  roman_num = \"XXIII\"\n    case 24:\n        roman_num = \"XXIV\"\n    case\
    \ 25:\n        roman_num = \"XXV\"\n    case 26:\n        roman_num = \"XXVI\"\
    \n    case 27:\n        roman_num = \"XXVII\"\n    case 28:\n        roman_num\
    \ = \"XXVIII\"\n    case 29:\n        roman_num = \"XXIX\"\n    case 30:\n   \
    \     roman_num = \"XXX\"\n    case 31:\n        roman_num = \"XXXI\"\n    case\
    \ 32:\n        roman_num = \"XXXII\"\n    case 33:\n        roman_num = \"XXXIII\"\
    \n    case 34:\n        roman_num = \"XXXIV\"\n    case 35:\n        roman_num\
    \ = \"XXXV\"\n    case 36:\n        roman_num = \"XXXVI\"\n    case 37:\n    \
    \    roman_num = \"XXXVII\"\n    case 38:\n        roman_num = \"XXXVIII\"\n \
    \   case 39:\n        roman_num = \"XXXIX\"\n    case 40:\n        roman_num =\
    \ \"XL\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8xvbo_2c_test.go:95:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075728
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := []string{\n       \
    \ \"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"\
    D\", \"CM\",\n        \"M\", \"MM\", \"MMM\",\n    }\n    roman_number := 0\n\
    \    for roman_number < len(romans) {\n        if number >= roman_number {\n \
    \           roman_number += romans[roman_number]\n            break\n        }\n\
    \        roman_number += romans[roman_number]\n    }\n    return fmt.Sprintf(\"\
    %v\", roman_number)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvqphb1p4_test.go:20:13: invalid operation: roman_number += romans[roman_number]
    (mismatched types int and string)

    /tmp/tmpvqphb1p4_test.go:23:9: invalid operation: roman_number += romans[roman_number]
    (mismatched types int and string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075730
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_numerals := map[int]string{\n\
    \        1: \"I\",\n        5: \"V\",\n        10: \"X\",\n        50: \"L\",\n\
    \        100: \"C\",\n        500: \"D\",\n        1000: \"M\",\n    }\n    result\
    \ := \"\"\n    for _, roman_numeral := range roman_numerals {\n        if number\
    \ >= roman_numeral {\n            result += roman_numerals[roman_numeral]\n  \
    \          number -= roman_numeral\n        }\n    }\n    if number > 0 {\n  \
    \      result += roman_numerals[number]\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpphmo0nna_test.go:24:22: invalid operation: number >= roman_numeral (mismatched
    types int and string)

    /tmp/tmpphmo0nna_test.go:25:38: cannot use roman_numeral (variable of type string)
    as type int in map index

    /tmp/tmpphmo0nna_test.go:26:13: invalid operation: number -= roman_numeral (mismatched
    types int and string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075730
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := []string{\"I\", \"\
    II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\"\
    , \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"\
    XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"\
    XXVIII\", \"XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\"\
    , \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\", \"L\", \"LI\", \"LXI\"\
    , \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\", \"\
    LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\"\
    , \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\"\
    , \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\", \"\
    XC\", \"C\", \"CI\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\",\
    \ \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\", \"CXXI\", \"CXXII\"\
    , \"CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"CXXVII\", \"CXXVIII\", \"CXXIX\"\
    , \"CXXX\", \"CXXXI\", \"CXXXII\", \"CXXXIII\", \"CXXXIV\", \"CXXXV\", \"CXXXVI\"\
    , \"CXXXVII\", \"CXXXVIII\", \"CXXXIX\", \"CC\", \"CCI\", \"CCII\", \"CCIII\"\
    , \"CCIV\", \"CCV\", \"CCVI\", \"CCVII\", \"CCVIII\", \"CCIX\", \"CCH\", \"CCHI\"\
    , \"CCHII\", \"CCHIII\", \"CCHIV\", \"CCHV\", \"CCHVI\", \"CCHVII\", \"CCHVIII\"\
    , \"CCHIX\", \"CCC\", \"CCCI\", \"CCCII\", \"CCCIII\", \"CCCIV\", \"CCCV\", \"\
    CCCVI\", \"CCCVII\", \"CCCVIII\", \"CC\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7wt98umh_test.go:13:1146: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075730
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_num := make([]string, 1000)\n\
    \    roman_num[0] = \"\"\n    roman_num[1] = \"I\"\n    roman_num[2] = \"II\"\n\
    \    roman_num[3] = \"III\"\n    roman_num[4] = \"IV\"\n    roman_num[5] = \"\
    V\"\n    roman_num[6] = \"VI\"\n    roman_num[7] = \"VII\"\n    roman_num[8] =\
    \ \"VIII\"\n    roman_num[9] = \"IX\"\n    roman_num[10] = \"X\"\n    roman_num[11]\
    \ = \"XI\"\n    roman_num[12] = \"XII\"\n    roman_num[13] = \"XIII\"\n    roman_num[14]\
    \ = \"XIV\"\n    roman_num[15] = \"XV\"\n    roman_num[16] = \"XVI\"\n    roman_num[17]\
    \ = \"XVII\"\n    roman_num[18] = \"XVIII\"\n    roman_num[19] = \"XIX\"\n   \
    \ roman_num[20] = \"XX\"\n    roman_num[21] = \"XXI\"\n    roman_num[22] = \"\
    XXII\"\n    roman_num[23] = \"XXIII\"\n    roman_num[24] = \"XXIV\"\n    roman_num[25]\
    \ = \"XXV\"\n    roman_num[26] = \"XXVI\"\n    roman_num[27] = \"XXVII\"\n   \
    \ roman_num[28] = \"XXVIII\"\n    roman_num[29] = \"XXIX\"\n    roman_num[30]\
    \ = \"XXX\"\n    roman_num[31] = \"XXXI\"\n    roman_num[32] = \"XXXII\"\n   \
    \ roman_num[33] = \"XXXIII\"\n    roman_num[34] = \"XXXIV\"\n    roman_num[35]\
    \ = \"XXXV\"\n    roman_num[36] = \"XXXVI\"\n    roman_num[37] = \"XXXVII\"\n\
    \    roman_num[38] = \"XXXVIII\"\n    roman_num[39] = \"XXXIX\"\n    roman_num[40]\
    \ = \"XL\"\n    roman_num[41] = \"L\"\n    roman_num[42] = \"LX\"\n    roman_num[43]\
    \ = \"LXX\"\n    roman_num[44] = \"LXXX\"\n    roman_num[45] = \"LXXXX\"\n   \
    \ roman_num[\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphzo46ygg_test.go:61:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075728
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_numerals := map[int]string{\n\
    \        1: \"I\",\n        5: \"V\",\n        10: \"X\",\n        50: \"L\",\n\
    \        100: \"C\",\n        500: \"D\",\n        1000: \"M\",\n    }\n    roman_numeral\
    \ := roman_numerals[number]\n    return strings.ToLower(roman_numeral)\n}\n\n\
    func TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnwct1mw7_test.go:23:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075730
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_num := \"\"\n    switch\
    \ number {\n    case 1:\n        roman_num = \"I\"\n    case 2:\n        roman_num\
    \ = \"II\"\n    case 3:\n        roman_num = \"III\"\n    case 4:\n        roman_num\
    \ = \"IV\"\n    case 5:\n        roman_num = \"V\"\n    case 6:\n        roman_num\
    \ = \"VI\"\n    case 7:\n        roman_num = \"VII\"\n    case 8:\n        roman_num\
    \ = \"VIII\"\n    case 9:\n        roman_num = \"IX\"\n    case 10:\n        roman_num\
    \ = \"X\"\n    case 11:\n        roman_num = \"XI\"\n    case 12:\n        roman_num\
    \ = \"XII\"\n    case 13:\n        roman_num = \"XIII\"\n    case 14:\n      \
    \  roman_num = \"XIV\"\n    case 15:\n        roman_num = \"XV\"\n    case 16:\n\
    \        roman_num = \"XVI\"\n    case 17:\n        roman_num = \"XVII\"\n   \
    \ case 18:\n        roman_num = \"XVIII\"\n    case 19:\n        roman_num = \"\
    XIX\"\n    case 20:\n        roman_num = \"XX\"\n    case 21:\n        roman_num\
    \ = \"XXI\"\n    case 22:\n        roman_num = \"XXII\"\n    case 23:\n      \
    \  roman_num = \"XXIII\"\n    case 24:\n        roman_num = \"XXIV\"\n    case\
    \ 25:\n        roman_num = \"XXV\"\n    case 26:\n        roman_num = \"XXVI\"\
    \n    case 27:\n        roman_num = \"XXVII\"\n    case 28:\n        roman_num\
    \ = \"XXVIII\"\n    case 29:\n        roman_num = \"XXIX\"\n    case 30:\n   \
    \     roman_num = \"XXX\"\n    case 31:\n        roman_num = \"XXXI\"\n    case\
    \ 32:\n        roman_num = \"XXXII\"\n    case 33:\n        roman_num = \"XXXIII\"\
    \n    case 34:\n        roman_num = \"XXXIV\"\n    case 35:\n        roman_num\
    \ = \"XXXV\"\n    case 36:\n        roman_num = \"XXXVI\"\n    case 37:\n    \
    \    roman_num = \"XXXVII\"\n    case 38:\n        roman_num = \"XXXVIII\"\n \
    \   case 39:\n        roman_num = \"XXXIX\"\n    case 40:\n        roman_num =\
    \ \"XL\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8xvbo_2c_test.go:95:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075728
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := map[int]string{\n \
    \       1: \"I\",\n        5: \"V\",\n        10: \"X\",\n        50: \"L\",\n\
    \        100: \"C\",\n        500: \"D\",\n        1000: \"M\",\n    }\n    result\
    \ := \"\"\n    for number > 0 {\n        result += \"M\"\n        number -= 50\n\
    \    }\n    for _, romanNum := range romans {\n        if number >= romanNum {\n\
    \            result += romans[romanNum]\n            number -= romanNum\n    \
    \    }\n    }\n    return result[0:len(result)-1]\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9tquj8r1_test.go:28:22: invalid operation: number >= romanNum (mismatched
    types int and string)

    /tmp/tmp9tquj8r1_test.go:29:30: cannot use romanNum (variable of type string)
    as type int in map index

    /tmp/tmp9tquj8r1_test.go:30:13: invalid operation: number -= romanNum (mismatched
    types int and string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075730
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_num := \"\"\n    switch\
    \ number {\n    case 1:\n        roman_num = \"I\"\n    case 2:\n        roman_num\
    \ = \"II\"\n    case 3:\n        roman_num = \"III\"\n    case 4:\n        roman_num\
    \ = \"IV\"\n    case 5:\n        roman_num = \"V\"\n    case 6:\n        roman_num\
    \ = \"VI\"\n    case 7:\n        roman_num = \"VII\"\n    case 8:\n        roman_num\
    \ = \"VIII\"\n    case 9:\n        roman_num = \"IX\"\n    case 10:\n        roman_num\
    \ = \"X\"\n    case 11:\n        roman_num = \"XI\"\n    case 12:\n        roman_num\
    \ = \"XII\"\n    case 13:\n        roman_num = \"XIII\"\n    case 14:\n      \
    \  roman_num = \"XIV\"\n    case 15:\n        roman_num = \"XV\"\n    case 16:\n\
    \        roman_num = \"XVI\"\n    case 17:\n        roman_num = \"XVII\"\n   \
    \ case 18:\n        roman_num = \"XVIII\"\n    case 19:\n        roman_num = \"\
    XIX\"\n    case 20:\n        roman_num = \"XX\"\n    case 21:\n        roman_num\
    \ = \"XXI\"\n    case 22:\n        roman_num = \"XXII\"\n    case 23:\n      \
    \  roman_num = \"XXIII\"\n    case 24:\n        roman_num = \"XXIV\"\n    case\
    \ 25:\n        roman_num = \"XXV\"\n    case 26:\n        roman_num = \"XXVI\"\
    \n    case 27:\n        roman_num = \"XXVII\"\n    case 28:\n        roman_num\
    \ = \"XXVIII\"\n    case 29:\n        roman_num = \"XXIX\"\n    case 30:\n   \
    \     roman_num = \"XXX\"\n    case 31:\n        roman_num = \"XXXI\"\n    case\
    \ 32:\n        roman_num = \"XXXII\"\n    case 33:\n        roman_num = \"XXXIII\"\
    \n    case 34:\n        roman_num = \"XXXIV\"\n    case 35:\n        roman_num\
    \ = \"XXXV\"\n    case 36:\n        roman_num = \"XXXVI\"\n    case 37:\n    \
    \    roman_num = \"XXXVII\"\n    case 38:\n        roman_num = \"XXXVIII\"\n \
    \   case 39:\n        roman_num = \"XXXIX\"\n    case 40:\n        roman_num =\
    \ \"XL\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8xvbo_2c_test.go:95:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075728
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := []string{\n       \
    \ \"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"\
    D\", \"CM\", \"M\", \"MN\", \"N\",\n        \"NM\", \"NN\", \"NX\", \"XX\", \"\
    XXL\", \"LXX\", \"LXXX\", \"XCXX\", \"CXX\", \"CXXX\", \"XXX\",\n        \"XLXXX\"\
    , \"LXXX\", \"LXXXX\", \"LXXXX\", \"LXXXX\", \"LXXXX\", \"LXXXX\", \"LXXXX\",\
    \ \"LXXXX\",\n        \"LXXXX\", \"LXXXX\", \"LXXXX\", \"LXXXX\", \"LXXXX\", \"\
    LXXXX\", \"LXXXX\", \"LXXXX\", \"LXXXX\",\n        \"LXXXX\", \"LXXXX\", \"LXXXX\"\
    , \"LXXXX\", \"LXXXX\", \"LXXXX\", \"LXXXX\", \"LXXXX\", \"LXXXX\",\n        \"\
    LXXXX\", \"LXXXX\", \"LXXXX\", \"LXXXX\", \"LXXXX\", \"LXXXX\", \"LXXXX\", \"\
    LXXXX\", \"LXXXX\",\n        \"LXXXX\", \"LXXXX\", \"LXXXX\", \"LXXXX\", \"LXXXX\"\
    , \"LXXXX\", \"LXXXX\", \"LXXXX\", \"LXXXX\",\n        \"LXXXX\", \"LXXXX\", \"\
    LXXXX\", \"LXXXX\", \"LXXXX\", \"LXXXX\", \"LXXXX\", \"LXXXX\", \"LXXXX\",\n \
    \       \"LXXXX\", \"LXXXX\", \"LXXXX\", \"LXXXX\", \"LXXXX\", \"LXXXX\", \"LXXXX\"\
    , \"LXXXX\", \"LXXXX\",\n        \"LXXXX\", \"LXXXX\", \"LXXXX\", \"LXXXX\", \"\
    LXXXX\", \"LXXXX\", \"LXXXX\", \"LXXXX\", \"LXXXX\",\n        \"LXXXX\", \"LXXXX\"\
    , \"LXXXX\", \"LXXXX\", \"LXXXX\", \"LXXXX\", \"LXXXX\", \"LXXXX\", \"LXXXX\"\
    ,\n        \"LXXXX\", \"LXXXX\", \"LXXXX\", \"LXXXX\", \"LXXXX\", \"LXXXX\", \"\
    LXXXX\", \"LXXXX\", \"LXXXX\",\n        \"LXXXX\", \"LXXXX\", \"LXXXX\", \"LXXXX\"\
    , \"LXXXX\", \"LXXXX\", \"LXXXX\", \"LXXXX\", \"LXXXX\",\n        \"LXXXX\", \"\
    LXXXX\", \"LXXXX\", \"LXXXX\", \"LXXXX\", \"LXXXX\", \"LXXXX\", \"LXXXX\", \"\
    LXXXX\",\n        \"LXXXX\", \"LXXXX\", \"LXXXX\", \"LXXXX\", \"LXXXX\", \"LXXXX\"\
    , \"LXXXX\", \"LXXXX\", \"LXXXX\",\n        \"LXXXX\", \"LXXXX\", \"LXXXX\", \"\
    LXXXX\", \"LXXXX\", \"LXXXX\", \"LXXXX\", \"LXXXX\", \"LXXXX\",\n        \"LXXXX\"\
    , \"LXXXX\", \"LXXXX\", \"LXXXX\", \"LXXXX\", \"LXXXX\", \"LXXXX\", \"LXXXX\"\
    , \"LXXXX\",\n        \"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpeppn6893_test.go:31:9: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075730
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := []string{\n       \
    \ \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\",\n\
    \        \"X\", \"XI\", \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\"\
    , \"XVIII\", \"XIX\",\n        \"XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\"\
    , \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\",\n        \"XXX\", \"XXXI\"\
    , \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\"\
    , \"XXXIX\",\n    }\n    result := \"\"\n    for _, romanIndex := range romans\
    \ {\n        if number >= romanIndex {\n            result += romanIndex\n   \
    \         number -= romanIndex\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpy6jd3phy_test.go:21:22: invalid operation: number >= romanIndex (mismatched
    types int and string)

    /tmp/tmpy6jd3phy_test.go:23:13: invalid operation: number -= romanIndex (mismatched
    types int and string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075730
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := []string{\"I\", \"\
    II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\"\
    , \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"\
    XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"\
    XXVIII\", \"XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\"\
    , \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\", \"L\", \"LI\", \"LX\"\
    , \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\"\
    , \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"\
    LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\",\
    \ \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"\
    LXXXIX\", \"XC\", \"C\", \"CI\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\"\
    , \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\", \"CXXI\", \"CXXII\"\
    , \"CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"CXXVII\", \"CXXVIII\", \"CXXIX\"\
    , \"CXXX\", \"CXXXI\", \"CXXXII\", \"CXXXIII\", \"CXXXIV\", \"CXXXV\", \"CXXXVI\"\
    , \"CXXXVII\", \"CXXXVIII\", \"CXXXIX\", \"CXL\", \"CL\", \"CLI\", \"CLX\", \"\
    CLXI\", \"CLXII\", \"CLXIII\", \"CLXIV\", \"CLXV\", \"CLXVI\", \"CLXVII\", \"\
    CLXVIII\", \"CLXIX\", \"CLXX\", \"CLXXI\", \"CLXXII\", \"CLXXIII\", \"CLXXIV\"\
    , \"CLXXV\", \"CLXXVI\", \"CLXXVII\", \"CLXXVIII\", \"CLXXIX\", \"CLXXX\", \"\
    CLXXXI\", \"CLXXXII\", \"CLXXXIII\", \"CLXXXIV\", \"\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_n0byut9_test.go:13:1157: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075730
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_num := \"\"\n    switch\
    \ number {\n    case 1:\n        roman_num = \"I\"\n    case 2:\n        roman_num\
    \ = \"II\"\n    case 3:\n        roman_num = \"III\"\n    case 4:\n        roman_num\
    \ = \"IV\"\n    case 5:\n        roman_num = \"V\"\n    case 6:\n        roman_num\
    \ = \"VI\"\n    case 7:\n        roman_num = \"VII\"\n    case 8:\n        roman_num\
    \ = \"VIII\"\n    case 9:\n        roman_num = \"IX\"\n    case 10:\n        roman_num\
    \ = \"X\"\n    case 11:\n        roman_num = \"XI\"\n    case 12:\n        roman_num\
    \ = \"XII\"\n    case 13:\n        roman_num = \"XIII\"\n    case 14:\n      \
    \  roman_num = \"XIV\"\n    case 15:\n        roman_num = \"XV\"\n    case 16:\n\
    \        roman_num = \"XVI\"\n    case 17:\n        roman_num = \"XVII\"\n   \
    \ case 18:\n        roman_num = \"XVIII\"\n    case 19:\n        roman_num = \"\
    XIX\"\n    case 20:\n        roman_num = \"XX\"\n    case 21:\n        roman_num\
    \ = \"XXI\"\n    case 22:\n        roman_num = \"XXII\"\n    case 23:\n      \
    \  roman_num = \"XXIII\"\n    case 24:\n        roman_num = \"XXIV\"\n    case\
    \ 25:\n        roman_num = \"XXV\"\n    case 26:\n        roman_num = \"XXVI\"\
    \n    case 27:\n        roman_num = \"XXVII\"\n    case 28:\n        roman_num\
    \ = \"XXVIII\"\n    case 29:\n        roman_num = \"XXIX\"\n    case 30:\n   \
    \     roman_num = \"XXX\"\n    case 31:\n        roman_num = \"XXXI\"\n    case\
    \ 32:\n        roman_num = \"XXXII\"\n    case 33:\n        roman_num = \"XXXIII\"\
    \n    case 34:\n        roman_num = \"XXXIV\"\n    case 35:\n        roman_num\
    \ = \"XXXV\"\n    case 36:\n        roman_num = \"XXXVI\"\n    case 37:\n    \
    \    roman_num = \"XXXVII\"\n    case 38:\n        roman_num = \"XXXVIII\"\n \
    \   case 39:\n        roman_num = \"XXXIX\"\n    case 40:\n        roman_num =\
    \ \"XL\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8xvbo_2c_test.go:95:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075728
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := map[int]string{\n \
    \       1: \"I\",\n        5: \"V\",\n        10: \"X\",\n        50: \"L\",\n\
    \        100: \"C\",\n        500: \"D\",\n        1000: \"M\",\n    }\n    result\
    \ := \"\"\n    for num, _ := range romans {\n        if number >= num {\n    \
    \        result += romans[num]\n            number -= num\n        }\n    }\n\
    \    return strings.ToLower(result)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9pg55rzc_test.go:29:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075730
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := []string{\"I\", \"\
    II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"}\n    result :=\
    \ \"\"\n    i := 0\n    for number > 0 {\n        result += romans[i]\n      \
    \  number -= romans[i].Length()\n        i++\n    }\n    return result\n}\n\n\
    func TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpe2jncdha_test.go:18:29: romans[i].Length undefined (type string has no
    field or method Length)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075730
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    var romanNum string\n    var\
    \ i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n\
    \ int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n\
    \    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n \
    \   var y int\n    var z int\n    var a int\n    var b int\n    var c int\n  \
    \  var d int\n    var e int\n    var f int\n    var g int\n    var h int\n   \
    \ var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var\
    \ n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s\
    \ int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n\
    \    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n \
    \   var d int\n    var e int\n    var f int\n    var g int\n    var h int\n  \
    \  var i int\n    var j int\n    var k int\n    var l int\n    var m int\n   \
    \ var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var\
    \ s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x\
    \ int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n\
    \    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n \
    \   var i int\n    var j int\n    var k int\n    var l int\n    var m int\n  \
    \  var n int\n    var o int\n    var p int\n    var q int\n    var r int\n   \
    \ var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var\
    \ x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c\
    \ int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n\
    \    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n \
    \   var n int\n    var o int\n    var p int\n    var q int\n    var r int\n  \
    \  var s int\n    var t int\n    var u int\n    var v int\n    var w int\n   \
    \ var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var\
    \ c int\n    var d int\n    var \nfunc TestInt_To_Mini_Roman(t *testing.T) {\n\
    \  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpgsqmlac7_test.go:141:1: expected ''IDENT'', found ''func''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075730
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    var roman = make([]string, 1000)\n\
    \    roman[0] = \"\"\n    roman[1] = \"I\"\n    roman[2] = \"II\"\n    roman[3]\
    \ = \"III\"\n    roman[4] = \"IV\"\n    roman[5] = \"V\"\n    roman[6] = \"VI\"\
    \n    roman[7] = \"VII\"\n    roman[8] = \"VIII\"\n    roman[9] = \"IX\"\n   \
    \ roman[10] = \"X\"\n    roman[11] = \"XI\"\n    roman[12] = \"XII\"\n    roman[13]\
    \ = \"XIII\"\n    roman[14] = \"XIV\"\n    roman[15] = \"XV\"\n    roman[16] =\
    \ \"XVI\"\n    roman[17] = \"XVII\"\n    roman[18] = \"XVIII\"\n    roman[19]\
    \ = \"XIX\"\n    roman[20] = \"XX\"\n    roman[21] = \"XXI\"\n    roman[22] =\
    \ \"XXII\"\n    roman[23] = \"XXIII\"\n    roman[24] = \"XXIV\"\n    roman[25]\
    \ = \"XXV\"\n    roman[26] = \"XXVI\"\n    roman[27] = \"XXVII\"\n    roman[28]\
    \ = \"XXVIII\"\n    roman[29] = \"XXIX\"\n    roman[30] = \"XXX\"\n    roman[31]\
    \ = \"XXXI\"\n    roman[32] = \"XXXII\"\n    roman[33] = \"XXXIII\"\n    roman[34]\
    \ = \"XXXIV\"\n    roman[35] = \"XXXV\"\n    roman[36] = \"XXXVI\"\n    roman[37]\
    \ = \"XXXVII\"\n    roman[38] = \"XXXVIII\"\n    roman[39] = \"XXXIX\"\n    roman[40]\
    \ = \"XL\"\n    roman[41] = \"L\"\n    roman[42] = \"LX\"\n    roman[43] = \"\
    LXX\"\n    roman[44] = \"LXXX\"\n    roman[45] = \"LXXXX\"\n    roman[46] = \"\
    LXXXXX\"\n    roman[47] = \"LXXXII\"\n    roman[48] = \"LXXXIII\"\n    roman[49]\
    \ = \"LXXXIV\"\n    roman[50] = \"L\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpi9zermcg_test.go:64:17: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075730
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romanNumerals := map[int]string{\n\
    \        1: \"I\",\n        5: \"V\",\n        10: \"X\",\n        50: \"L\",\n\
    \        100: \"C\",\n        500: \"D\",\n        1000: \"M\",\n    }\n    romanNumeral\
    \ := romanNumerals[number]\n    return strings.ToLower(romanNumeral)\n}\n\nfunc\
    \ TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmps23w240l_test.go:23:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075730
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_numerals := []string{\n\
    \        \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"\
    IX\", \"X\", \"XI\", \"XII\",\n        \"XIII\", \"XIV\", \"XV\", \"XVI\", \"\
    XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\", \"XXII\",\n        \"XXIII\", \"\
    XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\"\
    ,\n        \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\",\
    \ \"XXXVIII\", \"XXXIX\",\n        \"XL\", \"L\", \"LI\", \"LII\", \"LII\", \"\
    LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\",\n        \"LIX\", \"LX\"\
    , \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\"\
    ,\n        \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\"\
    , \"LXXVI\", \"LXXVII\",\n        \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\"\
    , \"LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\",\n        \"LXXXVI\", \"LXXXVII\"\
    , \"LXXXVIII\", \"LXXXIX\", \"XC\", \"C\", \"CI\", \"CII\", \"CII\",\n       \
    \ \"CIII\", \"CIV\", \"CV\", \"CVI\", \"CVII\", \"CVIII\", \"CIX\", \"CX\", \"\
    CXI\", \"CXII\",\n        \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"\
    CXVIII\", \"CXIX\", \"CXX\", \"CXXI\",\n        \"CXXII\", \"CXXIII\", \"CXXIV\"\
    , \"CXXV\", \"CXXVI\", \"CXXVII\", \"CXXVIII\", \"CXXIX\",\n        \"CXXX\",\
    \ \"CXXXI\", \"CXXXII\", \"CXXXIII\", \"CXXXIV\", \"CXXXV\", \"CXXXVI\", \"CXXXVII\"\
    ,\n        \"CXXXVIII\", \"CXXXIX\", \"CC\", \"CCI\", \"CCII\", \"CCIII\", \"\
    CCIV\", \"CCV\", \"CCVI\",\n        \"CCVII\", \"\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmppudwh2n5_test.go:28:18: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075730
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_num := \"\"\n    switch\
    \ number {\n    case 1:\n        roman_num = \"I\"\n    case 2:\n        roman_num\
    \ = \"II\"\n    case 3:\n        roman_num = \"III\"\n    case 4:\n        roman_num\
    \ = \"IV\"\n    case 5:\n        roman_num = \"V\"\n    case 6:\n        roman_num\
    \ = \"VI\"\n    case 7:\n        roman_num = \"VII\"\n    case 8:\n        roman_num\
    \ = \"VIII\"\n    case 9:\n        roman_num = \"IX\"\n    case 10:\n        roman_num\
    \ = \"X\"\n    case 11:\n        roman_num = \"XI\"\n    case 12:\n        roman_num\
    \ = \"XII\"\n    case 13:\n        roman_num = \"XIII\"\n    case 14:\n      \
    \  roman_num = \"XIV\"\n    case 15:\n        roman_num = \"XV\"\n    case 16:\n\
    \        roman_num = \"XVI\"\n    case 17:\n        roman_num = \"XVII\"\n   \
    \ case 18:\n        roman_num = \"XVIII\"\n    case 19:\n        roman_num = \"\
    XIX\"\n    case 20:\n        roman_num = \"XX\"\n    case 21:\n        roman_num\
    \ = \"XXI\"\n    case 22:\n        roman_num = \"XXII\"\n    case 23:\n      \
    \  roman_num = \"XXIII\"\n    case 24:\n        roman_num = \"XXIV\"\n    case\
    \ 25:\n        roman_num = \"XXV\"\n    case 26:\n        roman_num = \"XXVI\"\
    \n    case 27:\n        roman_num = \"XXVII\"\n    case 28:\n        roman_num\
    \ = \"XXVIII\"\n    case 29:\n        roman_num = \"XXIX\"\n    case 30:\n   \
    \     roman_num = \"XXX\"\n    case 31:\n        roman_num = \"XXXI\"\n    case\
    \ 32:\n        roman_num = \"XXXII\"\n    case 33:\n        roman_num = \"XXXIII\"\
    \n    case 34:\n        roman_num = \"XXXIV\"\n    case 35:\n        roman_num\
    \ = \"XXXV\"\n    case 36:\n        roman_num = \"XXXVI\"\n    case 37:\n    \
    \    roman_num = \"XXXVII\"\n    case 38:\n        roman_num = \"XXXVIII\"\n \
    \   case 39:\n        roman_num = \"XXXIX\"\n    case 40:\n        roman_num =\
    \ \"XL\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8xvbo_2c_test.go:95:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075728
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := []string{\"I\", \"\
    II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\"\
    , \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"\
    XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"\
    XXVIII\", \"XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\"\
    , \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\", \"L\", \"LI\", \"LII\"\
    , \"LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\", \"LIX\", \"LX\", \"\
    LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\"\
    , \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"\
    LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\",\
    \ \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"\
    LXXXIX\", \"XC\", \"C\", \"CI\", \"CII\", \"CIV\", \"CV\", \"CVI\", \"CVII\",\
    \ \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"CXV\"\
    , \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\", \"CXXI\", \"CXXII\", \"\
    CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"CXXVII\", \"CXXVIII\", \"CXXIX\",\
    \ \"CXXX\", \"CXXXI\", \"CXXXII\", \"CXXXIII\", \"CXXXIV\", \"CXXXV\", \"CXXXVI\"\
    , \"CXXXVII\", \"CXXXVIII\", \"CXXXIX\", \"CXL\", \"CL\", \"LI\", \"LII\", \"\
    LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\", \"LIX\", \"LX\", \"LXI\"\
    , \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVII\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpewshv08s_test.go:13:1144: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075728
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    var romanNumerals []string\n\
    \    romanNumerals = append(romanNumerals, \"I\", \"II\", \"III\", \"IV\", \"\
    V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\", \"XIII\", \"XIV\"\
    , \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\", \"XXII\", \"\
    XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\"\
    , \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\"\
    , \"XXXVIII\", \"XXXIX\", \"XL\", \"L\", \"LI\", \"LXI\", \"LXII\", \"LXIII\"\
    , \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\", \"LXIX\", \"LXX\", \"LXXI\"\
    , \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\", \"LXXVIII\"\
    , \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\"\
    , \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\", \"XC\", \"C\", \"CI\", \"\
    CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\"\
    , \"CXVIII\", \"CXIX\", \"CXX\", \"CXXI\", \"CXXII\", \"CXXIII\", \"CXXIV\", \"\
    CXXV\", \"CXXVI\", \"CXXVII\", \"CXXVIII\", \"CXXIX\", \"CXXX\", \"CXXXI\", \"\
    CXXXII\", \"CXXXIII\", \"CXXXIV\", \"CXXXV\", \"CXXXVI\", \"CXXXVII\", \"CXXXVIII\"\
    , \"CXXXIX\", \"CXL\", \"CL\", \"CLI\", \"CLXI\", \"CLXII\", \"CLXIII\", \"CLXIV\"\
    , \"CLXV\", \"CLXVI\", \"CLXVII\", \"CLXVIII\", \"CLXIX\", \"CLXX\", \"CLXXI\"\
    , \"CLXXII\", \"CLXXIII\", \"CLXXIV\", \"CLXXV\", \"CLXXVI\", \"CLXXVII\", \"\
    CLXXVIII\", \"CLXXIX\", \"CLXXX\", \"CLXXXI\", \"CLXXXII\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfetpydsy_test.go:14:1136: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075730
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    var roman = \"\"\n    switch\
    \ number {\n    case 1:\n        roman = \"I\"\n    case 2:\n        roman = \"\
    II\"\n    case 3:\n        roman = \"III\"\n    case 4:\n        roman = \"IV\"\
    \n    case 5:\n        roman = \"V\"\n    case 6:\n        roman = \"VI\"\n  \
    \  case 7:\n        roman = \"VII\"\n    case 8:\n        roman = \"VIII\"\n \
    \   case 9:\n        roman = \"IX\"\n    case 10:\n        roman = \"X\"\n   \
    \ case 11:\n        roman = \"XI\"\n    case 12:\n        roman = \"XII\"\n  \
    \  case 13:\n        roman = \"XIII\"\n    case 14:\n        roman = \"XIV\"\n\
    \    case 15:\n        roman = \"XV\"\n    case 16:\n        roman = \"XVI\"\n\
    \    case 17:\n        roman = \"XVII\"\n    case 18:\n        roman = \"XVIII\"\
    \n    case 19:\n        roman = \"XIX\"\n    case 20:\n        roman = \"XX\"\n\
    \    case 21:\n        roman = \"XXI\"\n    case 22:\n        roman = \"XXII\"\
    \n    case 23:\n        roman = \"XXIII\"\n    case 24:\n        roman = \"XXIV\"\
    \n    case 25:\n        roman = \"XXV\"\n    case 26:\n        roman = \"XXVI\"\
    \n    case 27:\n        roman = \"XXVII\"\n    case 28:\n        roman = \"XXVIII\"\
    \n    case 29:\n        roman = \"XXIX\"\n    case 30:\n        roman = \"XXX\"\
    \n    case 31:\n        roman = \"XXXI\"\n    case 32:\n        roman = \"XXXII\"\
    \n    case 33:\n        roman = \"XXXIII\"\n    case 34:\n        roman = \"XXXIV\"\
    \n    case 35:\n        roman = \"XXXV\"\n    case 36:\n        roman = \"XXXVI\"\
    \n    case 37:\n        roman = \"XXXVII\"\n    case 38:\n        roman = \"XXXVIII\"\
    \n    case 39:\n        roman = \"XXXIX\"\n    case 40:\n        roman = \"XL\"\
    \n    case 41:\n        roman = \"L\"\n    case 42:\n        roman = \"LX\"\n\
    \    case 43:\n        roman = \"LXX\"\n    case 44:\n        ro\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpic9_3wzl_test.go:103:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075728
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_numerals := map[int]string{\n\
    \        1: \"I\",\n        5: \"V\",\n        10: \"X\",\n        50: \"L\",\n\
    \        100: \"C\",\n        500: \"D\",\n        1000: \"M\",\n    }\n    roman_numeral\
    \ := \"\"\n    for roman_numeral, number := range roman_numerals {\n        if\
    \ number >= number {\n            break\n        }\n    }\n    return fmt.Sprintf(\"\
    %c\", roman_numeral) + int_to_mini_roman(number-roman_numeral)\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpn6wjp2ui_test.go:23:9: roman_numeral declared but not used

    /tmp/tmpn6wjp2ui_test.go:28:65: invalid operation: number - roman_numeral (mismatched
    types int and string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075730
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_number := \"\"\n    switch\
    \ number {\n    case 1:\n        roman_number = \"I\"\n    case 2:\n        roman_number\
    \ = \"II\"\n    case 3:\n        roman_number = \"III\"\n    case 4:\n       \
    \ roman_number = \"IV\"\n    case 5:\n        roman_number = \"V\"\n    case 6:\n\
    \        roman_number = \"VI\"\n    case 7:\n        roman_number = \"VII\"\n\
    \    case 8:\n        roman_number = \"VIII\"\n    case 9:\n        roman_number\
    \ = \"IX\"\n    case 10:\n        roman_number = \"X\"\n    case 11:\n       \
    \ roman_number = \"XI\"\n    case 12:\n        roman_number = \"XII\"\n    case\
    \ 13:\n        roman_number = \"XIII\"\n    case 14:\n        roman_number = \"\
    XIV\"\n    case 15:\n        roman_number = \"XV\"\n    case 16:\n        roman_number\
    \ = \"XVI\"\n    case 17:\n        roman_number = \"XVII\"\n    case 18:\n   \
    \     roman_number = \"XVIII\"\n    case 19:\n        roman_number = \"XIX\"\n\
    \    case 20:\n        roman_number = \"XX\"\n    case 21:\n        roman_number\
    \ = \"XXI\"\n    case 22:\n        roman_number = \"XXII\"\n    case 23:\n   \
    \     roman_number = \"XXIII\"\n    case 24:\n        roman_number = \"XXIV\"\n\
    \    case 25:\n        roman_number = \"XXV\"\n    case 26:\n        roman_number\
    \ = \"XXVI\"\n    case 27:\n        roman_number = \"XXVII\"\n    case 28:\n \
    \       roman_number = \"XXVIII\"\n    case 29:\n        roman_number = \"XXIX\"\
    \n    case 30:\n        roman_number = \"XXX\"\n    case 31:\n        roman_number\
    \ = \"XXXI\"\n    case 32:\n        roman_number = \"XXXII\"\n    case 33:\n \
    \       roman_number = \"XXXIII\"\n    case 34:\n        roman_number = \"XXXIV\"\
    \n    case 35:\n        roman_number = \"XXXV\"\n    case 36:\n        roman_number\
    \ = \"XXXVI\"\n    case 37:\n        roman_number = \"XXXVII\"\n    case 38:\n\
    \        roman_number = \"XXXVIII\"\n    case 39:\n        roman_number = \"XXXIX\"\
    \n    case 40:\n        roman_number = \"XL\"\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7aj4t2nh_test.go:95:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075728
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := []string{\"I\", \"\
    II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\"\
    , \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"\
    XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"\
    XXVIII\", \"XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\"\
    , \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\", \"L\", \"LI\", \"LII\"\
    , \"LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\", \"LIX\", \"LX\", \"\
    LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\"\
    , \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"\
    LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\",\
    \ \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"\
    LXXXIX\", \"XC\", \"C\", \"CI\", \"CII\", \"CIV\", \"CV\", \"CVI\", \"CVII\",\
    \ \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"CXV\"\
    , \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\", \"CXXI\", \"CXXII\", \"\
    CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"CXXVII\", \"CXXVIII\", \"CXXIX\",\
    \ \"CXXX\", \"CXXXI\", \"CXXXII\", \"CXXXIII\", \"CXXXIV\", \"CXXXV\", \"CXXXVI\"\
    , \"CXXXVII\", \"CXXXVIII\", \"CXXXIX\", \"CC\", \"CCI\", \"CCII\", \"CCIII\"\
    , \"CCIV\", \"CV\", \"CVI\", \"CVII\", \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"\
    CXII\", \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\"\
    , \"CXX\", \"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmptryuebdg_test.go:13:1166: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075730
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := map[int]string{\n \
    \       1: \"I\",\n        5: \"V\",\n        10: \"X\",\n        50: \"L\",\n\
    \        100: \"C\",\n        500: \"D\",\n        1000: \"M\",\n    }\n    roman_number\
    \ := \"\"\n    for roman_number, roman_number := range romans {\n        if number\
    \ >= roman_number {\n            break\n        }\n    }\n    return romans[roman_number]\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptm7nxvk3_test.go:23:23:\
    \ roman_number redeclared in this block\n\t/tmp/tmptm7nxvk3_test.go:23:9: other\
    \ declaration of roman_number\n/tmp/tmptm7nxvk3_test.go:28:19: cannot use roman_number\
    \ (variable of type string) as type int in map index\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075731
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := []string{\n       \
    \ \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"\
    X\", \"XI\", \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\"\
    , \"XIX\", \"XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\",\
    \ \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"\
    XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\", \"L\"\
    , \"LI\", \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\", \"\
    LIX\", \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\"\
    , \"LXVIII\", \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"\
    LXXV\", \"LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"\
    LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\"\
    , \"LXXXIX\", \"XC\", \"C\", \"CI\", \"CII\", \"CIV\", \"CV\", \"CVI\", \"CVII\"\
    , \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"CXV\"\
    , \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\", \"CXXI\", \"CXXII\", \"\
    CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"CXXVII\", \"CXXVIII\", \"CXXIX\",\
    \ \"CXXX\", \"CXXXI\", \"CXXXII\", \"CXXXIII\", \"CXXXIV\", \"CXXXV\", \"CXXXVI\"\
    , \"CXXXVII\", \"CXXXVIII\", \"CXXXIX\", \"CXL\", \"CL\", \"LI\", \"LII\", \"\
    LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\", \"LIX\", \"LX\", \"LXI\"\
    , \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"L\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp25s440y__test.go:14:1129: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075730
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_numerals := []string{\n\
    \        \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"\
    IX\", \"X\", \"XI\", \"XII\",\n        \"XIII\", \"XIV\", \"XV\", \"XVI\", \"\
    XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\", \"XXII\",\n        \"XXIII\", \"\
    XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\"\
    ,\n        \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\",\
    \ \"XXXVIII\", \"XXXIX\",\n        \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"\
    LXXXX\", \"LXXXXX\", \"LXXXXXX\", \"LXXXXXXX\",\n        \"LXXXXXV\", \"LXXXXXVI\"\
    , \"LXXXXXVII\", \"LXXXXXVIII\", \"LXXXXXIX\", \"LXXX\", \"LXXXI\",\n        \"\
    LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\"\
    ,\n        \"LXXXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"\
    LXXV\", \"LXXVI\",\n        \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\"\
    , \"LXXXII\", \"LXXXIII\", \"LXXXIV\",\n        \"LXXXV\", \"LXXXVI\", \"LXXXVII\"\
    , \"LXXXVIII\", \"LXXXIX\", \"LXL\", \"LXLI\", \"LXLII\",\n        \"LXLIII\"\
    , \"LXLIIII\", \"LXLIIV\", \"LXLIV\", \"LXLIVI\", \"LXLIVII\", \"LXLIVIII\",\n\
    \        \"LXLIIX\", \"LXLX\", \"LXLXI\", \"LXLXII\", \"LXLXIII\", \"LXLXIV\"\
    , \"LXLV\", \"LXLVI\",\n        \"LXLVII\", \"LXLVIII\", \"LXLVIV\", \"LXLVV\"\
    , \"LXLVVI\", \"LXLVVII\", \"LXLVVIII\",\n        \"LXLVIX\", \"LXLX\", \"LXLXI\"\
    , \"LXLXII\", \"LXLXIII\", \"LXLXIV\", \"LXL\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbyf9_jq4_test.go:27:67: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075730
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    var romanNum string\n    var\
    \ i int\n    var numDigits int\n\n    // Initialize variables\n    numDigits =\
    \ number\n    romanNum = \"\"\n\n    // Initialize a map of roman numerals to\
    \ their integer equivalents\n    romanMap := map[int]string{\n        1: \"I\"\
    ,\n        5: \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"\
    C\",\n        500: \"D\",\n        1000: \"M\",\n    }\n\n    // Iterate through\
    \ each number in the map\n    for i := 1; i <= numDigits; i++ {\n        // Get\
    \ the roman numeral equivalent of the current number\n        romanNum += romanMap[number%10]\n\
    \n        // Divide the current number by 10\n        number /= 10\n    }\n\n\
    \    // Return the roman numeral equivalent of the number\n    return romanNum\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpale2iwqu_test.go:14:9: i declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075731
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_numerals := map[int]string{\n\
    \        1: \"I\",\n        5: \"V\",\n        10: \"X\",\n        50: \"L\",\n\
    \        100: \"C\",\n        500: \"D\",\n        1000: \"M\",\n    }\n    roman_numeral\
    \ := \"\"\n    for roman_numeral, number := range roman_numerals {\n        if\
    \ number >= number {\n            break\n        }\n    }\n    if number > 1000\
    \ {\n        fmt.Println(\"Error: number too large\")\n    }\n    return roman_numeral\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpetqva84h_test.go:23:9: roman_numeral declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075731
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_numerals := []string{\n\
    \        \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"\
    IX\", \"X\", \"XI\", \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"\
    XVIII\", \"XIX\", \"XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"\
    XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\"\
    , \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\",\
    \ \"L\", \"LI\", \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"\
    LXVII\", \"LXVIII\", \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\"\
    , \"LXXV\", \"LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\"\
    , \"LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"\
    LXXXVIII\", \"LXXXIX\", \"XC\", \"C\", \"CI\", \"CIX\", \"CX\", \"CXI\", \"CXII\"\
    , \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"\
    CXX\", \"CXXI\", \"CXXII\", \"CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"CXXVII\"\
    , \"CXXVIII\", \"CXXIX\", \"CXXX\", \"CXXXI\", \"CXXXII\", \"CXXXIII\", \"CXXXIV\"\
    , \"CXXXV\", \"CXXXVI\", \"CXXXVII\", \"CXXXVIII\", \"CXXXIX\", \"CD\", \"D\"\
    , \"DI\", \"DII\", \"DIII\", \"DIIII\", \"DIIV\", \"DIV\", \"DIVI\", \"DIVII\"\
    , \"DIVIII\", \"DIX\", \"DX\", \"DXI\", \"DXII\", \"DXIII\", \"DXIV\", \"DXV\"\
    , \"DXVI\", \"DXVII\", \"DXVIII\", \"DXIX\", \"DXX\", \"DXXI\", \"DXXII\", \"\
    DXXIII\", \"DXXIV\", \"DXXV\", \"DXXVI\", \"DXXVII\", \"DXXVIII\", \"DXX\nfunc\
    \ TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmud9khji_test.go:14:1131: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075730
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000\
    \ {\n        fmt.Println(\"Invalid input\")\n    }\n    roman_num := \"\"\n  \
    \  switch number {\n    case 1:\n        roman_num = \"I\"\n    case 2:\n    \
    \    roman_num = \"II\"\n    case 3:\n        roman_num = \"III\"\n    case 4:\n\
    \        roman_num = \"IV\"\n    case 5:\n        roman_num = \"V\"\n    case\
    \ 6:\n        roman_num = \"VI\"\n    case 7:\n        roman_num = \"VII\"\n \
    \   case 8:\n        roman_num = \"VIII\"\n    case 9:\n        roman_num = \"\
    IX\"\n    case 10:\n        roman_num = \"X\"\n    case 11:\n        roman_num\
    \ = \"XI\"\n    case 12:\n        roman_num = \"XII\"\n    case 13:\n        roman_num\
    \ = \"XIII\"\n    case 14:\n        roman_num = \"XIV\"\n    case 15:\n      \
    \  roman_num = \"XV\"\n    case 16:\n        roman_num = \"XVI\"\n    case 17:\n\
    \        roman_num = \"XVII\"\n    case 18:\n        roman_num = \"XVIII\"\n \
    \   case 19:\n        roman_num = \"XIX\"\n    case 20:\n        roman_num = \"\
    XX\"\n    case 21:\n        roman_num = \"XXI\"\n    case 22:\n        roman_num\
    \ = \"XXII\"\n    case 23:\n        roman_num = \"XXIII\"\n    case 24:\n    \
    \    roman_num = \"XXIV\"\n    case 25:\n        roman_num = \"XXV\"\n    case\
    \ 26:\n        roman_num = \"XXVI\"\n    case 27:\n        roman_num = \"XXVII\"\
    \n    case 28:\n        roman_num = \"XXVIII\"\n    case 29:\n        roman_num\
    \ = \"XXIX\"\n    case 30:\n        roman_num = \"XXX\"\n    case 31:\n      \
    \  roman_num = \"XXXI\"\n    case 32:\n        roman_num = \"XXXII\"\n    case\
    \ 33:\n        roman_num = \"XXXIII\"\n    case 34:\n        roman_num = \"XXXIV\"\
    \n    case 35:\n        roman_num = \"XXXV\"\n    case 36:\n        roman_num\
    \ = \"XXXVI\"\n    case 37:\n        roman_num = \"XXXVII\"\n    case 38:\n  \
    \      roman_num = \"XXXVIII\"\n    case 39:\n        \nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6qo4mb0w_test.go:96:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075731
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := map[int]string{\n \
    \       1: \"I\",\n        5: \"V\",\n        10: \"X\",\n        50: \"L\",\n\
    \        100: \"C\",\n        500: \"D\",\n        1000: \"M\",\n    }\n    roman_number\
    \ := \"\"\n    for num, _ := range romans {\n        if number >= num {\n    \
    \        roman_number = romans[num]\n            break\n        }\n    }\n   \
    \ return strings.ToLower(roman_number)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5rouh6cd_test.go:29:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075729
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := map[int]string{\n \
    \       1: \"I\",\n        5: \"V\",\n        10: \"X\",\n        50: \"L\",\n\
    \        100: \"C\",\n        500: \"D\",\n        1000: \"M\",\n    }\n    result\
    \ := \"\"\n    for number > 0 {\n        result += romans[number%100]\n      \
    \  number /= 100\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmpqph57lrm_test.go:56: expected 'xix', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpqph57lrm_test.go:56: expected\
    \ 'clii', got 'I'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n \
    \       tmpqph57lrm_test.go:56: expected 'ccli', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmpqph57lrm_test.go:56: expected 'cdxxvi', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpqph57lrm_test.go:56:\
    \ expected 'd', got 'V'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n\
    \        tmpqph57lrm_test.go:56: expected 'i', got 'I'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6\
    \ (0.00s)\n        tmpqph57lrm_test.go:56: expected 'iv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmpqph57lrm_test.go:56: expected\
    \ 'xliii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n \
    \       tmpqph57lrm_test.go:56: expected 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9\
    \ (0.00s)\n        tmpqph57lrm_test.go:56: expected 'xciv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmpqph57lrm_test.go:56:\
    \ expected 'dxxxii', got 'V'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11\
    \ (0.00s)\n        tmpqph57lrm_test.go:56: expected 'cm', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpqph57lrm_test.go:56:\
    \ expected 'cmxciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmpqph57lrm_test.go:56: expected 'm', got 'X'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075732
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := []string{\n       \
    \ \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"\
    X\", \"XI\",\n        \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"\
    XVIII\", \"XIX\", \"XX\",\n        \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"\
    XXV\", \"XXVI\", \"XXVII\", \"XXVIII\",\n        \"XXIX\", \"XXX\", \"XXXI\",\
    \ \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\",\n        \"XXXVII\",\
    \ \"XXXVIII\", \"XXXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\",\n        \"\
    XXXIV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXXI\", \"XXXII\", \"XXXIII\"\
    ,\n        \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\"\
    , \"XXX\", \"XXXI\",\n        \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\"\
    , \"XXXVII\", \"XXXVIII\",\n        \"XXXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"\
    XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\",\n        \"XXXVII\", \"XXXVIII\", \"\
    XXXIX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\",\n        \"XXVI\", \"\
    XXVII\", \"XXVIII\", \"XXIX\", \"XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\"\
    ,\n        \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XX\", \"XXI\"\
    , \"XXII\", \"XXIII\",\n        \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\"\
    , \"XXIX\", \"XX\", \"XXI\", \"XXII\",\n        \"XXIII\", \"XXIV\", \"XXV\",\
    \ \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XX\", \"XXI\",\n        \"XXII\"\
    , \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"\
    XX\",\n        \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\"\
    , \"XXVIII\", \"XXIX\",\n        \"XX\", \"XXI\", \"XXII\", \"XX\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzp8paclv_test.go:30:30: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075731
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_numerals := []string{\n\
    \        \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"\
    IX\", \"X\", \"XI\", \"XII\", \"XIII\",\n        \"XIV\", \"XV\", \"XVI\", \"\
    XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\",\n\
    \        \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\"\
    , \"XXXII\", \"XXXIII\", \"XXXIV\",\n        \"XXXV\", \"XXXVI\", \"XXXVII\",\
    \ \"XXXVIII\", \"XXXIX\", \"XL\", \"L\", \"LI\", \"LXI\", \"LXII\", \"LXIII\"\
    ,\n        \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\", \"LXIX\", \"LXX\"\
    , \"LXXI\", \"LXXII\", \"LXXIII\",\n        \"LXXIV\", \"LXXV\", \"LXXVI\", \"\
    LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\",\n        \"\
    LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\"\
    , \"XC\", \"C\", \"CI\",\n        \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\"\
    , \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\",\n        \"CC\"\
    , \"CCI\", \"CCII\", \"CCIII\", \"CCIV\", \"CCV\", \"CCVI\", \"CCVII\", \"CCVIII\"\
    , \"CCIX\",\n        \"CD\", \"CDI\", \"CDII\", \"CDIII\", \"CDIV\", \"CDV\",\
    \ \"CDVI\", \"CDVII\", \"CDVIII\", \"CDIX\",\n        \"CDE\", \"CDEI\", \"CDEII\"\
    , \"CDEIII\", \"CDEIV\", \"CDEV\", \"CDEVI\", \"CDEVII\", \"CDEVIII\",\n     \
    \   \"CDEIX\", \"XD\", \"XDI\", \"XDII\", \"XDIII\", \"XDIIII\", \"XDIIV\", \"\
    XDIV\", \"XDIVI\", \"XDIVII\",\n        \"XDIVIII\", \"XDIIX\", \"XDIXX\", \"\
    XDIXXI\", \"XDIXXII\", \"XDIXXIII\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n\
    \  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8n98ou_1_test.go:26:59: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075731
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := []string{\n       \
    \ \"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"\
    D\", \"CM\", \"M\"\n    }\n    roman_number := 0\n    for _, roman_letter := range\
    \ romans {\n        if number >= roman_letter {\n            roman_number += roman_letter\
    \ - number\n            number -= roman_letter\n        }\n    }\n    return fmt.Sprintf(\"\
    %c\", roman_number)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8_3gnwp5_test.go:14:78: missing '','' before newline in composite literal

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075731
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := []string{\n       \
    \ \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"\
    X\", \"XI\", \"XII\", \"XIII\",\n        \"XIV\", \"XV\", \"XVI\", \"XVII\", \"\
    XVIII\", \"XIX\", \"XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\",\n        \"\
    XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\", \"XXXII\"\
    , \"XXXIII\", \"XXXIV\",\n        \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\"\
    , \"XXXIX\", \"XL\", \"L\", \"LI\", \"LXI\", \"LXII\", \"LXIII\",\n        \"\
    LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\", \"LXIX\", \"LXX\", \"LXXI\"\
    , \"LXXII\", \"LXXIII\",\n        \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\",\
    \ \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\",\n        \"LXXXIII\"\
    , \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\", \"\
    XC\", \"C\", \"CI\",\n        \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\",\
    \ \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\",\n        \"CXXI\"\
    , \"CXXII\", \"CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"CXXVII\", \"CXXVIII\"\
    , \"CXXIX\",\n        \"CXXX\", \"CXXXI\", \"CXXXII\", \"CXXXIII\", \"CXXXIV\"\
    , \"CXXXV\", \"CXXXVI\", \"CXXXVII\", \"CXXXVIII\",\n        \"CXXXIX\", \"CD\"\
    , \"D\", \"DI\", \"DII\", \"DIII\", \"DIIII\", \"DIIV\", \"DIV\", \"DIVI\", \"\
    DIVII\",\n        \"DIVIII\", \"DIX\", \"DX\", \"DXI\", \"DXII\", \"DXIII\", \"\
    DXIV\", \"DXV\", \"DXVI\", \"DXVII\", \"DXVIII\",\n        \"DXIX\", \"DXX\",\
    \ \"DXXI\", \"DXXII\", \"DXXIII\", \"DXXIV\", \"DXXV\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpb3o2bc6b_test.go:26:60: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075731
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_numerals := map[int]string{\n\
    \        1: \"I\",\n        5: \"V\",\n        10: \"X\",\n        50: \"L\",\n\
    \        100: \"C\",\n        500: \"D\",\n        1000: \"M\",\n    }\n\n   \
    \ roman_number := 0\n    for number > 0 {\n        roman_number += number % 10\n\
    \        number /= 10\n    }\n\n    return roman_numerals[roman_number]\n}\n\n\
    func TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmp55p4pkwr_test.go:58: expected 'xix', got 'X'\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmp55p4pkwr_test.go:58: expected\
    \ 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n  \
    \      tmp55p4pkwr_test.go:58: expected 'ccli', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmp55p4pkwr_test.go:58: expected 'cdxxvi', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmp55p4pkwr_test.go:58:\
    \ expected 'd', got 'V'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n\
    \        tmp55p4pkwr_test.go:58: expected 'i', got 'I'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6\
    \ (0.00s)\n        tmp55p4pkwr_test.go:58: expected 'iv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmp55p4pkwr_test.go:58: expected\
    \ 'xliii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n \
    \       tmp55p4pkwr_test.go:58: expected 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9\
    \ (0.00s)\n        tmp55p4pkwr_test.go:58: expected 'xciv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmp55p4pkwr_test.go:58:\
    \ expected 'dxxxii', got 'X'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11\
    \ (0.00s)\n        tmp55p4pkwr_test.go:58: expected 'cm', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmp55p4pkwr_test.go:58:\
    \ expected 'cmxciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmp55p4pkwr_test.go:58: expected 'm', got 'I'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075732
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := []string{\n       \
    \ \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\",\n\
    \        \"X\", \"XI\", \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\"\
    , \"XVIII\", \"XIX\",\n        \"XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\"\
    , \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\",\n        \"XXX\", \"XXIII\"\
    , \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXXI\", \"XXXII\"\
    , \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\"\
    ,\n        \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"LXXXX\", \"LXXXXX\", \"\
    LXXXXXX\", \"LXXXXXX\", \"LXXXXXXX\", \"LXXXXXII\", \"LXXXXXIII\", \"LXXXXXIV\"\
    , \"LXXXXXV\", \"LXXXXXVI\", \"LXXXXXVII\", \"LXXXXXVIII\", \"LXXXXXIX\",\n  \
    \      \"LXXX\", \"LXXXXI\", \"LXXXXII\", \"LXXXXIII\", \"LXXXXIV\", \"LXXXXV\"\
    , \"LXXXXVI\", \"LXXXXVII\", \"LXXXXVIII\", \"LXXXXIX\", \"LXX\", \"LXXI\", \"\
    LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\", \"LXXVIII\",\
    \ \"LXXIX\",\n        \"LXXXI\", \"LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\"\
    , \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\", \"LXXXX\", \"LXXXXX\", \"\
    LXXXXXX\", \"LXXXXXX\", \"LXXXXXXX\", \"LXXXXXII\", \"LXXXXXIII\", \"LXXXXXIV\"\
    , \"LXXXXXV\", \"LXXXXXVI\", \"LXXXXXVII\", \"LXXXXXVIII\", \"LXXXXXIX\",\n  \
    \      \"LXXXXI\", \"LXXXXII\", \"LXXXXIII\", \"LXXXXIV\", \"LXXXXV\", \"LXXXXVI\"\
    , \"LXXXXVII\", \"LXXXXVIII\", \"LXXXXIX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"\
    LXXIV\", \"LXXV\", \"LXXVI\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7dsshj5r_test.go:21:154: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075732
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_numerals := []string{\"\
    I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\"\
    , \"XI\", \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"\
    XIX\", \"XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\"\
    , \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"\
    XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\", \"L\", \"LI\",\
    \ \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\"\
    , \"LXVIII\", \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"\
    LXXV\", \"LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"\
    LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\"\
    , \"LXXXIX\", \"XC\", \"C\", \"CI\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"\
    CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\", \"CXXI\"\
    , \"CXXII\", \"CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"CXXVII\", \"CXXVIII\"\
    , \"CXXIX\", \"CXXX\", \"CXXXI\", \"CXXXII\", \"CXXXIII\", \"CXXXIV\", \"CXXXV\"\
    , \"CXXXVI\", \"CXXXVII\", \"CXXXVIII\", \"CXXXIX\", \"CXL\", \"CL\", \"CLI\"\
    , \"CLX\", \"CLXI\", \"CLXII\", \"CLXIII\", \"CLXIV\", \"CLXV\", \"CLXVI\", \"\
    CLXVII\", \"CLXVIII\", \"CLXIX\", \"CLXX\", \"CLXXI\", \"CLXXII\", \"CLXXIII\"\
    , \"CLXXIV\", \"CLXXV\", \"CLXXVI\", \"CLXXVII\", \"CLXXVIII\", \"CLXXIX\", \"\
    CLXXX\", \"CLXXXI\", \"CLXXXII\", \"CLXXXIII\", \"CLXXX\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphcop623z_test.go:13:1154: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075728
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_numerals := []string{\"\
    I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\"\
    , \"XI\", \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"\
    XIX\", \"XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\"\
    , \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"\
    XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\", \"L\", \"LI\",\
    \ \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\"\
    , \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"\
    LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\",\
    \ \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"\
    LXXXIX\", \"XC\", \"C\", \"CI\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\"\
    , \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\", \"CXXI\"\
    , \"CXXII\", \"CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"CXXVII\", \"CXXVIII\"\
    , \"CXXIX\", \"CXXX\", \"CXXXI\", \"CXXXII\", \"CXXXIII\", \"CXXXIV\", \"CXXXV\"\
    , \"CXXXVI\", \"CXXXVII\", \"CXXXVIII\", \"CXXXIX\", \"CC\", \"CCI\", \"CCII\"\
    , \"CCIII\", \"CCIV\", \"CCV\", \"CCVI\", \"CCVII\", \"CCVIII\", \"CCIX\", \"\
    CCL\", \"CCLI\", \"CCLII\", \"CCLIII\", \"CCLIV\", \"CCLV\", \"CCLVI\", \"CCLVII\"\
    , \"CCLVIII\", \"CCLIX\", \"CCL\", \"CCLI\", \"CCLXI\", \"CCLXII\", \"CCLXIII\"\
    , \"CCLXIV\", \"CCLXV\", \"CCLX\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n\
    \  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxoamoa11_test.go:13:1137: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075732
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := []string{\n       \
    \ \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"\
    X\", \"XI\", \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\"\
    , \"XIX\", \"XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\",\
    \ \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"\
    XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\", \"L\"\
    , \"LI\", \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\", \"\
    LIX\", \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\"\
    , \"LXVIII\", \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"\
    LXXV\", \"LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"\
    LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\"\
    , \"LXXXIX\", \"XC\", \"C\", \"CI\", \"CII\", \"CIV\", \"CV\", \"CVI\", \"CVII\"\
    , \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"CXV\"\
    , \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CC\", \"CCI\", \"CCII\", \"CCIII\"\
    , \"CCIV\", \"CCV\", \"CCVI\", \"CCVII\", \"CCVIII\", \"CCIX\", \"CD\", \"CD\"\
    , \"CDI\", \"CDII\", \"CDII\", \"CDIII\", \"CDIV\", \"CDV\", \"CDVI\", \"CDVII\"\
    , \"CDVIII\", \"CDIX\", \"CDE\", \"CDEI\", \"CDEII\", \"CDEIII\", \"CDEIV\", \"\
    CDEV\", \"CDEVI\", \"CDEVII\", \"CDEVIII\", \"CDEVIV\", \"CDEVV\", \"CDEVVI\"\
    , \"CDEVVII\", \"CDEVVIII\", \"CDEVIX\", \"CDF\", \"CDF\", \"CDFI\", \"CDFII\"\
    , \"CDFIII\", \"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp11ma4_tn_test.go:14:1157: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075732
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_numerals := []string{\n\
    \        \"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"\
    CD\", \"D\", \"CM\", \"M\"\n    }\n    roman_numeral := roman_numerals[number%100]\n\
    \    number /= 100\n    for number > 0 {\n        roman_numeral += roman_numerals[number%10]\n\
    \        number /= 10\n    }\n    return strings.ToLower(roman_numeral)\n}\n\n\
    func TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpkjzea4kx_test.go:14:78: missing '','' before newline in composite literal

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075732
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_numerals := map[int]string{\n\
    \        1: \"I\",\n        5: \"V\",\n        10: \"X\",\n        50: \"L\",\n\
    \        100: \"C\",\n        500: \"D\",\n        1000: \"M\",\n    }\n    roman_numeral\
    \ := roman_numerals[number]\n    return strings.ToLower(roman_numeral)\n}\n\n\
    func TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnwct1mw7_test.go:23:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075730
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000\
    \ {\n        fmt.Println(\"Invalid input\")\n    }\n    roman_numerals := []string{\n\
    \        \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"\
    IX\", \"X\", \"XI\", \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"\
    XVIII\", \"XIX\", \"XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"\
    XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\"\
    , \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XX\",\
    \ \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\"\
    , \"XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\", \"\
    XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\", \"XLI\", \"XLII\", \"XLIII\"\
    , \"XLIV\", \"XLIVI\", \"XLIVII\", \"XLIVIII\", \"XLIIX\", \"L\", \"LI\", \"LII\"\
    , \"LIII\", \"LIV\", \"LIVI\", \"LIVII\", \"LIVIII\", \"LIIX\", \"L\", \"LI\"\
    , \"LII\", \"LIII\", \"LIV\", \"LIVI\", \"LIVII\", \"LIVIII\", \"LIIX\", \"L\"\
    , \"LI\", \"LII\", \"LIII\", \"LIV\", \"LIVI\", \"LIVII\", \"LIVIII\", \"LIIX\"\
    , \"L\", \"LI\", \"LII\", \"LIII\", \"LIV\", \"LIVI\", \"LIVII\", \"LIVIII\",\
    \ \"LIIX\", \"L\", \"LI\", \"LII\", \"LIII\", \"LIV\", \"LIVI\", \"LIVII\", \"\
    LIVIII\", \"LIIX\", \"L\", \"LI\", \"LII\", \"LIII\", \"LIV\", \"LIVI\", \"LIVII\"\
    , \"LIVIII\", \"LIIX\", \"L\", \"LI\", \"LII\", \"LIII\", \"LIV\", \"LIVI\", \"\
    LIVII\", \"LIVIII\", \"LIIX\", \"L\", \"LI\", \"LII\", \"LIII\", \"LIV\", \"LIVI\"\
    , \"LIVII\", \"LIVIII\", \"LIIX\", \"L\", \"LI\", \"LII\", \"LIII\", \"LIV\",\
    \ \"LIVI\", \"LIVII\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate :=\
    \ int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpkdq_h24u_test.go:17:1137: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075732
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_number := \"\"\n    switch\
    \ number {\n    case 1:\n        roman_number = \"I\"\n    case 2:\n        roman_number\
    \ = \"II\"\n    case 3:\n        roman_number = \"III\"\n    case 4:\n       \
    \ roman_number = \"IV\"\n    case 5:\n        roman_number = \"V\"\n    case 6:\n\
    \        roman_number = \"VI\"\n    case 7:\n        roman_number = \"VII\"\n\
    \    case 8:\n        roman_number = \"VIII\"\n    case 9:\n        roman_number\
    \ = \"IX\"\n    case 10:\n        roman_number = \"X\"\n    case 11:\n       \
    \ roman_number = \"XI\"\n    case 12:\n        roman_number = \"XII\"\n    case\
    \ 13:\n        roman_number = \"XIII\"\n    case 14:\n        roman_number = \"\
    XIV\"\n    case 15:\n        roman_number = \"XV\"\n    case 16:\n        roman_number\
    \ = \"XVI\"\n    case 17:\n        roman_number = \"XVII\"\n    case 18:\n   \
    \     roman_number = \"XVIII\"\n    case 19:\n        roman_number = \"XIX\"\n\
    \    case 20:\n        roman_number = \"XX\"\n    case 21:\n        roman_number\
    \ = \"XXI\"\n    case 22:\n        roman_number = \"XXII\"\n    case 23:\n   \
    \     roman_number = \"XXIII\"\n    case 24:\n        roman_number = \"XXIV\"\n\
    \    case 25:\n        roman_number = \"XXV\"\n    case 26:\n        roman_number\
    \ = \"XXVI\"\n    case 27:\n        roman_number = \"XXVII\"\n    case 28:\n \
    \       roman_number = \"XXVIII\"\n    case 29:\n        roman_number = \"XXIX\"\
    \n    case 30:\n        roman_number = \"XXX\"\n    case 31:\n        roman_number\
    \ = \"XXXI\"\n    case 32:\n        roman_number = \"XXXII\"\n    case 33:\n \
    \       roman_number = \"XXXIII\"\n    case 34:\n        roman_number = \"XXXIV\"\
    \n    case 35:\n        roman_number = \"XXXV\"\n    case 36:\n        roman_number\
    \ = \"XXXVI\"\n    case 37:\n        roman_number = \"XXXVII\"\n    case 38:\n\
    \        roman_number = \"XXXVIII\"\n    case 39:\n        roman_number = \"XXXIX\"\
    \n    case 40:\n        roman_number = \"XL\"\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7aj4t2nh_test.go:95:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075728
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := []string{\n       \
    \ \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"\
    X\", \"XI\", \"XII\",\n        \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"\
    XVIII\", \"XIX\", \"XX\", \"XXI\", \"XXII\",\n        \"XXIII\", \"XXIV\", \"\
    XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\",\n       \
    \ \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\"\
    , \"XXXIX\",\n        \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"LXXXX\", \"\
    LXXXXX\", \"LXXXXXX\", \"LXXXXXXX\",\n        \"LXXXXXV\", \"LXXXXXVI\", \"LXXXXXVII\"\
    , \"LXXXXXVIII\", \"LXXXXXIX\", \"LXXX\", \"LXXXI\",\n        \"LXXXII\", \"LXXXIII\"\
    , \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\",\n        \"LXXXIX\"\
    , \"LXXXX\", \"LXXXXI\", \"LXXXXII\", \"LXXXXIII\", \"LXXXXIV\", \"LXXXXV\",\n\
    \        \"LXXXXVI\", \"LXXXXVII\", \"LXXXXVIII\", \"LXXXXIX\", \"LXXXXX\", \"\
    LXXXXXI\", \"LXXXXXII\",\n        \"LXXXXXIII\", \"LXXXXXIV\", \"LXXXXXV\", \"\
    LXXXXXVI\", \"LXXXXXVII\", \"LXXXXXVIII\",\n        \"LXXXXXIX\", \"LXXXXXX\"\
    , \"LXXXXXXX\", \"LXXXXXXXX\", \"LXXXXXXXXI\", \"LXXXXXXXXII\",\n        \"LXXXXXXXXIII\"\
    , \"LXXXXXXXXIV\", \"LXXXXXXXXV\", \"LXXXXXXXXVI\", \"LXXXXXXXXVII\",\n      \
    \  \"LXXXXXXXXVIII\", \"LXXXXXXXXIX\", \"LXXXXXXXXXX\", \"LXXXXXXXXXXX\", \"LXXXXXXXXXXXX\"\
    ,\n        \"LXXXXXXXXXXXXI\", \"LXXXXXXXXXXXXII\", \"LXXXXXXXXXXXXIII\", \"LXXXXXXXXXXXXIV\"\
    ,\n        \"LXXXXXXXXXXXXV\", \"LXXXXXXXXXXXXVI\", \"LXXXXXXXXXXXXVII\", \"LXXXXXXXXXXXXVIII\"\
    ,\n        \"LXXXXXXXXXXXXIX\", \"LXXXXXXXXXXXXXX\", \"LXXXXXXXXXXXXXXX\", \"\
    L\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpe_1typ6e_test.go:29:67: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075732
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    var roman = make([]string, 1000)\n\
    \    var roman_num int\n    var i int\n    for i = 1000; i >= 1; i-- {\n     \
    \   roman_num = (number % i) + i\n        roman[i] = int_to_roman(roman_num)\n\
    \        number = number / i\n    }\n    return roman[0]\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpa1tb0a4c_test.go:18:20: undefined: int_to_roman

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075732
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_num := make([]string, 1000)\n\
    \    roman_num[0] = \"I\"\n    roman_num[1] = \"V\"\n    roman_num[2] = \"X\"\n\
    \    roman_num[3] = \"L\"\n    roman_num[4] = \"C\"\n    roman_num[5] = \"D\"\n\
    \    roman_num[6] = \"M\"\n    roman_num[7] = \"M\"\n    roman_num[8] = \"C\"\n\
    \    roman_num[9] = \"L\"\n    roman_num[10] = \"X\"\n    roman_num[11] = \"V\"\
    \n    roman_num[12] = \"I\"\n    roman_num[13] = \"X\"\n    roman_num[14] = \"\
    L\"\n    roman_num[15] = \"C\"\n    roman_num[16] = \"D\"\n    roman_num[17] =\
    \ \"M\"\n    roman_num[18] = \"C\"\n    roman_num[19] = \"L\"\n    roman_num[20]\
    \ = \"X\"\n    roman_num[21] = \"V\"\n    roman_num[22] = \"I\"\n    roman_num[23]\
    \ = \"X\"\n    roman_num[24] = \"L\"\n    roman_num[25] = \"C\"\n    roman_num[26]\
    \ = \"D\"\n    roman_num[27] = \"M\"\n    roman_num[28] = \"C\"\n    roman_num[29]\
    \ = \"L\"\n    roman_num[30] = \"X\"\n    roman_num[31] = \"V\"\n    roman_num[32]\
    \ = \"I\"\n    roman_num[33] = \"X\"\n    roman_num[34] = \"L\"\n    roman_num[35]\
    \ = \"C\"\n    roman_num[36] = \"D\"\n    roman_num[37] = \"M\"\n    roman_num[38]\
    \ = \"C\"\n    roman_num[39] = \"L\"\n    roman_num[40] = \"X\"\n    roman_num[41]\
    \ = \"V\"\n    roman_num[42] = \"I\"\n    roman_num[43] = \"X\"\n    roman_num[44]\
    \ = \"L\"\n    roman_num[45] = \"C\"\n    roman_num[46] = \"D\"\n    roman_num[47]\
    \ = \"M\"\n    roman_num[48] = \"C\"\n    roman_num[49] = \"L\"\n    roman_num[50]\
    \ = \"X\"\n    roman_\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmppxlswea8_test.go:66:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075732
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := []string{\n       \
    \ \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\",\n\
    \        \"X\", \"XI\", \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\"\
    , \"XVIII\", \"XIX\",\n        \"XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\"\
    , \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\",\n        \"XXX\", \"XXXI\"\
    , \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\"\
    , \"XXXIX\",\n        \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"LXXXX\", \"\
    LXXXXX\", \"LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\"\
    , \"LXXXVIII\", \"LXXXIX\",\n        \"LX\", \"LXX\", \"LXXX\", \"LXXXX\", \"\
    LXXXXX\", \"LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\"\
    , \"LXXXVIII\", \"LXXXIX\",\n        \"LXX\", \"LXXX\", \"LXXXX\", \"LXXXXX\"\
    , \"LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"\
    LXXXVIII\", \"LXXXIX\",\n        \"LXXX\", \"LXXXX\", \"LXXXXX\", \"LXXXII\",\
    \ \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"\
    LXXXIX\",\n        \"LXXX\", \"LXXXX\", \"LXXXXX\", \"LXXXII\", \"LXXXIII\", \"\
    LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\",\n    \
    \    \"LXXX\", \"LXXXX\", \"LXXXXX\", \"LXXXII\", \"LXXXIII\", \"LXXXIV\", \"\
    LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\",\n        \"LXXX\"\
    , \"LXXXX\", \"LXXXXX\", \"LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\"\
    , \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\",\n        \"LXXX\", \"LXXXX\", \"LXX\n\
    func TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5tcat3e9_test.go:25:26: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075732
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := []string{\"I\", \"\
    II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\"\
    , \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"\
    XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"\
    XXVIII\", \"XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\"\
    , \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\", \"L\", \"LI\", \"LXI\"\
    , \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\", \"\
    LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\"\
    , \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\"\
    , \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\", \"\
    XC\", \"C\", \"CI\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\",\
    \ \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\", \"CXXI\", \"CXXII\"\
    , \"CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"CXXVII\", \"CXXVIII\", \"CXXIX\"\
    , \"CXXX\", \"CXXXI\", \"CXXXII\", \"CXXXIII\", \"CXXXIV\", \"CXXXV\", \"CXXXVI\"\
    , \"CXXXVII\", \"CXXXVIII\", \"CXXXIX\", \"CC\", \"CCI\", \"CCII\", \"CCIII\"\
    , \"CCIV\", \"CCV\", \"CCVI\", \"CCVII\", \"CCVIII\", \"CCIX\", \"CCH\", \"CCHI\"\
    , \"CCHII\", \"CCHIII\", \"CCHIV\", \"CCHV\", \"CCHVI\", \"CCHVII\", \"CCHVIII\"\
    , \"CCHIX\", \"XD\", \"D\", \"DI\", \"DII\", \"DIII\", \"DIIII\", \"DIIV\", \"\
    DIV\", \"DIVI\", \"DIVII\", \"DIVIII\", \"DIIX\", \"DX\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbv10xnyh_test.go:13:1156: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075732
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_num := \"\"\n    switch\
    \ number {\n    case 1:\n        roman_num = \"I\"\n    case 2:\n        roman_num\
    \ = \"II\"\n    case 3:\n        roman_num = \"III\"\n    case 4:\n        roman_num\
    \ = \"IV\"\n    case 5:\n        roman_num = \"V\"\n    case 6:\n        roman_num\
    \ = \"VI\"\n    case 7:\n        roman_num = \"VII\"\n    case 8:\n        roman_num\
    \ = \"VIII\"\n    case 9:\n        roman_num = \"IX\"\n    case 10:\n        roman_num\
    \ = \"X\"\n    case 11:\n        roman_num = \"XI\"\n    case 12:\n        roman_num\
    \ = \"XII\"\n    case 13:\n        roman_num = \"XIII\"\n    case 14:\n      \
    \  roman_num = \"XIV\"\n    case 15:\n        roman_num = \"XV\"\n    case 16:\n\
    \        roman_num = \"XVI\"\n    case 17:\n        roman_num = \"XVII\"\n   \
    \ case 18:\n        roman_num = \"XVIII\"\n    case 19:\n        roman_num = \"\
    XIX\"\n    case 20:\n        roman_num = \"XX\"\n    case 21:\n        roman_num\
    \ = \"XXI\"\n    case 22:\n        roman_num = \"XXII\"\n    case 23:\n      \
    \  roman_num = \"XXIII\"\n    case 24:\n        roman_num = \"XXIV\"\n    case\
    \ 25:\n        roman_num = \"XXV\"\n    case 26:\n        roman_num = \"XXVI\"\
    \n    case 27:\n        roman_num = \"XXVII\"\n    case 28:\n        roman_num\
    \ = \"XXVIII\"\n    case 29:\n        roman_num = \"XXIX\"\n    case 30:\n   \
    \     roman_num = \"XXX\"\n    case 31:\n        roman_num = \"XXXI\"\n    case\
    \ 32:\n        roman_num = \"XXXII\"\n    case 33:\n        roman_num = \"XXXIII\"\
    \n    case 34:\n        roman_num = \"XXXIV\"\n    case 35:\n        roman_num\
    \ = \"XXXV\"\n    case 36:\n        roman_num = \"XXXVI\"\n    case 37:\n    \
    \    roman_num = \"XXXVII\"\n    case 38:\n        roman_num = \"XXXVIII\"\n \
    \   case 39:\n        roman_num = \"XXXIX\"\n    case 40:\n        roman_num =\
    \ \"XL\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8xvbo_2c_test.go:95:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075728
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_number := \"\"\n    switch\
    \ number {\n    case 1:\n        roman_number = \"I\"\n    case 2:\n        roman_number\
    \ = \"II\"\n    case 3:\n        roman_number = \"III\"\n    case 4:\n       \
    \ roman_number = \"IV\"\n    case 5:\n        roman_number = \"V\"\n    case 6:\n\
    \        roman_number = \"VI\"\n    case 7:\n        roman_number = \"VII\"\n\
    \    case 8:\n        roman_number = \"VIII\"\n    case 9:\n        roman_number\
    \ = \"IX\"\n    case 10:\n        roman_number = \"X\"\n    case 11:\n       \
    \ roman_number = \"XI\"\n    case 12:\n        roman_number = \"XII\"\n    case\
    \ 13:\n        roman_number = \"XIII\"\n    case 14:\n        roman_number = \"\
    XIV\"\n    case 15:\n        roman_number = \"XV\"\n    case 16:\n        roman_number\
    \ = \"XVI\"\n    case 17:\n        roman_number = \"XVII\"\n    case 18:\n   \
    \     roman_number = \"XVIII\"\n    case 19:\n        roman_number = \"XIX\"\n\
    \    case 20:\n        roman_number = \"XX\"\n    case 21:\n        roman_number\
    \ = \"XXI\"\n    case 22:\n        roman_number = \"XXII\"\n    case 23:\n   \
    \     roman_number = \"XXIII\"\n    case 24:\n        roman_number = \"XXIV\"\n\
    \    case 25:\n        roman_number = \"XXV\"\n    case 26:\n        roman_number\
    \ = \"XXVI\"\n    case 27:\n        roman_number = \"XXVII\"\n    case 28:\n \
    \       roman_number = \"XXVIII\"\n    case 29:\n        roman_number = \"XXIX\"\
    \n    case 30:\n        roman_number = \"XXX\"\n    case 31:\n        roman_number\
    \ = \"XXXI\"\n    case 32:\n        roman_number = \"XXXII\"\n    case 33:\n \
    \       roman_number = \"XXXIII\"\n    case 34:\n        roman_number = \"XXXIV\"\
    \n    case 35:\n        roman_number = \"XXXV\"\n    case 36:\n        roman_number\
    \ = \"XXXVI\"\n    case 37:\n        roman_number = \"XXXVII\"\n    case 38:\n\
    \        roman_number = \"XXXVIII\"\n    case 39:\n        roman_number = \"XXXIX\"\
    \n    case 40:\n        roman_number = \"XL\"\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7aj4t2nh_test.go:95:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075728
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := []string{\n       \
    \ \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"\
    X\", \"XI\", \"XII\",\n        \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"\
    XVIII\", \"XIX\", \"XX\", \"XXI\", \"XXII\",\n        \"XXIII\", \"XXIV\", \"\
    XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\",\n       \
    \ \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\"\
    , \"XXXIX\",\n        \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"LXXXX\", \"\
    LXXXXX\", \"LXXXII\", \"LXXXIII\",\n        \"LXXXIV\", \"LXXXV\", \"LXXXVI\"\
    , \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\", \"LXXXVIII\",\n        \"XC\", \"C\"\
    , \"CXX\", \"CXXX\", \"CXXXX\", \"CXXXXX\", \"CXXXII\", \"CXXXIII\", \"CXXXIV\"\
    ,\n        \"CXXXV\", \"CXXXVI\", \"CXXXVII\", \"CXXXVIII\", \"CXXXIX\", \"CXXXVIII\"\
    , \"CXXXIX\",\n        \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"DCCD\", \"\
    DCCCC\", \"DCD\", \"DCDC\", \"DCC\",\n        \"DCCC\", \"DCD\", \"DCDC\", \"\
    DCC\", \"DCCC\", \"DCD\", \"DCDC\", \"DCC\", \"DCCC\", \"DCD\",\n        \"DCDC\"\
    , \"DCC\", \"DCCC\", \"DCD\", \"DCDC\", \"DCC\", \"DCCC\", \"DCD\", \"DCDC\",\
    \ \"DCC\",\n        \"DCCC\", \"DCD\", \"DCDC\", \"DCC\", \"DCCC\", \"DCD\", \"\
    DCDC\", \"DCC\", \"DCCC\", \"DCD\",\n        \"DCDC\", \"DCC\", \"DCCC\", \"DCD\"\
    , \"DCDC\", \"DCC\", \"DCCC\", \"DCD\", \"DCDC\", \"DCC\",\n        \"DCCC\",\
    \ \"DCD\", \"DCDC\", \"DCC\", \"DCCC\", \"DCD\", \"DCDC\", \"DCC\", \"DCCC\",\
    \ \"DCD\",\n        \"DCDC\", \"DCC\", \"DCCC\", \"DCD\", \"DCDC\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpd5zbxokm_test.go:28:39: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075732
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_num := \"\"\n    switch\
    \ number {\n    case 1:\n        roman_num = \"I\"\n    case 2:\n        roman_num\
    \ = \"II\"\n    case 3:\n        roman_num = \"III\"\n    case 4:\n        roman_num\
    \ = \"IV\"\n    case 5:\n        roman_num = \"V\"\n    case 6:\n        roman_num\
    \ = \"VI\"\n    case 7:\n        roman_num = \"VII\"\n    case 8:\n        roman_num\
    \ = \"VIII\"\n    case 9:\n        roman_num = \"IX\"\n    case 10:\n        roman_num\
    \ = \"X\"\n    case 11:\n        roman_num = \"XI\"\n    case 12:\n        roman_num\
    \ = \"XII\"\n    case 13:\n        roman_num = \"XIII\"\n    case 14:\n      \
    \  roman_num = \"XIV\"\n    case 15:\n        roman_num = \"XV\"\n    case 16:\n\
    \        roman_num = \"XVI\"\n    case 17:\n        roman_num = \"XVII\"\n   \
    \ case 18:\n        roman_num = \"XVIII\"\n    case 19:\n        roman_num = \"\
    XIX\"\n    case 20:\n        roman_num = \"XX\"\n    case 21:\n        roman_num\
    \ = \"XXI\"\n    case 22:\n        roman_num = \"XXII\"\n    case 23:\n      \
    \  roman_num = \"XXIII\"\n    case 24:\n        roman_num = \"XXIV\"\n    case\
    \ 25:\n        roman_num = \"XXV\"\n    case 26:\n        roman_num = \"XXVI\"\
    \n    case 27:\n        roman_num = \"XXVII\"\n    case 28:\n        roman_num\
    \ = \"XXVIII\"\n    case 29:\n        roman_num = \"XXIX\"\n    case 30:\n   \
    \     roman_num = \"XXX\"\n    case 31:\n        roman_num = \"XXXI\"\n    case\
    \ 32:\n        roman_num = \"XXXII\"\n    case 33:\n        roman_num = \"XXXIII\"\
    \n    case 34:\n        roman_num = \"XXXIV\"\n    case 35:\n        roman_num\
    \ = \"XXXV\"\n    case 36:\n        roman_num = \"XXXVI\"\n    case 37:\n    \
    \    roman_num = \"XXXVII\"\n    case 38:\n        roman_num = \"XXXVIII\"\n \
    \   case 39:\n        roman_num = \"XXXIX\"\n    case 40:\n        roman_num =\
    \ \"XL\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8xvbo_2c_test.go:95:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075728
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_numerals := map[int]string{\n\
    \        1: \"I\",\n        2: \"II\",\n        3: \"III\",\n        4: \"IV\"\
    ,\n        5: \"V\",\n        6: \"VI\",\n        7: \"VII\",\n        8: \"VIII\"\
    ,\n        9: \"IX\",\n        10: \"X\",\n        11: \"XI\",\n        12: \"\
    XII\",\n        13: \"XIII\",\n        14: \"XIV\",\n        15: \"XV\",\n   \
    \     16: \"XVI\",\n        17: \"XVII\",\n        18: \"XVIII\",\n        19:\
    \ \"XIX\",\n        20: \"XX\",\n        30: \"XXI\",\n        40: \"XL\",\n \
    \       50: \"L\",\n        60: \"LX\",\n        70: \"LXX\",\n        80: \"\
    LXXX\",\n        90: \"XC\",\n        100: \"C\",\n        1000: \"C\",\n    }\n\
    \    roman_numeral := \"\"\n    for roman_numeral, number := range roman_numerals\
    \ {\n        if number >= number {\n            break\n        }\n    }\n    if\
    \ number > 1000 {\n        fmt.Println(\"Error: number too large\")\n    }\n \
    \   return roman_numeral\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpadr5yl82_test.go:45:9: roman_numeral declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075732
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := []string{\n       \
    \ \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"\
    X\", \"XI\", \"XII\",\n        \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"\
    XVIII\", \"XIX\", \"XX\", \"XXI\", \"XXII\",\n        \"XXIII\", \"XXIV\", \"\
    XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\",\n       \
    \ \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\"\
    , \"XXXIX\",\n        \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"LXXXX\", \"\
    LXXXXX\", \"LXXXXXX\", \"LXXXXXXX\",\n        \"LXXXXXV\", \"LXXXXXVI\", \"LXXXXXVII\"\
    , \"LXXXXXVIII\", \"LXXXXXIX\", \"LXXX\", \"LXXXI\",\n        \"LXXXII\", \"LXXXIII\"\
    , \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\",\n        \"LXXXIX\"\
    , \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\",\n\
    \        \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\",\
    \ \"LXXXIII\", \"LXXXIV\",\n        \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\"\
    , \"LXXXIX\", \"LXL\", \"LXLI\", \"LXLII\",\n        \"LXLIII\", \"LXLIV\", \"\
    LXLV\", \"LXLVI\", \"LXLVII\", \"LXLVIII\", \"LXLIX\", \"LXX\",\n        \"LXXI\"\
    , \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\", \"LXXVIII\"\
    ,\n        \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\", \"LXXXIV\"\
    , \"LXXXV\", \"LXXXVI\",\n        \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\", \"LXL\"\
    , \"LXLI\", \"LXLII\", \"LXLIII\", \"LXLIV\",\n        \"LXLV\", \"\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7s88fyax_test.go:28:17: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075732
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_numerals := []string{\n\
    \        \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"\
    IX\", \"X\", \"XI\", \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"\
    XVIII\", \"XIX\", \"XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"\
    XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\"\
    , \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\",\
    \ \"L\", \"LI\", \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\"\
    , \"LIX\", \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\",\
    \ \"LXVII\", \"LXVIII\", \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"\
    LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"\
    LXXXI\", \"LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\"\
    , \"LXXXVIII\", \"LXXXIX\", \"XC\", \"C\", \"CI\", \"CII\", \"CIV\", \"CV\", \"\
    CVI\", \"CVII\", \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"\
    CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\", \"CXXI\"\
    , \"CXXII\", \"CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"CXXVII\", \"CXXVIII\"\
    , \"CXXIX\", \"CXXX\", \"CXXXI\", \"CXXXII\", \"CXXXIII\", \"CXXXIV\", \"CXXXV\"\
    , \"CXXXVI\", \"CXXXVII\", \"CXXXVIII\", \"CXXXIX\", \"CXL\", \"CL\", \"LI\",\
    \ \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\", \"LIX\", \"\
    LX\", \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"\
    \nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbe6hfw2i_test.go:14:1129: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075732
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_numerals := []string{\n\
    \        \"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"\
    CD\", \"D\", \"CM\",\n        \"M\", \"MM\", \"MMM\", \"MMMM\", \"MMMMM\", \"\
    MMMMMM\", \"MMMMMMM\", \"MMMMMMMM\",\n        \"MMMMMMMMM\", \"MMMMMMMMMM\", \"\
    MMMMMMMMMMM\", \"MMMMMMMMMMMM\", \"MMMMMMMMMMMMM\",\n        \"MMMMMMMMMMMMMM\"\
    , \"MMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMMM\",\n        \"\
    MMMMMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMMMMMM\",\n   \
    \     \"MMMMMMMMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMMMMMMMMM\"\
    ,\n        \"MMMMMMMMMMMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMMMMMMMMMMMM\"\
    ,\n        \"MMMMMMMMMMMMMMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\"\
    , \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\",\n        \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\"\
    , \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\"\
    ,\n        \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\"\
    , \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\",\n        \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\"\
    , \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\"\
    ,\n        \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\"\
    , \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\",\n        \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\"\
    , \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\"\
    ,\n        \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\"\
    , \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\",\n        \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\"\
    , \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\"\
    ,\n        \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\", \"\
    MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\"\
    ,\n        \"MMMMMMMMMMMMMMMM\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpt7xoh6w__test.go:30:9: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075732
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := []string{\n       \
    \ \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\",\n\
    \        \"X\", \"XI\", \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\"\
    , \"XVIII\", \"XIX\",\n        \"XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\"\
    , \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\",\n        \"XXX\", \"XXXI\"\
    , \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\"\
    , \"XXXIX\",\n    }\n    romanIndex := 0\n    romanNum := \"\"\n    romanNumLen\
    \ := 0\n    romanNumStr := \"\"\n    romanNumStrLen := 0\n    romanNumStr2 :=\
    \ \"\"\n    romanNumStr2Len := 0\n    romanNumStr3 := \"\"\n    romanNumStr3Len\
    \ := 0\n    romanNumStr4 := \"\"\n    romanNumStr4Len := 0\n    romanNumStr5 :=\
    \ \"\"\n    romanNumStr5Len := 0\n    romanNumStr6 := \"\"\n    romanNumStr6Len\
    \ := 0\n    romanNumStr7 := \"\"\n    romanNumStr7Len := 0\n    romanNumStr8 :=\
    \ \"\"\n    romanNumStr8Len := 0\n    romanNumStr9 := \"\"\n    romanNumStr9Len\
    \ := 0\n    romanNumStr10 := \"\"\n    romanNumStr10Len := 0\n    romanNumStr11\
    \ := \"\"\n    romanNumStr11Len := 0\n    romanNumStr12 := \"\"\n    romanNumStr12Len\
    \ := 0\n    romanNumStr13 := \"\"\n    romanNumStr13Len := 0\n    romanNumStr14\
    \ := \"\"\n    romanNumStr14Len := 0\n    romanNumStr15 := \"\"\n    romanNumStr15Len\
    \ := 0\n    romanNumStr16 := \"\"\n    romanNumStr16Len := 0\n    romanNumStr17\
    \ := \"\"\n    romanNumStr17Len := 0\n    romanNumStr18 := \"\"\n    romanNumStr18Len\
    \ := 0\n    romanNumStr\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpai95yzie_test.go:59:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075732
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_numerals := []string{\n\
    \        \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"\
    IX\", \"X\", \"XI\", \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"\
    XVIII\", \"XIX\", \"XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"\
    XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\"\
    , \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\",\
    \ \"L\", \"LI\", \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\"\
    , \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\"\
    , \"LXVIII\", \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"\
    LXXV\", \"LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"\
    LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\"\
    , \"LXXXIX\", \"XC\", \"C\", \"CI\", \"CII\", \"CIV\", \"CV\", \"CVI\", \"CVII\"\
    , \"CVIII\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\"\
    , \"CXVII\", \"CXVIII\", \"CXIX\", \"CC\", \"CCI\", \"CCII\", \"CCIII\", \"CCIV\"\
    , \"CCV\", \"CCVI\", \"CCVII\", \"CCVIII\", \"CCIX\", \"CD\", \"CD\", \"CDI\"\
    , \"CDII\", \"CDII\", \"CDIII\", \"CDIV\", \"CDV\", \"CDVI\", \"CDVII\", \"CDVIII\"\
    , \"CDIX\", \"CDE\", \"CDEI\", \"CDEII\", \"CDEIII\", \"CDEIV\", \"CDEV\", \"\
    CDEVI\", \"CDEVII\", \"CDEVIII\", \"CDEVIV\", \"CDEVV\", \"CDEVVI\", \"CDEVVII\"\
    , \"CDEVVIII\", \"CDEVIX\", \"CDF\", \"CDF\", \"CDFI\", \"CDFII\", \"CDFIII\"\
    , \"CDFIIII\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp66bpdqt6_test.go:14:1143: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075732
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := []string{\"I\", \"\
    II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\"\
    , \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"\
    XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"\
    XXVIII\", \"XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\"\
    , \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\", \"L\", \"LI\", \"LX\"\
    , \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\"\
    , \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"\
    LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\",\
    \ \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"\
    LXXXIX\", \"XC\", \"C\", \"CI\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\"\
    , \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\", \"CXXI\", \"CXXII\"\
    , \"CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"CXXVII\", \"CXXVIII\", \"CXXIX\"\
    , \"CXXX\", \"CXXXI\", \"CXXXII\", \"CXXXIII\", \"CXXXIV\", \"CXXXV\", \"CXXXVI\"\
    , \"CXXXVII\", \"CXXXVIII\", \"CXXXIX\", \"CXL\", \"CL\", \"CLI\", \"CLX\", \"\
    CLXI\", \"CLXII\", \"CLXIII\", \"CLXIV\", \"CLXV\", \"CLXVI\", \"CLXVII\", \"\
    CLXVIII\", \"CLXIX\", \"CLXX\", \"CLXXI\", \"CLXXII\", \"CLXXIII\", \"CLXXIV\"\
    , \"CLXXV\", \"CLXXVI\", \"CLXXVII\", \"CLXXVIII\", \"CLXXIX\", \"CLXXX\", \"\
    CLXXXI\", \"CLXXXII\", \"CLXXXIII\", \"CLXXXIV\", \"\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_n0byut9_test.go:13:1157: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075730
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := map[int]string{\n \
    \       1: \"I\",\n        5: \"V\",\n        10: \"X\",\n        50: \"L\",\n\
    \        100: \"C\",\n        500: \"D\",\n        1000: \"M\",\n    }\n    roman,\
    \ ok := romans[number]\n    if !ok {\n        fmt.Println(\"Invalid input\")\n\
    \    }\n    return roman\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Invalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid input\n\
    Invalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid\
    \ input\n--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmpcwfbu4ek_test.go:55: expected 'xix', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpcwfbu4ek_test.go:55: expected\
    \ 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n  \
    \      tmpcwfbu4ek_test.go:55: expected 'ccli', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmpcwfbu4ek_test.go:55: expected 'cdxxvi', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpcwfbu4ek_test.go:55:\
    \ expected 'd', got 'D'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n\
    \        tmpcwfbu4ek_test.go:55: expected 'i', got 'I'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6\
    \ (0.00s)\n        tmpcwfbu4ek_test.go:55: expected 'iv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmpcwfbu4ek_test.go:55: expected\
    \ 'xliii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n \
    \       tmpcwfbu4ek_test.go:55: expected 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9\
    \ (0.00s)\n        tmpcwfbu4ek_test.go:55: expected 'xciv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmpcwfbu4ek_test.go:55:\
    \ expected 'dxxxii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11\
    \ (0.00s)\n        tmpcwfbu4ek_test.go:55: expected 'cm', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpcwfbu4ek_test.go:55:\
    \ expected 'cmxciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmpcwfbu4ek_test.go:55: expected 'm', got 'M'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075729
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_numerals := map[int]string{\n\
    \        1: \"I\",\n        5: \"V\",\n        10: \"X\",\n        50: \"L\",\n\
    \        100: \"C\",\n        500: \"D\",\n        1000: \"M\",\n    }\n    roman_numeral\
    \ := roman_numerals[number]\n    return strings.ToLower(roman_numeral)\n}\n\n\
    func TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnwct1mw7_test.go:23:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075730
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_numerals := []string{\n\
    \        \"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"\
    CD\", \"D\", \"CM\", \"M\", \"MN\", \"N\",\n        \"NM\", \"NN\", \"NX\", \"\
    XX\", \"XXL\", \"LXXX\", \"CXXX\", \"DXXX\", \"CMXXX\", \"MXXX\", \"MMM\",\n \
    \       \"MMMN\", \"MMMM\", \"MMMMM\", \"MMMMMM\", \"MMMMMMM\", \"MMMMMMMM\",\
    \ \"MMMMMMMMM\", \"MMMMMMMMMM\",\n        \"MMMMMMMMMMM\", \"MMMMMMMMMMMM\", \"\
    MMMMMMMMMMMMM\", \"MMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMM\",\n        \"MMMMMMMMMMMMMMMM\"\
    , \"MMMMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMMMMM\",\n  \
    \      \"MMMMMMMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMMMMMMMM\"\
    , \"MMMMMMMMMMMMMMMMMMM\",\n        \"MMMMMMMMMMMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMMMMMMMMMMM\"\
    , \"MMMMMMMMMMMMMMMMMMMMMMMMMM\",\n        \"MMMMMMMMMMMMMMMMMMMMMMMMMMM\", \"\
    MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMM\",\n     \
    \   \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\"\
    , \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\",\n        \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\"\
    , \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\"\
    ,\n        \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\"\
    ,\n        \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\"\
    ,\n        \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\"\
    ,\n        \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\"\
    ,\n        \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\"\
    ,\n        \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\"\
    ,\n        \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n\
    func TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpminmuszx_test.go:30:63: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075732
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := []string{\"I\", \"\
    II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\"\
    , \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"\
    XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"\
    XXVIII\", \"XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\"\
    , \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\", \"L\", \"LI\", \"LX\"\
    , \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\"\
    , \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"\
    LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\",\
    \ \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"\
    LXXXIX\", \"XC\", \"C\", \"CI\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\"\
    , \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\", \"CXXI\", \"CXXII\"\
    , \"CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"CXXVII\", \"CXXVIII\", \"CXXIX\"\
    , \"CXXX\", \"CXXXI\", \"CXXXII\", \"CXXXIII\", \"CXXXIV\", \"CXXXV\", \"CXXXVI\"\
    , \"CXXXVII\", \"CXXXVIII\", \"CXXXIX\", \"CC\", \"CCI\", \"CCX\", \"CCXI\", \"\
    CCXII\", \"CCXIII\", \"CCXIV\", \"CCXV\", \"CCXVI\", \"CCXVII\", \"CCXVIII\",\
    \ \"CCXIX\", \"CCH\", \"CCHI\", \"CCHX\", \"CCHXI\", \"CCHXII\", \"CCHXIII\",\
    \ \"CCHXIV\", \"CCHXV\", \"CCHXVI\", \"CCHXVII\", \"CCHXVIII\", \"CCHXIX\", \"\
    CCCX\", \"CCCXI\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp424h0ava_test.go:13:1120: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075728
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_numerals := []string{\"\
    I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\"\
    , \"XI\", \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"\
    XIX\", \"XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\"\
    , \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"\
    XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\", \"L\", \"LI\",\
    \ \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\", \"LIX\", \"\
    LX\", \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"\
    LXVIII\", \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\"\
    , \"LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\"\
    , \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"\
    LXXXIX\", \"XC\", \"C\", \"CI\", \"CII\", \"CIV\", \"CV\", \"CVI\", \"CVII\",\
    \ \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"CXV\"\
    , \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CC\", \"CCI\", \"CCII\", \"CCIII\"\
    , \"CCIV\", \"CCV\", \"CCVI\", \"CCVII\", \"CCVIII\", \"CCIX\", \"CCX\", \"CCXI\"\
    , \"CCXII\", \"CCXIII\", \"CCXIV\", \"CCXV\", \"CCXVI\", \"CCXVII\", \"CCXVIII\"\
    , \"CCXIX\", \"CCXX\", \"CCXXI\", \"CCXXII\", \"CCXXIII\", \"CCXXIV\", \"CCXXV\"\
    , \"CCXXVI\", \"CCXXVII\", \"CCXXVIII\", \"CCXXIX\", \"CCXXX\", \"CCXXXI\", \"\
    CCXXXII\", \"CCXXXIII\", \"CCXXXIV\", \"CCXXXV\", \"CCXXXVI\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpx0g1ysv1_test.go:13:1155: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075732
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := []string{\n       \
    \ \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"\
    X\", \"XI\", \"XII\",\n        \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"\
    XVIII\", \"XIX\", \"XX\", \"XXI\", \"XXII\",\n        \"XXIII\", \"XXIV\", \"\
    XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\",\n       \
    \ \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\"\
    , \"XXXIX\",\n        \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"LXXXX\", \"\
    LXXXXX\", \"LXXXXXX\", \"LXXXXXXX\",\n        \"LXXXXXV\", \"LXXXXXVI\", \"LXXXXXVII\"\
    , \"LXXXXXVIII\", \"LXXXXXIX\", \"LXXX\", \"LXXXI\",\n        \"LXXXII\", \"LXXXIII\"\
    , \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\",\n        \"LXXXIX\"\
    , \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\",\n\
    \        \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\",\
    \ \"LXXXIII\", \"LXXXIV\",\n        \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\"\
    , \"LXXXIX\", \"LXL\", \"LXLI\", \"LXLII\",\n        \"LXLIII\", \"LXLIIII\",\
    \ \"LXLIIV\", \"LXLIV\", \"LXLIVI\", \"LXLIVII\", \"LXLIVIII\",\n        \"LXLIIX\"\
    , \"LXLX\", \"LXLXI\", \"LXLXII\", \"LXLXIII\", \"LXLXIV\", \"LXLXV\", \"LXLXVI\"\
    ,\n        \"LXLXVII\", \"LXLXVIII\", \"LXLXIX\", \"LXLY\", \"LXLI\", \"LXLII\"\
    , \"LXLIII\", \"LXLIIII\",\n        \"LXLIIV\", \"LXLIV\", \"LXLIVI\", \"LXLIVII\"\
    , \"LXLIVIII\", \"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate :=\
    \ int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpznu_mowh_test.go:27:61: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075732
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_num := []string{\"M\",\
    \ \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"\
    IV\", \"I\"}\n    roman_num := roman_num[:len(roman_num)-number]\n    return roman_num[number]\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp84bc0xe8_test.go:14:15: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075733
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000\
    \ {\n        fmt.Println(\"Invalid input\")\n    }\n    romans := []string{\n\
    \        \"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"\
    CD\", \"D\", \"CM\", \"M\", \"MN\", \"N\",\n        \"NX\", \"X\", \"XX\", \"\
    XXL\", \"L\", \"LX\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\", \"MN\", \"\
    N\",\n        \"NX\", \"X\", \"XX\", \"XXL\", \"L\", \"LX\", \"XC\", \"C\", \"\
    CD\", \"D\", \"CM\", \"M\", \"MN\", \"N\",\n        \"NX\", \"X\", \"XX\", \"\
    XXL\", \"L\", \"LX\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\", \"MN\", \"\
    N\",\n        \"NX\", \"X\", \"XX\", \"XXL\", \"L\", \"LX\", \"XC\", \"C\", \"\
    CD\", \"D\", \"CM\", \"M\", \"MN\", \"N\",\n        \"NX\", \"X\", \"XX\", \"\
    XXL\", \"L\", \"LX\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\", \"MN\", \"\
    N\",\n        \"NX\", \"X\", \"XX\", \"XXL\", \"L\", \"LX\", \"XC\", \"C\", \"\
    CD\", \"D\", \"CM\", \"M\", \"MN\", \"N\",\n        \"NX\", \"X\", \"XX\", \"\
    XXL\", \"L\", \"LX\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\", \"MN\", \"\
    N\",\n        \"NX\", \"X\", \"XX\", \"XXL\", \"L\", \"LX\", \"XC\", \"C\", \"\
    CD\", \"D\", \"CM\", \"M\", \"MN\", \"N\",\n        \"NX\", \"X\", \"XX\", \"\
    XXL\", \"L\", \"LX\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\", \"MN\", \"\
    N\",\n        \"NX\", \"X\", \"XX\", \"XXL\", \"L\", \"LX\", \"XC\", \"C\", \"\
    CD\", \"D\", \"CM\", \"M\", \"MN\", \"N\",\n        \"NX\", \"X\", \"XX\", \"\
    XXL\", \"L\", \"LX\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\", \"MN\", \"\
    N\",\n        \"NX\", \"X\", \"XX\", \"XXL\", \"L\", \"LX\", \"XC\", \"C\", \"\
    CD\", \"D\", \"CM\", \"M\", \"MN\", \"N\",\n        \"NX\", \"X\", \"XX\", \"\
    XXL\", \"L\", \"LX\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\", \"M\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmprcejhynr_test.go:30:77: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075733
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := []string{\"I\", \"\
    II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"}\n    result :=\
    \ \"\"\n    for _, romanIndex := range romans {\n        if number >= romanIndex\
    \ {\n            result += romanIndex\n            number -= romanIndex\n    \
    \    }\n    }\n    return strings.ToLower(result)\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpk3mr_c_i_test.go:16:22: invalid operation: number >= romanIndex (mismatched
    types int and string)

    /tmp/tmpk3mr_c_i_test.go:18:13: invalid operation: number -= romanIndex (mismatched
    types int and string)

    /tmp/tmpk3mr_c_i_test.go:21:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075734
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := map[int]string{\n \
    \       1: \"I\",\n        5: \"V\",\n        10: \"X\",\n        50: \"L\",\n\
    \        100: \"C\",\n        500: \"D\",\n        1000: \"M\",\n    }\n    roman_number\
    \ := \"\"\n    for roman_number == \"\" {\n        roman_number = romans[number]\n\
    \        if roman_number == \"\" {\n            roman_number = fmt.Sprintf(\"\
    %v\", number)\n        }\n        number -= roman_number\n    }\n    return strings.ToLower(roman_number)\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2rrg3qgw_test.go:28:9: invalid operation: number -= roman_number (mismatched
    types int and string)

    /tmp/tmp2rrg3qgw_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075734
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_number := \"\"\n    switch\
    \ number {\n    case 1:\n        roman_number = \"I\"\n    case 2:\n        roman_number\
    \ = \"II\"\n    case 3:\n        roman_number = \"III\"\n    case 4:\n       \
    \ roman_number = \"IV\"\n    case 5:\n        roman_number = \"V\"\n    case 6:\n\
    \        roman_number = \"VI\"\n    case 7:\n        roman_number = \"VII\"\n\
    \    case 8:\n        roman_number = \"VIII\"\n    case 9:\n        roman_number\
    \ = \"IX\"\n    case 10:\n        roman_number = \"X\"\n    case 11:\n       \
    \ roman_number = \"XI\"\n    case 12:\n        roman_number = \"XII\"\n    case\
    \ 13:\n        roman_number = \"XIII\"\n    case 14:\n        roman_number = \"\
    XIV\"\n    case 15:\n        roman_number = \"XV\"\n    case 16:\n        roman_number\
    \ = \"XVI\"\n    case 17:\n        roman_number = \"XVII\"\n    case 18:\n   \
    \     roman_number = \"XVIII\"\n    case 19:\n        roman_number = \"XIX\"\n\
    \    case 20:\n        roman_number = \"XX\"\n    case 21:\n        roman_number\
    \ = \"XXI\"\n    case 22:\n        roman_number = \"XXII\"\n    case 23:\n   \
    \     roman_number = \"XXIII\"\n    case 24:\n        roman_number = \"XXIV\"\n\
    \    case 25:\n        roman_number = \"XXV\"\n    case 26:\n        roman_number\
    \ = \"XXVI\"\n    case 27:\n        roman_number = \"XXVII\"\n    case 28:\n \
    \       roman_number = \"XXVIII\"\n    case 29:\n        roman_number = \"XXIX\"\
    \n    case 30:\n        roman_number = \"XXX\"\n    case 31:\n        roman_number\
    \ = \"XXXI\"\n    case 32:\n        roman_number = \"XXXII\"\n    case 33:\n \
    \       roman_number = \"XXXIII\"\n    case 34:\n        roman_number = \"XXXIV\"\
    \n    case 35:\n        roman_number = \"XXXV\"\n    case 36:\n        roman_number\
    \ = \"XXXVI\"\n    case 37:\n        roman_number = \"XXXVII\"\n    case 38:\n\
    \        roman_number = \"XXXVIII\"\n    case 39:\n        roman_number = \"XXXIX\"\
    \n    case 40:\n        roman_number = \"XL\"\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7aj4t2nh_test.go:95:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075728
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romanNumerals := map[int]string{\n\
    \        1: \"I\",\n        5: \"V\",\n        10: \"X\",\n        50: \"L\",\n\
    \        100: \"C\",\n        500: \"D\",\n        1000: \"M\",\n    }\n    romanNumeral\
    \ := romanNumerals[number]\n    return strings.ToLower(romanNumeral)\n}\n\nfunc\
    \ TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmps23w240l_test.go:23:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075730
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_num := make([]string, 1000)\n\
    \    roman_num[0] = \"I\"\n    roman_num[1] = \"II\"\n    roman_num[2] = \"III\"\
    \n    roman_num[3] = \"IV\"\n    roman_num[4] = \"V\"\n    roman_num[5] = \"VI\"\
    \n    roman_num[6] = \"VII\"\n    roman_num[7] = \"VIII\"\n    roman_num[8] =\
    \ \"IX\"\n    roman_num[9] = \"X\"\n    roman_num[10] = \"XI\"\n    roman_num[11]\
    \ = \"XII\"\n    roman_num[12] = \"XIII\"\n    roman_num[13] = \"XIV\"\n    roman_num[14]\
    \ = \"XV\"\n    roman_num[15] = \"XVI\"\n    roman_num[16] = \"XVII\"\n    roman_num[17]\
    \ = \"XVIII\"\n    roman_num[18] = \"XIX\"\n    roman_num[19] = \"XX\"\n    roman_num[20]\
    \ = \"XXI\"\n    roman_num[21] = \"XXII\"\n    roman_num[22] = \"XXIII\"\n   \
    \ roman_num[23] = \"XXIV\"\n    roman_num[24] = \"XXV\"\n    roman_num[25] = \"\
    XXVI\"\n    roman_num[26] = \"XXVII\"\n    roman_num[27] = \"XXVIII\"\n    roman_num[28]\
    \ = \"XXIX\"\n    roman_num[29] = \"XXX\"\n    roman_num[30] = \"XXXI\"\n    roman_num[31]\
    \ = \"XXXII\"\n    roman_num[32] = \"XXXIII\"\n    roman_num[33] = \"XXXIV\"\n\
    \    roman_num[34] = \"XXXV\"\n    roman_num[35] = \"XXXVI\"\n    roman_num[36]\
    \ = \"XXXVII\"\n    roman_num[37] = \"XXXVIII\"\n    roman_num[38] = \"XXXIX\"\
    \n    roman_num[39] = \"XL\"\n    roman_num[40] = \"L\"\n    roman_num[41] = \"\
    LX\"\n    roman_num[42] = \"LXX\"\n    roman_num[43] = \"LXXX\"\n    roman_num[44]\
    \ = \"LXXXX\"\n    roman_num[45] = \"LXXXXX\"\n    \nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp1vpen3w7_test.go:61:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075733
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := []string{\n       \
    \ \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"\
    X\", \"XI\", \"XII\",\n        \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"\
    XVIII\", \"XIX\", \"XX\", \"XXI\", \"XXII\",\n        \"XXIII\", \"XXIV\", \"\
    XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\",\n       \
    \ \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\"\
    , \"XXXIX\",\n        \"XL\", \"L\", \"LI\", \"LII\", \"LII\", \"LIII\", \"LIV\"\
    , \"LV\", \"LVI\", \"LVII\", \"LVIII\",\n        \"LIX\", \"LX\", \"LXI\", \"\
    LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\",\n     \
    \   \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"\
    LXXVI\", \"LXXVII\",\n        \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"\
    LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\",\n        \"LXXXVI\", \"LXXXVII\"\
    , \"LXXXVIII\", \"LXXXIX\", \"XC\", \"C\", \"CI\", \"CII\", \"CII\",\n       \
    \ \"CIII\", \"CIV\", \"CV\", \"CVI\", \"CVII\", \"CVIII\", \"CIX\", \"CX\", \"\
    CXI\", \"CXII\",\n        \"CXIII\", \"CIV\", \"CV\", \"CVI\", \"CVII\", \"CVIII\"\
    , \"CIX\", \"CX\", \"CXI\", \"CXII\",\n        \"CXIII\", \"CIV\", \"CV\", \"\
    CVI\", \"CVII\", \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\",\n        \"CXIII\"\
    , \"CIV\", \"CV\", \"CVI\", \"CVII\", \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"\
    CXII\",\n        \"CXIII\", \"CIV\", \"CV\", \"CVI\", \"CVII\", \"CVIII\", \"\
    CIX\", \"CX\", \"CXI\", \"CXII\",\n        \"CXIII\", \"CIV\", \"CV\", \"CVI\"\
    , \"CVII\", \"CVIII\", \"CIX\", \"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n\
    \  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3dw9ti7g_test.go:28:62: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075733
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_numerals := []string{\n\
    \        \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"\
    IX\", \"X\", \"XI\", \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"\
    XVIII\", \"XIX\", \"XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"\
    XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\"\
    , \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\",\
    \ \"L\", \"LI\", \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\"\
    , \"LIX\", \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\",\
    \ \"LXVII\", \"LXVIII\", \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"\
    LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"\
    LXXXI\", \"LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\"\
    , \"LXXXVIII\", \"LXXXIX\", \"XC\", \"C\", \"CI\", \"CII\", \"CIV\", \"CV\", \"\
    CVI\", \"CVII\", \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"\
    CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CC\", \"CCI\", \"\
    CCII\", \"CCIII\", \"CCIV\", \"CCV\", \"CCVI\", \"CCVII\", \"CCVIII\", \"CCIX\"\
    , \"CD\", \"CD\", \"CDI\", \"CDII\", \"CDIII\", \"CDIIII\", \"CDIIV\", \"CDIV\"\
    , \"CDIVI\", \"CDIVII\", \"CDIVIII\", \"CDIX\", \"CM\", \"CMI\", \"CMII\", \"\
    CMIII\", \"CMIV\", \"CMV\", \"CMVI\", \"CMVII\", \"CMVIII\", \"CMIX\", \"C\",\
    \ \"C\", \"CI\", \"CII\", \"CIV\", \"CV\", \"CVI\", \"CVII\", \"CVIII\", \"CIX\"\
    , \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpw4psoukj_test.go:14:1157: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075733
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_numerals := []string{\n\
    \        \"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"\
    CD\", \"D\", \"CM\", \"M\", \"MM\",\n        \"MMM\",\n    }\n    roman_numeral\
    \ := \"\"\n    for _, roman_numeral_string := range roman_numerals {\n       \
    \ if number >= len(roman_numerals) {\n            break\n        }\n        if\
    \ roman_numeral_string == roman_numerals[number] {\n            roman_numeral\
    \ += roman_numeral_string\n            number -= len(roman_numerals)\n       \
    \ }\n    }\n    if number > 0 {\n        roman_numeral += roman_numerals[number]\n\
    \    }\n    return roman_numeral.ToLower()\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwcn6t43f_test.go:30:26: roman_numeral.ToLower undefined (type string has
    no field or method ToLower)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075734
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := []string{\n       \
    \ \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"\
    X\", \"XI\", \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\"\
    , \"XIX\", \"XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\",\
    \ \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"\
    XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\", \"L\"\
    , \"LI\", \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\", \"\
    LX\", \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"\
    LXVIII\", \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\"\
    , \"LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\"\
    , \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"\
    LXXXIX\", \"XC\", \"C\", \"CI\", \"CII\", \"CIV\", \"CV\", \"CVI\", \"CVII\",\
    \ \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"CXV\"\
    , \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\", \"CXXI\", \"CXXII\", \"\
    CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"CXXVII\", \"CXXVIII\", \"CXXIX\",\
    \ \"CXXX\", \"CXXXI\", \"CXXXII\", \"CXXXIII\", \"CXXXIV\", \"CXXXV\", \"CXXXVI\"\
    , \"CXXXVII\", \"CXXXVIII\", \"CXXXIX\", \"CXL\", \"CL\", \"LI\", \"LII\", \"\
    LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\", \"LX\", \"LXI\", \"LXII\"\
    , \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzparh9lr_test.go:14:1115: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075733
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := []string{\n       \
    \ \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"\
    X\", \"XI\", \"XII\",\n        \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"\
    XVIII\", \"XIX\", \"XX\", \"XXI\", \"XXII\",\n        \"XXIII\", \"XXIV\", \"\
    XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\",\n       \
    \ \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\"\
    , \"XXXIX\",\n        \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"LXXXX\", \"\
    LXXXXX\", \"LXXXXXX\", \"LXXXXXXX\",\n        \"LXXXXXV\", \"LXXXXXVI\", \"LXXXXXVII\"\
    , \"LXXXXXVIII\", \"LXXXXXIX\", \"LXXX\", \"LXXXI\",\n        \"LXXXII\", \"LXXXIII\"\
    , \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\",\n\
    \        \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"\
    LXVII\", \"LXVIII\", \"LXIX\",\n        \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\"\
    , \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\",\n      \
    \  \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\"\
    , \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\",\n        \"XC\", \"C\", \"CC\", \"CCC\"\
    , \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\", \"M\", \"MM\", \"MMM\",\n\
    \        \"MMMM\", \"MMMMM\", \"MMMMMM\", \"MMMMMMM\", \"MMMMMMMM\", \"MMMMMMMMM\"\
    , \"MMMMMMMMMM\",\n        \"MMMMMMMMMMM\", \"MMMMMMMMMMMM\", \"MMMMMMMMMMMMM\"\
    , \"MMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMM\",\n        \"MMMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMMM\"\
    , \"MMMMMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMMMMM\",\n        \"MMMMMMMMMMMMMMMMMMMM\"\
    , \"MMMMMMMMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMMMMMMMM\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpoq7ar_ua_test.go:28:58: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075733
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    var romanNumerals []string\n\
    \    romanNumerals = append(romanNumerals, \"I\", \"II\", \"III\", \"IV\", \"\
    V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\", \"XIII\", \"XIV\"\
    , \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\", \"XXII\", \"\
    XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\"\
    , \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\"\
    , \"XXXVIII\", \"XXXIX\", \"XL\", \"L\", \"LI\", \"LX\", \"LXI\", \"LXII\", \"\
    LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\", \"LXIX\", \"LXX\"\
    , \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\"\
    , \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\", \"LXXXIV\"\
    , \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\", \"XC\", \"C\"\
    , \"CI\", \"CX\", \"CXX\", \"CXXI\", \"CXXII\", \"CXXIII\", \"CXXIV\", \"CXXV\"\
    , \"CXXVI\", \"CXXVII\", \"CXXVIII\", \"CXXIX\", \"CC\", \"CCI\", \"CCX\", \"\
    CCXX\", \"CCXXI\", \"CCXXII\", \"CCXXIII\", \"CCXXIV\", \"CCXXV\", \"CCXXVI\"\
    , \"CCXXVII\", \"CCXXVIII\", \"CCXXIX\", \"CCH\", \"CCHI\", \"CCHX\", \"CCHXX\"\
    , \"CCHXXI\", \"CCHXXII\", \"CCHXXIII\", \"CCHXXIV\", \"CCHXXV\", \"CCHXXVI\"\
    , \"CCHXXVII\", \"CCHXXVIII\", \"CCHXXIX\", \"XD\", \"D\", \"DI\", \"DX\", \"\
    DXX\", \"DXXI\", \"DXXII\", \"DXXIII\", \"DXXIV\", \"DXXV\", \"DXXVI\", \"DXXVII\"\
    , \"DXXVIII\", \"DXXIX\", \"DXXX\", \"DXXXI\", \"\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpu05w0pfe_test.go:14:1122: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075733
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_num := \"\"\n    switch\
    \ number {\n    case 1:\n        roman_num = \"I\"\n    case 2:\n        roman_num\
    \ = \"II\"\n    case 3:\n        roman_num = \"III\"\n    case 4:\n        roman_num\
    \ = \"IV\"\n    case 5:\n        roman_num = \"V\"\n    case 6:\n        roman_num\
    \ = \"VI\"\n    case 7:\n        roman_num = \"VII\"\n    case 8:\n        roman_num\
    \ = \"VIII\"\n    case 9:\n        roman_num = \"IX\"\n    case 10:\n        roman_num\
    \ = \"X\"\n    case 11:\n        roman_num = \"XI\"\n    case 12:\n        roman_num\
    \ = \"XII\"\n    case 13:\n        roman_num = \"XIII\"\n    case 14:\n      \
    \  roman_num = \"XIV\"\n    case 15:\n        roman_num = \"XV\"\n    case 16:\n\
    \        roman_num = \"XVI\"\n    case 17:\n        roman_num = \"XVII\"\n   \
    \ case 18:\n        roman_num = \"XVIII\"\n    case 19:\n        roman_num = \"\
    XIX\"\n    case 20:\n        roman_num = \"XX\"\n    case 21:\n        roman_num\
    \ = \"XXI\"\n    case 22:\n        roman_num = \"XXII\"\n    case 23:\n      \
    \  roman_num = \"XXIII\"\n    case 24:\n        roman_num = \"XXIV\"\n    case\
    \ 25:\n        roman_num = \"XXV\"\n    case 26:\n        roman_num = \"XXVI\"\
    \n    case 27:\n        roman_num = \"XXVII\"\n    case 28:\n        roman_num\
    \ = \"XXVIII\"\n    case 29:\n        roman_num = \"XXIX\"\n    case 30:\n   \
    \     roman_num = \"XXX\"\n    case 31:\n        roman_num = \"XXXI\"\n    case\
    \ 32:\n        roman_num = \"XXXII\"\n    case 33:\n        roman_num = \"XXXIII\"\
    \n    case 34:\n        roman_num = \"XXXIV\"\n    case 35:\n        roman_num\
    \ = \"XXXV\"\n    case 36:\n        roman_num = \"XXXVI\"\n    case 37:\n    \
    \    roman_num = \"XXXVII\"\n    case 38:\n        roman_num = \"XXXVIII\"\n \
    \   case 39:\n        roman_num = \"XXXIX\"\n    case 40:\n        roman_num =\
    \ \"XL\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8xvbo_2c_test.go:95:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075728
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := []string{\n       \
    \ \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"\
    X\", \"XI\", \"XII\", \"XIII\", \"XIV\",\n        \"XV\", \"XVI\", \"XVII\", \"\
    XVIII\", \"XIX\", \"XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"\
    XXVI\",\n        \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\", \"XXXII\"\
    , \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\",\n        \"XXXVIII\"\
    , \"XXXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXVI\", \"\
    XXVII\", \"XXVIII\",\n        \"XXVIII\", \"XXIX\", \"XXXI\", \"XXXII\", \"XXXIII\"\
    , \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\",\n        \"XXXIX\"\
    , \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\", \"\
    XXXVII\", \"XXXVIII\",\n        \"XXXIX\", \"XX\", \"XXI\", \"XXII\", \"XXIII\"\
    , \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\",\n        \"XX\"\
    , \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\"\
    , \"XXIX\", \"XX\",\n        \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\",\
    \ \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XX\", \"XXI\",\n        \"XXII\"\
    , \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"\
    XX\", \"XXI\", \"XXII\",\n        \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\"\
    , \"XXVIII\", \"XXIX\", \"XX\", \"XXI\", \"XXII\", \"XXIII\",\n        \"XXIV\"\
    , \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XX\", \"XXI\", \"XXII\"\
    , \"XXIII\", \"XXIV\",\n        \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\"\
    , \"XX\", \"XXI\", \"XXII\", \"XXII\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0u3guj5t_test.go:26:72: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075733
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000\
    \ {\n        fmt.Println(\"Invalid input\")\n    }\n    roman_num := \"\"\n  \
    \  switch number {\n    case 1:\n        roman_num = \"I\"\n    case 2:\n    \
    \    roman_num = \"II\"\n    case 3:\n        roman_num = \"III\"\n    case 4:\n\
    \        roman_num = \"IV\"\n    case 5:\n        roman_num = \"V\"\n    case\
    \ 6:\n        roman_num = \"VI\"\n    case 7:\n        roman_num = \"VII\"\n \
    \   case 8:\n        roman_num = \"VIII\"\n    case 9:\n        roman_num = \"\
    IX\"\n    case 10:\n        roman_num = \"X\"\n    case 11:\n        roman_num\
    \ = \"XI\"\n    case 12:\n        roman_num = \"XII\"\n    case 13:\n        roman_num\
    \ = \"XIII\"\n    case 14:\n        roman_num = \"XIV\"\n    case 15:\n      \
    \  roman_num = \"XV\"\n    case 16:\n        roman_num = \"XVI\"\n    case 17:\n\
    \        roman_num = \"XVII\"\n    case 18:\n        roman_num = \"XVIII\"\n \
    \   case 19:\n        roman_num = \"XIX\"\n    case 20:\n        roman_num = \"\
    XX\"\n    case 21:\n        roman_num = \"XXI\"\n    case 22:\n        roman_num\
    \ = \"XXII\"\n    case 23:\n        roman_num = \"XXIII\"\n    case 24:\n    \
    \    roman_num = \"XXIV\"\n    case 25:\n        roman_num = \"XXV\"\n    case\
    \ 26:\n        roman_num = \"XXVI\"\n    case 27:\n        roman_num = \"XXVII\"\
    \n    case 28:\n        roman_num = \"XXVIII\"\n    case 29:\n        roman_num\
    \ = \"XXIX\"\n    case 30:\n        roman_num = \"XXX\"\n    case 31:\n      \
    \  roman_num = \"XXXI\"\n    case 32:\n        roman_num = \"XXXII\"\n    case\
    \ 33:\n        roman_num = \"XXXIII\"\n    case 34:\n        roman_num = \"XXXIV\"\
    \n    case 35:\n        roman_num = \"XXXV\"\n    case 36:\n        roman_num\
    \ = \"XXXVI\"\n    case 37:\n        roman_num = \"XXXVII\"\n    case 38:\n  \
    \      roman_num = \"XXXVIII\"\n    case 39:\n        \nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6qo4mb0w_test.go:96:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075731
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_num := \"\"\n    switch\
    \ number {\n    case 1:\n        roman_num = \"I\"\n    case 2:\n        roman_num\
    \ = \"II\"\n    case 3:\n        roman_num = \"III\"\n    case 4:\n        roman_num\
    \ = \"IV\"\n    case 5:\n        roman_num = \"V\"\n    case 6:\n        roman_num\
    \ = \"VI\"\n    case 7:\n        roman_num = \"VII\"\n    case 8:\n        roman_num\
    \ = \"VIII\"\n    case 9:\n        roman_num = \"IX\"\n    case 10:\n        roman_num\
    \ = \"X\"\n    case 11:\n        roman_num = \"XI\"\n    case 12:\n        roman_num\
    \ = \"XII\"\n    case 13:\n        roman_num = \"XIII\"\n    case 14:\n      \
    \  roman_num = \"XIV\"\n    case 15:\n        roman_num = \"XV\"\n    case 16:\n\
    \        roman_num = \"XVI\"\n    case 17:\n        roman_num = \"XVII\"\n   \
    \ case 18:\n        roman_num = \"XVIII\"\n    case 19:\n        roman_num = \"\
    XIX\"\n    case 20:\n        roman_num = \"XX\"\n    case 21:\n        roman_num\
    \ = \"XXI\"\n    case 22:\n        roman_num = \"XXII\"\n    case 23:\n      \
    \  roman_num = \"XXIII\"\n    case 24:\n        roman_num = \"XXIV\"\n    case\
    \ 25:\n        roman_num = \"XXV\"\n    case 26:\n        roman_num = \"XXVI\"\
    \n    case 27:\n        roman_num = \"XXVII\"\n    case 28:\n        roman_num\
    \ = \"XXVIII\"\n    case 29:\n        roman_num = \"XXIX\"\n    case 30:\n   \
    \     roman_num = \"XXX\"\n    case 31:\n        roman_num = \"XXXI\"\n    case\
    \ 32:\n        roman_num = \"XXXII\"\n    case 33:\n        roman_num = \"XXXIII\"\
    \n    case 34:\n        roman_num = \"XXXIV\"\n    case 35:\n        roman_num\
    \ = \"XXXV\"\n    case 36:\n        roman_num = \"XXXVI\"\n    case 37:\n    \
    \    roman_num = \"XXXVII\"\n    case 38:\n        roman_num = \"XXXVIII\"\n \
    \   case 39:\n        roman_num = \"XXXIX\"\n    case 40:\n        roman_num =\
    \ \"XL\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8xvbo_2c_test.go:95:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075728
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_numerals := []string{\"\
    I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"}\n    result\
    \ := \"\"\n    for _, roman_numeral := range roman_numerals {\n        if number\
    \ >= roman_numeral+1 {\n            result += roman_numeral\n            number\
    \ -= roman_numeral+1\n        }\n    }\n    if number > 0 {\n        result +=\
    \ roman_numerals[len(roman_numerals)-1]\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp14kdw7cn_test.go:16:22: invalid operation: roman_numeral + 1 (mismatched
    types string and untyped int)

    /tmp/tmp14kdw7cn_test.go:18:23: invalid operation: roman_numeral + 1 (mismatched
    types string and untyped int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075734
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := []string{\n       \
    \ \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"\
    X\", \"XI\", \"XII\", \"XIII\",\n        \"XIV\", \"XV\", \"XVI\", \"XVII\", \"\
    XVIII\", \"XIX\", \"XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\",\n        \"\
    XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\", \"XXXII\"\
    , \"XXXIII\", \"XXXIV\",\n        \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\"\
    , \"XXXIX\", \"XL\", \"L\", \"LI\", \"LXI\", \"LXII\", \"LXIII\",\n        \"\
    LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\", \"LXIX\", \"LXX\", \"LXXI\"\
    , \"LXXII\", \"LXXIII\",\n        \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\",\
    \ \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\",\n        \"LXXXIII\"\
    , \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\", \"\
    XC\", \"C\",\n        \"CI\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"\
    CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\",\n        \"CXIX\", \"CXX\",\
    \ \"CXXI\", \"CXXII\", \"CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"CXXVII\"\
    , \"CXXVIII\",\n        \"CXXIX\", \"CXXX\", \"CXXXI\", \"CXXXII\", \"CXXXIII\"\
    , \"CXXXIV\", \"CXXXV\", \"CXXXVI\", \"CXXXVII\",\n        \"CXXXVIII\", \"CXXXIX\"\
    , \"CD\", \"D\", \"DI\", \"DII\", \"DIII\", \"DIIII\", \"DIIV\", \"DIV\", \"DIVI\"\
    ,\n        \"DIVII\", \"DIVIII\", \"DIVIV\", \"DIVV\", \"DIVVI\", \"DIVVII\",\
    \ \"DIVVIII\", \"DIVIX\", \"DXX\",\n        \"DXXI\", \"DXXII\", \"DXXIII\", \"\
    DXXIV\", \"DXXV\", \"DXXVI\", \"DXXVII\", \"D\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdle7nynj_test.go:26:72: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075733
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_number := \"\"\n    switch\
    \ number {\n    case 1:\n        roman_number = \"I\"\n    case 2:\n        roman_number\
    \ = \"II\"\n    case 3:\n        roman_number = \"III\"\n    case 4:\n       \
    \ roman_number = \"IV\"\n    case 5:\n        roman_number = \"V\"\n    case 6:\n\
    \        roman_number = \"VI\"\n    case 7:\n        roman_number = \"VII\"\n\
    \    case 8:\n        roman_number = \"VIII\"\n    case 9:\n        roman_number\
    \ = \"IX\"\n    case 10:\n        roman_number = \"X\"\n    case 11:\n       \
    \ roman_number = \"XI\"\n    case 12:\n        roman_number = \"XII\"\n    case\
    \ 13:\n        roman_number = \"XIII\"\n    case 14:\n        roman_number = \"\
    XIV\"\n    case 15:\n        roman_number = \"XV\"\n    case 16:\n        roman_number\
    \ = \"XVI\"\n    case 17:\n        roman_number = \"XVII\"\n    case 18:\n   \
    \     roman_number = \"XVIII\"\n    case 19:\n        roman_number = \"XIX\"\n\
    \    case 20:\n        roman_number = \"XX\"\n    case 21:\n        roman_number\
    \ = \"XXI\"\n    case 22:\n        roman_number = \"XXII\"\n    case 23:\n   \
    \     roman_number = \"XXIII\"\n    case 24:\n        roman_number = \"XXIV\"\n\
    \    case 25:\n        roman_number = \"XXV\"\n    case 26:\n        roman_number\
    \ = \"XXVI\"\n    case 27:\n        roman_number = \"XXVII\"\n    case 28:\n \
    \       roman_number = \"XXVIII\"\n    case 29:\n        roman_number = \"XXIX\"\
    \n    case 30:\n        roman_number = \"XXX\"\n    case 31:\n        roman_number\
    \ = \"XXXI\"\n    case 32:\n        roman_number = \"XXXII\"\n    case 33:\n \
    \       roman_number = \"XXXIII\"\n    case 34:\n        roman_number = \"XXXIV\"\
    \n    case 35:\n        roman_number = \"XXXV\"\n    case 36:\n        roman_number\
    \ = \"XXXVI\"\n    case 37:\n        roman_number = \"XXXVII\"\n    case 38:\n\
    \        roman_number = \"XXXVIII\"\n    case 39:\n        roman_number = \"XXXIX\"\
    \n    case 40:\n        roman_number = \"XL\"\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7aj4t2nh_test.go:95:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075728
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := []string{\n       \
    \ \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"\
    X\", \"XI\", \"XII\",\n        \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"\
    XVIII\", \"XIX\", \"XX\", \"XXI\", \"XXII\",\n        \"XXIII\", \"XXIV\", \"\
    XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\",\n       \
    \ \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\"\
    , \"XXXIX\",\n        \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"LXXXX\", \"\
    LXXXXX\", \"LXXXII\", \"LXXXIII\",\n        \"LXXXIV\", \"LXXXV\", \"LXXXVI\"\
    , \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\", \"LXXXVIII\",\n        \"LXXXXV\", \"\
    LXXXXVI\", \"LXXXXVII\", \"LXXXXVIII\", \"LXXXXIX\", \"LXXXXVIII\",\n        \"\
    LXXVIII\", \"LXXVIII\", \"LXXVIII\", \"LXXVIII\", \"LXXVIII\", \"LXXVIII\", \"\
    LXXVIII\",\n        \"LXXVIII\", \"LXXVIII\", \"LXXVIII\", \"LXXVIII\", \"LXXVIII\"\
    , \"LXXVIII\", \"LXXVIII\",\n        \"LXXVIII\", \"LXXVIII\", \"LXXVIII\", \"\
    LXXVIII\", \"LXXVIII\", \"LXXVIII\", \"LXXVIII\",\n        \"LXXVIII\", \"LXXVIII\"\
    , \"LXXVIII\", \"LXXVIII\", \"LXXVIII\", \"LXXVIII\", \"LXXVIII\",\n        \"\
    LXXVIII\", \"LXXVIII\", \"LXXVIII\", \"LXXVIII\", \"LXXVIII\", \"LXXVIII\", \"\
    LXXVIII\",\n        \"LXXVIII\", \"LXXVIII\", \"LXXVIII\", \"LXXVIII\", \"LXXVIII\"\
    , \"LXXVIII\", \"LXXVIII\",\n        \"LXXVIII\", \"L\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpa6zofbe7_test.go:27:20: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075734
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := map[int]string{\n \
    \       1: \"I\",\n        5: \"V\",\n        10: \"X\",\n        50: \"L\",\n\
    \        100: \"C\",\n        500: \"D\",\n        1000: \"M\",\n    }\n    roman_number\
    \ := 0\n    for number > 0 {\n        roman_number += number % 10\n        number\
    \ /= 10\n    }\n    return romans[roman_number]\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmp49ntvwog_test.go:56: expected 'xix', got 'X'\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmp49ntvwog_test.go:56: expected\
    \ 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n  \
    \      tmp49ntvwog_test.go:56: expected 'ccli', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmp49ntvwog_test.go:56: expected 'cdxxvi', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmp49ntvwog_test.go:56:\
    \ expected 'd', got 'V'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n\
    \        tmp49ntvwog_test.go:56: expected 'i', got 'I'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6\
    \ (0.00s)\n        tmp49ntvwog_test.go:56: expected 'iv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmp49ntvwog_test.go:56: expected\
    \ 'xliii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n \
    \       tmp49ntvwog_test.go:56: expected 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9\
    \ (0.00s)\n        tmp49ntvwog_test.go:56: expected 'xciv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmp49ntvwog_test.go:56:\
    \ expected 'dxxxii', got 'X'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11\
    \ (0.00s)\n        tmp49ntvwog_test.go:56: expected 'cm', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmp49ntvwog_test.go:56:\
    \ expected 'cmxciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmp49ntvwog_test.go:56: expected 'm', got 'I'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075735
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := map[int]string{\n \
    \       1: \"I\",\n        5: \"V\",\n        10: \"X\",\n        50: \"L\",\n\
    \        100: \"C\",\n        500: \"D\",\n        1000: \"M\",\n    }\n\n   \
    \ result := \"\"\n    for number > 0 {\n        result += \"M\"\n        number\
    \ -= 50\n    }\n\n    for _, romanNumeral := range romans {\n        if number\
    \ >= romanNumeral {\n            result += romanNumeral\n            number -=\
    \ romanNumeral\n        }\n    }\n\n    return result[0:1]\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprg5vbx77_test.go:30:22: invalid operation: number >= romanNumeral (mismatched
    types int and string)

    /tmp/tmprg5vbx77_test.go:32:13: invalid operation: number -= romanNumeral (mismatched
    types int and string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075734
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := []string{\n       \
    \ \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"\
    X\", \"XI\", \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\"\
    , \"XIX\", \"XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\",\
    \ \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"\
    XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\", \"L\"\
    , \"LI\", \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\", \"\
    LIX\", \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\"\
    , \"LXVIII\", \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"\
    LXXV\", \"LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"\
    LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\"\
    , \"LXXXIX\", \"XC\", \"C\", \"CI\", \"CII\", \"CIV\", \"CV\", \"CVI\", \"CVII\"\
    , \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"CXV\"\
    , \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CC\", \"CCI\", \"CCII\", \"CCIII\"\
    , \"CCIV\", \"CCV\", \"CCVI\", \"CCVII\", \"CCVIII\", \"CCIX\", \"CCX\", \"CCXI\"\
    , \"CCXII\", \"CCXIII\", \"CCXIV\", \"CCXV\", \"CCXVI\", \"CCXVII\", \"CCXVIII\"\
    , \"CCXIX\", \"CCXX\", \"CCXXI\", \"CCXXII\", \"CCXXIII\", \"CCXXIV\", \"CCXXV\"\
    , \"CCXXVI\", \"CCXXVII\", \"CCXXVIII\", \"CCXXIX\", \"CCXXX\", \"CCXXXI\", \"\
    CCXXXII\", \"CCXXXIII\", \"CCXXXIV\", \"CCXXXV\", \"CCXXXV\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzclhz7ar_test.go:14:1132: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075734
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := []string{\n       \
    \ \"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"\
    D\", \"CM\", \"M\", \"MM\",\n        \"MMM\",\n    }\n    romanIndex := 0\n  \
    \  romanLength := len(romans)\n    romanString := \"\"\n    for number > 0 {\n\
    \        romanString = romans[romanIndex]\n        romanIndex++\n        number\
    \ -= romanIndex\n    }\n    return strings.ToLower(romanString)\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdaox2yb1_test.go:18:5: romanLength declared but not used

    /tmp/tmpdaox2yb1_test.go:25:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075734
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romanNumerals := map[int]string{\n\
    \        1: \"I\",\n        5: \"V\",\n        10: \"X\",\n        50: \"L\",\n\
    \        100: \"C\",\n        500: \"D\",\n        1000: \"M\",\n    }\n    romanNumeral\
    \ := romanNumerals[number]\n    return strings.ToLower(romanNumeral)\n}\n\nfunc\
    \ TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmps23w240l_test.go:23:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075730
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_number := \"\"\n    switch\
    \ number {\n    case 1:\n        roman_number = \"I\"\n    case 2:\n        roman_number\
    \ = \"II\"\n    case 3:\n        roman_number = \"III\"\n    case 4:\n       \
    \ roman_number = \"IV\"\n    case 5:\n        roman_number = \"V\"\n    case 6:\n\
    \        roman_number = \"VI\"\n    case 7:\n        roman_number = \"VII\"\n\
    \    case 8:\n        roman_number = \"VIII\"\n    case 9:\n        roman_number\
    \ = \"IX\"\n    case 10:\n        roman_number = \"X\"\n    case 11:\n       \
    \ roman_number = \"XI\"\n    case 12:\n        roman_number = \"XII\"\n    case\
    \ 13:\n        roman_number = \"XIII\"\n    case 14:\n        roman_number = \"\
    XIV\"\n    case 15:\n        roman_number = \"XV\"\n    case 16:\n        roman_number\
    \ = \"XVI\"\n    case 17:\n        roman_number = \"XVII\"\n    case 18:\n   \
    \     roman_number = \"XVIII\"\n    case 19:\n        roman_number = \"XIX\"\n\
    \    case 20:\n        roman_number = \"XX\"\n    case 21:\n        roman_number\
    \ = \"XXI\"\n    case 22:\n        roman_number = \"XXII\"\n    case 23:\n   \
    \     roman_number = \"XXIII\"\n    case 24:\n        roman_number = \"XXIV\"\n\
    \    case 25:\n        roman_number = \"XXV\"\n    case 26:\n        roman_number\
    \ = \"XXVI\"\n    case 27:\n        roman_number = \"XXVII\"\n    case 28:\n \
    \       roman_number = \"XXVIII\"\n    case 29:\n        roman_number = \"XXIX\"\
    \n    case 30:\n        roman_number = \"XXX\"\n    case 31:\n        roman_number\
    \ = \"XXXI\"\n    case 32:\n        roman_number = \"XXXII\"\n    case 33:\n \
    \       roman_number = \"XXXIII\"\n    case 34:\n        roman_number = \"XXXIV\"\
    \n    case 35:\n        roman_number = \"XXXV\"\n    case 36:\n        roman_number\
    \ = \"XXXVI\"\n    case 37:\n        roman_number = \"XXXVII\"\n    case 38:\n\
    \        roman_number = \"XXXVIII\"\n    case 39:\n        roman_number = \"XXXIX\"\
    \n    case 40:\n        roman_number = \"XL\"\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7aj4t2nh_test.go:95:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075728
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_num := []string{\"I\",\
    \ \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"\
    XI\", \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\"\
    , \"XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\"\
    , \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"\
    XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\", \"L\", \"LI\",\
    \ \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\", \"LIX\", \"\
    LX\", \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"\
    LXVIII\", \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\"\
    , \"LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\"\
    , \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"\
    LXXXIX\", \"XC\", \"C\", \"CI\", \"CII\", \"CIV\", \"CV\", \"CVI\", \"CVII\",\
    \ \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"CXV\"\
    , \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\", \"CXXI\", \"CXXII\", \"\
    CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"CXXVII\", \"CXXVIII\", \"CXXIX\",\
    \ \"CXXX\", \"CXXXI\", \"CXXXII\", \"CXXXIII\", \"CXXXIV\", \"CXXXV\", \"CXXXVI\"\
    , \"CXXXVII\", \"CXXXVIII\", \"CXXXIX\", \"CXL\", \"CL\", \"LI\", \"LII\", \"\
    LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\", \"LIX\", \"LX\", \"LXI\"\
    , \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVII\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdg4g8650_test.go:13:1147: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075734
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := map[int]string{\n \
    \       1: \"I\",\n        5: \"V\",\n        10: \"X\",\n        50: \"L\",\n\
    \        100: \"C\",\n        500: \"D\",\n        1000: \"M\",\n    }\n    roman_number\
    \ := \"\"\n    for _, roman_numeral := range romans {\n        if number >= roman_numeral\
    \ {\n            roman_number = roman_numeral\n            break\n        }\n\
    \    }\n    return roman_number\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp37vi3cdl_test.go:24:22: invalid operation: number >= roman_numeral (mismatched
    types int and string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075734
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := []string{\"I\", \"\
    II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\"\
    , \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"\
    XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"\
    XXVIII\", \"XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\"\
    , \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\", \"L\", \"LI\", \"LII\"\
    , \"LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\", \"LIX\", \"LX\", \"\
    LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\"\
    , \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"\
    LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\",\
    \ \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"\
    LXXXIX\", \"XC\", \"C\", \"CI\", \"CII\", \"CIV\", \"CV\", \"CVI\", \"CVII\",\
    \ \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"CXV\"\
    , \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\", \"CXXI\", \"CXXII\", \"\
    CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"CXXVII\", \"CXXVIII\", \"CXXIX\",\
    \ \"CXXX\", \"CXXXI\", \"CXXXII\", \"CXXXIII\", \"CXXXIV\", \"CXXXV\", \"CXXXVI\"\
    , \"CXXXVII\", \"CXXXVIII\", \"CXXXIX\", \"CC\", \"CCI\", \"CCII\", \"CCIII\"\
    , \"CCIV\", \"CV\", \"CVI\", \"CVII\", \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"\
    CXII\", \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\"\
    , \"CXX\", \"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmptryuebdg_test.go:13:1166: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075730
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_numerals := []string{\"\
    I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\"\
    , \"XI\", \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"\
    XIX\", \"XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\"\
    , \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"\
    XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\", \"L\", \"LI\",\
    \ \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\", \"LIX\", \"\
    LX\", \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"\
    LXVIII\", \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\"\
    , \"LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\"\
    , \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"\
    LXXXIX\", \"XC\", \"C\", \"CI\", \"CII\", \"CIV\", \"CV\", \"CVI\", \"CVII\",\
    \ \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"CXV\"\
    , \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CC\", \"CCI\", \"CCII\", \"CCIII\"\
    , \"CIV\", \"CV\", \"CVI\", \"CVII\", \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"\
    CXII\", \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\"\
    , \"CC\", \"CCI\", \"CCII\", \"CCIII\", \"CIV\", \"CV\", \"CVI\", \"CVII\", \"\
    CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"CXV\", \"\
    CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CC\", \"CCI\", \"CCII\", \"CCIII\"\
    , \"CIV\", \"CV\", \"CVI\", \"CVII\", \"CVIII\", \"\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmprfjxu77k_test.go:13:1197: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075734
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_numerals := []string{\n\
    \        \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"\
    IX\", \"X\", \"XI\", \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"\
    XVIII\", \"XIX\", \"XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"\
    XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\"\
    , \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\",\
    \ \"XLI\", \"XLII\", \"XLIII\", \"XLIIII\", \"XLIV\", \"XLIVI\", \"XLIVII\", \"\
    XLIVIII\", \"XLIVIV\", \"XLIVV\", \"XLIVVI\", \"XLIVVII\", \"XLIVVIII\", \"XLIVVIV\"\
    , \"XLIVVV\", \"XLIVVVI\", \"XLIVVVII\", \"XLIVVVIII\", \"XLIVVVIV\", \"XLIVVVV\"\
    , \"XLIVVVVI\", \"XLIVVVVII\", \"XLIVVVVIII\", \"XLIVVVVIV\", \"XLIVVVVV\", \"\
    XLIVVVVI\", \"XLIVVVVII\", \"XLIVVVVIII\", \"XLIVVVVIV\", \"XLIVVVVV\", \"XLIVVVVI\"\
    , \"XLIVVVVII\", \"XLIVVVVIII\", \"XLIVVVVIV\", \"XLIVVVVV\", \"XLIVVVVI\", \"\
    XLIVVVVII\", \"XLIVVVVIII\", \"XLIVVVVIV\", \"XLIVVVVV\", \"XLIVVVVI\", \"XLIVVVVII\"\
    , \"XLIVVVVIII\", \"XLIVVVVIV\", \"XLIVVVVV\", \"XLIVVVVI\", \"XLIVVVVII\", \"\
    XLIVVVVIII\", \"XLIVVVVIV\", \"XLIVVVVV\", \"XLIVVVVI\", \"XLIVVVVII\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpredljvt9_test.go:14:911: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075734
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_number := \"\"\n    switch\
    \ number {\n    case 1:\n        roman_number = \"I\"\n    case 2:\n        roman_number\
    \ = \"II\"\n    case 3:\n        roman_number = \"III\"\n    case 4:\n       \
    \ roman_number = \"IV\"\n    case 5:\n        roman_number = \"V\"\n    case 6:\n\
    \        roman_number = \"VI\"\n    case 7:\n        roman_number = \"VII\"\n\
    \    case 8:\n        roman_number = \"VIII\"\n    case 9:\n        roman_number\
    \ = \"IX\"\n    case 10:\n        roman_number = \"X\"\n    case 11:\n       \
    \ roman_number = \"XI\"\n    case 12:\n        roman_number = \"XII\"\n    case\
    \ 13:\n        roman_number = \"XIII\"\n    case 14:\n        roman_number = \"\
    XIV\"\n    case 15:\n        roman_number = \"XV\"\n    case 16:\n        roman_number\
    \ = \"XVI\"\n    case 17:\n        roman_number = \"XVII\"\n    case 18:\n   \
    \     roman_number = \"XVIII\"\n    case 19:\n        roman_number = \"XIX\"\n\
    \    case 20:\n        roman_number = \"XX\"\n    case 21:\n        roman_number\
    \ = \"XXI\"\n    case 22:\n        roman_number = \"XXII\"\n    case 23:\n   \
    \     roman_number = \"XXIII\"\n    case 24:\n        roman_number = \"XXIV\"\n\
    \    case 25:\n        roman_number = \"XXV\"\n    case 26:\n        roman_number\
    \ = \"XXVI\"\n    case 27:\n        roman_number = \"XXVII\"\n    case 28:\n \
    \       roman_number = \"XXVIII\"\n    case 29:\n        roman_number = \"XXIX\"\
    \n    case 30:\n        roman_number = \"XXX\"\n    case 31:\n        roman_number\
    \ = \"XXXI\"\n    case 32:\n        roman_number = \"XXXII\"\n    case 33:\n \
    \       roman_number = \"XXXIII\"\n    case 34:\n        roman_number = \"XXXIV\"\
    \n    case 35:\n        roman_number = \"XXXV\"\n    case 36:\n        roman_number\
    \ = \"XXXVI\"\n    case 37:\n        roman_number = \"XXXVII\"\n    case 38:\n\
    \        roman_number = \"XXXVIII\"\n    case 39:\n        roman_number = \"XXXIX\"\
    \n    case 40:\n        roman_number = \"XL\"\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7aj4t2nh_test.go:95:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075728
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := []string{\"I\", \"\
    II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\"\
    , \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"\
    XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"\
    XXVIII\", \"XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\"\
    , \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\", \"L\", \"LI\", \"LX\"\
    , \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\"\
    , \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"\
    LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\",\
    \ \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"\
    LXXXIX\", \"XC\", \"C\", \"CI\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\"\
    , \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\", \"CXXI\", \"CXXII\"\
    , \"CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"CXXVII\", \"CXXVIII\", \"CXXIX\"\
    , \"CXXX\", \"CXXXI\", \"CXXXII\", \"CXXXIII\", \"CXXXIV\", \"CXXXV\", \"CXXXVI\"\
    , \"CXXXVII\", \"CXXXVIII\", \"CXXXIX\", \"CC\", \"CCI\", \"CCX\", \"CCXI\", \"\
    CCXII\", \"CCXIII\", \"CCXIV\", \"CCXV\", \"CCXVI\", \"CCXVII\", \"CCXVIII\",\
    \ \"CCXIX\", \"CCH\", \"CCHI\", \"CCHX\", \"CCHXI\", \"CCHXII\", \"CCHXIII\",\
    \ \"CCHXIV\", \"CCHXV\", \"CCHXVI\", \"CCHXVII\", \"CCHXVIII\", \"CCHXIX\", \"\
    CCCX\", \"CCCXI\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp424h0ava_test.go:13:1120: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075728
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_numerals := []string{\n\
    \        \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"\
    IX\", \"X\", \"XI\", \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"\
    XVIII\", \"XIX\", \"XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"\
    XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\"\
    , \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\",\
    \ \"L\", \"LI\", \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\"\
    , \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\"\
    , \"LXVIII\", \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"\
    LXXV\", \"LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"\
    LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\"\
    , \"LXXXIX\", \"XC\", \"C\", \"CI\", \"CII\", \"CIV\", \"CV\", \"CVI\", \"CVII\"\
    , \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"CXV\"\
    , \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\", \"CXXI\", \"CXXII\", \"\
    CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"CXXVII\", \"CXXVIII\", \"CXXIX\",\
    \ \"CXXX\", \"CXXXI\", \"CXXXII\", \"CXXXIII\", \"CXXXIV\", \"CXXXV\", \"CXXXVI\"\
    , \"CXXXVII\", \"CXXXVIII\", \"CXXXIX\", \"CXL\", \"CL\", \"LI\", \"LII\", \"\
    LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\", \"LX\", \"LXI\", \"LXII\"\
    , \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXV\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpgqxhsaxa_test.go:14:1115: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075734
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_numerals := []string{\n\
    \        \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"\
    IX\", \"X\", \"XI\", \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"\
    XVIII\", \"XIX\", \"XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"\
    XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\"\
    , \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\",\
    \ \"L\", \"LI\", \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\"\
    , \"LIX\", \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\",\
    \ \"LXVII\", \"LXVIII\", \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"\
    LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"\
    LXXXI\", \"LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\"\
    , \"LXXXVIII\", \"LXXXIX\", \"XC\", \"C\", \"CI\", \"CII\", \"CIV\", \"CV\", \"\
    CVI\", \"CVII\", \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"\
    CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\", \"CXXI\"\
    , \"CXXII\", \"CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"CXXVII\", \"CXXVIII\"\
    , \"CXXIX\", \"CXXX\", \"CXXXI\", \"CXXXII\", \"CXXXIII\", \"CXXXIV\", \"CXXXV\"\
    , \"CXXXVI\", \"CXXXVII\", \"CXXXVIII\", \"CXXXIX\", \"CC\", \"CCI\", \"CCII\"\
    , \"CCIII\", \"CCIV\", \"CV\", \"CVI\", \"CVII\", \"CVIII\", \"CIX\", \"CX\",\
    \ \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\"\
    , \"CXIX\", \"C\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9cr1m1w7_test.go:14:1144: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075735
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := []string{\n       \
    \ \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"\
    X\", \"XI\", \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\"\
    , \"XIX\", \"XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\",\
    \ \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"\
    XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\", \"L\"\
    , \"LI\", \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\", \"\
    LIX\", \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\"\
    , \"LXVIII\", \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"\
    LXXV\", \"LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"\
    LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\"\
    , \"LXXXIX\", \"XC\", \"C\", \"CI\", \"CII\", \"CIV\", \"CV\", \"CVI\", \"CVII\"\
    , \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"CXV\"\
    , \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\", \"CXXI\", \"CXXII\", \"\
    CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"CXXVII\", \"CXXVIII\", \"CXXIX\",\
    \ \"CXXX\", \"CXXXI\", \"CXXXII\", \"CXXXIII\", \"CXXXIV\", \"CXXXV\", \"CXXXVI\"\
    , \"CXXXVII\", \"CXXXVIII\", \"CXXXIX\", \"CXL\", \"CL\", \"LI\", \"LII\", \"\
    LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\", \"LIX\", \"LX\", \"LXI\"\
    , \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LX\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbpva6ger_test.go:14:1129: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075735
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_num := \"\"\n    switch\
    \ number {\n    case 1:\n        roman_num = \"I\"\n    case 2:\n        roman_num\
    \ = \"II\"\n    case 3:\n        roman_num = \"III\"\n    case 4:\n        roman_num\
    \ = \"IV\"\n    case 5:\n        roman_num = \"V\"\n    case 6:\n        roman_num\
    \ = \"VI\"\n    case 7:\n        roman_num = \"VII\"\n    case 8:\n        roman_num\
    \ = \"VIII\"\n    case 9:\n        roman_num = \"IX\"\n    case 10:\n        roman_num\
    \ = \"X\"\n    case 11:\n        roman_num = \"XI\"\n    case 12:\n        roman_num\
    \ = \"XII\"\n    case 13:\n        roman_num = \"XIII\"\n    case 14:\n      \
    \  roman_num = \"XIV\"\n    case 15:\n        roman_num = \"XV\"\n    case 16:\n\
    \        roman_num = \"XVI\"\n    case 17:\n        roman_num = \"XVII\"\n   \
    \ case 18:\n        roman_num = \"XVIII\"\n    case 19:\n        roman_num = \"\
    XIX\"\n    case 20:\n        roman_num = \"XX\"\n    case 21:\n        roman_num\
    \ = \"XXI\"\n    case 22:\n        roman_num = \"XXII\"\n    case 23:\n      \
    \  roman_num = \"XXIII\"\n    case 24:\n        roman_num = \"XXIV\"\n    case\
    \ 25:\n        roman_num = \"XXV\"\n    case 26:\n        roman_num = \"XXVI\"\
    \n    case 27:\n        roman_num = \"XXVII\"\n    case 28:\n        roman_num\
    \ = \"XXVIII\"\n    case 29:\n        roman_num = \"XXIX\"\n    case 30:\n   \
    \     roman_num = \"XXX\"\n    case 31:\n        roman_num = \"XXXI\"\n    case\
    \ 32:\n        roman_num = \"XXXII\"\n    case 33:\n        roman_num = \"XXXIII\"\
    \n    case 34:\n        roman_num = \"XXXIV\"\n    case 35:\n        roman_num\
    \ = \"XXXV\"\n    case 36:\n        roman_num = \"XXXVI\"\n    case 37:\n    \
    \    roman_num = \"XXXVII\"\n    case 38:\n        roman_num = \"XXXVIII\"\n \
    \   case 39:\n        roman_num = \"XXXIX\"\n    case 40:\n        roman_num =\
    \ \"XL\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8xvbo_2c_test.go:95:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075728
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_number := \"\"\n    switch\
    \ number {\n    case 1:\n        roman_number = \"I\"\n    case 2:\n        roman_number\
    \ = \"II\"\n    case 3:\n        roman_number = \"III\"\n    case 4:\n       \
    \ roman_number = \"IV\"\n    case 5:\n        roman_number = \"V\"\n    case 6:\n\
    \        roman_number = \"VI\"\n    case 7:\n        roman_number = \"VII\"\n\
    \    case 8:\n        roman_number = \"VIII\"\n    case 9:\n        roman_number\
    \ = \"IX\"\n    case 10:\n        roman_number = \"X\"\n    case 11:\n       \
    \ roman_number = \"XI\"\n    case 12:\n        roman_number = \"XII\"\n    case\
    \ 13:\n        roman_number = \"XIII\"\n    case 14:\n        roman_number = \"\
    XIV\"\n    case 15:\n        roman_number = \"XV\"\n    case 16:\n        roman_number\
    \ = \"XVI\"\n    case 17:\n        roman_number = \"XVII\"\n    case 18:\n   \
    \     roman_number = \"XVIII\"\n    case 19:\n        roman_number = \"XIX\"\n\
    \    case 20:\n        roman_number = \"XX\"\n    case 21:\n        roman_number\
    \ = \"XXI\"\n    case 22:\n        roman_number = \"XXII\"\n    case 23:\n   \
    \     roman_number = \"XXIII\"\n    case 24:\n        roman_number = \"XXIV\"\n\
    \    case 25:\n        roman_number = \"XXV\"\n    case 26:\n        roman_number\
    \ = \"XXVI\"\n    case 27:\n        roman_number = \"XXVII\"\n    case 28:\n \
    \       roman_number = \"XXVIII\"\n    case 29:\n        roman_number = \"XXIX\"\
    \n    case 30:\n        roman_number = \"XXX\"\n    case 31:\n        roman_number\
    \ = \"XXXI\"\n    case 32:\n        roman_number = \"XXXII\"\n    case 33:\n \
    \       roman_number = \"XXXIII\"\n    case 34:\n        roman_number = \"XXXIV\"\
    \n    case 35:\n        roman_number = \"XXXV\"\n    case 36:\n        roman_number\
    \ = \"XXXVI\"\n    case 37:\n        roman_number = \"XXXVII\"\n    case 38:\n\
    \        roman_number = \"XXXVIII\"\n    case 39:\n        roman_number = \"XXXIX\"\
    \n    case 40:\n        roman_number = \"XL\"\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7aj4t2nh_test.go:95:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075728
- exit_code: null
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    var roman = make([]string, 1000)\n\
    \    var i int\n    for i = 1; i <= 1000; i++ {\n        roman[i] = fmt.Sprintf(\"\
    %v\", i%10)\n        i /= 10\n    }\n    return roman[number]\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660075748
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := []string{\"I\", \"\
    II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\"\
    , \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"\
    XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"\
    XXVIII\", \"XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\"\
    , \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\", \"L\", \"LI\", \"LII\"\
    , \"LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\", \"LIX\", \"LX\", \"\
    LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\"\
    , \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"\
    LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\",\
    \ \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"\
    LXXXIX\", \"XC\", \"C\", \"CI\", \"CII\", \"CIV\", \"CV\", \"CVI\", \"CVII\",\
    \ \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"CXV\"\
    , \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\", \"CXXI\", \"CXXII\", \"\
    CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"CXXVII\", \"CXXVIII\", \"CXXIX\",\
    \ \"CXXX\", \"CXXXI\", \"CXXXII\", \"CXXXIII\", \"CXXXIV\", \"CXXXV\", \"CXXXVI\"\
    , \"CXXXVII\", \"CXXXVIII\", \"CXXXIX\", \"CXL\", \"CL\", \"LI\", \"LII\", \"\
    LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\", \"LIX\", \"LX\", \"LXI\"\
    , \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVII\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpewshv08s_test.go:13:1144: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075728
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := []string{\n       \
    \ \"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"\
    D\", \"CM\", \"M\", \"MN\", \"N\",\n        \"NM\", \"NN\", \"NX\", \"XX\", \"\
    XXL\", \"XC\", \"XC\", \"XC\", \"XC\", \"XC\", \"XC\", \"XC\", \"XC\",\n     \
    \   \"XC\", \"XC\", \"XC\", \"XC\", \"XC\", \"XC\", \"XC\", \"XC\", \"XC\", \"\
    XC\", \"XC\", \"XC\", \"XC\",\n        \"XC\", \"XC\", \"XC\", \"XC\", \"XC\"\
    , \"XC\", \"XC\", \"XC\", \"XC\", \"XC\", \"XC\", \"XC\", \"XC\",\n        \"\
    XC\", \"XC\", \"XC\", \"XC\", \"XC\", \"XC\", \"XC\", \"XC\", \"XC\", \"XC\",\
    \ \"XC\", \"XC\", \"XC\",\n        \"XC\", \"XC\", \"XC\", \"XC\", \"XC\", \"\
    XC\", \"XC\", \"XC\", \"XC\", \"XC\", \"XC\", \"XC\", \"XC\",\n        \"XC\"\
    , \"XC\", \"XC\", \"XC\", \"XC\", \"XC\", \"XC\", \"XC\", \"XC\", \"XC\", \"XC\"\
    , \"XC\", \"XC\",\n        \"XC\", \"XC\", \"XC\", \"XC\", \"XC\", \"XC\", \"\
    XC\", \"XC\", \"XC\", \"XC\", \"XC\", \"XC\", \"XC\",\n        \"XC\", \"XC\"\
    , \"XC\", \"XC\", \"XC\", \"XC\", \"XC\", \"XC\", \"XC\", \"XC\", \"XC\", \"XC\"\
    , \"XC\",\n        \"XC\", \"XC\", \"XC\", \"XC\", \"XC\", \"XC\", \"XC\", \"\
    XC\", \"XC\", \"XC\", \"XC\", \"XC\", \"XC\",\n        \"XC\", \"XC\", \"XC\"\
    , \"XC\", \"XC\", \"XC\", \"XC\", \"XC\", \"XC\", \"XC\", \"XC\", \"XC\", \"XC\"\
    ,\n        \"XC\", \"XC\", \"XC\", \"XC\", \"XC\", \"XC\", \"XC\", \"XC\", \"\
    XC\", \"XC\", \"XC\", \"XC\", \"XC\",\n        \"XC\", \"XC\", \"XC\", \"XC\"\
    , \"XC\", \"XC\", \"X\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpsgygqni__test.go:26:45: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075735
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := []string{\n       \
    \ \"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"\
    D\", \"CM\", \"M\", \"MN\", \"N\",\n        \"NX\", \"XX\", \"X\", \"IX\", \"\
    V\", \"IV\", \"I\",\n    }\n    result := \"\"\n    i := 0\n    for number > 0\
    \ {\n        result += romans[i]\n        number -= romans[i]\n        i++\n \
    \   }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp32rt5q7k_test.go:21:9: invalid operation: number -= romans[i] (mismatched
    types int and string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075735
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := []string{\n       \
    \ \"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"\
    D\", \"CM\",\n        \"M\", \"MM\", \"MMM\",\n    }\n    roman_number := 0\n\
    \    for i := 0; i < len(romans); i++ {\n        if number >= romans[i] {\n  \
    \          roman_number = roman_number * 10 + romans[i]\n            number -=\
    \ romans[i]\n        }\n    }\n    return fmt.Sprintf(\"%v\", roman_number)\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3rdb423m_test.go:19:22: invalid operation: number >= romans[i] (mismatched
    types int and string)

    /tmp/tmp3rdb423m_test.go:20:28: invalid operation: roman_number * 10 + romans[i]
    (mismatched types int and string)

    /tmp/tmp3rdb423m_test.go:21:13: invalid operation: number -= romans[i] (mismatched
    types int and string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075735
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_numerals := map[int]string{\n\
    \        1: \"I\",\n        5: \"V\",\n        10: \"X\",\n        50: \"L\",\n\
    \        100: \"C\",\n        500: \"D\",\n        1000: \"M\",\n    }\n    roman_numeral\
    \ := roman_numerals[number]\n    if number < 1000 {\n        return roman_numeral\n\
    \    }\n    number -= 1000\n    roman_numeral += roman_numerals[number]\n    return\
    \ roman_numeral\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmpv_ryg2qp_test.go:57: expected 'xix', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpv_ryg2qp_test.go:57: expected\
    \ 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n  \
    \      tmpv_ryg2qp_test.go:57: expected 'ccli', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmpv_ryg2qp_test.go:57: expected 'cdxxvi', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpv_ryg2qp_test.go:57:\
    \ expected 'd', got 'D'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n\
    \        tmpv_ryg2qp_test.go:57: expected 'i', got 'I'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6\
    \ (0.00s)\n        tmpv_ryg2qp_test.go:57: expected 'iv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmpv_ryg2qp_test.go:57: expected\
    \ 'xliii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n \
    \       tmpv_ryg2qp_test.go:57: expected 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9\
    \ (0.00s)\n        tmpv_ryg2qp_test.go:57: expected 'xciv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmpv_ryg2qp_test.go:57:\
    \ expected 'dxxxii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11\
    \ (0.00s)\n        tmpv_ryg2qp_test.go:57: expected 'cm', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpv_ryg2qp_test.go:57:\
    \ expected 'cmxciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmpv_ryg2qp_test.go:57: expected 'm', got 'M'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075736
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := []string{\n       \
    \ \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"\
    X\", \"XI\", \"XII\",\n        \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"\
    XVIII\", \"XIX\", \"XX\", \"XXI\", \"XXII\",\n        \"XXIII\", \"XXIV\", \"\
    XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\",\n       \
    \ \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\"\
    , \"XXXIX\",\n        \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"LXXXX\", \"\
    LXXXXX\", \"LXXXXXX\", \"LXXXXXXX\",\n        \"LXXXXXV\", \"LXXXXXVI\", \"LXXXXXVII\"\
    , \"LXXXXXVIII\", \"LXXXXXIX\", \"LXXX\", \"LXXXI\",\n        \"LXXXII\", \"LXXXIII\"\
    , \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\",\n        \"LXXXIX\"\
    , \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\",\n\
    \        \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\",\
    \ \"LXXXIII\", \"LXXXIV\",\n        \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\"\
    , \"LXXXIX\", \"LXL\", \"LXLI\", \"LXLII\",\n        \"LXLIII\", \"LXLIV\", \"\
    LXLV\", \"LXLVI\", \"LXLVII\", \"LXLVIII\", \"LXLIX\", \"LX\",\n        \"LXI\"\
    , \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\", \"\
    LXIX\",\n        \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\"\
    , \"LXXVI\", \"LXXVII\",\n        \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\"\
    , \"LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\",\n        \"LXXXV\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpowtaessn_test.go:28:9: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075735
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := []string{\n       \
    \ \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"\
    X\", \"XI\", \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\"\
    , \"XIX\", \"XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\",\
    \ \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"\
    XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\", \"L\"\
    , \"LI\", \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\", \"\
    LIX\", \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\"\
    , \"LXVIII\", \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"\
    LXXV\", \"LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"\
    LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\"\
    , \"LXXXIX\", \"XC\", \"C\", \"CI\", \"CII\", \"CIV\", \"CV\", \"CVI\", \"CVII\"\
    , \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"CXV\"\
    , \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\", \"CXXI\", \"CXXII\", \"\
    CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"CXXVII\", \"CXXVIII\", \"CXXIX\",\
    \ \"CXXX\", \"CXXXI\", \"CXXXII\", \"CXXXIII\", \"CXXXIV\", \"CXXXV\", \"CXXXVI\"\
    , \"CXXXVII\", \"CXXXVIII\", \"CXXXIX\", \"CXL\", \"CL\", \"LI\", \"LII\", \"\
    LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\", \"LIX\", \"LX\", \"LXI\"\
    , \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"L\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp25s440y__test.go:14:1129: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075730
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_numerals := map[int]string{\n\
    \        1: \"I\",\n        5: \"V\",\n        10: \"X\",\n        50: \"L\",\n\
    \        100: \"C\",\n        500: \"D\",\n        1000: \"M\",\n    }\n    roman_numeral\
    \ := \"\"\n    for num, _ := range roman_numerals {\n        if number >= num\
    \ {\n            roman_numeral += roman_numerals[num]\n            number -= num\n\
    \        }\n    }\n    return strings.ToLower(roman_numeral)\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmps5kdrqk0_test.go:29:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075735
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_numerals := map[int]string{\n\
    \        1: \"I\",\n        2: \"II\",\n        3: \"III\",\n        4: \"IV\"\
    ,\n        5: \"V\",\n        6: \"VI\",\n        7: \"VII\",\n        8: \"VIII\"\
    ,\n        9: \"IX\",\n        10: \"X\",\n        11: \"XI\",\n        12: \"\
    XII\",\n        13: \"XIII\",\n        14: \"XIV\",\n        15: \"XV\",\n   \
    \     16: \"XVI\",\n        17: \"XVII\",\n        18: \"XVIII\",\n        19:\
    \ \"XIX\",\n        20: \"XX\",\n        30: \"XXI\",\n        40: \"XL\",\n \
    \       50: \"L\",\n        60: \"LX\",\n        70: \"LXX\",\n        80: \"\
    LXXX\",\n        90: \"XC\",\n        100: \"C\",\n        200: \"CC\",\n    \
    \    300: \"CCC\",\n        400: \"CD\",\n        500: \"D\",\n        600: \"\
    DC\",\n        700: \"DCC\",\n        800: \"DCCC\",\n        900: \"CM\",\n \
    \       1000: \"M\",\n    }\n    roman_numeral := \"\"\n    for roman_numeral,\
    \ number := range roman_numerals {\n        if number <= number {\n          \
    \  break\n        }\n    }\n    if roman_numeral == \"\" {\n        fmt.Println(\"\
    Error: no roman numeral for number\", number)\n    }\n    return roman_numeral\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpd_uakhby_test.go:53:9: roman_numeral declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075736
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romanNumerals := map[int]string{\n\
    \        1: \"I\",\n        5: \"V\",\n        10: \"X\",\n        50: \"L\",\n\
    \        100: \"C\",\n        500: \"D\",\n        1000: \"M\",\n    }\n    romanNumeral\
    \ := \"\"\n    for romanNumeral, number := range romanNumerals {\n        if number\
    \ >= number {\n            break\n        }\n    }\n    return fmt.Sprintf(\"\
    %c\", romanNumeral) + int_to_mini_roman(number-romanNumeral)\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpr1bd34j7_test.go:23:9: romanNumeral declared but not used

    /tmp/tmpr1bd34j7_test.go:28:64: invalid operation: number - romanNumeral (mismatched
    types int and string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075736
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := map[int]string{\n \
    \       1: \"I\",\n        5: \"V\",\n        10: \"X\",\n        50: \"L\",\n\
    \        100: \"C\",\n        500: \"D\",\n        1000: \"M\",\n    }\n    result\
    \ := \"\"\n    for num, _ := range romans {\n        if number >= num {\n    \
    \        result += romans[num]\n            number -= num\n        }\n    }\n\
    \    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmpry3lv9zh_test.go:58: expected 'xix', got 'IVX'\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpry3lv9zh_test.go:58:\
    \ expected 'clii', got 'VXLI'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2\
    \ (0.00s)\n        tmpry3lv9zh_test.go:58: expected 'ccli', got 'XLCIV'\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmpry3lv9zh_test.go:58:\
    \ expected 'cdxxvi', got 'LCIVX'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4\
    \ (0.00s)\n        tmpry3lv9zh_test.go:58: expected 'd', got 'IVXLC'\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmpry3lv9zh_test.go:58:\
    \ expected 'i', got 'I'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n\
    \        tmpry3lv9zh_test.go:58: expected 'iv', got 'I'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7\
    \ (0.00s)\n        tmpry3lv9zh_test.go:58: expected 'xliii', got 'VXI'\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmpry3lv9zh_test.go:58:\
    \ expected 'xc', got 'IVXL'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n\
    \        tmpry3lv9zh_test.go:58: expected 'xciv', got 'XLIV'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10\
    \ (0.00s)\n        tmpry3lv9zh_test.go:58: expected 'dxxxii', got 'IVXLC'\n  \
    \  --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmpry3lv9zh_test.go:58:\
    \ expected 'cm', got 'IVXLCD'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12\
    \ (0.00s)\n        tmpry3lv9zh_test.go:58: expected 'cmxciv', got 'DIVXLC'\n \
    \   --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmpry3lv9zh_test.go:58:\
    \ expected 'm', got 'DIVXLC'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075736
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_numerals := map[int]string{\n\
    \        1: \"I\",\n        5: \"V\",\n        10: \"X\",\n        50: \"L\",\n\
    \        100: \"C\",\n        500: \"D\",\n        1000: \"M\",\n    }\n    roman_numeral\
    \ := roman_numerals[number]\n    return strings.ToLower(roman_numeral)\n}\n\n\
    func TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnwct1mw7_test.go:23:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075730
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_num := \"\"\n    switch\
    \ number {\n    case 1:\n        roman_num = \"I\"\n    case 2:\n        roman_num\
    \ = \"II\"\n    case 3:\n        roman_num = \"III\"\n    case 4:\n        roman_num\
    \ = \"IV\"\n    case 5:\n        roman_num = \"V\"\n    case 6:\n        roman_num\
    \ = \"VI\"\n    case 7:\n        roman_num = \"VII\"\n    case 8:\n        roman_num\
    \ = \"VIII\"\n    case 9:\n        roman_num = \"IX\"\n    case 10:\n        roman_num\
    \ = \"X\"\n    case 11:\n        roman_num = \"XI\"\n    case 12:\n        roman_num\
    \ = \"XII\"\n    case 13:\n        roman_num = \"XIII\"\n    case 14:\n      \
    \  roman_num = \"XIV\"\n    case 15:\n        roman_num = \"XV\"\n    case 16:\n\
    \        roman_num = \"XVI\"\n    case 17:\n        roman_num = \"XVII\"\n   \
    \ case 18:\n        roman_num = \"XVIII\"\n    case 19:\n        roman_num = \"\
    XIX\"\n    case 20:\n        roman_num = \"XX\"\n    case 21:\n        roman_num\
    \ = \"XXI\"\n    case 22:\n        roman_num = \"XXII\"\n    case 23:\n      \
    \  roman_num = \"XXIII\"\n    case 24:\n        roman_num = \"XXIV\"\n    case\
    \ 25:\n        roman_num = \"XXV\"\n    case 26:\n        roman_num = \"XXVI\"\
    \n    case 27:\n        roman_num = \"XXVII\"\n    case 28:\n        roman_num\
    \ = \"XXVIII\"\n    case 29:\n        roman_num = \"XXIX\"\n    case 30:\n   \
    \     roman_num = \"XXX\"\n    case 31:\n        roman_num = \"XXXI\"\n    case\
    \ 32:\n        roman_num = \"XXXII\"\n    case 33:\n        roman_num = \"XXXIII\"\
    \n    case 34:\n        roman_num = \"XXXIV\"\n    case 35:\n        roman_num\
    \ = \"XXXV\"\n    case 36:\n        roman_num = \"XXXVI\"\n    case 37:\n    \
    \    roman_num = \"XXXVII\"\n    case 38:\n        roman_num = \"XXXVIII\"\n \
    \   case 39:\n        roman_num = \"XXXIX\"\n    case 40:\n        roman_num =\
    \ \"XL\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8xvbo_2c_test.go:95:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075728
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := []string{\n       \
    \ \"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"\
    D\", \"CM\",\n        \"M\", \"MM\", \"MMM\",\n    }\n    roman_number := 0\n\
    \    for roman_number < len(romans) {\n        if number >= romans[roman_number]\
    \ {\n            number -= romans[roman_number]\n            return romans[roman_number]\
    \ + string(number)\n        }\n        roman_number++\n    }\n    return string(number)\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp71aiv1a8_test.go:19:22: invalid operation: number >= romans[roman_number]
    (mismatched types int and string)

    /tmp/tmp71aiv1a8_test.go:20:13: invalid operation: number -= romans[roman_number]
    (mismatched types int and string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075736
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_numerals := []string{\"\
    I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\"\
    , \"XI\", \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"\
    XIX\", \"XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\"\
    , \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"\
    XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\", \"L\", \"LI\",\
    \ \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\"\
    , \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"\
    LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\",\
    \ \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"\
    LXXXIX\", \"XC\", \"C\", \"CI\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\"\
    , \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\", \"CXXI\"\
    , \"CXXII\", \"CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"CXXVII\", \"CXXVIII\"\
    , \"CXXIX\", \"CXXX\", \"CXXXI\", \"CXXXII\", \"CXXXIII\", \"CXXXIV\", \"CXXXV\"\
    , \"CXXXVI\", \"CXXXVII\", \"CXXXVIII\", \"CXXXIX\", \"CC\", \"CCI\", \"CCII\"\
    , \"CCIII\", \"CCIV\", \"CCV\", \"CCVI\", \"CCVII\", \"CCVIII\", \"CCIX\", \"\
    CXX\", \"CXXI\", \"CXXII\", \"CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"CXXVII\"\
    , \"CXXVIII\", \"CXXIX\", \"CXXX\", \"CXXXI\", \"CXXXII\", \"CXXXIII\", \"CXXXIV\"\
    , \"CXXXV\", \"CXXXVI\", \"CXXXVII\", \"\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpg1yju1ri_test.go:13:1151: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075735
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := []string{\"I\", \"\
    II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\"\
    , \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"\
    XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"\
    XXVIII\", \"XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\"\
    , \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\", \"L\", \"LI\", \"LII\"\
    , \"LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\", \"LIX\", \"LX\", \"\
    LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\"\
    , \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"\
    LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\",\
    \ \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"\
    LXXXIX\", \"XC\", \"C\", \"CI\", \"CII\", \"CIV\", \"CV\", \"CVI\", \"CVII\",\
    \ \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"CXV\"\
    , \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\", \"CXXI\", \"CXXII\", \"\
    CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"CXXVII\", \"CXXVIII\", \"CXXIX\",\
    \ \"CXXX\", \"CXXXI\", \"CXXXII\", \"CXXXIII\", \"CXXXIV\", \"CXXXV\", \"CXXXVI\"\
    , \"CXXXVII\", \"CXXXVIII\", \"CXXXIX\", \"CXL\", \"CL\", \"LI\", \"LII\", \"\
    LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\", \"LIX\", \"LX\", \"LXI\"\
    , \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVII\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpewshv08s_test.go:13:1144: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075728
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_numerals := map[int]string{\n\
    \        1: \"I\",\n        5: \"V\",\n        10: \"X\",\n        50: \"L\",\n\
    \        100: \"C\",\n        500: \"D\",\n        1000: \"M\",\n    }\n    roman_numeral\
    \ := roman_numerals[number]\n    return strings.ToLower(roman_numeral)\n}\n\n\
    func TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnwct1mw7_test.go:23:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075730
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    var roman_numerals []string\n\
    \    roman_numerals = append(roman_numerals, \"\", \"I\", \"II\", \"III\", \"\
    IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\", \"XIII\"\
    , \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\", \"\
    XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\"\
    , \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\", \"\
    XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\", \"L\", \"LI\", \"LXI\", \"LXII\", \"\
    LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\", \"LXIX\", \"LXX\"\
    , \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\"\
    , \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\", \"LXXXIV\"\
    , \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\", \"XC\", \"C\"\
    , \"CI\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"CXV\", \"\
    CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\", \"CXXI\", \"CXXII\", \"CXXIII\"\
    , \"CXXIV\", \"CXXV\", \"CXXVI\", \"CXXVII\", \"CXXVIII\", \"CXXIX\", \"CXXX\"\
    , \"CXXXI\", \"CXXXII\", \"CXXXIII\", \"CXXXIV\", \"CXXXV\", \"CXXXVI\", \"CXXXVII\"\
    , \"CXXXVIII\", \"CXXXIX\", \"CXL\", \"CL\", \"CLI\", \"CLXI\", \"CLXII\", \"\
    CLXIII\", \"CLXIV\", \"CLXV\", \"CLXVI\", \"CLXVII\", \"CLXVIII\", \"CLXIX\",\
    \ \"CLXX\", \"CLXXI\", \"CLXXII\", \"CLXXIII\", \"CLXXIV\", \"CLXXV\", \"CLXXVI\"\
    , \"CLXXVII\", \"CLXXVIII\", \"CLXXIX\", \"CLXXX\", \"CLXXXI\", \"CL\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpl2pk0x_0_test.go:14:1142: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075735
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := []string{\"I\", \"\
    II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\"\
    , \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"\
    XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"\
    XXVIII\", \"XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\"\
    , \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\", \"L\", \"LI\", \"LII\"\
    , \"LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\", \"LIX\", \"LX\", \"\
    LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\"\
    , \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"\
    LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\",\
    \ \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"\
    LXXXIX\", \"XC\", \"C\", \"CI\", \"CII\", \"CIV\", \"CV\", \"CVI\", \"CVII\",\
    \ \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"CXV\"\
    , \"CXVI\", \"CXVII\", \"CXVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\"\
    , \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CIX\", \"CX\", \"CXI\"\
    , \"CXII\", \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"\
    CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\"\
    , \"CXVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"CXV\"\
    , \"CXVI\", \"CXVII\", \"CXVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\"\
    , \"CXIV\", \"CXV\", \"CXVI\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpl901evyu_test.go:13:1174: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075735
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    var roman_numerals []string\n\
    \    roman_numerals = append(roman_numerals, roman_to_mini_roman(number))\n  \
    \  roman_numerals = append(roman_numerals, mini_roman_to_mini_roman(number))\n\
    \    roman_numerals = append(roman_numerals, mini_roman_to_roman(number))\n  \
    \  roman_numerals = append(roman_numerals, roman_to_roman(number))\n    roman_numerals\
    \ = append(roman_numerals, mini_roman_to_roman(number))\n    roman_numerals =\
    \ append(roman_numerals, roman_to_mini_roman(number))\n    roman_numerals = append(roman_numerals,\
    \ mini_roman_to_mini_roman(number))\n    roman_numerals = append(roman_numerals,\
    \ mini_roman_to_mini_roman(number))\n    roman_numerals = append(roman_numerals,\
    \ mini_roman_to_mini_roman(number))\n    roman_numerals = append(roman_numerals,\
    \ mini_roman_to_mini_roman(number))\n    roman_numerals = append(roman_numerals,\
    \ mini_roman_to_mini_roman(number))\n    roman_numerals = append(roman_numerals,\
    \ mini_roman_to_mini_roman(number))\n    roman_numerals = append(roman_numerals,\
    \ mini_roman_to_mini_roman(number))\n    roman_numerals = append(roman_numerals,\
    \ mini_roman_to_mini_roman(number))\n    roman_numerals = append(roman_numerals,\
    \ mini_roman_to_mini_roman(number))\n    roman_numerals = append(roman_numerals,\
    \ mini_roman_to_mini_roman(number))\n    roman_numerals = append(roman_numerals,\
    \ mini_roman_to_mini_roman(number))\n    roman_numerals = append(roman_numerals,\
    \ mini_roman_to_mini_roman(number))\n    roman_numerals = append(roman_numerals,\
    \ mini_roman_to_mini_roman(number))\n    roman_numerals = append(roman_numerals,\
    \ mini_roman_to_mini_roman(number))\n    roman_numerals = append(roman_numerals,\
    \ mini_ro\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpur12c9tk_test.go:34:52: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075735
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := map[int]string{\n \
    \       1: \"I\",\n        5: \"V\",\n        10: \"X\",\n        50: \"L\",\n\
    \        100: \"C\",\n        500: \"D\",\n        1000: \"M\",\n    }\n    roman,\
    \ ok := romans[number]\n    if !ok {\n        fmt.Println(\"Invalid input\")\n\
    \    }\n    return roman\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Invalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid input\n\
    Invalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid\
    \ input\n--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmpcwfbu4ek_test.go:55: expected 'xix', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpcwfbu4ek_test.go:55: expected\
    \ 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n  \
    \      tmpcwfbu4ek_test.go:55: expected 'ccli', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmpcwfbu4ek_test.go:55: expected 'cdxxvi', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpcwfbu4ek_test.go:55:\
    \ expected 'd', got 'D'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n\
    \        tmpcwfbu4ek_test.go:55: expected 'i', got 'I'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6\
    \ (0.00s)\n        tmpcwfbu4ek_test.go:55: expected 'iv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmpcwfbu4ek_test.go:55: expected\
    \ 'xliii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n \
    \       tmpcwfbu4ek_test.go:55: expected 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9\
    \ (0.00s)\n        tmpcwfbu4ek_test.go:55: expected 'xciv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmpcwfbu4ek_test.go:55:\
    \ expected 'dxxxii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11\
    \ (0.00s)\n        tmpcwfbu4ek_test.go:55: expected 'cm', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpcwfbu4ek_test.go:55:\
    \ expected 'cmxciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmpcwfbu4ek_test.go:55: expected 'm', got 'M'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075729
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romanNumerals := []string{\n\
    \        \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"\
    IX\", \"X\", \"XI\", \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"\
    XVIII\", \"XIX\", \"XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"\
    XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\"\
    , \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\",\
    \ \"L\", \"LI\", \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\"\
    , \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\"\
    , \"LXVIII\", \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"\
    LXXV\", \"LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"\
    LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\"\
    , \"LXXXIX\", \"XC\", \"C\", \"CI\", \"CII\", \"CIV\", \"CV\", \"CVI\", \"CVII\"\
    , \"CVIII\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\"\
    , \"CXVII\", \"CXVIII\", \"CXIX\", \"CC\", \"CCI\", \"CCII\", \"CCIII\", \"CCIV\"\
    , \"CCV\", \"CCVI\", \"CCVII\", \"CCVIII\", \"CCIX\", \"CD\", \"CDI\", \"CDII\"\
    , \"CDIII\", \"CDIV\", \"CDV\", \"CDVI\", \"CDVII\", \"CDVIII\", \"CDIX\", \"\
    CXX\", \"CXXI\", \"CXXII\", \"CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"CXXVII\"\
    , \"CXXVIII\", \"CXXIX\", \"CXXX\", \"CXXXI\", \"CXXXII\", \"CXXXIII\", \"CXXXIV\"\
    , \"CXXXV\", \"CXXXVI\", \"CXXXVII\", \"CXXXVIII\", \"CXXXIX\", \"C\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp2u3z0xit_test.go:14:1135: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075735
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_numerals := []string{\n\
    \        \"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"\
    CD\", \"D\", \"CM\",\n        \"M\", \"MM\", \"MMM\",\n    }\n    roman_numeral_string\
    \ := \"\"\n    for _, roman_numeral := range roman_numerals {\n        if number\
    \ >= roman_numeral {\n            roman_numeral_string = roman_numeral\n     \
    \       break\n        }\n    }\n    if roman_numeral_string == \"\" {\n     \
    \   fmt.Println(\"Invalid input\")\n    }\n    return roman_numeral_string\n}\n\
    \nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpaixpdioi_test.go:19:22: invalid operation: number >= roman_numeral (mismatched
    types int and string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075736
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := map[int]string{\n \
    \       1: \"I\",\n        5: \"V\",\n        10: \"X\",\n        50: \"L\",\n\
    \        100: \"C\",\n        500: \"D\",\n        1000: \"M\",\n    }\n    roman_number\
    \ := \"\"\n    for roman_number, number := range romans {\n        if number >=\
    \ number {\n            break\n        }\n    }\n    return fmt.Sprintf(\"%v\"\
    , romans[number])\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2wf1nq5v_test.go:22:5: roman_number declared but not used

    /tmp/tmp2wf1nq5v_test.go:23:9: roman_number declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075736
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := []string{\n       \
    \ \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"\
    X\", \"XI\", \"XII\",\n        \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"\
    XVIII\", \"XIX\", \"XX\", \"XXI\", \"XXII\",\n        \"XXIII\", \"XXIV\", \"\
    XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\",\n       \
    \ \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\"\
    , \"XXXIX\",\n        \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"LXXXX\", \"\
    LXXXXX\", \"LXXXXXX\", \"LXXXXXXX\",\n        \"LXXXXXV\", \"LXXXXXVI\", \"LXXXXXVII\"\
    , \"LXXXXXVIII\", \"LXXXXXIX\", \"LXXX\", \"LXXXI\",\n        \"LXXXII\", \"LXXXIII\"\
    , \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\",\n        \"LXXXIX\"\
    , \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\",\n\
    \        \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\",\
    \ \"LXXXIII\", \"LXXXIV\",\n        \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\"\
    , \"LXXXIX\", \"LXL\", \"LXLI\", \"LXLII\",\n        \"LXLIII\", \"LXLIIII\",\
    \ \"LXLIIV\", \"LXLIV\", \"LXLIVI\", \"LXLIVII\", \"LXLIVIII\",\n        \"LXLIIX\"\
    , \"LXLX\", \"LXLXI\", \"LXLXII\", \"LXLXIII\", \"LXLXIV\", \"LXLV\", \"LXLVI\"\
    ,\n        \"LXLVII\", \"LXLVIII\", \"LXLVIV\", \"LXLVV\", \"LXLVVI\", \"LXLVVII\"\
    , \"LXLVVIII\",\n        \"LXLVIX\", \"LXLX\", \"LXLXI\", \"LXLXII\", \"LXLXIII\"\
    , \"LXLXIV\", \"LXLV\", \"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0qi_0bc4_test.go:27:75: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075736
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_num := \"\"\n    switch\
    \ number {\n    case 1:\n        roman_num = \"I\"\n    case 2:\n        roman_num\
    \ = \"II\"\n    case 3:\n        roman_num = \"III\"\n    case 4:\n        roman_num\
    \ = \"IV\"\n    case 5:\n        roman_num = \"V\"\n    case 6:\n        roman_num\
    \ = \"VI\"\n    case 7:\n        roman_num = \"VII\"\n    case 8:\n        roman_num\
    \ = \"VIII\"\n    case 9:\n        roman_num = \"IX\"\n    case 10:\n        roman_num\
    \ = \"X\"\n    case 11:\n        roman_num = \"XI\"\n    case 12:\n        roman_num\
    \ = \"XII\"\n    case 13:\n        roman_num = \"XIII\"\n    case 14:\n      \
    \  roman_num = \"XIV\"\n    case 15:\n        roman_num = \"XV\"\n    case 16:\n\
    \        roman_num = \"XVI\"\n    case 17:\n        roman_num = \"XVII\"\n   \
    \ case 18:\n        roman_num = \"XVIII\"\n    case 19:\n        roman_num = \"\
    XIX\"\n    case 20:\n        roman_num = \"XX\"\n    case 21:\n        roman_num\
    \ = \"XXI\"\n    case 22:\n        roman_num = \"XXII\"\n    case 23:\n      \
    \  roman_num = \"XXIII\"\n    case 24:\n        roman_num = \"XXIV\"\n    case\
    \ 25:\n        roman_num = \"XXV\"\n    case 26:\n        roman_num = \"XXVI\"\
    \n    case 27:\n        roman_num = \"XXVII\"\n    case 28:\n        roman_num\
    \ = \"XXVIII\"\n    case 29:\n        roman_num = \"XXIX\"\n    case 30:\n   \
    \     roman_num = \"XXX\"\n    case 31:\n        roman_num = \"XXXI\"\n    case\
    \ 32:\n        roman_num = \"XXXII\"\n    case 33:\n        roman_num = \"XXXIII\"\
    \n    case 34:\n        roman_num = \"XXXIV\"\n    case 35:\n        roman_num\
    \ = \"XXXV\"\n    case 36:\n        roman_num = \"XXXVI\"\n    case 37:\n    \
    \    roman_num = \"XXXVII\"\n    case 38:\n        roman_num = \"XXXVIII\"\n \
    \   case 39:\n        roman_num = \"XXXIX\"\n    case 40:\n        roman_num =\
    \ \"XL\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8xvbo_2c_test.go:95:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075728
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_num := \"\"\n    switch\
    \ number {\n    case 1:\n        roman_num = \"I\"\n    case 2:\n        roman_num\
    \ = \"II\"\n    case 3:\n        roman_num = \"III\"\n    case 4:\n        roman_num\
    \ = \"IV\"\n    case 5:\n        roman_num = \"V\"\n    case 6:\n        roman_num\
    \ = \"VI\"\n    case 7:\n        roman_num = \"VII\"\n    case 8:\n        roman_num\
    \ = \"VIII\"\n    case 9:\n        roman_num = \"IX\"\n    case 10:\n        roman_num\
    \ = \"X\"\n    case 11:\n        roman_num = \"XI\"\n    case 12:\n        roman_num\
    \ = \"XII\"\n    case 13:\n        roman_num = \"XIII\"\n    case 14:\n      \
    \  roman_num = \"XIV\"\n    case 15:\n        roman_num = \"XV\"\n    case 16:\n\
    \        roman_num = \"XVI\"\n    case 17:\n        roman_num = \"XVII\"\n   \
    \ case 18:\n        roman_num = \"XVIII\"\n    case 19:\n        roman_num = \"\
    XIX\"\n    case 20:\n        roman_num = \"XX\"\n    case 21:\n        roman_num\
    \ = \"XXI\"\n    case 22:\n        roman_num = \"XXII\"\n    case 23:\n      \
    \  roman_num = \"XXIII\"\n    case 24:\n        roman_num = \"XXIV\"\n    case\
    \ 25:\n        roman_num = \"XXV\"\n    case 26:\n        roman_num = \"XXVI\"\
    \n    case 27:\n        roman_num = \"XXVII\"\n    case 28:\n        roman_num\
    \ = \"XXVIII\"\n    case 29:\n        roman_num = \"XXIX\"\n    case 30:\n   \
    \     roman_num = \"XXX\"\n    case 31:\n        roman_num = \"XXXI\"\n    case\
    \ 32:\n        roman_num = \"XXXII\"\n    case 33:\n        roman_num = \"XXXIII\"\
    \n    case 34:\n        roman_num = \"XXXIV\"\n    case 35:\n        roman_num\
    \ = \"XXXV\"\n    case 36:\n        roman_num = \"XXXVI\"\n    case 37:\n    \
    \    roman_num = \"XXXVII\"\n    case 38:\n        roman_num = \"XXXVIII\"\n \
    \   case 39:\n        roman_num = \"XXXIX\"\n    case 40:\n        roman_num =\
    \ \"XL\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8xvbo_2c_test.go:95:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075728
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := []string{\"I\", \"\
    II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\"\
    , \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"\
    XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"\
    XXVIII\", \"XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\"\
    , \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\", \"L\", \"LI\", \"LII\"\
    , \"LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\", \"LIX\", \"LX\", \"\
    LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\"\
    , \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"\
    LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\",\
    \ \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"\
    LXXXIX\", \"XC\", \"C\", \"CI\", \"CII\", \"CIV\", \"CV\", \"CVI\", \"CVII\",\
    \ \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"CXV\"\
    , \"CXVI\", \"CXVII\", \"CXVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\"\
    , \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CIX\", \"CX\", \"CXI\"\
    , \"CXII\", \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"\
    CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\"\
    , \"CXVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"CXV\"\
    , \"CXVI\", \"CXVII\", \"CXVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\"\
    , \"CXIV\", \"CXV\", \"CXV\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6mcy9p06_test.go:13:1174: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075736
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := []string{\n       \
    \ \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"\
    X\", \"XI\", \"XII\",\n        \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"\
    XVIII\", \"XIX\", \"XX\", \"XXI\", \"XXII\",\n        \"XXIII\", \"XXIV\", \"\
    XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\",\n       \
    \ \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\"\
    , \"XXXIX\",\n        \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"LXXXX\", \"\
    LXXXXX\", \"LXXXII\", \"LXXXIII\",\n        \"LXXXIV\", \"LXXXV\", \"LXXXVI\"\
    , \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\", \"LXXXVIII\",\n        \"LXXXIX\", \"\
    LXXXIX\", \"LXXXIX\", \"LXXXIX\", \"LXXXIX\", \"LXXXIX\", \"LXXXIX\",\n      \
    \  \"LXXXIX\", \"LXXXIX\", \"LXXXIX\", \"LXXXIX\", \"LXXXIX\", \"LXXXIX\", \"\
    LXXXIX\",\n        \"LXXXIX\", \"LXXXIX\", \"LXXXIX\", \"LXXXIX\", \"LXXXIX\"\
    , \"LXXXIX\", \"LXXXIX\",\n        \"LXXXIX\", \"LXXXIX\", \"LXXXIX\", \"LXXXIX\"\
    , \"LXXXIX\", \"LXXXIX\", \"LXXXIX\",\n        \"LXXXIX\", \"LXXXIX\", \"LXXXIX\"\
    , \"LXXXIX\", \"LXXXIX\", \"LXXXIX\", \"LXXXIX\",\n        \"LXXXIX\", \"LXXXIX\"\
    , \"LXXXIX\", \"LXXXIX\", \"LXXXIX\", \"LXXXIX\", \"LXXXIX\",\n        \"LXXXIX\"\
    , \"LXXXIX\", \"LXXXIX\", \"LXXXIX\", \"LXXXIX\", \"LXXXIX\", \"LXXXIX\",\n  \
    \      \"LXXXIX\", \"LXXXIX\", \"LXXXIX\", \"LXXXIX\", \"LXXXIX\", \"LXXXIX\"\
    , \"LXXXIX\",\n        \"LXXXIX\", \"LXXXIX\", \"LXXXIX\", \"LXXXIX\", \"LXXXIX\"\
    , \"LXXXIX\", \"LXXXIX\",\n        \"LXXXIX\", \"LXXXIX\", \"LXXXIX\", \"LXXXIX\"\
    , \"LXXXIX\", \"LXXXIX\", \"LXXXIX\",\n        \"LXXXIX\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmptwy2jxvv_test.go:30:9: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075736
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    if number < 1 {\n        fmt.Println(\"\
    Invalid input\")\n        return \"Invalid input\"\n    }\n    if number < 1000\
    \ {\n        return fmt.Sprintf(\"%d\", number)\n    }\n    romans := []string{\"\
    M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\"\
    , \"IV\", \"I\"}\n    result := \"\"\n    for _, romanIndex := range romans {\n\
    \        result += \"M\"\n        if number >= 1000 && number < 1000000 {\n  \
    \          result += romanIndex\n            number -= number/1000\n        }\
    \ else {\n            result += romanIndex\n        }\n    }\n    return result\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmptpoeoyzp_test.go:60: expected 'xix', got '19'\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmptpoeoyzp_test.go:60: expected\
    \ 'clii', got '152'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n\
    \        tmptpoeoyzp_test.go:60: expected 'ccli', got '251'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmptpoeoyzp_test.go:60: expected 'cdxxvi', got '426'\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmptpoeoyzp_test.go:60:\
    \ expected 'd', got '500'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n\
    \        tmptpoeoyzp_test.go:60: expected 'i', got '1'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6\
    \ (0.00s)\n        tmptpoeoyzp_test.go:60: expected 'iv', got '4'\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmptpoeoyzp_test.go:60: expected\
    \ 'xliii', got '43'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n\
    \        tmptpoeoyzp_test.go:60: expected 'xc', got '90'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9\
    \ (0.00s)\n        tmptpoeoyzp_test.go:60: expected 'xciv', got '94'\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmptpoeoyzp_test.go:60:\
    \ expected 'dxxxii', got '532'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11\
    \ (0.00s)\n        tmptpoeoyzp_test.go:60: expected 'cm', got '900'\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmptpoeoyzp_test.go:60:\
    \ expected 'cmxciv', got '994'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmptpoeoyzp_test.go:60: expected 'm', got 'MMMCMMDMCDMCMXCMLMXLMXMIXMVMIVMI'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075737
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_numerals := []string{\n\
    \        \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"\
    IX\", \"X\", \"XI\", \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"\
    XVIII\", \"XIX\", \"XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"\
    XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\"\
    , \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\",\
    \ \"L\", \"LI\", \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\"\
    , \"LIX\", \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\",\
    \ \"LXVII\", \"LXVIII\", \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"\
    LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"\
    LXXXI\", \"LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\"\
    , \"LXXXVIII\", \"LXXXIX\", \"XC\", \"C\", \"CI\", \"CII\", \"CIV\", \"CV\", \"\
    CVI\", \"CVII\", \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"\
    CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\", \"CXXI\"\
    , \"CXXII\", \"CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"CXXVII\", \"CXXVIII\"\
    , \"CXXIX\", \"CXXX\", \"CXXXI\", \"CXXXII\", \"CXXXIII\", \"CXXXIV\", \"CXXXV\"\
    , \"CXXXVI\", \"CXXXVII\", \"CXXXVIII\", \"CXXXIX\", \"CXL\", \"CL\", \"LI\",\
    \ \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\", \"LIX\", \"\
    LX\", \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXV\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdwhu2x4j_test.go:14:1120: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075736
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_numerals := map[int]string{\n\
    \        1: \"I\",\n        2: \"II\",\n        3: \"III\",\n        4: \"IV\"\
    ,\n        5: \"V\",\n        6: \"VI\",\n        7: \"VII\",\n        8: \"VIII\"\
    ,\n        9: \"IX\",\n        10: \"X\",\n        11: \"XI\",\n        12: \"\
    XII\",\n        13: \"XIII\",\n        14: \"XIV\",\n        15: \"XV\",\n   \
    \     16: \"XVI\",\n        17: \"XVII\",\n        18: \"XVIII\",\n        19:\
    \ \"XIX\",\n        20: \"XX\",\n        30: \"XXX\",\n        40: \"XL\",\n \
    \       50: \"L\",\n        60: \"LX\",\n        70: \"LXX\",\n        80: \"\
    LXXX\",\n        90: \"XC\",\n        100: \"C\",\n        200: \"CC\",\n    \
    \    300: \"CCC\",\n        400: \"CD\",\n        500: \"D\",\n        600: \"\
    DC\",\n        700: \"DCC\",\n        800: \"DCCC\",\n        900: \"CM\",\n \
    \       1000: \"M\",\n    }\n    roman_numeral := \"\"\n    for roman_numeral,\
    \ number := range roman_numerals {\n        if number <= number {\n          \
    \  break\n        }\n    }\n    if number > 1000 {\n        fmt.Println(\"Error:\
    \ number too large\")\n    }\n    return roman_numeral\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvb1d0nxo_test.go:53:9: roman_numeral declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075737
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_numerals := []string{\n\
    \        \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"\
    IX\", \"X\", \"XI\",\n        \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"\
    XVII\", \"XVIII\", \"XIX\", \"XX\",\n        \"XXI\", \"XXII\", \"XXIII\", \"\
    XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\",\n        \"XXIX\", \"XXX\",\
    \ \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\",\n        \"XXVII\"\
    , \"XXVIII\", \"XXIX\", \"XXX\", \"XI\", \"XI\", \"XII\", \"XIII\", \"XIV\",\n\
    \        \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XVI\", \"XVII\", \"\
    XVIII\", \"XIX\",\n        \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"\
    XXVI\", \"XXVII\", \"XXVIII\",\n        \"XXIX\", \"XXX\", \"X\", \"XI\", \"XII\"\
    , \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\",\n        \"XVIII\", \"XIX\", \"\
    XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XXI\", \"XXII\", \"XXIII\",\n        \"\
    XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"X\", \"\
    XI\",\n        \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\"\
    , \"XIX\", \"XVI\",\n        \"XVII\", \"XVIII\", \"XIX\", \"XVI\", \"XVII\",\
    \ \"XVIII\", \"XIX\", \"XXI\", \"XXII\",\n        \"XXIII\", \"XXIV\", \"XXV\"\
    , \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\",\n        \"X\", \"XI\",\
    \ \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\",\n\
    \        \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XVI\", \"XVII\", \"XVIII\",\
    \ \"XIX\", \"XXI\",\n        \"XXII\", \"XXIII\", \"XXIV\", \"\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5fdippjf_test.go:29:34: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075736
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := map[int]string{\n \
    \       1: \"I\",\n        5: \"V\",\n        10: \"X\",\n        50: \"L\",\n\
    \        100: \"C\",\n        500: \"D\",\n        1000: \"M\",\n    }\n    result\
    \ := \"\"\n    for num, _ := range romans {\n        if number >= num {\n    \
    \        result += romans[num]\n            number -= num\n        }\n    }\n\
    \    return strings.ToLower(result)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9pg55rzc_test.go:29:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075730
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_numerals := []string{\n\
    \        \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"\
    IX\", \"X\", \"XI\", \"XII\", \"XIII\",\n        \"XIV\", \"XV\", \"XVI\", \"\
    XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\",\n\
    \        \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\"\
    , \"XXXII\", \"XXXIII\", \"XXXIV\",\n        \"XXXV\", \"XXXVI\", \"XXXVII\",\
    \ \"XXXVIII\", \"XXXIX\", \"XL\", \"L\", \"LI\", \"LXI\", \"LXII\", \"LXIII\"\
    ,\n        \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\", \"LXIX\", \"LXX\"\
    , \"LXXI\", \"LXXII\", \"LXXIII\",\n        \"LXXIV\", \"LXXV\", \"LXXVI\", \"\
    LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\",\n        \"\
    LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\"\
    , \"XC\", \"C\", \"CI\",\n        \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"CXV\"\
    , \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\", \"CXXI\",\n        \"CXXII\"\
    , \"CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"CXXVII\", \"CXXVIII\", \"CXXIX\"\
    , \"CXXX\",\n        \"CXXXI\", \"CXXXII\", \"CXXXIII\", \"CXXXIV\", \"CXXXV\"\
    , \"CXXXVI\", \"CXXXVII\", \"CXXXVIII\", \"CXXXIX\",\n        \"CC\", \"CCI\"\
    , \"CCXI\", \"CCXII\", \"CCXIII\", \"CCXIV\", \"CCXV\", \"CCXVI\", \"CCXVII\"\
    , \"CCXVIII\",\n        \"CCXIX\", \"CCXX\", \"CCXXI\", \"CCXXII\", \"CCXXIII\"\
    , \"CCXXIV\", \"CCXXV\", \"CCXXVI\", \"CCXXVII\",\n        \"CCXXVIII\", \"CCXXIX\"\
    , \"CC\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpet5wtrry_test.go:26:31: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075737
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_numerals := []string{\n\
    \        \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"\
    IX\", \"X\", \"XI\", \"XII\",\n        \"XIII\", \"XIV\", \"XV\", \"XVI\", \"\
    XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\", \"XXII\",\n        \"XXIII\", \"\
    XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\"\
    ,\n        \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\",\
    \ \"XXXVIII\", \"XXXIX\",\n        \"XL\", \"L\", \"LI\", \"LXI\", \"LXII\", \"\
    LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\",\n        \"LXVIII\", \"LXIX\"\
    , \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\",\n\
    \        \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\",\
    \ \"LXXXIII\", \"LXXXIV\",\n        \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\"\
    , \"LXXXIX\", \"XC\", \"C\", \"CI\", \"CXI\",\n        \"CXII\", \"CXIII\", \"\
    CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\",\n       \
    \ \"CXXI\", \"CXXII\", \"CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"CXXVII\"\
    , \"CXXVIII\",\n        \"CXXIX\", \"CXXX\", \"CXXXI\", \"CXXXII\", \"CXXXIII\"\
    , \"CXXXIV\", \"CXXXV\", \"CXXXVI\",\n        \"CXXXVII\", \"CXXXVIII\", \"CXXXIX\"\
    , \"CC\", \"CCI\", \"CCXI\", \"CCXII\", \"CCXIII\",\n        \"CCXIV\", \"CCXV\"\
    , \"CCXVI\", \"CCXVII\", \"CCXVIII\", \"CCXIX\", \"CCH\", \"CCHI\",\n        \"\
    CCHII\", \"CCHIII\", \"CCHIV\", \"CCHV\", \"CCHVI\", \"CCHVII\", \"CCHVIII\",\
    \ \"CCHIX\",\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6_v8m84g_test.go:28:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075737
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_numerals := []string{\n\
    \        \"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"\
    CD\", \"D\", \"CM\", \"M\", \"MN\", \"N\", \"NM\", \"NN\",\n    }\n    result\
    \ := \"\"\n    for _, roman_numeral := range roman_numerals {\n        if number\
    \ >= roman_numeral[0] {\n            result += roman_numeral[1:]\n           \
    \ number -= roman_numeral[0]\n        }\n    }\n    if number > 0 {\n        result\
    \ += roman_numerals[len(roman_numerals)-1]\n    }\n    return result\n}\n\nfunc\
    \ TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcgi2c1js_test.go:18:22: invalid operation: number >= roman_numeral[0]
    (mismatched types int and byte)

    /tmp/tmpcgi2c1js_test.go:20:13: invalid operation: number -= roman_numeral[0]
    (mismatched types int and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075737
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_number := \"\"\n    switch\
    \ number {\n    case 1:\n        roman_number = \"I\"\n    case 2:\n        roman_number\
    \ = \"II\"\n    case 3:\n        roman_number = \"III\"\n    case 4:\n       \
    \ roman_number = \"IV\"\n    case 5:\n        roman_number = \"V\"\n    case 6:\n\
    \        roman_number = \"VI\"\n    case 7:\n        roman_number = \"VII\"\n\
    \    case 8:\n        roman_number = \"VIII\"\n    case 9:\n        roman_number\
    \ = \"IX\"\n    case 10:\n        roman_number = \"X\"\n    case 11:\n       \
    \ roman_number = \"XI\"\n    case 12:\n        roman_number = \"XII\"\n    case\
    \ 13:\n        roman_number = \"XIII\"\n    case 14:\n        roman_number = \"\
    XIV\"\n    case 15:\n        roman_number = \"XV\"\n    case 16:\n        roman_number\
    \ = \"XVI\"\n    case 17:\n        roman_number = \"XVII\"\n    case 18:\n   \
    \     roman_number = \"XVIII\"\n    case 19:\n        roman_number = \"XIX\"\n\
    \    case 20:\n        roman_number = \"XX\"\n    case 21:\n        roman_number\
    \ = \"XXI\"\n    case 22:\n        roman_number = \"XXII\"\n    case 23:\n   \
    \     roman_number = \"XXIII\"\n    case 24:\n        roman_number = \"XXIV\"\n\
    \    case 25:\n        roman_number = \"XXV\"\n    case 26:\n        roman_number\
    \ = \"XXVI\"\n    case 27:\n        roman_number = \"XXVII\"\n    case 28:\n \
    \       roman_number = \"XXVIII\"\n    case 29:\n        roman_number = \"XXIX\"\
    \n    case 30:\n        roman_number = \"XXX\"\n    case 31:\n        roman_number\
    \ = \"XXXI\"\n    case 32:\n        roman_number = \"XXXII\"\n    case 33:\n \
    \       roman_number = \"XXXIII\"\n    case 34:\n        roman_number = \"XXXIV\"\
    \n    case 35:\n        roman_number = \"XXXV\"\n    case 36:\n        roman_number\
    \ = \"XXXVI\"\n    case 37:\n        roman_number = \"XXXVII\"\n    case 38:\n\
    \        roman_number = \"XXXVIII\"\n    case 39:\n        roman_number = \"XXXIX\"\
    \n    case 40:\n        roman_number = \"XL\"\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7aj4t2nh_test.go:95:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075728
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := []string{\n       \
    \ \"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"\
    D\", \"CM\", \"M\"\n    }\n    result := \"\"\n    for _, romanIndex := range\
    \ romans {\n        if number >= romanIndex {\n            result += romanIndex\n\
    \            number -= romanIndex\n        }\n    }\n    if number > 0 {\n   \
    \     result += romans[len(romans)-1]\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp71_9nv29_test.go:14:78: missing '','' before newline in composite literal

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075737
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_numerals := []string{\n\
    \        \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"\
    IX\", \"X\", \"XI\", \"XII\",\n        \"XIII\", \"XIV\", \"XV\", \"XVI\", \"\
    XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\", \"XXII\",\n        \"XXIII\", \"\
    XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\"\
    ,\n        \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\",\
    \ \"XXXVIII\", \"XXXIX\",\n        \"XL\", \"L\", \"LI\", \"LII\", \"LII\", \"\
    LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\",\n        \"LIX\", \"LX\"\
    , \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\"\
    ,\n        \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\"\
    , \"LXXVI\", \"LXXVII\",\n        \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\"\
    , \"LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\",\n        \"LXXXVI\", \"LXXXVII\"\
    , \"LXXXVIII\", \"LXXXIX\", \"XC\", \"C\", \"CI\", \"CII\", \"CII\",\n       \
    \ \"CIII\", \"CIV\", \"CV\", \"CVI\", \"CVII\", \"CVIII\", \"CIX\", \"CX\", \"\
    CXI\", \"CXII\",\n        \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"\
    CXVIII\", \"CXIX\", \"CXX\", \"CXXI\",\n        \"CXXII\", \"CXXIII\", \"CXXIV\"\
    , \"CXXV\", \"CXXVI\", \"CXXVII\", \"CXXVIII\", \"CXXIX\",\n        \"CXXX\",\
    \ \"CXXXI\", \"CXXXII\", \"CXXXIII\", \"CXXXIV\", \"CXXXV\", \"CXXXVI\", \"CXXXVII\"\
    ,\n        \"CXXXVIII\", \"CXXXIX\", \"CC\", \"CCI\", \"CCII\", \"CCIII\", \"\
    CCIV\", \"CCV\", \"CCVI\",\n        \"CCVII\", \"\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmppudwh2n5_test.go:28:18: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075730
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000\
    \ {\n        fmt.Println(\"Invalid input\")\n    }\n    romans := []string{\n\
    \        \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"\
    IX\", \"X\", \"XI\", \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"\
    XVIII\", \"XIX\", \"XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"\
    XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\"\
    , \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XXX\"\
    , \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\"\
    , \"XXXVIII\", \"XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\",\
    \ \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XXX\", \"XXXI\",\
    \ \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\"\
    , \"XXXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\", \"\
    XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"\
    XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\",\
    \ \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\", \"\
    XXXVII\", \"XXXVIII\", \"XXXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"\
    XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XXX\", \"\
    XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"\
    XXXVIII\", \"XXXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"\
    XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XXX\", \"XXXI\", \"XXXII\"\
    , \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\"\
    , \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqv23asvx_test.go:17:1228: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075737
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_numerals := []string{\n\
    \        \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"\
    IX\", \"X\", \"XI\", \"XII\",\n        \"XIII\", \"XIV\", \"XV\", \"XVI\", \"\
    XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\", \"XXII\",\n        \"XXIII\", \"\
    XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\"\
    ,\n        \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\",\
    \ \"XXXVIII\", \"XXXIX\",\n        \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"\
    LXXXX\", \"LXXXXX\", \"LXXXXXX\", \"LXXXXXXX\",\n        \"LXXXXXV\", \"LXXXXXVI\"\
    , \"LXXXXXVII\", \"LXXXXXVIII\", \"LXXXXXIX\", \"LXXX\", \"LXXXI\",\n        \"\
    LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\"\
    ,\n        \"LXXXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"\
    LXXV\", \"LXXVI\",\n        \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\"\
    , \"LXXXII\", \"LXXXIII\", \"LXXXIV\",\n        \"LXXXV\", \"LXXXVI\", \"LXXXVII\"\
    , \"LXXXVIII\", \"LXXXIX\", \"LXL\", \"LXLI\", \"LXLII\",\n        \"LXLIII\"\
    , \"LXLIV\", \"LXLIVI\", \"LXLIVII\", \"LXLIVIII\", \"LXLIIX\", \"LXLX\", \"LXLXI\"\
    ,\n        \"LXLXII\", \"LXLXIII\", \"LXLXIV\", \"LXLXV\", \"LXLXVI\", \"LXLXVII\"\
    , \"LXLXVIII\",\n        \"LXLXIX\", \"LXL\", \"LXLI\", \"LXLII\", \"LXLIII\"\
    , \"LXLIV\", \"LXLIVI\", \"LXLIVII\",\n        \"LXLIVIII\", \"LXLIIX\", \"LXLXX\"\
    , \"LXLXI\", \"LXLXII\", \"L\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmptcg_mufx_test.go:27:59: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075737
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := []string{\n       \
    \ \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"\
    X\", \"XI\", \"XII\",\n        \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"\
    XVIII\", \"XIX\", \"XX\", \"XXI\", \"XXII\",\n        \"XXIII\", \"XXIV\", \"\
    XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\",\n       \
    \ \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\"\
    , \"XXXIX\",\n        \"XL\", \"L\", \"LI\", \"LII\", \"LII\", \"LIII\", \"LIV\"\
    , \"LV\", \"LVI\", \"LVII\", \"LVIII\",\n        \"LX\", \"LXI\", \"LXII\", \"\
    LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\",\n        \"LXIX\"\
    , \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\", \"\
    LXXVII\",\n        \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\", \"\
    LXXXIII\", \"LXXXIV\", \"LXXXV\",\n        \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\"\
    , \"LXXXIX\", \"XC\", \"C\", \"CI\", \"CII\", \"CII\",\n        \"CIII\", \"CIV\"\
    , \"CV\", \"CVI\", \"CVII\", \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\",\n\
    \        \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\"\
    , \"CXX\", \"CXXI\",\n        \"CXXII\", \"CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\"\
    , \"CXXVII\", \"CXXVIII\", \"CXXIX\",\n        \"CXXX\", \"CXXXI\", \"CXXXII\"\
    , \"CXXXIII\", \"CXXXIV\", \"CXXXV\", \"CXXXVI\", \"CXXXVII\",\n        \"CXXXVIII\"\
    , \"CXXXIX\", \"CC\", \"CCI\", \"CCII\", \"CCIII\", \"CCIV\", \"CV\", \"CVI\"\
    ,\n        \"CVII\", \"CVIII\", \"CIX\", \"\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvucw2e5c_test.go:28:33: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075737
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_numerals := map[int]string{\n\
    \        1: \"I\",\n        5: \"V\",\n        10: \"X\",\n        50: \"L\",\n\
    \        100: \"C\",\n        500: \"D\",\n        1000: \"M\",\n    }\n    roman_numeral\
    \ := \"\"\n    for roman_numeral, number := range roman_numerals {\n        if\
    \ number >= number {\n            roman_numeral += roman_numerals[number]\n  \
    \      }\n    }\n    return roman_numeral\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptghqt9rs_test.go:25:13: invalid operation: roman_numeral += roman_numerals[number]
    (mismatched types int and string)

    /tmp/tmptghqt9rs_test.go:25:45: cannot use number (variable of type string) as
    type int in map index

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075737
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := map[int]string{\n \
    \       1: \"I\",\n        5: \"V\",\n        10: \"X\",\n        50: \"L\",\n\
    \        100: \"C\",\n        500: \"D\",\n        1000: \"M\",\n    }\n    roman_number\
    \ := 0\n    for number > 0 {\n        roman_number += number % 10\n        number\
    \ /= 10\n    }\n    return romans[roman_number]\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmp49ntvwog_test.go:56: expected 'xix', got 'X'\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmp49ntvwog_test.go:56: expected\
    \ 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n  \
    \      tmp49ntvwog_test.go:56: expected 'ccli', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmp49ntvwog_test.go:56: expected 'cdxxvi', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmp49ntvwog_test.go:56:\
    \ expected 'd', got 'V'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n\
    \        tmp49ntvwog_test.go:56: expected 'i', got 'I'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6\
    \ (0.00s)\n        tmp49ntvwog_test.go:56: expected 'iv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmp49ntvwog_test.go:56: expected\
    \ 'xliii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n \
    \       tmp49ntvwog_test.go:56: expected 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9\
    \ (0.00s)\n        tmp49ntvwog_test.go:56: expected 'xciv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmp49ntvwog_test.go:56:\
    \ expected 'dxxxii', got 'X'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11\
    \ (0.00s)\n        tmp49ntvwog_test.go:56: expected 'cm', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmp49ntvwog_test.go:56:\
    \ expected 'cmxciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmp49ntvwog_test.go:56: expected 'm', got 'I'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075735
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    romans := map[int]string{\n \
    \       1: \"I\",\n        5: \"V\",\n        10: \"X\",\n        50: \"L\",\n\
    \        100: \"C\",\n        500: \"D\",\n        1000: \"M\",\n    }\n    roman,\
    \ ok := romans[number]\n    if !ok {\n        fmt.Println(\"Invalid input\")\n\
    \    }\n    return roman\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Invalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid input\n\
    Invalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid\
    \ input\n--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmpcwfbu4ek_test.go:55: expected 'xix', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpcwfbu4ek_test.go:55: expected\
    \ 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n  \
    \      tmpcwfbu4ek_test.go:55: expected 'ccli', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmpcwfbu4ek_test.go:55: expected 'cdxxvi', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpcwfbu4ek_test.go:55:\
    \ expected 'd', got 'D'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n\
    \        tmpcwfbu4ek_test.go:55: expected 'i', got 'I'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6\
    \ (0.00s)\n        tmpcwfbu4ek_test.go:55: expected 'iv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmpcwfbu4ek_test.go:55: expected\
    \ 'xliii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n \
    \       tmpcwfbu4ek_test.go:55: expected 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9\
    \ (0.00s)\n        tmpcwfbu4ek_test.go:55: expected 'xciv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmpcwfbu4ek_test.go:55:\
    \ expected 'dxxxii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11\
    \ (0.00s)\n        tmpcwfbu4ek_test.go:55: expected 'cm', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpcwfbu4ek_test.go:55:\
    \ expected 'cmxciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmpcwfbu4ek_test.go:55: expected 'm', got 'M'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075729
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_numerals := map[int]string{\n\
    \        1: \"I\",\n        5: \"V\",\n        10: \"X\",\n        50: \"L\",\n\
    \        100: \"C\",\n        500: \"D\",\n        1000: \"M\",\n    }\n    roman_numeral\
    \ := roman_numerals[number]\n    return strings.ToLower(roman_numeral)\n}\n\n\
    func TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnwct1mw7_test.go:23:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075730
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_num := []string{\"I\",\
    \ \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"\
    XI\", \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\"\
    , \"XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\"\
    , \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"\
    XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\", \"L\", \"LI\",\
    \ \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\"\
    , \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"\
    LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\",\
    \ \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"\
    LXXXIX\", \"XC\", \"C\", \"CI\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\"\
    , \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\", \"CXXI\"\
    , \"CXXII\", \"CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"CXXVII\", \"CXXVIII\"\
    , \"CXXIX\", \"CXXX\", \"CXXXI\", \"CXXXII\", \"CXXXIII\", \"CXXXIV\", \"CXXXV\"\
    , \"CXXXVI\", \"CXXXVII\", \"CXXXVIII\", \"CXXXIX\", \"CD\", \"D\", \"DI\", \"\
    DII\", \"DIII\", \"DIIII\", \"DIIV\", \"DIV\", \"DIVI\", \"DIVII\", \"DIVIII\"\
    , \"DIX\", \"DX\", \"DXI\", \"DXII\", \"DXIII\", \"DXIV\", \"DXV\", \"DXVI\",\
    \ \"DXVII\", \"DXVIII\", \"DXIX\", \"DXX\", \"DXXI\", \"DXXII\", \"DXXIII\", \"\
    DXXIV\", \"DXXV\", \"DXXVI\", \"DXXVII\", \"DXXVIII\", \"DXXIX\", \"DXXX\nfunc\
    \ TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpkq63dggn_test.go:13:1158: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075737
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_numerals := map[int]string{\n\
    \        1: \"I\",\n        5: \"V\",\n        10: \"X\",\n        50: \"L\",\n\
    \        100: \"C\",\n        500: \"D\",\n        1000: \"M\",\n    }\n    roman_numeral\
    \ := \"\"\n    for roman_numeral, number := range roman_numerals {\n        if\
    \ number <= number {\n            break\n        }\n    }\n    return fmt.Sprintf(\"\
    %v\", roman_numeral)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9yz62h4u_test.go:23:9: roman_numeral declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075737
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_numerals := []string{\n\
    \        \"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"\
    CD\", \"D\", \"CM\",\n        \"M\", \"MM\", \"MMM\",\n    }\n    roman_numeral_string\
    \ := \"\"\n    for _, roman_numeral := range roman_numerals {\n        if number\
    \ >= roman_numeral[0] {\n            roman_numeral_string += roman_numeral\n \
    \           number -= roman_numeral[0]\n        }\n    }\n    return roman_numeral_string\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0z20_p6a_test.go:19:22: invalid operation: number >= roman_numeral[0]
    (mismatched types int and byte)

    /tmp/tmp0z20_p6a_test.go:21:13: invalid operation: number -= roman_numeral[0]
    (mismatched types int and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075737
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_numerals := []string{\"\
    I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\"\
    , \"XI\", \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"\
    XIX\", \"XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\"\
    , \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"\
    XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\", \"L\", \"LI\",\
    \ \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\", \"LIX\", \"\
    LX\", \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"\
    LXVIII\", \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\"\
    , \"LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\"\
    , \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"\
    LXXXIX\", \"XC\", \"C\", \"CI\", \"CII\", \"CIV\", \"CV\", \"CVI\", \"CVII\",\
    \ \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"CXV\"\
    , \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\", \"CXXI\", \"CXXII\", \"\
    CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"CXXVII\", \"CXXVIII\", \"CXXIX\",\
    \ \"CXXX\", \"CXXXI\", \"CXXXII\", \"CXXXIII\", \"CXXXIV\", \"CXXXV\", \"CXXXVI\"\
    , \"CXXXVII\", \"CXXXVIII\", \"CXXXIX\", \"CC\", \"CCI\", \"CCII\", \"CCIII\"\
    , \"CCIV\", \"CV\", \"CVI\", \"CVII\", \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"\
    CXII\", \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\"\
    , \"C\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmparpnv_8r_test.go:13:1167: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075737
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_numerals := map[int]string{\n\
    \        1: \"I\",\n        5: \"V\",\n        10: \"X\",\n        50: \"L\",\n\
    \        100: \"C\",\n        500: \"D\",\n        1000: \"M\",\n    }\n    roman_numeral\
    \ := \"\"\n    for roman_numeral, number := range roman_numerals {\n        if\
    \ number >= number {\n            roman_numeral += roman_numerals[number]\n  \
    \          break\n        }\n    }\n    return fmt.Sprintf(\"%v\", roman_numeral)\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpql93_maw_test.go:25:13: invalid operation: roman_numeral += roman_numerals[number]
    (mismatched types int and string)

    /tmp/tmpql93_maw_test.go:25:45: cannot use number (variable of type string) as
    type int in map index

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075737
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_numerals := []string{\"\
    I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\"\
    , \"XI\", \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"\
    XIX\", \"XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\"\
    , \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"\
    XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\", \"L\", \"LI\",\
    \ \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\"\
    , \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"\
    LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\",\
    \ \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"\
    LXXXIX\", \"XC\", \"C\", \"CI\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\"\
    , \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\", \"CXXI\"\
    , \"CXXII\", \"CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"CXXVII\", \"CXXVIII\"\
    , \"CXXIX\", \"CXXX\", \"CXXXI\", \"CXXXII\", \"CXXXIII\", \"CXXXIV\", \"CXXXV\"\
    , \"CXXXVI\", \"CXXXVII\", \"CXXXVIII\", \"CXXXIX\", \"CC\", \"CCI\", \"CCII\"\
    , \"CCIII\", \"CCIV\", \"CCV\", \"CCVI\", \"CCVII\", \"CCVIII\", \"CCIX\", \"\
    CXX\", \"CXXI\", \"CXXII\", \"CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"CXXVII\"\
    , \"CXXVIII\", \"CXXIX\", \"CXXX\", \"CXXXI\", \"CXXXII\", \"CXXXIII\", \"CXXXIV\"\
    , \"CXXXV\", \"CXXXVI\", \"CXXXVII\", \"\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpg1yju1ri_test.go:13:1151: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075735
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_numerals := []string{\n\
    \        \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"\
    IX\", \"X\", \"XI\", \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"\
    XVIII\", \"XIX\", \"XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"\
    XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\"\
    , \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\",\
    \ \"L\", \"LI\", \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\"\
    , \"LIX\", \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\",\
    \ \"LXVII\", \"LXVIII\", \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"\
    LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"\
    LXXXI\", \"LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\"\
    , \"LXXXVIII\", \"LXXXIX\", \"XC\", \"C\", \"CI\", \"CII\", \"CIV\", \"CV\", \"\
    CVI\", \"CVII\", \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"\
    CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\", \"CXXI\"\
    , \"CXXII\", \"CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"CXXVII\", \"CXXVIII\"\
    , \"CXXIX\", \"CXXX\", \"CXXXI\", \"CXXXII\", \"CXXXIII\", \"CXXXIV\", \"CXXXV\"\
    , \"CXXXVI\", \"CXXXVII\", \"CXXXVIII\", \"CXXXIX\", \"CC\", \"CCI\", \"CCII\"\
    , \"CCIII\", \"CCIV\", \"CV\", \"CVI\", \"CVII\", \"CVIII\", \"CIX\", \"CX\",\
    \ \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\"\
    , \"CXIX\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpoiud0hk__test.go:14:1136: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075737
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_number := \"\"\n    switch\
    \ number {\n    case 1:\n        roman_number = \"I\"\n    case 2:\n        roman_number\
    \ = \"II\"\n    case 3:\n        roman_number = \"III\"\n    case 4:\n       \
    \ roman_number = \"IV\"\n    case 5:\n        roman_number = \"V\"\n    case 6:\n\
    \        roman_number = \"VI\"\n    case 7:\n        roman_number = \"VII\"\n\
    \    case 8:\n        roman_number = \"VIII\"\n    case 9:\n        roman_number\
    \ = \"IX\"\n    case 10:\n        roman_number = \"X\"\n    case 11:\n       \
    \ roman_number = \"XI\"\n    case 12:\n        roman_number = \"XII\"\n    case\
    \ 13:\n        roman_number = \"XIII\"\n    case 14:\n        roman_number = \"\
    XIV\"\n    case 15:\n        roman_number = \"XV\"\n    case 16:\n        roman_number\
    \ = \"XVI\"\n    case 17:\n        roman_number = \"XVII\"\n    case 18:\n   \
    \     roman_number = \"XVIII\"\n    case 19:\n        roman_number = \"XIX\"\n\
    \    case 20:\n        roman_number = \"XX\"\n    case 21:\n        roman_number\
    \ = \"XXI\"\n    case 22:\n        roman_number = \"XXII\"\n    case 23:\n   \
    \     roman_number = \"XXIII\"\n    case 24:\n        roman_number = \"XXIV\"\n\
    \    case 25:\n        roman_number = \"XXV\"\n    case 26:\n        roman_number\
    \ = \"XXVI\"\n    case 27:\n        roman_number = \"XXVII\"\n    case 28:\n \
    \       roman_number = \"XXVIII\"\n    case 29:\n        roman_number = \"XXIX\"\
    \n    case 30:\n        roman_number = \"XXX\"\n    case 31:\n        roman_number\
    \ = \"XXXI\"\n    case 32:\n        roman_number = \"XXXII\"\n    case 33:\n \
    \       roman_number = \"XXXIII\"\n    case 34:\n        roman_number = \"XXXIV\"\
    \n    case 35:\n        roman_number = \"XXXV\"\n    case 36:\n        roman_number\
    \ = \"XXXVI\"\n    case 37:\n        roman_number = \"XXXVII\"\n    case 38:\n\
    \        roman_number = \"XXXVIII\"\n    case 39:\n        roman_number = \"XXXIX\"\
    \n    case 40:\n        roman_number = \"XL\"\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7aj4t2nh_test.go:95:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075728
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_numerals := []string{\n\
    \        \"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"\
    CD\", \"D\", \"CM\", \"M\", \"MN\", \"N\", \"NM\", \"NN\",\n    }\n    roman_numeral_string\
    \ := \"\"\n    for _, roman_numeral := range roman_numerals {\n        if number\
    \ >= roman_numeral[0] {\n            roman_numeral_string += roman_numeral\n \
    \           number -= roman_numeral[0]\n        }\n    }\n    return roman_numeral_string\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgywhb09b_test.go:18:22: invalid operation: number >= roman_numeral[0]
    (mismatched types int and byte)

    /tmp/tmpgywhb09b_test.go:20:13: invalid operation: number -= roman_numeral[0]
    (mismatched types int and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075737
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_numerals := []string{\n\
    \        \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"\
    IX\", \"X\", \"XI\", \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"\
    XVIII\", \"XIX\", \"XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"\
    XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\"\
    , \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\",\
    \ \"L\", \"LI\", \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"\
    LXVII\", \"LXVIII\", \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\"\
    , \"LXXV\", \"LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\"\
    , \"LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"\
    LXXXVIII\", \"LXXXIX\", \"XC\", \"C\", \"CI\", \"CIX\", \"CX\", \"CXI\", \"CXII\"\
    , \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"\
    CXX\", \"CXXI\", \"CXXII\", \"CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"CXXVII\"\
    , \"CXXVIII\", \"CXXIX\", \"CXXX\", \"CXXXI\", \"CXXXII\", \"CXXXIII\", \"CXXXIV\"\
    , \"CXXXV\", \"CXXXVI\", \"CXXXVII\", \"CXXXVIII\", \"CXXXIX\", \"CXL\", \"CL\"\
    , \"CLI\", \"CLXI\", \"CLXII\", \"CLXIII\", \"CLXIV\", \"CLXV\", \"CLXVI\", \"\
    CLXVII\", \"CLXVIII\", \"CLXIX\", \"CLXX\", \"CLXXI\", \"CLXXII\", \"CLXXIII\"\
    , \"CLXXIV\", \"CLXXV\", \"CLXXVI\", \"CLXXVII\", \"CLXXVIII\", \"CLXXIX\", \"\
    CLXXX\", \"CLXXXI\", \"CLXXXII\", \"CLXXXIII\", \"CLXXXIV\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3tvu2d2f_test.go:14:1125: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075737
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    var roman_num string\n    var\
    \ i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n\
    \ int\n\n    for i = 1, i <= 1000, i++ {\n        roman_num += fmt.Sprintf(\"\
    %v\", number)\n        number = number / 10\n    }\n\n    for i = 1, i <= 1000,\
    \ i++ {\n        roman_num += fmt.Sprintf(\"%v\", number)\n        number = number\
    \ / 10\n    }\n\n    for i = 1, i <= 1000, i++ {\n        roman_num += fmt.Sprintf(\"\
    %v\", number)\n        number = number / 10\n    }\n\n    for i = 1, i <= 1000,\
    \ i++ {\n        roman_num += fmt.Sprintf(\"%v\", number)\n        number = number\
    \ / 10\n    }\n\n    for i = 1, i <= 1000, i++ {\n        roman_num += fmt.Sprintf(\"\
    %v\", number)\n        number = number / 10\n    }\n\n    for i = 1, i <= 1000,\
    \ i++ {\n        roman_num += fmt.Sprintf(\"%v\", number)\n        number = number\
    \ / 10\n    }\n\n    for i = 1, i <= 1000, i++ {\n        roman_num += fmt.Sprintf(\"\
    %v\", number)\n        number = number / 10\n    }\n\n    for i = 1, i <= 1000,\
    \ i++ {\n        roman_num += fmt.Sprintf(\"%v\", number)\n        number = number\
    \ / 10\n    }\n\n    for i = 1, i <= 1000, i++ {\n        roman_num += fmt.Sprintf(\"\
    %v\", number)\n        number = number / 10\n    }\n\n    for i = 1, i <= 1000,\
    \ i++ {\n        roman_num += fmt.Sprintf(\"%v\", number)\n        number = number\
    \ / 10\n    }\n\n    for i = 1, i <= 1000, i++ {\n        roman_num += fmt.Sprintf(\"\
    %v\", number)\n        number = number / 10\n    }\n\n    for i = 1, i <= 1000,\
    \ i++ {\n        roman_num += fmt.Sprintf(\"%v\", number)\n        number = number\
    \ / 10\n    }\n\n    for i = 1, i <= 1000, i++ {\n        roman_num += fmt.Sprintf(\"\
    %v\", number)\n        number = number / 10\n    }\n\n    for i = 1, i <= 1000,\
    \ i++ {\n        roman_num += fmt.Sprintf(\"%v\", number)\n        number = number\
    \ / 10\n    }\n\n    for i = 1, i <= 1000, i++ {\n        roman_num += fmt.Sprintf(\"\
    %v\", number)\n        number = number / 10\n    }\n\n    for i = 1, i <= 1000,\
    \ i++ {\n        roman_num += fmt.Sprintf(\"%v\", number)\n        number = number\
    \ / 10\n    }\n\n    for i = 1, i <= 1000, i++ {\n        roman_num += fmt.Sprintf(\"\
    %v\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmprfiyl3ds_test.go:21:28: expected ''{'', found ''++''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075737
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_numerals := map[int]string{\n\
    \        1: \"I\",\n        2: \"II\",\n        3: \"III\",\n        4: \"IV\"\
    ,\n        5: \"V\",\n        6: \"VI\",\n        7: \"VII\",\n        8: \"VIII\"\
    ,\n        9: \"IX\",\n        10: \"X\",\n        11: \"XI\",\n        12: \"\
    XII\",\n        13: \"XIII\",\n        14: \"XIV\",\n        15: \"XV\",\n   \
    \     16: \"XVI\",\n        17: \"XVII\",\n        18: \"XVIII\",\n        19:\
    \ \"XIX\",\n        20: \"XX\",\n        30: \"XXI\",\n        40: \"XL\",\n \
    \       50: \"L\",\n        60: \"LX\",\n        70: \"LXX\",\n        80: \"\
    LXXX\",\n        90: \"XC\",\n        100: \"C\",\n        1000: \"C\",\n    }\n\
    \    roman_numeral := \"\"\n    for roman_numeral, number := range roman_numerals\
    \ {\n        if number >= number {\n            break\n        }\n    }\n    return\
    \ fmt.Sprintf(\"%v\", roman_numeral)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpv40m2dzk_test.go:45:9: roman_numeral declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075737
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_num := \"\"\n    switch\
    \ number {\n    case 1:\n        roman_num = \"I\"\n    case 2:\n        roman_num\
    \ = \"II\"\n    case 3:\n        roman_num = \"III\"\n    case 4:\n        roman_num\
    \ = \"IV\"\n    case 5:\n        roman_num = \"V\"\n    case 6:\n        roman_num\
    \ = \"VI\"\n    case 7:\n        roman_num = \"VII\"\n    case 8:\n        roman_num\
    \ = \"VIII\"\n    case 9:\n        roman_num = \"IX\"\n    case 10:\n        roman_num\
    \ = \"X\"\n    case 11:\n        roman_num = \"XI\"\n    case 12:\n        roman_num\
    \ = \"XII\"\n    case 13:\n        roman_num = \"XIII\"\n    case 14:\n      \
    \  roman_num = \"XIV\"\n    case 15:\n        roman_num = \"XV\"\n    case 16:\n\
    \        roman_num = \"XVI\"\n    case 17:\n        roman_num = \"XVII\"\n   \
    \ case 18:\n        roman_num = \"XVIII\"\n    case 19:\n        roman_num = \"\
    XIX\"\n    case 20:\n        roman_num = \"XX\"\n    case 21:\n        roman_num\
    \ = \"XXI\"\n    case 22:\n        roman_num = \"XXII\"\n    case 23:\n      \
    \  roman_num = \"XXIII\"\n    case 24:\n        roman_num = \"XXIV\"\n    case\
    \ 25:\n        roman_num = \"XXV\"\n    case 26:\n        roman_num = \"XXVI\"\
    \n    case 27:\n        roman_num = \"XXVII\"\n    case 28:\n        roman_num\
    \ = \"XXVIII\"\n    case 29:\n        roman_num = \"XXIX\"\n    case 30:\n   \
    \     roman_num = \"XXX\"\n    case 31:\n        roman_num = \"XXXI\"\n    case\
    \ 32:\n        roman_num = \"XXXII\"\n    case 33:\n        roman_num = \"XXXIII\"\
    \n    case 34:\n        roman_num = \"XXXIV\"\n    case 35:\n        roman_num\
    \ = \"XXXV\"\n    case 36:\n        roman_num = \"XXXVI\"\n    case 37:\n    \
    \    roman_num = \"XXXVII\"\n    case 38:\n        roman_num = \"XXXVIII\"\n \
    \   case 39:\n        roman_num = \"XXXIX\"\n    case 40:\n        roman_num =\
    \ \"XL\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8xvbo_2c_test.go:95:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075728
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_num := make([]string, 1000)\n\
    \    roman_num[0] = \"I\"\n    roman_num[1] = \"II\"\n    roman_num[2] = \"III\"\
    \n    roman_num[3] = \"IV\"\n    roman_num[4] = \"V\"\n    roman_num[5] = \"VI\"\
    \n    roman_num[6] = \"VII\"\n    roman_num[7] = \"VIII\"\n    roman_num[8] =\
    \ \"IX\"\n    roman_num[9] = \"X\"\n    roman_num[10] = \"XI\"\n    roman_num[11]\
    \ = \"XII\"\n    roman_num[12] = \"XIII\"\n    roman_num[13] = \"XIV\"\n    roman_num[14]\
    \ = \"XV\"\n    roman_num[15] = \"XVI\"\n    roman_num[16] = \"XVII\"\n    roman_num[17]\
    \ = \"XVIII\"\n    roman_num[18] = \"XIX\"\n    roman_num[19] = \"XX\"\n    roman_num[20]\
    \ = \"XXI\"\n    roman_num[21] = \"XXII\"\n    roman_num[22] = \"XXIII\"\n   \
    \ roman_num[23] = \"XXIV\"\n    roman_num[24] = \"XXV\"\n    roman_num[25] = \"\
    XXVI\"\n    roman_num[26] = \"XXVII\"\n    roman_num[27] = \"XXVIII\"\n    roman_num[28]\
    \ = \"XXIX\"\n    roman_num[29] = \"XXX\"\n    roman_num[30] = \"XXXI\"\n    roman_num[31]\
    \ = \"XXXII\"\n    roman_num[32] = \"XXXIII\"\n    roman_num[33] = \"XXXIV\"\n\
    \    roman_num[34] = \"XXXV\"\n    roman_num[35] = \"XXXVI\"\n    roman_num[36]\
    \ = \"XXXVII\"\n    roman_num[37] = \"XXXVIII\"\n    roman_num[38] = \"XXXIX\"\
    \n    roman_num[39] = \"XL\"\n    roman_num[40] = \"L\"\n    roman_num[41] = \"\
    LX\"\n    roman_num[42] = \"LXX\"\n    roman_num[43] = \"LXXX\"\n    roman_num[44]\
    \ = \"LXXXX\"\n    roman_num[45] = \"LXXXXX\"\n    \nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp1vpen3w7_test.go:61:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075733
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_numerals := map[int]string{\n\
    \        1: \"I\",\n        5: \"V\",\n        10: \"X\",\n        50: \"L\",\n\
    \        100: \"C\",\n        500: \"D\",\n        1000: \"M\",\n    }\n    roman_numeral\
    \ := \"\"\n    for roman_numeral, number := range roman_numerals {\n        if\
    \ number >= number {\n            break\n        }\n    }\n    return fmt.Sprintf(\"\
    %c\", roman_numeral) + int_to_mini_roman(number-roman_numeral)\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpn6wjp2ui_test.go:23:9: roman_numeral declared but not used

    /tmp/tmpn6wjp2ui_test.go:28:65: invalid operation: number - roman_numeral (mismatched
    types int and string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075730
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_numerals := map[int]string{\n\
    \        1: \"I\",\n        2: \"II\",\n        3: \"III\",\n        4: \"IV\"\
    ,\n        5: \"V\",\n        6: \"VI\",\n        7: \"VII\",\n        8: \"VIII\"\
    ,\n        9: \"IX\",\n        10: \"X\",\n        11: \"XI\",\n        12: \"\
    XII\",\n        13: \"XIII\",\n        14: \"XIV\",\n        15: \"XV\",\n   \
    \     16: \"XVI\",\n        17: \"XVII\",\n        18: \"XVIII\",\n        19:\
    \ \"XIX\",\n        20: \"XX\",\n        30: \"XXI\",\n        40: \"XL\",\n \
    \       50: \"L\",\n        60: \"LX\",\n        70: \"LXX\",\n        80: \"\
    LXXX\",\n        90: \"XC\",\n        100: \"C\",\n        1000: \"C\",\n    }\n\
    \    roman_numeral := \"\"\n    for _, roman_numeral_string := range roman_numerals\
    \ {\n        if number >= roman_numeral_string {\n            roman_numeral +=\
    \ roman_numeral_string\n            number -= roman_numeral_string\n        }\n\
    \    }\n    return roman_numeral\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsrh1r2es_test.go:46:22: invalid operation: number >= roman_numeral_string
    (mismatched types int and string)

    /tmp/tmpsrh1r2es_test.go:48:13: invalid operation: number -= roman_numeral_string
    (mismatched types int and string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075737
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_numerals := map[int]string{\n\
    \        1: \"I\",\n        2: \"II\",\n        3: \"III\",\n        4: \"IV\"\
    ,\n        5: \"V\",\n        6: \"VI\",\n        7: \"VII\",\n        8: \"VIII\"\
    ,\n        9: \"IX\",\n        10: \"X\",\n        11: \"XI\",\n        12: \"\
    XII\",\n        13: \"XIII\",\n        14: \"XIV\",\n        15: \"XV\",\n   \
    \     16: \"XVI\",\n        17: \"XVII\",\n        18: \"XVIII\",\n        19:\
    \ \"XIX\",\n        20: \"XX\",\n        30: \"XXX\",\n        40: \"XL\",\n \
    \       50: \"L\",\n        60: \"LX\",\n        70: \"LXX\",\n        80: \"\
    LXXX\",\n        90: \"XC\",\n        100: \"C\",\n        200: \"CC\",\n    \
    \    300: \"CCC\",\n        400: \"CD\",\n        500: \"D\",\n        600: \"\
    DC\",\n        700: \"DCC\",\n        800: \"DCCC\",\n        900: \"CM\",\n \
    \       1000: \"M\",\n    }\n    roman_numeral_string := \"\"\n    for roman_numeral,\
    \ roman := range roman_numerals {\n        if number >= roman_numeral {\n    \
    \        roman_numeral_string += roman\n            number -= roman_numeral\n\
    \        }\n    }\n    return strings.ToLower(roman_numeral_string)\n}\n\nfunc\
    \ TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppavyoz64_test.go:59:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075737
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    func int_to_mini_roman(number int) string {\n    roman_numerals := []string{\n\
    \        \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"\
    IX\", \"X\", \"XI\", \"XII\",\n        \"XIII\", \"XIV\", \"XV\", \"XVI\", \"\
    XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\", \"XXII\",\n        \"XXIII\", \"\
    XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\"\
    ,\n        \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\",\
    \ \"XXXVIII\", \"XXXIX\",\n        \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"\
    LXXXX\", \"LXXXXX\", \"LXXXII\", \"LXXXIII\",\n        \"LXXXIV\", \"LXXXV\",\
    \ \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\", \"LXXXVIII\",\n        \"\
    LXXXIX\", \"LXXXIX\", \"LXXXIX\", \"LXXXIX\", \"LXXXIX\", \"LXXXIX\", \"LXXXIX\"\
    ,\n        \"LXXXIX\", \"LXXXIX\", \"LXXXIX\", \"LXXXIX\", \"LXXXIX\", \"LXXXIX\"\
    , \"LXXXIX\",\n        \"LXXXIX\", \"LXXXIX\", \"LXXXIX\", \"LXXXIX\", \"LXXXIX\"\
    , \"LXXXIX\", \"LXXXIX\",\n        \"LXXXIX\", \"LXXXIX\", \"LXXXIX\", \"LXXXIX\"\
    , \"LXXXIX\", \"LXXXIX\", \"LXXXIX\",\n        \"LXXXIX\", \"LXXXIX\", \"LXXXIX\"\
    , \"LXXXIX\", \"LXXXIX\", \"LXXXIX\", \"LXXXIX\",\n        \"LXXXIX\", \"LXXXIX\"\
    , \"LXXXIX\", \"LXXXIX\", \"LXXXIX\", \"LXXXIX\", \"LXXXIX\",\n        \"LXXXIX\"\
    , \"LXXXIX\", \"LXXXIX\", \"LXXXIX\", \"LXXXIX\", \"LXXXIX\", \"LXXXIX\",\n  \
    \      \"LXXXIX\", \"LXXXIX\", \"LXXXIX\", \"LXXXIX\", \"LXXXIX\", \"LXXXIX\"\
    , \"LXXXIX\",\n        \"LXXXIX\", \"LXXXIX\", \"LXXXIX\", \"LXXXIX\", \"LXXXIX\"\
    , \"LXXXIX\", \"LXXXIX\",\n        \"LXXXIX\", \"LXXXIX\", \"LXXXIX\", \"LXXXIX\"\
    , \"LXXXIX\", \"LXXXIX\", \"LXXXIX\",\n        \"L\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpr7lqozh7_test.go:30:9: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075737
