language: go_test.go
name: HumanEval_10_make_palindrome
results:
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find longest postfix of myString that is a palindrome.\n\
    \    longestPalindrome := \"\"\n    longestPalindromeLen := 0\n    for i := 0;\
    \ i < len(myString); i++ {\n        postfix := myString[i : len(myString)-i]\n\
    \        if isPalindrome(postfix) {\n            longestPalindrome = longestPalindrome\
    \ + postfix\n            longestPalindromeLen = len(longestPalindrome)\n     \
    \   }\n    }\n    // Append the reverse of the longest postfix to the end of the\
    \ string.\n    longestPalindrome = longestPalindrome + myString[:len(myString)-longestPalindromeLen]\n\
    \    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n\
    \  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmqd1_9xz_test.go:18:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075600
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for i := 0; i < len(myString); i++ {\n        postfix := myString[i:]\n\
    \        prefix := myString[:i]\n        postfix = append(postfix, reverseString(prefix)...)\n\
    \        if isPalindrome(postfix) {\n            longestPalindrome = append(longestPalindrome,\
    \ postfix...)\n            longestPalindromeLen = len(postfix)\n        }\n  \
    \  }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpoihic9mf_test.go:14:5: longestPalindromeLen declared but not used

    /tmp/tmpoihic9mf_test.go:18:26: first argument to append must be a slice; have
    postfix (variable of type string)

    /tmp/tmpoihic9mf_test.go:18:35: undefined: reverseString

    /tmp/tmpoihic9mf_test.go:19:12: undefined: isPalindrome

    /tmp/tmpoihic9mf_test.go:20:40: first argument to append must be a slice; have
    longestPalindrome (variable of type string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075600
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find the longest postfix of supplied string that is\
    \ a palindrome.\n    longestPalindrome := \"\"\n    for i := len(myString) - 1;\
    \ i >= 0; i-- {\n        postfix := myString[:i+1]\n        if isPalindrome(postfix)\
    \ {\n            longestPalindrome = postfix\n            break\n        }\n \
    \   }\n\n    // Append to the end of the string reverse of a string prefix that\
    \ comes before the palindromic suffix.\n    prefix := myString[:len(myString)-len(longestPalindrome)]\n\
    \    return prefix + longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpz5c3g1f4_test.go:17:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075600
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    var myStringLen int = len(myString)\n    var myStringPrefix\
    \ string\n    var myStringSuffix string\n    var myStringPalindrome string\n\n\
    \    // Find longest postfix of string that is a palindrome.\n    for i := 0;\
    \ i < myStringLen; i++ {\n        myStringPrefix = myString[:i]\n        myStringSuffix\
    \ = myString[i:]\n        myStringPalindrome = myStringPrefix + myStringSuffix\n\
    \        if myStringPalindrome == myString {\n            return myStringPalindrome\n\
    \        }\n    }\n\n    return \"\"\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__2\
    \ (0.00s)\n        tmpj81r80n7_test.go:48: expected 'xyzyx', got 'xyz'\n    ---\
    \ FAIL: TestMake_Palindrome/test_num__4 (0.00s)\n        tmpj81r80n7_test.go:48:\
    \ expected 'jerryrrej', got 'jerry'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660075600
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for _, char := range myString {\n        postfix := \"\"\n        postfix\
    \ += char\n        postfix += char\n        postfix += char\n        postfix +=\
    \ char\n        postfix += char\n        postfix += char\n        postfix += char\n\
    \        postfix += char\n        postfix += char\n        postfix += char\n \
    \       postfix += char\n        postfix += char\n        postfix += char\n  \
    \      postfix += char\n        postfix += char\n        postfix += char\n   \
    \     postfix += char\n        postfix += char\n        postfix += char\n    \
    \    postfix += char\n        postfix += char\n        postfix += char\n     \
    \   postfix += char\n        postfix += char\n        postfix += char\n      \
    \  postfix += char\n        postfix += char\n        postfix += char\n       \
    \ postfix += char\n        postfix += char\n        postfix += char\n        postfix\
    \ += char\n        postfix += char\n        postfix += char\n        postfix +=\
    \ char\n        postfix += char\n        postfix += char\n        postfix += char\n\
    \        postfix += char\n        postfix += char\n        postfix += char\n \
    \       postfix += char\n        postfix += char\n        postfix += char\n  \
    \      postfix += char\n        postfix += char\n        postfix += char\n   \
    \     postfix += char\n        postfix += char\n        postfix += char\n    \
    \    postfix += char\n        postfix += char\n        postfix += char\n     \
    \   postfix += char\n        postfix += char\n        postfix += char\n      \
    \  postfix += char\n        postfix += char\n        postfix += char\n       \
    \ postfix += char\n        postfix += char\n        postfix += char\n        postfix\
    \ += char\n        postfix += char\n        postfix += char\n        postfix +=\
    \ char\n        postfix += char\n        postfix += char\n        postfix += char\n\
    \        postfix += char\n        postfix += char\n        postfix += char\n \
    \       postfix += char\n        postfix += char\n        postfix += char\n  \
    \      postfix += char\n        postfix += char\n        postfix += char\n   \
    \     postfix += char\n        postfix += \nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpg97ezhnv_test.go:97:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075599
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for i := 0; i < len(myString); i++ {\n        postfix := myString[i :\
    \ len(myString)-i]\n        postfix += string(myString[len(myString)-i:len(myString)])\n\
    \        if isPalindrome(postfix) {\n            longestPalindrome = postfix\n\
    \            longestPalindromeLen = len(postfix)\n        }\n    }\n    return\
    \ longestPalindrome + string(myString[0:longestPalindromeLen])\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpngua_unb_test.go:18:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075600
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix\
    \ of supplied string that is a palindrome.\n    // - Append to the end of the\
    \ string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // - Repeat until we find longest postfix that is a palindrome.\n    // -\
    \ Return it.\n    longestPalindrome := \"\"\n    longestPalindromeLen := 0\n \
    \   for i := 0; i < len(myString); i++ {\n        postfix := myString[:i]\n  \
    \      reverse := myString[i+1:]\n        if isPalindrome(postfix) {\n       \
    \     longestPalindrome = postfix + reverse\n            longestPalindromeLen\
    \ = len(postfix)\n        }\n    }\n    if longestPalindromeLen > 0 {\n      \
    \  return longestPalindrome\n    }\n    return \"\"\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjmp62ckq_test.go:24:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075600
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find the longest postfix of supplied string that is\
    \ a palindrome.\n    longestPalindrome := \"\"\n    for i := len(myString) - 1;\
    \ i >= 0; i-- {\n        longestPalindrome += myString[i]\n    }\n    // Append\
    \ to the end of the string reverse of a string prefix that comes before the palindromic\
    \ suffix.\n    longestPalindrome += myString[len(longestPalindrome):]\n    //\
    \ Return palindrome string.\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptguuxbjf_test.go:16:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075600
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // The longest postfix is found by reversing a postfix of\
    \ myString that ends with a palindromic suffix.\n    // The longest postfix is\
    \ found by reversing a postfix of myString that begins with a palindromic prefix.\n\
    \    // The longest postfix is found by reversing a postfix of myString that begins\
    \ with a palindromic prefix and ends with a palindromic suffix.\n    // The longest\
    \ postfix is found by reversing a postfix of myString that begins with a palindromic\
    \ prefix and ends with a palindromic suffix.\n    // The longest postfix is found\
    \ by reversing a postfix of myString that begins with a palindromic prefix and\
    \ ends with a palindromic suffix.\n    // The longest postfix is found by reversing\
    \ a postfix of myString that begins with a palindromic prefix and ends with a\
    \ palindromic suffix.\n    // The longest postfix is found by reversing a postfix\
    \ of myString that begins with a palindromic prefix and ends with a palindromic\
    \ suffix.\n    // The longest postfix is found by reversing a postfix of myString\
    \ that begins with a palindromic prefix and ends with a palindromic suffix.\n\
    \    // The longest postfix is found by reversing a postfix of myString that begins\
    \ with a palindromic prefix and ends with a palindromic suffix.\n    // The longest\
    \ postfix is found by reversing a postfix of myString that begins with a palindromic\
    \ prefix and ends with a palindromic suffix.\n    // The longest postfix is found\
    \ by reversing a postfix of myString that begins with a palindromic prefix and\
    \ ends with a palindromic suffix.\n    // The longest postfix is found by reversing\
    \ a postfix of myString that begins with a palindromic prefix and ends with a\
    \ palindromic suffix.\n    // The longest postfix is found by reversing a postfix\
    \ of myString that begins with a palindromic prefix and ends with a palindromic\
    \ suffix.\n    // The longest postfix is found by reversing a postfix of myString\
    \ that begins with a palindromic prefix and ends with a palindromic \nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp2oibhwjw_test.go:28:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075599
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find longest postfix of myString that is a palindrome\n\
    \    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n   \
    \     longestPalindrome += myString[i]\n    }\n    longestPalindrome += myString[len(myString)-1]\n\
    \n    // Append reverse of the string prefix that comes before the palindromic\
    \ suffix\n    longestPalindrome += myString[0:len(myString)-1]\n\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp29b5po03_test.go:16:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmp29b5po03_test.go:18:5: invalid operation: longestPalindrome += myString[len(myString)
    - 1] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075600
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for i := 0; i < len(myString); i++ {\n        prefix := myString[0:i]\n\
    \        suffix := myString[i:]\n        postfix := longestPalindrome[0:longestPalindromeLen]\n\
    \        postfix += suffix\n        postfix += prefix\n        postfix += suffix\n\
    \        postfix += prefix\n        postfix += suffix\n        postfix += prefix\n\
    \        postfix += suffix\n        postfix += prefix\n        postfix += suffix\n\
    \        postfix += prefix\n        postfix += suffix\n        postfix += prefix\n\
    \        postfix += suffix\n        postfix += prefix\n        postfix += suffix\n\
    \        postfix += prefix\n        postfix += suffix\n        postfix += prefix\n\
    \        postfix += suffix\n        postfix += prefix\n        postfix += suffix\n\
    \        postfix += prefix\n        postfix += suffix\n        postfix += prefix\n\
    \        postfix += suffix\n        postfix += prefix\n        postfix += suffix\n\
    \        postfix += prefix\n        postfix += suffix\n        postfix += prefix\n\
    \        postfix += suffix\n        postfix += prefix\n        postfix += suffix\n\
    \        postfix += prefix\n        postfix += suffix\n        postfix += prefix\n\
    \        postfix += suffix\n        postfix += prefix\n        postfix += suffix\n\
    \        postfix += prefix\n        postfix += suffix\n        postfix += prefix\n\
    \        postfix += suffix\n        postfix += prefix\n        postfix += suffix\n\
    \        postfix += prefix\n        postfix += suffix\n        postfix += prefix\n\
    \        postfix += suffix\n        postfix += prefix\n        postfix += suffix\n\
    \        postfix += prefix\n        postfix += suffix\n        postfix += prefix\n\
    \        postfix += suffix\n        postfix += prefix\n        postfix += suffix\n\
    \        postfix += prefix\n        postfix += suffix\n        postfix += prefix\n\
    \        postfix += suffix\n        postfix += prefix\n        postfix += suffix\n\
    \        postfix += prefix\n        postfix += suffix\n        postfix += prefix\n\
    \        postfix += suffix\n        postfix += prefix\n        postfix += suffix\n\
    \        postfix += prefix\n        postfix += suffix\n        postfix += prefix\n\
    \        postfix += suffix\n        postfix += prefix\n        postfix \nfunc\
    \ TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphm5sn8rg_test.go:94:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075599
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find the longest postfix of supplied string that is\
    \ a palindrome.\n    longestPalindrome := \"\"\n    for i := len(myString) - 1;\
    \ i >= 0; i-- {\n        postfix := myString[:i+1]\n        if isPalindrome(postfix)\
    \ {\n            longestPalindrome = postfix\n        }\n    }\n    // Append\
    \ to the end of the string reverse of a string prefix that comes before the palindromic\
    \ suffix.\n    prefix := myString[:len(longestPalindrome)]\n    return prefix\
    \ + reverseString(longestPalindrome)\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6vb9akuh_test.go:17:12: undefined: isPalindrome

    /tmp/tmp6vb9akuh_test.go:23:21: undefined: reverseString

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075600
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLength\
    \ := 0\n    for i := 0; i < len(myString); i++ {\n        postfix := myString[i:]\n\
    \        postfix += myString[:i]\n        postfix += myString[i:]\n        postfix\
    \ += myString[:i]\n        postfix += myString[i:]\n        postfix += myString[:i]\n\
    \        postfix += myString[i:]\n        postfix += myString[:i]\n        postfix\
    \ += myString[i:]\n        postfix += myString[:i]\n        postfix += myString[i:]\n\
    \        postfix += myString[:i]\n        postfix += myString[i:]\n        postfix\
    \ += myString[:i]\n        postfix += myString[i:]\n        postfix += myString[:i]\n\
    \        postfix += myString[i:]\n        postfix += myString[:i]\n        postfix\
    \ += myString[i:]\n        postfix += myString[:i]\n        postfix += myString[i:]\n\
    \        postfix += myString[:i]\n        postfix += myString[i:]\n        postfix\
    \ += myString[:i]\n        postfix += myString[i:]\n        postfix += myString[:i]\n\
    \        postfix += myString[i:]\n        postfix += myString[:i]\n        postfix\
    \ += myString[i:]\n        postfix += myString[:i]\n        postfix += myString[i:]\n\
    \        postfix += myString[:i]\n        postfix += myString[i:]\n        postfix\
    \ += myString[:i]\n        postfix += myString[i:]\n        postfix += myString[:i]\n\
    \        postfix += myString[i:]\n        postfix += myString[:i]\n        postfix\
    \ += myString[i:]\n        postfix += myString[:i]\n        postfix += myString[i:]\n\
    \        postfix += myString[:i]\n        postfix += myString[i:]\n        postfix\
    \ += myString[:i]\n        postfix += myString[i:]\n        postfix += myString[:i]\n\
    \        postfix += myString[i:]\n        postfix += myString[:i]\n        postfix\
    \ += myString[i:]\n        postfix += myString[:i]\n        postfix += myString[i:]\n\
    \        postfix += myString[:i]\n        postfix += myString[i:]\n        postfix\
    \ \nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxhekt225_test.go:70:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075599
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for i := 0; i < len(myString); i++ {\n        postfix := myString[i:]\n\
    \        prefix := myString[:i]\n        postfix = append(postfix, reverseString(prefix)...)\n\
    \        postfix = append(postfix, postfix...)\n        postfix = append(postfix,\
    \ postfix...)\n        if isPalindrome(postfix) {\n            longestPalindrome\
    \ = postfix\n            longestPalindromeLen = len(postfix)\n        }\n    }\n\
    \    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n\
    \  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3vifd63b_test.go:14:5: longestPalindromeLen declared but not used

    /tmp/tmp3vifd63b_test.go:18:26: first argument to append must be a slice; have
    postfix (variable of type string)

    /tmp/tmp3vifd63b_test.go:18:35: undefined: reverseString

    /tmp/tmp3vifd63b_test.go:19:26: first argument to append must be a slice; have
    postfix (variable of type string)

    /tmp/tmp3vifd63b_test.go:20:26: first argument to append must be a slice; have
    postfix (variable of type string)

    /tmp/tmp3vifd63b_test.go:21:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075600
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find longest postfix of myString that is a palindrome.\n\
    \    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n   \
    \     longestPalindrome += myString[i]\n    }\n    longestPalindrome = longestPalindrome[:len(longestPalindrome)-1]\n\
    \    longestPalindrome = longestPalindrome[:len(longestPalindrome)-1]\n    longestPalindrome\
    \ = longestPalindrome[:len(longestPalindrome)-1]\n    longestPalindrome = longestPalindrome[:len(longestPalindrome)-1]\n\
    \    longestPalindrome = longestPalindrome[:len(longestPalindrome)-1]\n    longestPalindrome\
    \ = longestPalindrome[:len(longestPalindrome)-1]\n    longestPalindrome = longestPalindrome[:len(longestPalindrome)-1]\n\
    \    longestPalindrome = longestPalindrome[:len(longestPalindrome)-1]\n    longestPalindrome\
    \ = longestPalindrome[:len(longestPalindrome)-1]\n    longestPalindrome = longestPalindrome[:len(longestPalindrome)-1]\n\
    \    longestPalindrome = longestPalindrome[:len(longestPalindrome)-1]\n    longestPalindrome\
    \ = longestPalindrome[:len(longestPalindrome)-1]\n    longestPalindrome = longestPalindrome[:len(longestPalindrome)-1]\n\
    \    longestPalindrome = longestPalindrome[:len(longestPalindrome)-1]\n    longestPalindrome\
    \ = longestPalindrome[:len(longestPalindrome)-1]\n    longestPalindrome = longestPalindrome[:len(longestPalindrome)-1]\n\
    \    longestPalindrome = longestPalindrome[:len(longestPalindrome)-1]\n    longestPalindrome\
    \ = longestPalindrome[:len(longestPalindrome)-1]\n    longestPalindrome = longestPalindrome[:len(longestPalindrome)-1]\n\
    \    longestPalindrome = longestPalindrome[:len(longestPalindrome)-1]\n    longestPalindrome\
    \ = longestPalindrome[:len(longestPalindrome)-1]\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvfhoizef_test.go:40:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075599
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find longest postfix of myString that is a palindrome.\n\
    \    longestPalindrome := \"\"\n    for i := len(myString) - 1; i >= 0; i-- {\n\
    \        longestPalindrome += myString[i]\n    }\n    // Append to the end of\
    \ the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    longestPalindrome += myString[len(longestPalindrome):]\n    // Return palindrome\
    \ string.\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpx0ka41j9_test.go:16:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075600
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    var myStringLen int = len(myString)\n    var myStringPrefix\
    \ string\n    var myStringSuffix string\n    var myStringPalindrome string\n \
    \   var myStringPalindromeLen int\n\n    for i := 0; i < myStringLen; i++ {\n\
    \        myStringPrefix = myString[0:i]\n        myStringSuffix = myString[i:]\n\
    \        myStringPalindrome = myStringPrefix + myStringSuffix\n        myStringPalindromeLen\
    \ = len(myStringPalindrome)\n        if myStringPalindromeLen > myStringLen {\n\
    \            break\n        }\n    }\n\n    myStringPalindrome = myStringPalindrome[0:myStringLen]\n\
    \    return myStringPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n\
    \  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__2\
    \ (0.00s)\n        tmp1go10v_9_test.go:50: expected 'xyzyx', got 'xyz'\n    ---\
    \ FAIL: TestMake_Palindrome/test_num__4 (0.00s)\n        tmp1go10v_9_test.go:50:\
    \ expected 'jerryrrej', got 'jerry'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660075600
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for _, char := range myString {\n        longestPalindromeLen += 1 //\
    \ count the character\n        longestPalindrome += string([]rune(char)[longestPalindromeLen:]\
    \ + string([]rune(char)[:longestPalindromeLen])\n    }\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0eiw25c1_test.go:17:118: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075599
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for _, char := range myString {\n        longestPalindromeLen += len(char)\
    \ + 1\n        if longestPalindromeLen > len(longestPalindrome) {\n          \
    \  longestPalindrome = char\n        }\n    }\n    for i := len(longestPalindrome);\
    \ i < len(myString); i++ {\n        longestPalindrome += myString[len(myString)-1-i]\n\
    \    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvu16dicp_test.go:16:37: invalid argument: char (variable of type rune)
    for len

    /tmp/tmpvu16dicp_test.go:18:33: cannot use char (variable of type rune) as type
    string in assignment

    /tmp/tmpvu16dicp_test.go:22:9: invalid operation: longestPalindrome += myString[len(myString)
    - 1 - i] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075600
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for i := 0; i < len(myString); i++ {\n        prefix := myString[:i]\n\
    \        suffix := myString[i:]\n        postfix := reverse(prefix)\n        postfix\
    \ += suffix\n        postfix += prefix\n        postfix += suffix\n        postfix\
    \ += prefix\n        postfix += suffix\n        postfix += prefix\n        postfix\
    \ += suffix\n        postfix += prefix\n        postfix += suffix\n        postfix\
    \ += prefix\n        postfix += suffix\n        postfix += prefix\n        postfix\
    \ += suffix\n        postfix += prefix\n        postfix += suffix\n        postfix\
    \ += prefix\n        postfix += suffix\n        postfix += prefix\n        postfix\
    \ += suffix\n        postfix += prefix\n        postfix += suffix\n        postfix\
    \ += prefix\n        postfix += suffix\n        postfix += prefix\n        postfix\
    \ += suffix\n        postfix += prefix\n        postfix += suffix\n        postfix\
    \ += prefix\n        postfix += suffix\n        postfix += prefix\n        postfix\
    \ += suffix\n        postfix += prefix\n        postfix += suffix\n        postfix\
    \ += prefix\n        postfix += suffix\n        postfix += prefix\n        postfix\
    \ += suffix\n        postfix += prefix\n        postfix += suffix\n        postfix\
    \ += prefix\n        postfix += suffix\n        postfix += prefix\n        postfix\
    \ += suffix\n        postfix += prefix\n        postfix += suffix\n        postfix\
    \ += prefix\n        postfix += suffix\n        postfix += prefix\n        postfix\
    \ += suffix\n        postfix += prefix\n        postfix += suffix\n        postfix\
    \ += prefix\n        postfix += suffix\n        postfix += prefix\n        postfix\
    \ += suffix\n        postfix += prefix\n        postfix += suffix\n        postfix\
    \ += prefix\n        postfix += suffix\n        postfix += prefix\n        postfix\
    \ += suffix\n        postfix += prefix\n        postfix += suffix\n        postfix\
    \ += prefix\n        postfix += suffix\n        postfix += prefix\n        postfix\
    \ += suffix\n        postfix += prefix\n        postfix += suffix\n        postfix\
    \ += prefix\n        postfix += suffix\n        postfix += prefix\n        postfix\
    \ += suffix\n        postfix += prefix\n        postfix += suffix\n        postfix\
    \ += prefix\n        post\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3raes_bk_test.go:96:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075599
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find the longest postfix of supplied string that is\
    \ a palindrome.\n    longestPalindrome := \"\"\n    for i := len(myString) - 1;\
    \ i >= 0; i-- {\n        postfix := myString[:i+1]\n        if isPalindrome(postfix)\
    \ {\n            longestPalindrome = postfix + longestPalindrome\n        }\n\
    \    }\n    // Append to the end of the string reverse of a string prefix that\
    \ comes before the palindromic suffix.\n    longestPalindrome += myString[len(longestPalindrome):]\n\
    \    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n\
    \  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpysvuh_kn_test.go:17:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075600
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLength\
    \ := 0\n    for _, char := range myString {\n        longestPalindromeLength++\n\
    \        longestPalindrome = longestPalindrome + string([]rune(char)[longestPalindromeLength:])\n\
    \    }\n    longestPalindrome = longestPalindrome + string([]rune(longestPalindrome)[:longestPalindromeLength])\n\
    \    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n\
    \  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppf9173cw_test.go:17:63: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075600
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    longestPalindromeLen := len(myString)\n    for i := 0; i < longestPalindromeLen;\
    \ i++ {\n        longestPalindrome += myString[i]\n    }\n    longestPalindrome\
    \ += myString[len(myString)-longestPalindromeLen:]\n    longestPalindrome = longestPalindrome[0:len(longestPalindrome)-1]\n\
    \    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n\
    \  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpo8ej_799_test.go:15:26: no new variables on left side of :=

    /tmp/tmpo8ej_799_test.go:17:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075600
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix\
    \ of supplied string that is a palindrome.\n    // - Append to the end of the\
    \ string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // - Repeat until we find longest postfix that is a palindrome.\n    // -\
    \ Return this longest postfix that is a palindrome.\n    longestPalindrome :=\
    \ \"\"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >= 0;\
    \ i-- {\n        postfix := myString[:i+1]\n        postfix += string(myString[len(myString)-i-1:])\n\
    \        if isPalindrome(postfix) {\n            longestPalindrome = postfix\n\
    \            longestPalindromeLen = len(postfix)\n        }\n    }\n    return\
    \ longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpofpz8f0i_test.go:20:5: longestPalindromeLen declared but not used

    /tmp/tmpofpz8f0i_test.go:24:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075601
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for i := 0; i < len(myString); i++ {\n        prefix := myString[:i]\n\
    \        suffix := myString[i:]\n        postfix := reverse(prefix)\n        if\
    \ postfix != suffix {\n            longestPalindrome = postfix + \"-\" + longestPalindrome\n\
    \            longestPalindromeLen = len(postfix)\n        }\n    }\n    return\
    \ longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp13z517ls_test.go:18:20: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075601
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix\
    \ of supplied string that is a palindrome.\n    // - Append to the end of the\
    \ string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // - Repeat until we find longest postfix of supplied string that is a palindrome.\n\
    \    // - Return this longest postfix of supplied string that is a palindrome.\n\
    \    // - Algorithm is simple - just find the longest postfix of supplied string\
    \ that is a palindrome.\n    // - We need to find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - We need to find the longest postfix of\
    \ supplied string that is a palindrome.\n    // - We need to find the longest\
    \ postfix of supplied string that is a palindrome.\n    // - We need to find the\
    \ longest postfix of supplied string that is a palindrome.\n    // - We need to\
    \ find the longest postfix of supplied string that is a palindrome.\n    // -\
    \ We need to find the longest postfix of supplied string that is a palindrome.\n\
    \    // - We need to find the longest postfix of supplied string that is a palindrome.\n\
    \    // - We need to find the longest postfix of supplied string that is a palindrome.\n\
    \    // - We need to find the longest postfix of supplied string that is a palindrome.\n\
    \    // - We need to find the longest postfix of supplied string that is a palindrome.\n\
    \    // - We need to find the longest postfix of supplied string that is a palindrome.\n\
    \    // - We need to find the longest postfix of supplied string that is a palindrome.\n\
    \    // - We need to find the longest postfix of supplied string that is a palindrome.\n\
    \    // - We need to find the longest postfix of supplied string that is a palindrome.\n\
    \    // - We need to find the longest postfix of supplied string that is a palindrome.\n\
    \    // - We need to find the longest postfix of supplied string that is a palindrome.\n\
    \    // - We need to find the longest postfix of supplied string that is a palindrome.\n\
    \    // - We need to find the longest postfix of supplied string that is a palindrome.\n\
    \    // - We need to find the longest postfix of supplied string that is a palindrome.\n\
    \    // - We need to find the longest postfix of supplied string that is a palindrome.\n\
    \    // - We need to find the lon\nfunc TestMake_Palindrome(t *testing.T) {\n\
    \  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpme6eaysa_test.go:41:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075600
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    longestPalindromeLen := len(myString)\n    for i := 0; i < longestPalindromeLen;\
    \ i++ {\n        prefix := myString[0:i]\n        suffix := myString[i+1:]\n \
    \       postfix := reverseString(prefix)\n        if suffix == postfix {\n   \
    \         longestPalindrome = prefix + postfix\n            longestPalindromeLen\
    \ = len(longestPalindrome)\n        }\n    }\n    return longestPalindrome\n}\n\
    \nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2rdz1731_test.go:15:26: no new variables on left side of :=

    /tmp/tmp2rdz1731_test.go:19:20: undefined: reverseString

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075601
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for i := 0; i < len(myString); i++ {\n        postfix := myString[i:]\n\
    \        postfix += myString[:i]\n        postfix += myString[:i+1]\n        postfix\
    \ += myString[:i+2]\n        postfix += myString[:i+3]\n        postfix += myString[:i+4]\n\
    \        postfix += myString[:i+5]\n        postfix += myString[:i+6]\n      \
    \  postfix += myString[:i+7]\n        postfix += myString[:i+8]\n        postfix\
    \ += myString[:i+9]\n        postfix += myString[:i+10]\n        postfix += myString[:i+11]\n\
    \        postfix += myString[:i+12]\n        postfix += myString[:i+13]\n    \
    \    postfix += myString[:i+14]\n        postfix += myString[:i+15]\n        postfix\
    \ += myString[:i+16]\n        postfix += myString[:i+17]\n        postfix += myString[:i+18]\n\
    \        postfix += myString[:i+19]\n        postfix += myString[:i+20]\n    \
    \    postfix += myString[:i+21]\n        postfix += myString[:i+22]\n        postfix\
    \ += myString[:i+23]\n        postfix += myString[:i+24]\n        postfix += myString[:i+25]\n\
    \        postfix += myString[:i+26]\n        postfix += myString[:i+27]\n    \
    \    postfix += myString[:i+28]\n        postfix += myString[:i+29]\n        postfix\
    \ += myString[:i+30]\n        postfix += myString[:i+31]\n        postfix += myString[:i+32]\n\
    \        postfix += myString[:i+33]\n        postfix += myString[:i+34]\n    \
    \    postfix += myString[:i+35]\n        postfix += myString[:i+36]\n        postfix\
    \ += myString[:i+37]\n        postfix += myString[:i+38]\n        postfix += myString[:i+39]\n\
    \        postfix += myString[:i+40]\n        postfix += myString[:i+41]\n    \
    \    postfix += myString[:i+42]\n        postfix += myString[:i+43]\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmplw82w76m_test.go:62:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075600
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for _, char := range myString {\n        postfix := \"\"\n        for\
    \ i := 0; i < longestPalindromeLen; i++ {\n            postfix += char\n     \
    \   }\n        postfix += string([]byte{char})\n        postfix += string([]byte{char})\n\
    \        if postfix != longestPalindrome {\n            longestPalindrome = postfix\n\
    \            longestPalindromeLen = len(postfix)\n        }\n    }\n    return\
    \ longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpoae4izoc_test.go:18:13: invalid operation: postfix += char (mismatched
    types string and rune)

    /tmp/tmpoae4izoc_test.go:20:34: cannot use char (variable of type rune) as type
    byte in array or slice literal

    /tmp/tmpoae4izoc_test.go:21:34: cannot use char (variable of type rune) as type
    byte in array or slice literal

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075601
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // The longest postfix is found by reversing a string that\
    \ comes before it.\n    // Example: suppose the supplied string is \"abba\", the\
    \ longest postfix is \"abba\".\n    // The longest postfix is \"abba\" because\
    \ \"abba\" is a palindrome.\n    // The longest postfix is \"abba\" because \"\
    abba\" comes before \"abba\".\n    // The longest postfix is \"abba\" because\
    \ \"abba\" comes before \"abba\".\n    // The longest postfix is \"abba\" because\
    \ \"abba\" comes before \"abba\".\n    // The longest postfix is \"abba\" because\
    \ \"abba\" comes before \"abba\".\n    // The longest postfix is \"abba\" because\
    \ \"abba\" comes before \"abba\".\n    // The longest postfix is \"abba\" because\
    \ \"abba\" comes before \"abba\".\n    // The longest postfix is \"abba\" because\
    \ \"abba\" comes before \"abba\".\n    // The longest postfix is \"abba\" because\
    \ \"abba\" comes before \"abba\".\n    // The longest postfix is \"abba\" because\
    \ \"abba\" comes before \"abba\".\n    // The longest postfix is \"abba\" because\
    \ \"abba\" comes before \"abba\".\n    // The longest postfix is \"abba\" because\
    \ \"abba\" comes before \"abba\".\n    // The longest postfix is \"abba\" because\
    \ \"abba\" comes before \"abba\".\n    // The longest postfix is \"abba\" because\
    \ \"abba\" comes before \"abba\".\n    // The longest postfix is \"abba\" because\
    \ \"abba\" comes before \"abba\".\n    // The longest postfix is \"abba\" because\
    \ \"abba\" comes before \"abba\".\n    // The longest postfix is \"abba\" because\
    \ \"abba\" comes before \"abba\".\n    // The longest postfix is \"abba\" because\
    \ \"abba\" comes before \"abba\".\n    // The longest postfix is \"abba\" because\
    \ \"abba\" comes before \"abba\".\n    // The longest postfix is \"abba\" because\
    \ \"abba\" comes before \"ab\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3bo48isb_test.go:36:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075600
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find longest postfix of myString that is a palindrome.\n\
    \    // This will be the length of the palindrome plus one.\n    longestPalindrome\
    \ := 0\n    for i := 0; i < len(myString); i++ {\n        // Find longest postfix\
    \ of myString that is a palindrome.\n        // This will be the length of the\
    \ palindrome plus one.\n        longestPalindrome = longestPalindrome + len(myString[i:])\n\
    \        // If this postfix is a palindrome, add it to the end of the string.\n\
    \        if myString[i:] == myString[:len(myString)-len(myString[i:])] {\n   \
    \         longestPalindrome = longestPalindrome + 1\n        }\n    }\n    //\
    \ Add one to the length of the palindrome to account for the initial character.\n\
    \    longestPalindrome++\n    // Add reverse of myString prefix that comes before\
    \ the palindromic suffix.\n    return myString[:longestPalindrome] + myString[len(myString)-longestPalindrome:]\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\npanic: runtime error: slice bounds\
    \ out of range [:1] with length 0 [recovered]\n\tpanic: runtime error: slice bounds\
    \ out of range [:1] with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.make_palindrome(...)\n\t/tmp/tmpdip3gen4_test.go:28\n\
    command-line-arguments_test.TestMake_Palindrome(0x0?)\n\t/tmp/tmpdip3gen4_test.go:38\
    \ +0x1a\ntesting.tRunner(0xc0001a0340, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075602
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Initialize a palindrome suffix to an empty string.\n\
    \    var palindromeSuffix string = \"\"\n\n    // Initialize a palindrome prefix\
    \ to an empty string.\n    var palindromePrefix string = \"\"\n\n    // Initialize\
    \ a palindrome suffix to an empty string.\n    var palindromeSuffixReverse string\
    \ = \"\"\n\n    // Initialize a palindrome prefix to an empty string.\n    var\
    \ palindromePrefixReverse string = \"\"\n\n    // Initialize a palindrome suffix\
    \ to an empty string.\n    var palindromeSuffixReverse string = \"\"\n\n    //\
    \ Initialize a palindrome prefix to an empty string.\n    var palindromePrefixReverse\
    \ string = \"\"\n\n    // Initialize a palindrome suffix to an empty string.\n\
    \    var palindromeSuffixReverse string = \"\"\n\n    // Initialize a palindrome\
    \ prefix to an empty string.\n    var palindromePrefixReverse string = \"\"\n\n\
    \    // Initialize a palindrome suffix to an empty string.\n    var palindromeSuffixReverse\
    \ string = \"\"\n\n    // Initialize a palindrome prefix to an empty string.\n\
    \    var palindromePrefixReverse string = \"\"\n\n    // Initialize a palindrome\
    \ suffix to an empty string.\n    var palindromeSuffixReverse string = \"\"\n\n\
    \    // Initialize a palindrome prefix to an empty string.\n    var palindromePrefixReverse\
    \ string = \"\"\n\n    // Initialize a palindrome suffix to an empty string.\n\
    \    var palindromeSuffixReverse string = \"\"\n\n    // Initialize a palindrome\
    \ prefix to an empty string.\n    var palindromePrefixReverse string = \"\"\n\n\
    \    // Initialize a palindrome suffix to an empty string.\n    var palindromeSuffixReverse\
    \ string = \"\"\n\n    // Initialize a palindrome prefix to an empty string.\n\
    \    var palindromePrefixReverse string = \"\"\n\n    // Initialize a palindrome\
    \ suffix to an empty string.\n    var palindromeSuffixReverse string = \"\"\n\n\
    \    // Initialize a palindrome prefix to an empty string.\n    var palindromePrefixReverse\
    \ string = \"\"\n\n    // Initialize a palindrome suffix to an empty string.\n\
    \    var palindromeSuffixReverse string = \"\"\n\n    // Initialize a palindrome\
    \ prefix to an empty string.\n    var palindromePrefixReverse string = \"\"\n\n\
    \    // Initialize a palindrome suffix to an empty string.\n    var palindromeSuffixReverse\
    \ string = \"\"\n\n    // Initialize a palindrome prefix to an empty string.\n\
    \    var palindromePrefixReverse string = \"\"\n\n    // Initialize a palindrome\
    \ suffix \nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpc99xa_am_test.go:80:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075601
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLength\
    \ := 0\n    longestPalindromeLengthPalindrome := 0\n    longestPalindromeLengthPalindromePalindrome\
    \ := 0\n    longestPalindromeLengthPalindromePalindromePalindrome := 0\n    for\
    \ i := 0; i < len(myString); i++ {\n        postfix := myString[i:]\n        postfix\
    \ += \"-\"\n        postfix += myString[:i]\n        postfix += \"-\"\n      \
    \  postfix += myString[:i+1]\n        postfix += \"-\"\n        postfix += myString[:i+2]\n\
    \        postfix += \"-\"\n        postfix += myString[:i+3]\n        postfix\
    \ += \"-\"\n        postfix += myString[:i+4]\n        postfix += \"-\"\n    \
    \    postfix += myString[:i+5]\n        postfix += \"-\"\n        postfix += myString[:i+6]\n\
    \        postfix += \"-\"\n        postfix += myString[:i+7]\n        postfix\
    \ += \"-\"\n        postfix += myString[:i+8]\n        postfix += \"-\"\n    \
    \    postfix += myString[:i+9]\n        postfix += \"-\"\n        postfix += myString[:i+10]\n\
    \        postfix += \"-\"\n        postfix += myString[:i+11]\n        postfix\
    \ += \"-\"\n        postfix += myString[:i+12]\n        postfix += \"-\"\n   \
    \     postfix += myString[:i+13]\n        postfix += \"-\"\n        postfix +=\
    \ myString[:i+14]\n        postfix += \"-\"\n        postfix += myString[:i+15]\n\
    \        postfix += \"-\"\n        postfix += myString[:i+16]\n        postfix\
    \ += \"-\"\n        postfix += myString[:i+17]\n        postfix += \"-\"\n   \
    \     postfix += myString[:i+18]\n        postfix += \"-\"\n        postfix +=\
    \ myString[:i+19]\n        postfix += \"-\"\n        postfix += myString[:i+20]\n\
    \        postfix += \"-\"\n        postfix += myString[:i+21]\n        postfix\
    \ += \"-\"\n        postfix += myString[:i+22]\n        postfix += \"-\"\n   \
    \     postfix += myString[:i+23]\n        postfix += \"-\"\n        postfix +=\
    \ myString[:i+24]\n        postfix += \"\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5ijhx20t_test.go:70:20: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075601
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    var myStringPalindrome string\n    var myStringPalindromeLen\
    \ int\n    var myStringPalindromePrefix string\n    var myStringPalindromeSuffix\
    \ string\n\n    // Find the longest postfix of supplied string that is a palindrome.\n\
    \    for i := 0; i < len(myString); i++ {\n        myStringPalindromeLen += 1\
    \ // Increment the length of the palindrome by 1.\n        myStringPalindrome\
    \ = myString[:myStringPalindromeLen]\n        myStringPalindromePrefix = myString[:i]\n\
    \        myStringPalindromeSuffix = myString[i:]\n        if myStringPalindrome\
    \ == myStringPalindromeSuffix {\n            break\n        }\n    }\n\n    //\
    \ Append to the end of the string reverse of a string prefix that comes before\
    \ the palindromic suffix.\n    myStringPalindrome = myStringPalindromePrefix +\
    \ myStringPalindromeSuffix + myStringPalindrome\n    return myStringPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__1\
    \ (0.00s)\n        tmpq1zg_9s3_test.go:51: expected 'x', got 'xx'\n    --- FAIL:\
    \ TestMake_Palindrome/test_num__2 (0.00s)\n        tmpq1zg_9s3_test.go:51: expected\
    \ 'xyzyx', got 'xyzxyz'\n    --- FAIL: TestMake_Palindrome/test_num__3 (0.00s)\n\
    \        tmpq1zg_9s3_test.go:51: expected 'xyx', got 'xyxxyx'\n    --- FAIL: TestMake_Palindrome/test_num__4\
    \ (0.00s)\n        tmpq1zg_9s3_test.go:51: expected 'jerryrrej', got 'jerryjerry'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075602
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find the longest postfix of supplied string that is\
    \ a palindrome.\n    longestPalindrome := \"\"\n    longestPalindromeLen := 0\n\
    \    for i := len(myString) - 1; i >= 0; i-- {\n        postfix := myString[:i+1]\n\
    \        if isPalindrome(postfix) {\n            longestPalindrome = postfix\n\
    \            longestPalindromeLen = len(postfix)\n        }\n    }\n    // Append\
    \ to the end of the string reverse of a string prefix that comes before the palindromic\
    \ suffix.\n    prefix := myString[:longestPalindromeLen]\n    return prefix +\
    \ reverseString(longestPalindrome)\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3n6_d7ej_test.go:18:12: undefined: isPalindrome

    /tmp/tmp3n6_d7ej_test.go:25:21: undefined: reverseString

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075602
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find the longest postfix of supplied string that is\
    \ a palindrome.\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString);\
    \ i++ {\n        postfix := myString[i:]\n        if isPalindrome(postfix) {\n\
    \            longestPalindrome = postfix + \"-\" + longestPalindrome\n       \
    \ }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvwujhg3__test.go:17:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075602
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for i := 0; i < len(myString); i++ {\n        postfix := myString[:i]\n\
    \        postfix += string(myString[len(myString)-i:][:len(myString)-i])\n   \
    \     postfix += myString[:i]\n        postfix += string(myString[len(myString)-i:][:len(myString)-i])\n\
    \        if postfix != longestPalindrome {\n            longestPalindrome = postfix\n\
    \            longestPalindromeLen = len(postfix)\n        }\n    }\n    return\
    \ longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbazzeebo_test.go:14:5: longestPalindromeLen declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075602
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find longest postfix of myString that is a palindrome.\n\
    \    longestPalindrome := \"\"\n    longestPalindromeLen := 0\n    for i := 0;\
    \ i < len(myString); i++ {\n        postfix := myString[longestPalindromeLen:]\
    \ + myString[:i]\n        if isPalindrome(postfix) {\n            longestPalindrome\
    \ = postfix\n            longestPalindromeLen = len(postfix)\n        }\n    }\n\
    \    // Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    prefix := myString[:longestPalindromeLen]\n\
    \    return prefix + longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpin_xydwy_test.go:18:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075602
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find longest postfix of myString that is a palindrome.\n\
    \    // The longest postfix is found by reversing myString and finding the longest\
    \ prefix that is a palindrome.\n    // The longest prefix is found by reversing\
    \ myString and finding the longest suffix that is a palindrome.\n    // The longest\
    \ suffix is found by reversing myString and finding the longest prefix that is\
    \ a palindrome.\n    // The longest prefix is found by reversing myString and\
    \ finding the longest suffix that is a palindrome.\n    // The longest suffix\
    \ is found by reversing myString and finding the longest prefix that is a palindrome.\n\
    \    // The longest prefix is found by reversing myString and finding the longest\
    \ suffix that is a palindrome.\n    // The longest suffix is found by reversing\
    \ myString and finding the longest prefix that is a palindrome.\n    // The longest\
    \ prefix is found by reversing myString and finding the longest suffix that is\
    \ a palindrome.\n    // The longest suffix is found by reversing myString and\
    \ finding the longest prefix that is a palindrome.\n    // The longest prefix\
    \ is found by reversing myString and finding the longest suffix that is a palindrome.\n\
    \    // The longest suffix is found by reversing myString and finding the longest\
    \ prefix that is a palindrome.\n    // The longest prefix is found by reversing\
    \ myString and finding the longest suffix that is a palindrome.\n    // The longest\
    \ suffix is found by reversing myString and finding the longest prefix that is\
    \ a palindrome.\n    // The longest prefix is found by reversing myString and\
    \ finding the longest suffix that is a palindrome.\n    // The longest suffix\
    \ is found by reversing myString and finding the longest prefix that is a palindrome.\n\
    \    // The longest prefix is found by reversing myString and finding the longest\
    \ suffix that is a palindrome.\n    // The longest suffix is found by reversing\
    \ myString and finding the longest prefix that is a palindrome.\n    // The longest\
    \ prefix is found by reversing myString and finding the longest suffix that is\
    \ a palindrome.\n    // The longest suffix is found by reversing myString and\
    \ finding the longest prefix that is a palindrome.\n    // The longest prefix\
    \ is found by reversing myString and finding the longest suffix that is a \nfunc\
    \ TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphkq9kjz1_test.go:34:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075601
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find longest postfix of myString that is a palindrome\n\
    \    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n   \
    \     postfix := myString[i:]\n        postfix += myString[:i]\n        if isPalindrome(postfix)\
    \ {\n            longestPalindrome = postfix\n        }\n    }\n    // Append\
    \ reverse of longestPalindrome to myString\n    longestPalindrome += myString[len(longestPalindrome):]\n\
    \    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n\
    \  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgnuq2jek_test.go:18:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075602
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for _, char := range myString {\n        longestPalindromeLen += len(char)\n\
    \        if longestPalindromeLen > longestPalindromeLen {\n            longestPalindrome\
    \ = char\n            longestPalindromeLen = len(char)\n        }\n    }\n   \
    \ longestPalindromeLen -= len(longestPalindrome)\n    longestPalindrome = longestPalindrome\
    \ + string(myString[longestPalindromeLen:])\n    return longestPalindrome\n}\n\
    \nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7atjk9ap_test.go:16:37: invalid argument: char (variable of type rune)
    for len

    /tmp/tmp7atjk9ap_test.go:18:33: cannot use char (variable of type rune) as type
    string in assignment

    /tmp/tmp7atjk9ap_test.go:19:40: invalid argument: char (variable of type rune)
    for len

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075602
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Initialize a variable to hold our result\n    var result\
    \ string\n\n    // Initialize a variable to hold our longest postfix of myString\n\
    \    var longestPostfix string\n\n    // Initialize a variable to hold our longest\
    \ postfix of myString reversed\n    var longestPostfixReversed string\n\n    //\
    \ Initialize a variable to hold our longest postfix of myString reversed\n   \
    \ var longestPostfixReversed2 string\n\n    // Initialize a variable to hold our\
    \ longest postfix of myString reversed\n    var longestPostfixReversed3 string\n\
    \n    // Initialize a variable to hold our longest postfix of myString reversed\n\
    \    var longestPostfixReversed4 string\n\n    // Initialize a variable to hold\
    \ our longest postfix of myString reversed\n    var longestPostfixReversed5 string\n\
    \n    // Initialize a variable to hold our longest postfix of myString reversed\n\
    \    var longestPostfixReversed6 string\n\n    // Initialize a variable to hold\
    \ our longest postfix of myString reversed\n    var longestPostfixReversed7 string\n\
    \n    // Initialize a variable to hold our longest postfix of myString reversed\n\
    \    var longestPostfixReversed8 string\n\n    // Initialize a variable to hold\
    \ our longest postfix of myString reversed\n    var longestPostfixReversed9 string\n\
    \n    // Initialize a variable to hold our longest postfix of myString reversed\n\
    \    var longestPostfixReversed10 string\n\n    // Initialize a variable to hold\
    \ our longest postfix of myString reversed\n    var longestPostfixReversed11 string\n\
    \n    // Initialize a variable to hold our longest postfix of myString reversed\n\
    \    var longestPostfixReversed12 string\n\n    // Initialize a variable to hold\
    \ our longest postfix of myString reversed\n    var longestPostfixReversed13 string\n\
    \n    // Initialize a variable to hold our longest postfix of myString reversed\n\
    \    var longestPostfixReversed14 string\n\n    // Initialize a variable to hold\
    \ our longest postfix of myString reversed\n    var longestPostfixReversed15 string\n\
    \n    // Initialize a variable to hold our longest postfix of myString reversed\n\
    \    var longestPostfixReversed16 string\n\n    // Initialize a variable to hold\
    \ our longest postfix of myString reversed\n    var longestPostfixReversed17 string\n\
    \n    // Initialize a variable to hold our longest postfix of myString reversed\n\
    \    var longestPostfixReversed18 string\n\n    // Initialize a variable to hold\
    \ our longest post\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmrcdjqy8_test.go:74:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075601
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // The longest postfix is always one character longer than\
    \ the supplied string.\n    // The longest postfix is always one character longer\
    \ than the supplied string.\n    // The longest postfix is always one character\
    \ longer than the supplied string.\n    // The longest postfix is always one character\
    \ longer than the supplied string.\n    // The longest postfix is always one character\
    \ longer than the supplied string.\n    // The longest postfix is always one character\
    \ longer than the supplied string.\n    // The longest postfix is always one character\
    \ longer than the supplied string.\n    // The longest postfix is always one character\
    \ longer than the supplied string.\n    // The longest postfix is always one character\
    \ longer than the supplied string.\n    // The longest postfix is always one character\
    \ longer than the supplied string.\n    // The longest postfix is always one character\
    \ longer than the supplied string.\n    // The longest postfix is always one character\
    \ longer than the supplied string.\n    // The longest postfix is always one character\
    \ longer than the supplied string.\n    // The longest postfix is always one character\
    \ longer than the supplied string.\n    // The longest postfix is always one character\
    \ longer than the supplied string.\n    // The longest postfix is always one character\
    \ longer than the supplied string.\n    // The longest postfix is always one character\
    \ longer than the supplied string.\n    // The longest postfix is always one character\
    \ longer than the supplied string.\n    // The longest postfix is always one character\
    \ longer than the supplied string.\n    // The longest postfix is always one character\
    \ longer than the supplied string.\n    // The longest postfix is always one character\
    \ longer than the supplied string.\n    // The longest postfix is always one character\
    \ longer than the supplied string.\n    // The longest postfix is always one character\
    \ longer than the supplied string.\n    // The longest postfix is always one character\
    \ longer than the supplied string.\n    // The longest postfix is always one character\
    \ longer than the supplied string.\n    // The longest postfix is always one character\
    \ longer than the supplied string.\n    // The longest postfix is always one character\
    \ longer than the supplied string.\n    // The longest postfix is always one character\
    \ longer than the supplied string.\n    // The longest postfix is always one character\
    \ longer than the supplied string.\n    // The longest postfix is always one character\
    \ longer than the supplied string.\n    // The longest postfix is always one character\
    \ longer than the supplied string.\n\nfunc TestMake_Palindrome(t *testing.T) {\n\
    \  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpi6o6m_6i_test.go:46:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075601
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for i := 0; i < len(myString); i++ {\n        postfix := myString[i:]\n\
    \        postfix += string(myString[:i])\n        postfix += string(myString[i+1:])\n\
    \        postfix += string(myString[:len(myString)-i])\n        postfix += string(myString[len(myString)-i:])\n\
    \        postfix += string(myString[:len(myString)-i-1])\n        postfix += string(myString[len(myString)-i-1:])\n\
    \        postfix += string(myString[:len(myString)-i-2])\n        postfix += string(myString[len(myString)-i-2:])\n\
    \        postfix += string(myString[:len(myString)-i-3])\n        postfix += string(myString[len(myString)-i-3:])\n\
    \        postfix += string(myString[:len(myString)-i-4])\n        postfix += string(myString[len(myString)-i-4:])\n\
    \        postfix += string(myString[:len(myString)-i-5])\n        postfix += string(myString[len(myString)-i-5:])\n\
    \        postfix += string(myString[:len(myString)-i-6])\n        postfix += string(myString[len(myString)-i-6:])\n\
    \        postfix += string(myString[:len(myString)-i-7])\n        postfix += string(myString[len(myString)-i-7:])\n\
    \        postfix += string(myString[:len(myString)-i-8])\n        postfix += string(myString[len(myString)-i-8:])\n\
    \        postfix += string(myString[:len(myString)-i-9])\n        postfix += string(myString[len(myString)-i-9:])\n\
    \        postfix += string(myString[:len(myString)-i-10])\n        postfix +=\
    \ string(myString[len(myString)-i-10:])\n        postfix += string(myString[:len(myString)-i-11])\n\
    \        postfix += string(myString[len(myString)-i-11:])\n        postfix +=\
    \ string(myString[:len(myString)-i-12])\n        postfix += string(myString[len(myString)-i-12:])\n\
    \        postfix += string(myString[:len(myString)-i-13])\n        postfix +=\
    \ string(myString[len(myString)-i-13:])\n        postfix += string(myString[:len(myString)-i-14])\n\
    \        postfix += string(myString[len(myString)-i-14:])\n        postfix +=\
    \ string(myString[:len(myString)-i-15])\n        postfix += \nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpnm6mtpfx_test.go:51:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075601
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find longest postfix of myString that is a palindrome.\n\
    \    // This will be the length of the palindrome plus 1.\n    longestPalindrome\
    \ := 0\n    for i := 0; i < len(myString); i++ {\n        longestPalindrome =\
    \ longestPalindrome + 1\n        if myString[len(myString)-i-1] != myString[len(myString)-i-longestPalindrome]\
    \ {\n            longestPalindrome = 0\n            break\n        }\n    }\n\
    \    // Append the reverse of the string prefix that comes before the palindromic\
    \ suffix.\n    result := myString\n    for i := 0; i < longestPalindrome; i++\
    \ {\n        result = result + myString[len(myString)-i]\n    }\n    return result\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcdon969j_test.go:26:18: invalid operation: result + myString[len(myString)
    - i] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075602
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find longest postfix of myString that is a palindrome\n\
    \    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n   \
    \     longestPalindrome += myString[i]\n    }\n    longestPalindrome += myString[len(myString)-1:]\n\
    \n    // Append reverse of longestPalindrome to myString\n    prefix := \"\"\n\
    \    for i := 0; i < len(longestPalindrome); i++ {\n        prefix += longestPalindrome[len(longestPalindrome)-i-1]\n\
    \    }\n    return prefix + longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9aj_k6qz_test.go:16:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmp9aj_k6qz_test.go:23:9: invalid operation: prefix += longestPalindrome[len(longestPalindrome)
    - i - 1] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075602
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find longest postfix of myString that is a palindrome.\n\
    \    longestPalindrome := \"\"\n    longestPalindromeLen := 0\n    for i := 0;\
    \ i < len(myString); i++ {\n        postfix := myString[i:]\n        postfix :=\
    \ append(postfix, myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n\
    \        postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, \nfunc TestMake_Palindrome(t *testing.T) {\n \
    \ candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpcjfgbxlg_test.go:51:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075602
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // The longest postfix is found by reversing a substring\
    \ of the supplied string that begins\n    // with the longest postfix.\n    //\
    \ The longest postfix is found by reversing a substring of the supplied string\
    \ that begins\n    // with the longest postfix.\n    // The longest postfix is\
    \ found by reversing a substring of the supplied string that begins\n    // with\
    \ the longest postfix.\n    // The longest postfix is found by reversing a substring\
    \ of the supplied string that begins\n    // with the longest postfix.\n    //\
    \ The longest postfix is found by reversing a substring of the supplied string\
    \ that begins\n    // with the longest postfix.\n    // The longest postfix is\
    \ found by reversing a substring of the supplied string that begins\n    // with\
    \ the longest postfix.\n    // The longest postfix is found by reversing a substring\
    \ of the supplied string that begins\n    // with the longest postfix.\n    //\
    \ The longest postfix is found by reversing a substring of the supplied string\
    \ that begins\n    // with the longest postfix.\n    // The longest postfix is\
    \ found by reversing a substring of the supplied string that begins\n    // with\
    \ the longest postfix.\n    // The longest postfix is found by reversing a substring\
    \ of the supplied string that begins\n    // with the longest postfix.\n    //\
    \ The longest postfix is found by reversing a substring of the supplied string\
    \ that begins\n    // with the longest postfix.\n    // The longest postfix is\
    \ found by reversing a substring of the supplied string that begins\n    // with\
    \ the longest postfix.\n    // The longest postfix is found by reversing a substring\
    \ of the supplied string that begins\n    // with the longest postfix.\n    //\
    \ The longest postfix is found by reversing a substring of the supplied string\
    \ that begins\n    // with the longest postfix.\n    // The longest postfix is\
    \ found by reversing a substring of the supplied string that begins\n    // with\
    \ the longest postfix.\n    // The longest postfix is found by reversing a substring\
    \ of the supplied string that begins\n    // with the longest postfix.\n    //\
    \ The longest postfix is found by reversing a substring of the supplied string\
    \ that begins\n    // with the longest postfix.\n    // The lon\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6gxm8jo1_test.go:49:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075602
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLength\
    \ := 0\n    longestPalindromeLength := len(myString)\n    for i := 0; i < longestPalindromeLength;\
    \ i++ {\n        postfix := myString[longestPalindromeLength - i]\n        postfix\
    \ := append(postfix, postfix[len(postfix)-1])\n        postfix := append(postfix,\
    \ postfix[0])\n        if postfix != myString {\n            longestPalindrome\
    \ = postfix\n            longestPalindromeLength = len(postfix)\n        }\n \
    \   }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph1rccl9s_test.go:15:29: no new variables on left side of :=

    /tmp/tmph1rccl9s_test.go:18:17: no new variables on left side of :=

    /tmp/tmph1rccl9s_test.go:18:27: first argument to append must be a slice; have
    postfix (variable of type byte)

    /tmp/tmph1rccl9s_test.go:18:43: invalid operation: cannot index postfix (variable
    of type byte)

    /tmp/tmph1rccl9s_test.go:19:17: no new variables on left side of :=

    /tmp/tmph1rccl9s_test.go:19:27: first argument to append must be a slice; have
    postfix (variable of type byte)

    /tmp/tmph1rccl9s_test.go:19:43: invalid operation: cannot index postfix (variable
    of type byte)

    /tmp/tmph1rccl9s_test.go:20:23: invalid operation: postfix != myString (mismatched
    types byte and string)

    /tmp/tmph1rccl9s_test.go:21:33: cannot use postfix (variable of type byte) as
    type string in assignment

    /tmp/tmph1rccl9s_test.go:22:43: invalid argument: postfix (variable of type byte)
    for len

    /tmp/tmph1rccl9s_test.go:22:43: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075602
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for i := 0; i < len(myString); i++ {\n        prefix := myString[:i]\n\
    \        suffix := myString[i:]\n        postfix := reversePostfix(prefix)\n \
    \       postfix += suffix\n        postfix += reversePostfix(suffix)\n       \
    \ postfix += prefix\n        postfix += reversePostfix(prefix)\n        postfix\
    \ += suffix\n        postfix += reversePostfix(suffix)\n        postfix += prefix\n\
    \        postfix += reversePostfix(prefix)\n        postfix += suffix\n      \
    \  postfix += reversePostfix(suffix)\n        postfix += prefix\n        postfix\
    \ += reversePostfix(suffix)\n        postfix += suffix\n        postfix += reversePostfix(suffix)\n\
    \        postfix += prefix\n        postfix += reversePostfix(suffix)\n      \
    \  postfix += suffix\n        postfix += reversePostfix(suffix)\n        postfix\
    \ += prefix\n        postfix += reversePostfix(suffix)\n        postfix += suffix\n\
    \        postfix += reversePostfix(suffix)\n        postfix += prefix\n      \
    \  postfix += reversePostfix(suffix)\n        postfix += suffix\n        postfix\
    \ += reversePostfix(suffix)\n        postfix += prefix\n        postfix += reversePostfix(suffix)\n\
    \        postfix += suffix\n        postfix += reversePostfix(suffix)\n      \
    \  postfix += prefix\n        postfix += reversePostfix(suffix)\n        postfix\
    \ += suffix\n        postfix += reversePostfix(suffix)\n        postfix += prefix\n\
    \        postfix += reversePostfix(suffix)\n        postfix += suffix\n      \
    \  postfix += reversePostfix(suffix)\n        postfix += prefix\n        postfix\
    \ += reversePostfix(suffix)\n        postfix += suffix\n        postfix += reversePostfix(suffix)\n\
    \        postfix += prefix\n        postfix += reversePostfix(suffix)\n      \
    \  postfix += suffix\n        postfix += reversePostfix(suffix)\n        postfix\
    \ += prefix\n        postfix += reversePostfix(suffix)\n        postfix += suffix\n\
    \        postfix += reversePostfix(suffix)\n        postfix += prefix\n      \
    \  postfix += reversePostfix(suffix)\n        postfix += suffix\n        postfix\
    \ += reversePostfix(suffi\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp41j3thxb_test.go:72:40: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075602
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find longest postfix of myString that is a palindrome.\n\
    \    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n   \
    \     postfix := myString[:i]\n        reverse := myString[i+1:]\n        if isPalindrome(postfix)\
    \ {\n            longestPalindrome = longestPalindrome + reverse + postfix\n \
    \       }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpozxrygdt_test.go:18:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075603
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find longest postfix of supplied string that is a palindrome.\n\
    \    // This will be the length of the palindrome plus one.\n    longestPalindrome\
    \ := 0\n    for i := len(myString) - 1; i >= 0; i-- {\n        // Find longest\
    \ postfix of supplied string that is a palindrome.\n        // This will be the\
    \ length of the palindrome plus one.\n        longestPalindrome = longestPalindrome+1\
    \ // Add one to longest palindrome.\n        // Add reverse of string prefix that\
    \ comes before the palindromic suffix.\n        myString = myString[:i] + myString[i+longestPalindrome:]\n\
    \    }\n    return myString\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n \
    \ candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\npanic: runtime error: slice bounds\
    \ out of range [3:2] [recovered]\n\tpanic: runtime error: slice bounds out of\
    \ range [3:2]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620, 0xc000014360})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.make_palindrome(...)\n\t/tmp/tmpnjo5olbz_test.go:21\n\
    command-line-arguments_test.TestMake_Palindrome(0x0?)\n\t/tmp/tmpnjo5olbz_test.go:35\
    \ +0x606\ntesting.tRunner(0xc0001924e0, 0x528f60)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075603
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for _, char := range myString {\n        longestPalindromeLen += len(char)\
    \ + 1 // +1 for the char itself\n        if longestPalindromeLen > len(longestPalindrome)\
    \ {\n            longestPalindrome = char\n            longestPalindromeLen =\
    \ len(char)\n        }\n    }\n    longestPalindrome += string(myString[len(myString)-longestPalindromeLen:])\n\
    \    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n\
    \  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdd0sk2s6_test.go:16:37: invalid argument: char (variable of type rune)
    for len

    /tmp/tmpdd0sk2s6_test.go:18:33: cannot use char (variable of type rune) as type
    string in assignment

    /tmp/tmpdd0sk2s6_test.go:19:40: invalid argument: char (variable of type rune)
    for len

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075603
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find longest postfix of myString that is a palindrome\n\
    \    longestPalindrome := \"\"\n    longestPalindromeLen := 0\n    for i := 0;\
    \ i < len(myString); i++ {\n        postfix := myString[longestPalindromeLen :\
    \ i+1]\n        postfix += \"-\"\n        postfix += myString[0:longestPalindromeLen]\n\
    \        postfix += \"-\"\n        postfix += myString[i+1:]\n        postfix\
    \ += \"-\"\n        postfix += myString[0:i]\n        postfix += \"-\"\n     \
    \   postfix += myString[i+1:]\n        postfix += \"-\"\n        postfix += myString[0:longestPalindromeLen]\n\
    \        postfix += \"-\"\n        postfix += myString[i+1:]\n        postfix\
    \ += \"-\"\n        postfix += myString[0:i]\n        postfix += \"-\"\n     \
    \   postfix += myString[i+1:]\n        postfix += \"-\"\n        postfix += myString[0:longestPalindromeLen]\n\
    \        postfix += \"-\"\n        postfix += myString[i+1:]\n        postfix\
    \ += \"-\"\n        postfix += myString[0:i]\n        postfix += \"-\"\n     \
    \   postfix += myString[i+1:]\n        postfix += \"-\"\n        postfix += myString[0:longestPalindromeLen]\n\
    \        postfix += \"-\"\n        postfix += myString[i+1:]\n        postfix\
    \ += \"-\"\n        postfix += myString[0:i]\n        postfix += \"-\"\n     \
    \   postfix += myString[i+1:]\n        postfix += \"-\"\n        postfix += myString[0:longestPalindromeLen]\n\
    \        postfix += \"-\"\n        postfix += myString[i+1:]\n        postfix\
    \ += \"-\"\n        postfix += myString[0:i]\n        postfix += \"-\"\n     \
    \   postfix += myString[i+1:]\n        postfix += \"-\"\n        postfix += myString[0:longestPalindromeLen]\n\
    \        postfix += \"-\"\n        postfix += myString[i+1:]\n        postfix\
    \ += \"-\"\n        postfix += myString[0:i]\n        postfix += \"-\"\n     \
    \   postfix += myString[i+1:]\n        postfix += \"-\"\n        postfix += myString[0:longestPalindromeLen]\n\
    \        postfix += \"-\"\n        postfix += myString[i+1:]\n        postfix\
    \ += \"-\"\n        postfix += myString[0:i]\n        \nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmprifqooii_test.go:73:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075603
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    longestPalindromeLen += len(myString) / 2\n    for i := 0; i < len(myString);\
    \ i++ {\n        prefix := myString[:i]\n        suffix := myString[i:]\n    \
    \    if isPalindrome(prefix, suffix) {\n            longestPalindromeLen += i\n\
    \            longestPalindrome = prefix + suffix\n        }\n    }\n    return\
    \ longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsmelamlv_test.go:19:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075603
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find longest postfix of myString that is a palindrome.\n\
    \    longestPalindrome := \"\"\n    for i := len(myString) - 1; i >= 0; i-- {\n\
    \        postfix := myString[0:i+1]\n        if isPalindrome(postfix) {\n    \
    \        longestPalindrome = postfix\n            break\n        }\n    }\n\n\
    \    // Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    prefix := myString[0:longestPalindrome]\n\
    \    suffix := myString[longestPalindrome+1:]\n    return prefix + reverseString(suffix)\
    \ + longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjb3pn1vn_test.go:17:12: undefined: isPalindrome

    /tmp/tmpjb3pn1vn_test.go:24:26: invalid argument: index longestPalindrome (variable
    of type string) must be integer

    /tmp/tmpjb3pn1vn_test.go:25:24: invalid operation: longestPalindrome + 1 (mismatched
    types string and untyped int)

    /tmp/tmpjb3pn1vn_test.go:26:21: undefined: reverseString

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075603
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    longestPalindromeLen := len(myString) - 2\n    for i := 0; i < longestPalindromeLen;\
    \ i++ {\n        prefix := myString[0:i]\n        suffix := myString[i+1:]\n \
    \       reversedSuffix := suffix[len(suffix)-1::-1]\n        if suffix == reversedSuffix\
    \ {\n            longestPalindrome += prefix + suffix\n        }\n    }\n    return\
    \ longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpme50cb5__test.go:19:47: 2nd index required in 3-index slice

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075603
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for _, char := range myString {\n        if char == ' ' {\n         \
    \   longestPalindrome = longestPalindrome[:longestPalindromeLen]\n           \
    \ longestPalindromeLen += 1 // space is counted as a character\n        } else\
    \ {\n            longestPalindrome += string([]byte{char})\n            longestPalindromeLen\
    \ += len([]byte{char})\n        }\n    }\n    longestPalindrome = longestPalindrome[:longestPalindromeLen]\n\
    \    longestPalindromeLen += len(longestPalindrome)\n    longestPalindrome = longestPalindrome[:longestPalindromeLen]\n\
    \    longestPalindromeLen += len(longestPalindrome)\n    longestPalindrome = longestPalindrome[:longestPalindromeLen]\n\
    \    longestPalindromeLen += len(longestPalindrome)\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_v0czs38_test.go:20:48: cannot use char (variable of type rune) as type
    byte in array or slice literal

    /tmp/tmp_v0czs38_test.go:21:48: cannot use char (variable of type rune) as type
    byte in array or slice literal

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075603
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find longest postfix of myString that is a palindrome.\n\
    \    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n   \
    \     postfix := myString[i:]\n        postfix += myString[:i]\n        if isPalindrome(postfix)\
    \ {\n            longestPalindrome = postfix\n        }\n    }\n    // Append\
    \ the reverse of the longest postfix to the end of the string.\n    return longestPalindrome\
    \ + reverse(longestPalindrome)\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n\
    \  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpy4yc0a4m_test.go:18:12: undefined: isPalindrome

    /tmp/tmpy4yc0a4m_test.go:23:32: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075603
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for _, char := range myString {\n        longestPalindromeLen += len(char)\
    \ + 1\n    }\n    for i := 0; i < longestPalindromeLen; i++ {\n        longestPalindrome\
    \ += myString[len(myString)-1-i]\n    }\n    return longestPalindrome\n}\n\nfunc\
    \ TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpa_uff6li_test.go:16:37: invalid argument: char (variable of type rune)
    for len

    /tmp/tmpa_uff6li_test.go:19:9: invalid operation: longestPalindrome += myString[len(myString)
    - 1 - i] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075604
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLength\
    \ := 0\n    for _, char := range myString {\n        longestPalindromeLength++\n\
    \        if longestPalindromeLength > len(longestPalindrome) {\n            longestPalindrome\
    \ = char\n        }\n    }\n    longestPalindromeLength = len(longestPalindrome)\n\
    \    for i := 0; i < longestPalindromeLength; i++ {\n        char := myString[len(myString)-(i+1)]\n\
    \        myString = myString[:len(myString)-(i+1)] + char + myString[len(myString)-(i+1):]\n\
    \    }\n    return myString\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n \
    \ candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp05xqrbbu_test.go:18:33: cannot use char (variable of type rune) as type
    string in assignment

    /tmp/tmp05xqrbbu_test.go:24:28: invalid operation: myString[:len(myString) - (i
    + 1)] + char (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075604
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix\
    \ of supplied string that is a palindrome.\n    // - Append to the end of the\
    \ string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // - Repeat until no palindromic suffix is found.\n    // - Return this palindromic\
    \ suffix.\n    longestPalindrome := \"\"\n    longestPalindromeLen := 0\n    for\
    \ i := 0; i < len(myString); i++ {\n        postfix := myString[i:]\n        postfix\
    \ += strings.Reverse(postfix)\n        postfix += myString[:i]\n        postfix\
    \ += strings.Reverse(postfix)\n        postfix += myString[i:]\n        postfix\
    \ += strings.Reverse(postfix)\n        postfix += myString[:i]\n        postfix\
    \ += strings.Reverse(postfix)\n        postfix += myString[i:]\n        postfix\
    \ += strings.Reverse(postfix)\n        postfix += myString[:i]\n        postfix\
    \ += strings.Reverse(postfix)\n        postfix += myString[i:]\n        postfix\
    \ += strings.Reverse(postfix)\n        postfix += myString[:i]\n        postfix\
    \ += strings.Reverse(postfix)\n        postfix += myString[i:]\n        postfix\
    \ += strings.Reverse(postfix)\n        postfix += myString[:i]\n        postfix\
    \ += strings.Reverse(postfix)\n        postfix += myString[i:]\n        postfix\
    \ += strings.Reverse(postfix)\n        postfix += myString[:i]\n        postfix\
    \ += strings.Reverse(postfix)\n        postfix += myString[i:]\n        postfix\
    \ += strings.Reverse(postfix)\n        postfix += myString[:i]\n        postfix\
    \ += strings.Reverse(postfix)\n        postfix += myString[i:]\n        postfix\
    \ += strings.Reverse(postfix)\n        postfix += myString[:i]\n        postfix\
    \ += strings.Reverse(postfix)\n        postfix += myString[i:]\n        postfix\
    \ += strings.Reverse(postfix)\n        postfix += myString[:i]\n        postfix\
    \ += strings.Reverse(postfix)\n        postfix += myString[i:]\n        postfix\
    \ += strings.Reverse(postfix)\n        postfix += myString[:i]\n        postfix\
    \ += strings.Reverse(postfix)\n        postfix += myString[i:]\n        \nfunc\
    \ TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpsh546aih_test.go:64:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075603
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find longest postfix of myString that is a palindrome\n\
    \    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n   \
    \     longestPalindrome += myString[i]\n    }\n    longestPalindrome += myString[len(myString)-len(longestPalindrome):]\n\
    \n    // Append reverse of prefix that comes before longestPalindrome\n    prefix\
    \ := myString[:len(myString)-len(longestPalindrome)]\n    prefix += longestPalindrome\n\
    \    return prefix\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp96dyj4sv_test.go:16:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075604
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    var myStringLen int = len(myString)\n    var myStringPrefix\
    \ string\n    var myStringSuffix string\n    var myStringPalindrome string\n \
    \   var myStringPalindromeLen int\n\n    for i := 0; i < myStringLen; i++ {\n\
    \        myStringPrefix = myString[:i]\n        myStringSuffix = myString[i:]\n\
    \        myStringPalindrome = myStringPrefix + reverse(myStringSuffix) + myStringSuffix\n\
    \        myStringPalindromeLen = len(myStringPalindrome)\n        if myStringPalindromeLen\
    \ > myStringLen {\n            break\n        }\n    }\n    return myStringPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplwjpy_ti_test.go:22:47: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075604
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    longestPalindromeLen := len(myString)\n    for i := 0; i < longestPalindromeLen;\
    \ i++ {\n        prefix := myString[0:i]\n        reverse := myString[len(myString)-i:]\n\
    \        if isPalindrome(prefix, reverse) {\n            longestPalindrome = prefix\
    \ + reverse\n            longestPalindromeLen = len(longestPalindrome)\n     \
    \   }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcnltgdhr_test.go:15:26: no new variables on left side of :=

    /tmp/tmpcnltgdhr_test.go:19:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075604
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for i := 0; i < len(myString); i++ {\n        postfix := myString[i:]\n\
    \        prefix := myString[:i]\n        postfix = append(postfix, reverseString(prefix)...)\n\
    \        postfix = append(postfix, postfix...)\n        if isPalindrome(postfix)\
    \ {\n            longestPalindrome = postfix\n            longestPalindromeLen\
    \ = len(postfix)\n        }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0ms6pf2r_test.go:14:5: longestPalindromeLen declared but not used

    /tmp/tmp0ms6pf2r_test.go:18:26: first argument to append must be a slice; have
    postfix (variable of type string)

    /tmp/tmp0ms6pf2r_test.go:18:35: undefined: reverseString

    /tmp/tmp0ms6pf2r_test.go:19:26: first argument to append must be a slice; have
    postfix (variable of type string)

    /tmp/tmp0ms6pf2r_test.go:20:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075604
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for i := 0; i < len(myString); i++ {\n        prefix := myString[:i]\n\
    \        suffix := myString[i:]\n        postfix := reversePostfix(prefix)\n \
    \       if postfix != suffix {\n            longestPalindrome = prefix + postfix\n\
    \            longestPalindromeLen = len(longestPalindrome)\n        }\n    }\n\
    \    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n\
    \  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3rsvz0_g_test.go:14:5: longestPalindromeLen declared but not used

    /tmp/tmp3rsvz0_g_test.go:18:20: undefined: reversePostfix

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075604
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for _, char := range myString {\n        postfix := \"\"\n        for\
    \ i := 0; i < len(myString); i++ {\n            postfix += string(myString[i :\
    \ len(myString)-(i+1)])\n        }\n        postfix += string(myString[len(myString)-len(postfix):])\n\
    \        postfix += string(myString[:len(myString)-len(postfix)])\n        if\
    \ postfix != longestPalindrome {\n            longestPalindrome = postfix\n  \
    \          longestPalindromeLen = len(postfix)\n        }\n    }\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj812o87q_test.go:14:5: longestPalindromeLen declared but not used

    /tmp/tmpj812o87q_test.go:15:12: char declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075604
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find the longest postfix of supplied string that is\
    \ a palindrome.\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString);\
    \ i++ {\n        postfix := myString[i:]\n        if isPalindrome(postfix) {\n\
    \            longestPalindrome = myString[:i]\n            break\n        }\n\
    \    }\n    // Append to the end of the string reverse of a string prefix that\
    \ comes before the palindromic suffix.\n    suffix := myString[len(longestPalindrome):]\n\
    \    suffix += reverse(longestPalindrome)\n    return suffix\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjhpzh__1_test.go:17:12: undefined: isPalindrome

    /tmp/tmpjhpzh__1_test.go:24:15: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075604
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for i := 0; i < len(myString); i++ {\n        prefix := myString[:i]\n\
    \        suffix := myString[i:]\n        longestPalindromeLen := len(longestPalindrome)\n\
    \        longestPalindrome = longestPalindrome + prefix + suffix\n    }\n    return\
    \ longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp37k_msmo_test.go:14:5: longestPalindromeLen declared but not used

    /tmp/tmp37k_msmo_test.go:18:9: longestPalindromeLen declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075604
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    longestPalindromeLen += len(myString) - 1 // add one to account for first\
    \ character\n    for i := 0; i < len(myString); i++ {\n        prefix := myString[:i]\n\
    \        postfix := myString[i:]\n        postfix += string(Reverse(prefix))\n\
    \        if postfix != prefix {\n            longestPalindrome = postfix\n   \
    \         longestPalindromeLen = len(postfix)\n        }\n    }\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpt3_y0irk_test.go:19:27: undefined: Reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075604
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find the longest postfix of supplied string that is\
    \ a palindrome.\n    longestPalindrome := \"\"\n    for i := len(myString) - 1;\
    \ i >= 0; i-- {\n        longestPalindrome += myString[i]\n    }\n    // Append\
    \ to the end of the string reverse of a string prefix that comes before the palindromic\
    \ suffix.\n    longestPalindrome += myString[len(longestPalindrome):]\n    //\
    \ Return palindrome string.\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptguuxbjf_test.go:16:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075600
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find longest postfix that is a palindrome\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        postfix := myString[i:]\n        if isPalindrome(postfix) {\n   \
    \         longestPalindrome = postfix\n            longestPalindromeLen = len(postfix)\n\
    \        }\n    }\n    // Append reverse of prefix that comes before longest palindromic\
    \ suffix\n    prefix := myString[:longestPalindromeLen]\n    return prefix + reverseString(longestPalindrome)\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_y1ly5xa_test.go:18:12: undefined: isPalindrome

    /tmp/tmp_y1ly5xa_test.go:25:21: undefined: reverseString

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075604
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Initialize a variable to hold the longest postfix of\
    \ myString that is a palindrome.\n    var longestPalindrome string\n    // Initialize\
    \ a variable to hold the reverse of the longest postfix of myString that is a\
    \ palindrome.\n    var longestPalindromeReverse string\n    // Initialize a variable\
    \ to hold the length of the longest postfix of myString that is a palindrome.\n\
    \    var longestPalindromeLength int\n    // Initialize a variable to hold the\
    \ length of the longest postfix of myString that is a palindrome.\n    var longestPalindromeReverseLength\
    \ int\n    // Initialize a variable to hold the length of the longest postfix\
    \ of myString that is a palindrome.\n    var longestPalindromeReverseLength2 int\n\
    \    // Initialize a variable to hold the length of the longest postfix of myString\
    \ that is a palindrome.\n    var longestPalindromeReverseLength3 int\n    // Initialize\
    \ a variable to hold the length of the longest postfix of myString that is a palindrome.\n\
    \    var longestPalindromeReverseLength4 int\n    // Initialize a variable to\
    \ hold the length of the longest postfix of myString that is a palindrome.\n \
    \   var longestPalindromeReverseLength5 int\n    // Initialize a variable to hold\
    \ the length of the longest postfix of myString that is a palindrome.\n    var\
    \ longestPalindromeReverseLength6 int\n    // Initialize a variable to hold the\
    \ length of the longest postfix of myString that is a palindrome.\n    var longestPalindromeReverseLength7\
    \ int\n    // Initialize a variable to hold the length of the longest postfix\
    \ of myString that is a palindrome.\n    var longestPalindromeReverseLength8 int\n\
    \    // Initialize a variable to hold the length of the longest postfix of myString\
    \ that is a palindrome.\n    var longestPalindromeReverseLength9 int\n    // Initialize\
    \ a variable to hold the length of the longest postfix of myString that is a palindrome.\n\
    \    var longestPalindromeReverseLength10 int\n    // Initialize a variable to\
    \ hold the length of the longest postfix of myString that is a palindrome.\n \
    \   var longestPalindromeReverseLength11 int\n    // Initialize a variable to\
    \ hold the length of the longest postfix of myString that is a palindrome.\n \
    \   var longestPalindromeReverseLength12 int\n    // Initialize a variable to\
    \ hold the length of the longest postfix of myString that is a palindrome.\n\n\
    func TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmcom1cha_test.go:45:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075604
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for i := 0; i < len(myString); i++ {\n        postfix := myString[i:]\n\
    \        postfix += string(myString[:i])\n        postfix += string(myString[i+1:])\n\
    \        postfix += string(myString[:len(myString)-i])\n        postfix += string(myString[len(myString)-i:])\n\
    \        postfix += string(myString[:len(myString)-i-1])\n        postfix += string(myString[len(myString)-i-1:])\n\
    \        postfix += string(myString[:len(myString)-i-2])\n        postfix += string(myString[len(myString)-i-2:])\n\
    \        postfix += string(myString[:len(myString)-i-3])\n        postfix += string(myString[len(myString)-i-3:])\n\
    \        postfix += string(myString[:len(myString)-i-4])\n        postfix += string(myString[len(myString)-i-4:])\n\
    \        postfix += string(myString[:len(myString)-i-5])\n        postfix += string(myString[len(myString)-i-5:])\n\
    \        postfix += string(myString[:len(myString)-i-6])\n        postfix += string(myString[len(myString)-i-6:])\n\
    \        postfix += string(myString[:len(myString)-i-7])\n        postfix += string(myString[len(myString)-i-7:])\n\
    \        postfix += string(myString[:len(myString)-i-8])\n        postfix += string(myString[len(myString)-i-8:])\n\
    \        postfix += string(myString[:len(myString)-i-9])\n        postfix += string(myString[len(myString)-i-9:])\n\
    \        postfix += string(myString[:len(myString)-i-10])\n        postfix +=\
    \ string(myString[len(myString)-i-10:])\n        postfix += string(myString[:len(myString)-i-11])\n\
    \        postfix += string(myString[len(myString)-i-11:])\n        postfix +=\
    \ string(myString[:len(myString)-i-12])\n        postfix += string(myString[len(myString)-i-12:])\n\
    \        postfix += string(myString[:len(myString)-i-13])\n        postfix +=\
    \ string(myString[len(myString)-i-13:])\n        postfix += string(myString[:len(myString)-i-14])\n\
    \        postfix += string(myString[len(myString)-i-14:])\n        postfix +=\
    \ string(myString[:len(myString)-i-15])\n        postfix += \nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpnm6mtpfx_test.go:51:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075601
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for i := len(myString) - 1; i >= 0; i-- {\n        prefix := myString[:i]\n\
    \        reverse := myString[i+1:]\n        if isPalindrome(prefix, reverse) {\n\
    \            longestPalindrome = prefix + reverse\n            longestPalindromeLen\
    \ = len(longestPalindrome)\n        }\n    }\n    return longestPalindrome\n}\n\
    \nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpef7tp06u_test.go:14:5: longestPalindromeLen declared but not used

    /tmp/tmpef7tp06u_test.go:18:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075604
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find the longest postfix of supplied string that is\
    \ a palindrome.\n    longestPalindrome := \"\"\n    longestPalindromeLen := 0\n\
    \    for i := 0; i < len(myString); i++ {\n        postfix := myString[i:]\n \
    \       if isPalindrome(postfix) {\n            longestPalindrome = myString[:i]\n\
    \            longestPalindromeLen = len(longestPalindrome)\n        }\n    }\n\
    \    // Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    prefix := myString[:longestPalindromeLen]\n\
    \    return prefix + longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpymxfdwxa_test.go:18:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075604
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find longest postfix of myString that is a palindrome\n\
    \    longestPalindrome := \"\"\n    longestPalindromeLen := 0\n    for i := 0;\
    \ i < len(myString); i++ {\n        postfix := myString[:i]\n        postfix +=\
    \ string(myString[len(myString)-i:][:len(myString)-i])\n        postfix += myString[len(myString)-i:][:len(myString)-i]\n\
    \        postfix += string(myString[len(myString)-i:][:len(myString)-i])\n   \
    \     postfix += myString[len(myString)-i:][:len(myString)-i]\n        postfix\
    \ += string(myString[len(myString)-i:][:len(myString)-i])\n        postfix +=\
    \ myString[len(myString)-i:][:len(myString)-i]\n        postfix += string(myString[len(myString)-i:][:len(myString)-i])\n\
    \        postfix += myString[len(myString)-i:][:len(myString)-i]\n        postfix\
    \ += string(myString[len(myString)-i:][:len(myString)-i])\n        postfix +=\
    \ myString[len(myString)-i:][:len(myString)-i]\n        postfix += string(myString[len(myString)-i:][:len(myString)-i])\n\
    \        postfix += myString[len(myString)-i:][:len(myString)-i]\n        postfix\
    \ += string(myString[len(myString)-i:][:len(myString)-i])\n        postfix +=\
    \ myString[len(myString)-i:][:len(myString)-i]\n        postfix += string(myString[len(myString)-i:][:len(myString)-i])\n\
    \        postfix += myString[len(myString)-i:][:len(myString)-i]\n        postfix\
    \ += string(myString[len(myString)-i:][:len(myString)-i])\n        postfix +=\
    \ myString[len(myString)-i:][:len(myString)-i]\n        postfix += string(myString[len(myString)-i:][:len(myString)-i])\n\
    \        postfix += myString[len(myString)-i:][:len(myString)-i]\n        postfix\
    \ += string(myString[len(myString)-i:][:len(myString)-i])\n        postfix +=\
    \ myString[len(myString)-i:][:len(myString)-i]\n        postfix += string(myString[len(myString)-i:][:len(myString)-i])\n\
    \        postfix += myString[len(myString)-i:][:len(myString)-i]\n        postfix\
    \ += string(myString[len(myString)-i:]\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpv9lp2c6__test.go:42:53: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find longest postfix that is a palindrome\n    longestPalindrome\
    \ := \"\"\n    for i := 0; i < len(myString); i++ {\n        postfix := myString[:i]\n\
    \        postfix += fmt.Sprintf(\"%c\", myString[len(myString)-i-1])\n       \
    \ if isPalindrome(postfix) {\n            longestPalindrome = postfix\n      \
    \  }\n    }\n    // Append reverse of prefix that comes before longest postfix\
    \ to end of string\n    result := myString + fmt.Sprintf(\"%c\", longestPalindrome[len(longestPalindrome)-1])\n\
    \    return result\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpao52yizg_test.go:18:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    var myStringLen int = len(myString)\n    var myStringPrefix\
    \ string\n    var myStringSuffix string\n\n    for i := 0; i < myStringLen; i++\
    \ {\n        if myString[i] != myString[len(myString)-i-1] {\n            myStringPrefix\
    \ = myString[:i]\n            myStringSuffix = myString[i:]\n            break\n\
    \        }\n    }\n\n    myStringSuffix = myStringSuffix + myString[len(myString)-myStringLen:]\n\
    \    myStringSuffix = myStringSuffix + myStringPrefix[len(myStringPrefix)-myStringLen:]\n\
    \n    return myStringPrefix + myStringSuffix\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\npanic: runtime error: slice bounds\
    \ out of range [-1:] [recovered]\n\tpanic: runtime error: slice bounds out of\
    \ range [-1:]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620, 0xc000014360})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.make_palindrome(...)\n\t/tmp/tmpeedfpp5a_test.go:26\n\
    command-line-arguments_test.TestMake_Palindrome(0x0?)\n\t/tmp/tmpeedfpp5a_test.go:39\
    \ +0x76f\ntesting.tRunner(0xc0001924e0, 0x528f60)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075606
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLength\
    \ := 0\n    longestPalindromePrefix := \"\"\n    longestPalindromeSuffix := \"\
    \"\n    longestPalindromePostfix := \"\"\n    longestPalindromePostfixLength :=\
    \ 0\n    longestPalindromePostfixPrefix := \"\"\n    longestPalindromePostfixSuffix\
    \ := \"\"\n\n    for i := 0; i < len(myString); i++ {\n        longestPalindrome\
    \ = longestPalindrome + myString[i]\n        longestPalindromeLength++\n    }\n\
    \n    for i := 0; i < len(myString); i++ {\n        longestPalindromePrefix =\
    \ longestPalindromePrefix + myString[i]\n        longestPalindromePrefixLength++\n\
    \    }\n\n    for i := 0; i < len(myString); i++ {\n        longestPalindromeSuffix\
    \ = longestPalindromeSuffix + myString[i]\n        longestPalindromeSuffixLength++\n\
    \    }\n\n    for i := 0; i < len(myString); i++ {\n        longestPalindromePostfix\
    \ = longestPalindromePostfix + myString[i]\n        longestPalindromePostfixLength++\n\
    \    }\n\n    for i := 0; i < len(myString); i++ {\n        longestPalindromePostfixPrefix\
    \ = longestPalindromePostfixPrefix + myString[i]\n        longestPalindromePostfixPrefixLength++\n\
    \    }\n\n    for i := 0; i < len(myString); i++ {\n        longestPalindromePostfixSuffix\
    \ = longestPalindromePostfixSuffix + myString[i]\n        longestPalindromePostfixSuffixLength++\n\
    \    }\n\n    if longestPalindromeLength > longestPalindromePostfixLength {\n\
    \        return longestPalindrome\n    }\n\n    if longestPalindromeLength < longestPalindromePostfixLength\
    \ {\n        return longestPalindromePostfix\n    }\n\n    if longestPalindromeLength\
    \ == longestPalindromePostfixLength {\n        if longestPalindromeLength < longestPalindromePostfixLength\
    \ {\n            return longestPalindromePostfix\n        }\n\n        if longestPalindromeLength\
    \ > longestPalindromePostfixLength {\n            return longestPalindrome\n \
    \       }\n    }\n\n    if longestPalindromeLength > longestPalindromePostfixLength\
    \ {\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp790uyvcm_test.go:72:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find longest postfix of myString that is a palindrome.\n\
    \    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n   \
    \     longestPalindrome += myString[i]\n    }\n    longestPalindrome = longestPalindrome[:len(longestPalindrome)-1]\n\
    \n    // Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    prefix := longestPalindrome\n    suffix\
    \ := myString[len(longestPalindrome):]\n    suffix := suffix[:len(suffix)-1]\n\
    \    suffix := suffix[:len(suffix)-1]\n    suffix := suffix[:len(suffix)-1]\n\
    \    suffix := suffix[:len(suffix)-1]\n    suffix := suffix[:len(suffix)-1]\n\
    \    suffix := suffix[:len(suffix)-1]\n    suffix := suffix[:len(suffix)-1]\n\
    \    suffix := suffix[:len(suffix)-1]\n    suffix := suffix[:len(suffix)-1]\n\
    \    suffix := suffix[:len(suffix)-1]\n    suffix := suffix[:len(suffix)-1]\n\
    \    suffix := suffix[:len(suffix)-1]\n    suffix := suffix[:len(suffix)-1]\n\
    \    suffix := suffix[:len(suffix)-1]\n    suffix := suffix[:len(suffix)-1]\n\
    \    suffix := suffix[:len(suffix)-1]\n    suffix := suffix[:len(suffix)-1]\n\
    \    suffix := suffix[:len(suffix)-1]\n    suffix := suffix[:len(suffix)-1]\n\
    \    suffix := suffix[:len(suffix)-1]\n    suffix := suffix[:len(suffix)-1]\n\
    \    suffix := suffix[:len(suffix)-1]\n    suffix := suffix[:len(suffix)-1]\n\
    \    suffix := suffix[:len(suffix)-1]\n    suffix := suffix[:len(suffix)-1]\n\
    \    suffix := suffix[:len(suffix)-1]\n    suffix := suffix[:len(suffix)-1]\n\
    \    suffix := suffix[:len(suffix)-1]\n    suffix := suffix[:len(suffix)-1]\n\
    \    suffix := suffix[:len(suffix)-1]\n    suffix := suffix[:len(suffix)-1]\n\
    \    suffix := suffix[:len(suffix)-1]\n    suffix := suffix[:len(suffix)-1]\n\
    \    suffix := suffix[:len(suffix)-1]\n    suffix := suffix[:len(suffix)-1]\n\
    \    suffix := suffix[:len(suffix)-1]\n    suffix := suffix[:len(suffix)-1]\n\
    \    suffix := suffix[:len(suffix)-1]\n    suffix := suffix[:len(suffix)-1]\n\
    \    suffix := suffix[:\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_117ka4p_test.go:63:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find longest postfix of myString that is a palindrome.\n\
    \    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n   \
    \     postfix := myString[i:]\n        postfix += myString[:i]\n        postfix\
    \ += myString[i:]\n        postfix += myString[:i]\n        postfix += myString[i:]\n\
    \        postfix += myString[:i]\n        postfix += myString[i:]\n        postfix\
    \ += myString[:i]\n        postfix += myString[i:]\n        postfix += myString[:i]\n\
    \        postfix += myString[i:]\n        postfix += myString[:i]\n        postfix\
    \ += myString[i:]\n        postfix += myString[:i]\n        postfix += myString[i:]\n\
    \        postfix += myString[:i]\n        postfix += myString[i:]\n        postfix\
    \ += myString[:i]\n        postfix += myString[i:]\n        postfix += myString[:i]\n\
    \        postfix += myString[i:]\n        postfix += myString[:i]\n        postfix\
    \ += myString[i:]\n        postfix += myString[:i]\n        postfix += myString[i:]\n\
    \        postfix += myString[:i]\n        postfix += myString[i:]\n        postfix\
    \ += myString[:i]\n        postfix += myString[i:]\n        postfix += myString[:i]\n\
    \        postfix += myString[i:]\n        postfix += myString[:i]\n        postfix\
    \ += myString[i:]\n        postfix += myString[:i]\n        postfix += myString[i:]\n\
    \        postfix += myString[:i]\n        postfix += myString[i:]\n        postfix\
    \ += myString[:i]\n        postfix += myString[i:]\n        postfix += myString[:i]\n\
    \        postfix += myString[i:]\n        postfix += myString[:i]\n        postfix\
    \ += myString[i:]\n        postfix += myString[:i]\n        postfix += myString[i:]\n\
    \        postfix += myString[:i]\n        postfix += myString[i:]\n        postfix\
    \ += myString[:i]\n        postfix += myString[i:]\n        postfix += myString[:i]\n\
    \        postfix += myString[i:]\n        postfix += myString[:i]\n        postfix\
    \ += myString[i\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp1l4sacgx_test.go:68:30: expected '']'', found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix\
    \ of supplied string that is a palindrome.\n    // - Append to the end of the\
    \ string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    longestPalindrome := \"\"\n    longestPalindromeLen := 0\n    for i := len(myString)\
    \ - 1; i >= 0; i-- {\n        postfix := myString[:i+1]\n        if isPalindrome(postfix)\
    \ {\n            longestPalindrome = postfix\n            longestPalindromeLen\
    \ = len(postfix)\n        }\n    }\n    // Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    prefix :=\
    \ myString[:longestPalindromeLen]\n    suffix := myString[longestPalindromeLen:]\n\
    \    return prefix + reverseString(suffix) + longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdi9qsbbu_test.go:21:12: undefined: isPalindrome

    /tmp/tmpdi9qsbbu_test.go:29:21: undefined: reverseString

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find the longest postfix of supplied string that is\
    \ a palindrome.\n    longestPalindrome := \"\"\n    for i := len(myString) - 1;\
    \ i >= 0; i-- {\n        postfix := myString[:i+1]\n        if isPalindrome(postfix)\
    \ {\n            longestPalindrome = postfix + \"-\" + longestPalindrome\n   \
    \     }\n    }\n    // Append to the end of the string reverse of a string prefix\
    \ that comes before the palindromic suffix.\n    return longestPalindrome + \"\
    -\" + myString\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate :=\
    \ make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3jtwnaxi_test.go:17:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for i := len(myString) - 1; i >= 0; i-- {\n        prefix := myString[:i]\n\
    \        suffix := myString[i:]\n        postfix := append(prefix, suffix...)\n\
    \        if isPalindrome(postfix) {\n            longestPalindrome = postfix\n\
    \            longestPalindromeLen = len(postfix)\n        }\n    }\n    return\
    \ longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpy3wm4yar_test.go:18:27: first argument to append must be a slice; have
    prefix (variable of type string)

    /tmp/tmpy3wm4yar_test.go:19:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075606
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for i := 0; i < len(myString); i++ {\n        postfix := myString[i:]\n\
    \        postfix += myString[:i]\n        postfix += myString[:len(myString)-i]\n\
    \        postfix += myString[len(myString)-1-i:]\n        postfix += myString[len(myString)-1-i:]\n\
    \        postfix += myString[:len(myString)-len(postfix)]\n        postfix +=\
    \ myString[len(myString)-1-i:]\n        postfix += myString[:len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-1-i:]\n        postfix += myString[:len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-1-i:]\n        postfix += myString[:len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-1-i:]\n        postfix += myString[:len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-1-i:]\n        postfix += myString[:len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-1-i:]\n        postfix += myString[:len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-1-i:]\n        postfix += myString[:len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-1-i:]\n        postfix += myString[:len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-1-i:]\n        postfix += myString[:len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-1-i:]\n        postfix += myString[:len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-1-i:]\n        postfix += myString[:len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-1-i:]\n        postfix += myString[:len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-1-i:]\n        postfix += myString[:len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-1-i:]\n        postfix += myString[:len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-1-i:]\n        postfix += \nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpgtr6s0tf_test.go:52:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for i := 0; i < len(myString); i++ {\n        postfix := myString[i:]\n\
    \        postfix += myString[:i]\n        postfix += myString[:len(myString)-i]\n\
    \        postfix += myString[len(myString)-1-i:]\n        postfix += myString[len(myString)-2-i:]\n\
    \        postfix += myString[len(myString)-3-i:]\n        postfix += myString[len(myString)-4-i:]\n\
    \        postfix += myString[len(myString)-5-i:]\n        postfix += myString[len(myString)-6-i:]\n\
    \        postfix += myString[len(myString)-7-i:]\n        postfix += myString[len(myString)-8-i:]\n\
    \        postfix += myString[len(myString)-9-i:]\n        postfix += myString[len(myString)-10-i:]\n\
    \        postfix += myString[len(myString)-11-i:]\n        postfix += myString[len(myString)-12-i:]\n\
    \        postfix += myString[len(myString)-13-i:]\n        postfix += myString[len(myString)-14-i:]\n\
    \        postfix += myString[len(myString)-15-i:]\n        postfix += myString[len(myString)-16-i:]\n\
    \        postfix += myString[len(myString)-17-i:]\n        postfix += myString[len(myString)-18-i:]\n\
    \        postfix += myString[len(myString)-19-i:]\n        postfix += myString[len(myString)-20-i:]\n\
    \        postfix += myString[len(myString)-21-i:]\n        postfix += myString[len(myString)-22-i:]\n\
    \        postfix += myString[len(myString)-23-i:]\n        postfix += myString[len(myString)-24-i:]\n\
    \        postfix += myString[len(myString)-25-i:]\n        postfix += myString[len(myString)-26-i:]\n\
    \        postfix += myString[len(myString)-27-i:]\n        postfix += myString[len(myString)-28-i:]\n\
    \        postfix += myString[len(myString)-29-i:]\n        postfix += myString[len(myString)-30-i:]\n\
    \        postfix += myString[len(myString)-31-i:]\n        postfix += myString[len(myString)-32-i:]\n\
    \        postfix += myString[len(myString)-33-i:]\n        postfix += myString\n\
    func TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp2l8gbj8k_test.go:53:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for _, letter := range myString {\n        longestPalindromeLen += len(letter)\n\
    \        if longestPalindromeLen > len(longestPalindrome) {\n            longestPalindrome\
    \ = letter\n            longestPalindromeLen = len(letter)\n        }\n    }\n\
    \    longestPalindrome += string(myString[len(myString)-longestPalindromeLen:])\n\
    \    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n\
    \  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxnat4rkz_test.go:16:37: invalid argument: letter (variable of type rune)
    for len

    /tmp/tmpxnat4rkz_test.go:18:33: cannot use letter (variable of type rune) as type
    string in assignment

    /tmp/tmpxnat4rkz_test.go:19:40: invalid argument: letter (variable of type rune)
    for len

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075606
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    longestPalindromePos := 0\n    for i := 0; i < len(myString); i++ {\n\
    \        char := myString[i]\n        if char == ' ' {\n            longestPalindrome\
    \ = myString[longestPalindromePos : i]\n            longestPalindromeLen = len(longestPalindrome)\n\
    \            longestPalindromePos = i\n        }\n    }\n    longestPalindrome\
    \ = myString[longestPalindromePos : longestPalindromePos + longestPalindromeLen]\n\
    \    longestPalindrome = longestPalindrome[0 : len(longestPalindrome)-1]\n   \
    \ longestPalindrome = longestPalindrome + make_palindrome(myString[longestPalindromePos\
    \ + longestPalindromeLen : len(myString)])\n    return longestPalindrome\n}\n\n\
    func TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\npanic: runtime error: slice bounds\
    \ out of range [:-1] [recovered]\n\tpanic: runtime error: slice bounds out of\
    \ range [:-1]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512620, 0xc000014360})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x512620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.make_palindrome({0x0?, 0x4b3114?})\n\t/tmp/tmp1onjp15r_test.go:25\
    \ +0xda\ncommand-line-arguments_test.TestMake_Palindrome(0x0?)\n\t/tmp/tmp1onjp15r_test.go:37\
    \ +0x45\ntesting.tRunner(0xc0001a0340, 0x527f60)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075606
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find the longest postfix of supplied string that is\
    \ a palindrome.\n    longestPalindrome := \"\"\n    longestPalindromeLen := 0\n\
    \    for i := len(myString) - 1; i >= 0; i-- {\n        postfix := myString[:i+1]\n\
    \        if isPalindrome(postfix) {\n            longestPalindrome = postfix\n\
    \            longestPalindromeLen = len(postfix)\n        }\n    }\n    // Append\
    \ to the end of the string reverse of a string prefix that comes before the palindromic\
    \ suffix.\n    result := myString[:longestPalindromeLen]\n    for i := 0; i <\
    \ longestPalindromeLen; i++ {\n        result = append(result, myString[len(myString)-1-i]...)\n\
    \    }\n    return result\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpoo21x346_test.go:14:5: longestPalindrome declared but not used

    /tmp/tmpoo21x346_test.go:18:12: undefined: isPalindrome

    /tmp/tmpoo21x346_test.go:26:25: first argument to append must be a slice; have
    result (variable of type string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075606
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for i := 0; i < len(myString); i++ {\n        prefix := myString[0:i]\n\
    \        suffix := myString[i+1:]\n        postfix := \"\"\n        postLen, err\
    \ := strconv.Atoi(suffix)\n        if err != nil {\n            fmt.Println(\"\
    Error converting string to int:\", err)\n        }\n        for j := 0; j < postLen;\
    \ j++ {\n            postfix += string(myString[i+j])\n        }\n        postLen,\
    \ err = strconv.Atoi(prefix)\n        if err != nil {\n            fmt.Println(\"\
    Error converting string to int:\", err)\n        }\n        if postLen > longestPalindromeLen\
    \ {\n            longestPalindrome = postfix\n            longestPalindromeLen\
    \ = postLen\n        }\n    }\n    return longestPalindrome + string(myString[len(longestPalindrome):])\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpw8j78zuu_test.go:19:25: undefined: strconv

    /tmp/tmpw8j78zuu_test.go:26:24: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075606
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find the longest postfix of supplied string that is\
    \ a palindrome.\n    longestPalindrome := \"\"\n    longestPalindromeLen := 0\n\
    \    for i := 0; i < len(myString); i++ {\n        postfix := myString[i:]\n \
    \       postfix += string(myString[:i])\n        postfix += string(myString[i+1:])\n\
    \        postfix += string(myString[:i+1])\n        postfix += string(myString[i-1:])\n\
    \        postfix += string(myString[i+2:])\n        postfix += string(myString[:i+2])\n\
    \        postfix += string(myString[i-2:])\n        postfix += string(myString[i+2:])\n\
    \        postfix += string(myString[:i-2]) + string(myString[i-1:])\n        postfix\
    \ += string(myString[i+1:])\n        postfix += string(myString[:i])\n       \
    \ postfix += string(myString[i:])\n        postfix += string(myString[:i])\n \
    \       postfix += string(myString[i:])\n        postfix += string(myString[:i])\n\
    \        postfix += string(myString[i:])\n        postfix += string(myString[:i])\n\
    \        postfix += string(myString[i:])\n        postfix += string(myString[:i])\n\
    \        postfix += string(myString[i:])\n        postfix += string(myString[:i])\n\
    \        postfix += string(myString[i:])\n        postfix += string(myString[:i])\n\
    \        postfix += string(myString[i:])\n        postfix += string(myString[:i])\n\
    \        postfix += string(myString[i:])\n        postfix += string(myString[:i])\n\
    \        postfix += string(myString[i:])\n        postfix += string(myString[:i])\n\
    \        postfix += string(myString[i:])\n        postfix += string(myString[:i])\n\
    \        postfix += string(myString[i:])\n        postfix += string(myString[:i])\n\
    \        postfix += string(myString[i:])\n        postfix += string(myString[:i])\n\
    \        postfix += string(myString[i:])\n        postfix += string(myString[:i])\n\
    \        postfix += string(myString[i:])\n        postfix += string(myString[:i])\n\
    \        postfix += string(myString[i:])\n        postfix += string(myString[:i])\n\
    \        postfix += string(myString[i:])\n        postfix += string(myString[:i])\n\
    \        postfix += string(myString[i:])\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyxe5r7_b_test.go:63:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find longest postfix of myString that is a palindrome.\n\
    \    // This will be the length of the palindrome plus 1.\n    longestPalindrome\
    \ := 0\n    for i := len(myString) - 1; i >= 0; i-- {\n        // If this character\
    \ is not a palindrome then skip it.\n        if !isPalindrome(myString[i]) {\n\
    \            continue\n        }\n        // If this character is a palindrome\
    \ then find the length of the palindrome.\n        // The palindrome is one character\
    \ longer than the original string.\n        longestPalindrome = i\n        break\n\
    \    }\n    // If no palindrome was found then return an empty string.\n    if\
    \ longestPalindrome == 0 {\n        return \"\"\n    }\n    // Append the reverse\
    \ of the string prefix that comes before the palindromic suffix.\n    // This\
    \ will be the length of the palindrome minus 1.\n    result := myString[:longestPalindrome]\n\
    \    for i := longestPalindrome - 1; i >= 0; i-- {\n        result = append(result,\
    \ myString[i])\n    }\n    return result\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1i45cs1__test.go:18:13: undefined: isPalindrome

    /tmp/tmp1i45cs1__test.go:34:25: first argument to append must be a slice; have
    result (variable of type string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075606
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for i := 0; i < len(myString); i++ {\n        prefix := myString[:i]\n\
    \        suffix := myString[i:]\n        if isPalindrome(prefix, suffix) {\n \
    \           longestPalindrome = prefix + suffix\n            longestPalindromeLen\
    \ = len(longestPalindrome)\n        }\n    }\n    return longestPalindrome\n}\n\
    \nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptbl62ine_test.go:14:5: longestPalindromeLen declared but not used

    /tmp/tmptbl62ine_test.go:18:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075606
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find the longest postfix of supplied string that is\
    \ a palindrome.\n    longestPalindrome := \"\"\n    longestPalindromeLen := 0\n\
    \    for i := 0; i < len(myString); i++ {\n        postfix := myString[i : len(myString)-i]\n\
    \        postfix := append(postfix, postfix[len(postfix)-1:]...)\n        postfix\
    \ := append(postfix, postfix[:len(postfix)-1]...)\n        if postfix != myString\
    \ {\n            longestPalindrome = postfix\n            longestPalindromeLen\
    \ = len(postfix)\n        }\n    }\n    // Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    prefix :=\
    \ myString[:len(myString)-longestPalindromeLen]\n    return append(prefix, append(longestPalindrome,\
    \ myString[len(myString)-longestPalindromeLen:]...)...)\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzp6n_yx2_test.go:18:17: no new variables on left side of :=

    /tmp/tmpzp6n_yx2_test.go:18:27: first argument to append must be a slice; have
    postfix (variable of type string)

    /tmp/tmpzp6n_yx2_test.go:19:17: no new variables on left side of :=

    /tmp/tmpzp6n_yx2_test.go:19:27: first argument to append must be a slice; have
    postfix (variable of type string)

    /tmp/tmpzp6n_yx2_test.go:27:19: first argument to append must be a slice; have
    prefix (variable of type string)

    /tmp/tmpzp6n_yx2_test.go:27:34: first argument to append must be a slice; have
    longestPalindrome (variable of type string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075606
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find longest postfix of myString that is a palindrome.\n\
    \    longestPalindrome := \"\"\n    longestPalindromeLen := 0\n    for i := 0;\
    \ i < len(myString); i++ {\n        postfix := myString[i:]\n        postfix +=\
    \ \"-\"\n        postfix += myString[:i]\n        postfix += \"-\"\n        postfix\
    \ += myString[i:]\n        postfix += \"-\"\n        postfix += myString[:i]\n\
    \        postfix += \"-\"\n        postfix += myString[i:]\n        postfix +=\
    \ \"-\"\n        postfix += myString[:i]\n        postfix += \"-\"\n        postfix\
    \ += myString[i:]\n        postfix += \"-\"\n        postfix += myString[:i]\n\
    \        postfix += \"-\"\n        postfix += myString[i:]\n        postfix +=\
    \ \"-\"\n        postfix += myString[:i]\n        postfix += \"-\"\n        postfix\
    \ += myString[i:]\n        postfix += \"-\"\n        postfix += myString[:i]\n\
    \        postfix += \"-\"\n        postfix += myString[i:]\n        postfix +=\
    \ \"-\"\n        postfix += myString[:i]\n        postfix += \"-\"\n        postfix\
    \ += myString[i:]\n        postfix += \"-\"\n        postfix += myString[:i]\n\
    \        postfix += \"-\"\n        postfix += myString[i:]\n        postfix +=\
    \ \"-\"\n        postfix += myString[:i]\n        postfix += \"-\"\n        postfix\
    \ += myString[i:]\n        postfix += \"-\"\n        postfix += myString[:i]\n\
    \        postfix += \"-\"\n        postfix += myString[i:]\n        postfix +=\
    \ \"-\"\n        postfix += myString[:i]\n        postfix += \"-\"\n        postfix\
    \ += myString[i:]\n        postfix += \"-\"\n        postfix += myString[:i]\n\
    \        postfix += \"-\"\n        postfix += myString[i:]\n        postfix +=\
    \ \"-\"\n        postfix += myString[:i]\n        postfix += \"-\"\n        postfix\
    \ += myString[i:]\n        postfix += \"-\"\n        postfix += myString[:i]\n\
    \        postfix += \"-\"\n        postfix += myString[i:]\n        postfix +=\
    \ \"-\"\n        postfix += myString[:i]\n        postfix += \"-\"\n        postfix\
    \ += myString[i:]\n        postfix += \"-\"\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9deqir50_test.go:80:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075606
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find longest postfix of myString that is a palindrome.\n\
    \    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n   \
    \     longestPalindrome += myString[i]\n    }\n    longestPalindrome += myString[len(myString)-len(longestPalindrome):]\n\
    \    longestPalindrome = longestPalindrome[0:len(longestPalindrome)-1]\n\n   \
    \ // Append reverse of string prefix that comes before the palindromic suffix.\n\
    \    prefix := \"\"\n    for i := 0; i < len(longestPalindrome); i++ {\n     \
    \   prefix += longestPalindrome[len(longestPalindrome)-1-i]\n    }\n    prefix\
    \ += longestPalindrome[0:len(longestPalindrome)-1]\n\n    return prefix + longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyfc17vvl_test.go:16:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmpyfc17vvl_test.go:24:9: invalid operation: prefix += longestPalindrome[len(longestPalindrome)
    - 1 - i] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075606
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    var longestPalindrome string\n    var longestPalindromeLen\
    \ int\n    var longestPalindromePrefix string\n    var longestPalindromeSuffix\
    \ string\n    var longestPalindromeSuffixLen int\n    var longestPalindromeSuffixPrefix\
    \ string\n    var longestPalindromeSuffixSuffix string\n    var longestPalindromeSuffixSuffixLen\
    \ int\n\n    for i := 0; i < len(myString); i++ {\n        longestPalindromeLen\
    \ := 0\n        longestPalindromePrefix := \"\"\n        longestPalindromeSuffix\
    \ := \"\"\n        longestPalindromeSuffixLen := 0\n        longestPalindromeSuffixPrefix\
    \ := \"\"\n        longestPalindromeSuffixSuffix := \"\"\n        longestPalindromeSuffixSuffixLen\
    \ := 0\n\n        for j := 0; j < len(myString); j++ {\n            if myString[i]\
    \ == myString[j] {\n                longestPalindromeLen += 1\n              \
    \  if longestPalindromeLen > longestPalindromeSuffixLen {\n                  \
    \  longestPalindromeSuffixLen = longestPalindromeLen\n                    longestPalindromeSuffixPrefix\
    \ = myString[:j]\n                    longestPalindromeSuffixSuffix = myString[j:]\n\
    \                }\n                if longestPalindromeLen > longestPalindromeSuffixSuffixLen\
    \ {\n                    longestPalindromeSuffixSuffixLen = longestPalindromeLen\n\
    \                    longestPalindromeSuffixSuffixPrefix = myString[:j]\n    \
    \                longestPalindromeSuffixSuffixSuffix = myString[j:]\n        \
    \        }\n            } else {\n                longestPalindromeLen -= 1\n\
    \                if longestPalindromeLen > longestPalindromeSuffixLen {\n    \
    \                longestPalindromeSuffixLen = longestPalindromeLen\n         \
    \           longestPalindromeSuffixPrefix = myString[:j]\n                   \
    \ longestPalindromeSuffixSuffix = myString[j:]\n                }\n          \
    \      if longestPalindromeLen > longestPalindromeSuffixSuffixLen {\n        \
    \            longestPalindromeSuffixSuffixLen = longestPalindromeLen\n       \
    \             longestPalindromeSuffixSuffixPrefix = myString[:j]\n           \
    \         longestPalindromeSuffixSuffixSuffix = myString[j:]\n               \
    \ }\n            }\n        }\n\n        if longestPalindromeLen > longestPalindromeSuffixLen\
    \ {\n            longestPalindrome = longestPalindromeSuffixSuffix\n        }\
    \ else {\n            \nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpgnci_25e_test.go:63:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075606
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find the longest postfix of supplied string that is\
    \ a palindrome.\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString);\
    \ i++ {\n        postfix := myString[i:]\n        if isPalindrome(postfix) {\n\
    \            longestPalindrome = myString[:i]\n            break\n        }\n\
    \    }\n    // Append to the end of the string reverse of a string prefix that\
    \ comes before the palindromic suffix.\n    longestPalindrome += myString[:len(myString)-len(longestPalindrome)]\n\
    \    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n\
    \  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_n88mz0r_test.go:17:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075606
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for i := 0; i < len(myString); i++ {\n        postfix := myString[i:]\n\
    \        prefix := myString[:i]\n        postfix = append(postfix, reverseString(prefix)...)\n\
    \        postfix = append(postfix, postfix...)\n        postfix = append(postfix,\
    \ postfix...)\n        postfix = append(postfix, postfix...)\n        postfix\
    \ = append(postfix, postfix...)\n        postfix = append(postfix, postfix...)\n\
    \        postfix = append(postfix, postfix...)\n        postfix = append(postfix,\
    \ postfix...)\n        postfix = append(postfix, postfix...)\n        postfix\
    \ = append(postfix, postfix...)\n        postfix = append(postfix, postfix...)\n\
    \        postfix = append(postfix, postfix...)\n        postfix = append(postfix,\
    \ postfix...)\n        postfix = append(postfix, postfix...)\n        postfix\
    \ = append(postfix, postfix...)\n        postfix = append(postfix, postfix...)\n\
    \        postfix = append(postfix, postfix...)\n        postfix = append(postfix,\
    \ postfix...)\n        postfix = append(postfix, postfix...)\n        postfix\
    \ = append(postfix, postfix...)\n        postfix = append(postfix, postfix...)\n\
    \        postfix = append(postfix, postfix...)\n        postfix = append(postfix,\
    \ postfix...)\n        postfix = append(postfix, postfix...)\n        postfix\
    \ = append(postfix, postfix...)\n        postfix = append(postfix, postfix...)\n\
    \        postfix = append(postfix, postfix...)\n        postfix = append(postfix,\
    \ postfix...)\n        postfix = append(postfix, postfix...)\n        postfix\
    \ = append(postfix, postfix...)\n        postfix = append(postfix, postfix...)\n\
    \        postfix = append(postfix, postfix...)\n        postfix = append(postfix,\
    \ postfix...)\n        postfix = append(postfix, postfix...)\n        postfix\
    \ = append(postfix, postfix...)\n        postfix = append(postfix, postfix...)\n\
    \        postfix = append(postfix, postfix...)\n        postfix = append(postfix,\
    \ postfix...)\n        postfix = append(postfix, postfix...)\n        postfix\
    \ = append(postfix, postfix...)\n        postfix = append(postfix, postfix...)\n\
    \        postfix = append(postfix, postfix...)\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7oey5xfo_test.go:61:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075606
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find the longest postfix of supplied string that is\
    \ a palindrome.\n    longestPalindrome := \"\"\n    for i := len(myString) - 1;\
    \ i >= 0; i-- {\n        longestPalindrome += myString[i]\n    }\n    // Append\
    \ to the end of the string reverse of a string prefix that comes before the palindromic\
    \ suffix.\n    longestPalindrome += myString[len(longestPalindrome):]\n    //\
    \ Return palindrome string.\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptguuxbjf_test.go:16:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075600
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLength\
    \ := 0\n    for i := 0; i < len(myString); i++ {\n        postfix := myString[i:]\n\
    \        prefix := myString[:i]\n        postfix += make_palindrome(postfix)\n\
    \        prefix += make_palindrome(prefix)\n        if postfix != prefix {\n \
    \           longestPalindrome = postfix\n            longestPalindromeLength =\
    \ i\n        }\n    }\n    if longestPalindromeLength > 0 {\n        return myString[:longestPalindromeLength]\n\
    \    }\n    return myString\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n \
    \ candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpuh83e1sv_test.go:13:5: longestPalindrome declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075606
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    longestPalindromeLen := len(myString)\n    for i := 0; i < longestPalindromeLen;\
    \ i++ {\n        postfix := myString[longestPalindromeLen-i:longestPalindromeLen]\n\
    \        prefix := myString[0:longestPalindromeLen-i]\n        reverse := append(prefix,\
    \ postfix)\n        if isPalindrome(reverse) {\n            longestPalindrome\
    \ = reverse\n            longestPalindromeLen = len(longestPalindrome)\n     \
    \   }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8d20xcvi_test.go:15:26: no new variables on left side of :=

    /tmp/tmp8d20xcvi_test.go:19:27: first argument to append must be a slice; have
    prefix (variable of type string)

    /tmp/tmp8d20xcvi_test.go:20:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075606
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for i := 0; i < len(myString); i++ {\n        longestPalindromeLen +=\
    \ len(myString) - i\n        longestPalindrome = myString[:longestPalindromeLen]\
    \ + myString[len(myString) - longestPalindromeLen:] + longestPalindrome\n    }\n\
    \    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n\
    \  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\npanic: runtime error: slice bounds\
    \ out of range [:5] with length 3 [recovered]\n\tpanic: runtime error: slice bounds\
    \ out of range [:5] with length 3\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.make_palindrome(...)\n\t/tmp/tmp0mw9na6l_test.go:17\n\
    command-line-arguments_test.TestMake_Palindrome(0x0?)\n\t/tmp/tmp0mw9na6l_test.go:31\
    \ +0x5ec\ntesting.tRunner(0xc0001924e0, 0x528f60)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075607
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for i := 0; i < len(myString); i++ {\n        postfix := myString[i:]\n\
    \        prefix := myString[:i]\n        postfix += reverseString(prefix)\n  \
    \      longestPalindrome = postfix\n        longestPalindromeLen = len(postfix)\n\
    \    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpy_s278ov_test.go:14:5: longestPalindromeLen declared but not used

    /tmp/tmpy_s278ov_test.go:18:20: undefined: reverseString

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075607
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find the longest postfix of supplied string that is\
    \ a palindrome.\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString);\
    \ i++ {\n        longestPalindrome += myString[i]\n    }\n    longestPalindrome\
    \ += myString[len(myString)-1:]\n\n    // Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    prefix :=\
    \ \"\"\n    for i := 0; i < len(longestPalindrome); i++ {\n        prefix += longestPalindrome[len(longestPalindrome)-1-i]\n\
    \    }\n\n    // Return palindrome + prefix.\n    return prefix + longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpek8le5as_test.go:16:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmpek8le5as_test.go:23:9: invalid operation: prefix += longestPalindrome[len(longestPalindrome)
    - 1 - i] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075607
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find longest postfix of myString that is a palindrome.\n\
    \    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n   \
    \     postfix := myString[:i]\n        if isPalindrome(postfix) {\n          \
    \  longestPalindrome = postfix\n            break\n        }\n    }\n    // Append\
    \ reverse of longest postfix to myString.\n    result := myString\n    for i :=\
    \ len(longestPalindrome) - 1; i >= 0; i-- {\n        result = result + longestPalindrome[i]\n\
    \    }\n    return result\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpatwkoglc_test.go:17:12: undefined: isPalindrome

    /tmp/tmpatwkoglc_test.go:25:18: invalid operation: result + longestPalindrome[i]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075607
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for _, char := range myString {\n        if char == ' ' {\n         \
    \   longestPalindrome = longestPalindrome[:longestPalindromeLen]\n           \
    \ longestPalindromeLen += 1 // space is 1 char long\n        } else {\n      \
    \      longestPalindromeLen += 1 // other chars are 1 char long\n        }\n \
    \   }\n    longestPalindrome += myString[:longestPalindromeLen]\n    longestPalindromeLen\
    \ += 1 // space is 1 char long\n    longestPalindrome = longestPalindrome[:longestPalindromeLen]\n\
    \    longestPalindromeLen += 1 // space is 1 char long\n    longestPalindrome\
    \ = longestPalindrome[:longestPalindromeLen]\n    longestPalindromeLen += 1 //\
    \ space is 1 char long\n    longestPalindrome = longestPalindrome[:longestPalindromeLen]\n\
    \    longestPalindromeLen += 1 // space is 1 char long\n    longestPalindrome\
    \ = longestPalindrome[:longestPalindromeLen]\n    longestPalindromeLen += 1 //\
    \ space is 1 char long\n    longestPalindrome = longestPalindrome[:longestPalindromeLen]\n\
    \    longestPalindromeLen += 1 // space is 1 char long\n    longestPalindrome\
    \ = longestPalindrome[:longestPalindromeLen]\n    longestPalindromeLen += 1 //\
    \ space is 1 char long\n    longestPalindrome = longestPalindrome[:longestPalindromeLen]\n\
    \    longestPalindromeLen += 1 // space is 1 char long\n    longestPalindrome\
    \ = longestPalindrome[:longestPalindromeLen]\n    longestPalindromeLen += 1 //\
    \ space is 1 char long\n    longestPalindrome = longestPalindrome[:longestPalindromeLen]\n\
    \    longestPalindromeLen += 1 // space is 1 char long\n    longestPalindrome\
    \ = longestPalindrome[:longestPalindromeLen]\n    longestPalindromeLen += 1 //\
    \ space is 1 char long\n    longestPalindrome = longestPalindrome[:\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp1zmnjxz__test.go:46:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075606
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for _, char := range myString {\n        longestPalindromeLen += 1 //\
    \ count the character\n        longestPalindrome += string([]rune(char)[longestPalindromeLen:]\
    \ + string([]rune(char)[:longestPalindromeLen])\n    }\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0eiw25c1_test.go:17:118: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075599
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    longestPalindromeLen += len(myString) / 2\n    for i := 0; i < len(myString);\
    \ i++ {\n        prefix := myString[:i]\n        suffix := myString[i:]\n    \
    \    postfix := append(prefix, suffix...)\n        postfix := append(postfix,\
    \ suffix...)\n        postfix := append(postfix, suffix...)\n        postfix :=\
    \ append(postfix, suffix...)\n        postfix := append(postfix, suffix...)\n\
    \        postfix := append(postfix, suffix...)\n        postfix := append(postfix,\
    \ suffix...)\n        postfix := append(postfix, suffix...)\n        postfix :=\
    \ append(postfix, suffix...)\n        postfix := append(postfix, suffix...)\n\
    \        postfix := append(postfix, suffix...)\n        postfix := append(postfix,\
    \ suffix...)\n        postfix := append(postfix, suffix...)\n        postfix :=\
    \ append(postfix, suffix...)\n        postfix := append(postfix, suffix...)\n\
    \        postfix := append(postfix, suffix...)\n        postfix := append(postfix,\
    \ suffix...)\n        postfix := append(postfix, suffix...)\n        postfix :=\
    \ append(postfix, suffix...)\n        postfix := append(postfix, suffix...)\n\
    \        postfix := append(postfix, suffix...)\n        postfix := append(postfix,\
    \ suffix...)\n        postfix := append(postfix, suffix...)\n        postfix :=\
    \ append(postfix, suffix...)\n        postfix := append(postfix, suffix...)\n\
    \        postfix := append(postfix, suffix...)\n        postfix := append(postfix,\
    \ suffix...)\n        postfix := append(postfix, suffix...)\n        postfix :=\
    \ append(postfix, suffix...)\n        postfix := append(postfix, suffix...)\n\
    \        postfix := append(postfix, suffix...)\n        postfix := append(postfix,\
    \ suffix...)\n        postfix := append(postfix, suffix...)\n        postfix :=\
    \ append(postfix, suffix...)\n        postfix := append(postfix, suffix...)\n\
    \        postfix := append(postfix, suffix...)\n        postfix := append(postfix,\
    \ suffix...)\n        postfix := append(postfix, suffix...)\n        postfix :=\
    \ append(postfix, suffix...)\n        postfix := append(postfix, suffix...)\n\
    \        postfix := append(postfix, suffix...)\n        postfix \nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpu3kmce2e_test.go:61:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075607
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for i := 0; i < len(myString); i++ {\n        postfix := myString[i:]\n\
    \        postfix += myString[:i]\n        postfix += myString[:i+1]\n        postfix\
    \ += myString[:i+2]\n        postfix += myString[:i+3]\n        postfix += myString[:i+4]\n\
    \        postfix += myString[:i+5]\n        postfix += myString[:i+6]\n      \
    \  postfix += myString[:i+7]\n        postfix += myString[:i+8]\n        postfix\
    \ += myString[:i+9]\n        postfix += myString[:i+10]\n        postfix += myString[:i+11]\n\
    \        postfix += myString[:i+12]\n        postfix += myString[:i+13]\n    \
    \    postfix += myString[:i+14]\n        postfix += myString[:i+15]\n        postfix\
    \ += myString[:i+16]\n        postfix += myString[:i+17]\n        postfix += myString[:i+18]\n\
    \        postfix += myString[:i+19]\n        postfix += myString[:i+20]\n    \
    \    postfix += myString[:i+21]\n        postfix += myString[:i+22]\n        postfix\
    \ += myString[:i+23]\n        postfix += myString[:i+24]\n        postfix += myString[:i+25]\n\
    \        postfix += myString[:i+26]\n        postfix += myString[:i+27]\n    \
    \    postfix += myString[:i+28]\n        postfix += myString[:i+29]\n        postfix\
    \ += myString[:i+30]\n        postfix += myString[:i+31]\n        postfix += myString[:i+32]\n\
    \        postfix += myString[:i+33]\n        postfix += myString[:i+34]\n    \
    \    postfix += myString[:i+35]\n        postfix += myString[:i+36]\n        postfix\
    \ += myString[:i+37]\n        postfix += myString[:i+38]\n        postfix += myString[:i+39]\n\
    \        postfix += myString[:i+40]\n        postfix += myString[:i+41]\n    \
    \    postfix += myString[:i+42]\n        postfix += myString[:i+43]\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmplw82w76m_test.go:62:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075600
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find longest postfix of myString that is a palindrome.\n\
    \    // For example \"abba\" -> \"abba\"\n    // For \"abba\" -> \"abb\" -> \"\
    ab\" -> \"a\"\n    // For \"abba\" -> \"abb\" -> \"ab\" -> \"a\" -> \"b\"\n  \
    \  // For \"abba\" -> \"abb\" -> \"ab\" -> \"a\" -> \"b\" -> \"a\"\n    // For\
    \ \"abba\" -> \"abb\" -> \"ab\" -> \"a\" -> \"b\" -> \"a\" -> \"b\"\n    // For\
    \ \"abba\" -> \"abb\" -> \"ab\" -> \"a\" -> \"b\" -> \"a\" -> \"b\" -> \"a\"\n\
    \    // For \"abba\" -> \"abb\" -> \"ab\" -> \"a\" -> \"b\" -> \"a\" -> \"b\"\
    \ -> \"a\" -> \"b\"\n    // For \"abba\" -> \"abb\" -> \"ab\" -> \"a\" -> \"b\"\
    \ -> \"a\" -> \"b\" -> \"a\" -> \"b\" -> \"a\"\n    // For \"abba\" -> \"abb\"\
    \ -> \"ab\" -> \"a\" -> \"b\" -> \"a\" -> \"b\" -> \"a\" -> \"b\" -> \"a\" ->\
    \ \"b\"\n    // For \"abba\" -> \"abb\" -> \"ab\" -> \"a\" -> \"b\" -> \"a\" ->\
    \ \"b\" -> \"a\" -> \"b\" -> \"a\" -> \"b\" -> \"a\"\n    // For \"abba\" -> \"\
    abb\" -> \"ab\" -> \"a\" -> \"b\" -> \"a\" -> \"b\" -> \"a\" -> \"b\" -> \"a\"\
    \ -> \"b\" -> \"a\" -> \"b\"\n    // For \"abba\" -> \"abb\" -> \"ab\" -> \"a\"\
    \ -> \"b\" -> \"a\" -> \"b\" -> \"a\" -> \"b\" -> \"a\" -> \"b\" -> \"a\" -> \"\
    b\"\n    // For \"abba\" -> \"abb\" -> \"ab\" -> \"a\" -> \"b\" -> \"a\" -> \"\
    b\" -> \"a\" -> \"b\" -> \"a\" -> \"b\" -> \"a\" -> \"b\" -> \"a\"\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8686srq4_test.go:27:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075607
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for i := 0; i < len(myString); i++ {\n        postfix := myString[i:]\n\
    \        prefix := myString[:i]\n        postfix = append(postfix, reverse(prefix))\n\
    \        postfix = append(postfix, postfix...)\n        postfix = append(postfix,\
    \ reverse(postfix)...)\n        postfix = append(postfix, postfix...)\n      \
    \  postfix = append(postfix, reverse(postfix)...)\n        postfix = append(postfix,\
    \ postfix...)\n        postfix = append(postfix, reverse(postfix)...)\n      \
    \  postfix = append(postfix, postfix...)\n        postfix = append(postfix, reverse(postfix)...)\n\
    \        postfix = append(postfix, postfix...)\n        postfix = append(postfix,\
    \ reverse(postfix)...)\n        postfix = append(postfix, postfix...)\n      \
    \  postfix = append(postfix, reverse(postfix)...)\n        postfix = append(postfix,\
    \ postfix...)\n        postfix = append(postfix, reverse(postfix)...)\n      \
    \  postfix = append(postfix, postfix...)\n        postfix = append(postfix, reverse(postfix)...)\n\
    \        postfix = append(postfix, postfix...)\n        postfix = append(postfix,\
    \ reverse(postfix)...)\n        postfix = append(postfix, postfix...)\n      \
    \  postfix = append(postfix, reverse(postfix)...)\n        postfix = append(postfix,\
    \ postfix...)\n        postfix = append(postfix, reverse(postfix)...)\n      \
    \  postfix = append(postfix, postfix...)\n        postfix = append(postfix, reverse(postfix)...)\n\
    \        postfix = append(postfix, postfix...)\n        postfix = append(postfix,\
    \ reverse(postfix)...)\n        postfix = append(postfix, postfix...)\n      \
    \  postfix = append(postfix, reverse(postfix)...)\n        postfix = append(postfix,\
    \ postfix...)\n        postfix = append(postfix, reverse(postfix)...)\n      \
    \  postfix = append(postfix, postfix...)\n        postfix = append(postfix, reverse(postfix)...)\n\
    \        postfix = append(postfix, postfix...)\n        postfix = append(postfix,\
    \ reverse(postfix)...)\n        postfix = append(postfix, postfix...)\n      \
    \  postfix = append(postfix, reverse(postfix)...)\n        postfix = append(postfix,\
    \ postfix...)\n        postfix = append(postfix, reverse(\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_oa7y8km_test.go:57:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075607
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLength\
    \ := 0\n    for _, char := range myString {\n        postfix := \"\"\n       \
    \ for i := 0; i < longestPalindromeLength; i++ {\n            postfix += char\n\
    \        }\n        postfix += char\n        postfix += char\n        postfix\
    \ += char\n        postfix += char\n        postfix += char\n        postfix +=\
    \ char\n        postfix += char\n        postfix += char\n        postfix += char\n\
    \        postfix += char\n        postfix += char\n        postfix += char\n \
    \       postfix += char\n        postfix += char\n        postfix += char\n  \
    \      postfix += char\n        postfix += char\n        postfix += char\n   \
    \     postfix += char\n        postfix += char\n        postfix += char\n    \
    \    postfix += char\n        postfix += char\n        postfix += char\n     \
    \   postfix += char\n        postfix += char\n        postfix += char\n      \
    \  postfix += char\n        postfix += char\n        postfix += char\n       \
    \ postfix += char\n        postfix += char\n        postfix += char\n        postfix\
    \ += char\n        postfix += char\n        postfix += char\n        postfix +=\
    \ char\n        postfix += char\n        postfix += char\n        postfix += char\n\
    \        postfix += char\n        postfix += char\n        postfix += char\n \
    \       postfix += char\n        postfix += char\n        postfix += char\n  \
    \      postfix += char\n        postfix += char\n        postfix += char\n   \
    \     postfix += char\n        postfix += char\n        postfix += char\n    \
    \    postfix += char\n        postfix += char\n        postfix += char\n     \
    \   postfix += char\n        postfix += char\n        postfix += char\n      \
    \  postfix += char\n        postfix += char\n        postfix += char\n       \
    \ postfix += char\n        postfix += char\n        postfix += char\n        postfix\
    \ += char\n        postfix += char\n        postfix += char\n        postfix +=\
    \ char\n        postfix += char\n        postfix += char\n        postfix += char\n\
    \        postfix += char\n        postfix += char\n        postfix += char\n \
    \       postfix += char\n        postfix += \nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8j06lx9y_test.go:96:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075607
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find the longest postfix of supplied string that is\
    \ a palindrome.\n    longestPalindrome := \"\"\n    for i := len(myString) - 1;\
    \ i >= 0; i-- {\n        postfix := myString[:i+1]\n        if isPalindrome(postfix)\
    \ {\n            longestPalindrome = postfix + longestPalindrome\n        }\n\
    \    }\n    // Append to the end of the string reverse of a string prefix that\
    \ comes before the palindromic suffix.\n    return longestPalindrome + myString[len(longestPalindrome):]\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpg5uevt6g_test.go:17:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075608
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for i := 0; i < len(myString); i++ {\n        prefix := myString[:i]\n\
    \        postfix := myString[i:]\n        if isPalindrome(prefix, postfix) {\n\
    \            longestPalindrome = prefix + reverseString(postfix)\n           \
    \ longestPalindromeLen = len(longestPalindrome)\n        }\n    }\n    return\
    \ longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpz6k2s6ax_test.go:14:5: longestPalindromeLen declared but not used

    /tmp/tmpz6k2s6ax_test.go:18:12: undefined: isPalindrome

    /tmp/tmpz6k2s6ax_test.go:19:42: undefined: reverseString

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075608
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find the longest postfix of supplied string that is\
    \ a palindrome.\n    longestPalindrome := \"\"\n    longestPalindromeLen := 0\n\
    \    for i := 0; i < len(myString); i++ {\n        postfix := myString[:i]\n \
    \       postfix += fmt.Sprintf(\"%c\", myString[len(myString)-i-1])\n        postfix\
    \ += myString[i:]\n        if postfix != make_palindrome(postfix) {\n        \
    \    continue\n        }\n        longestPalindrome = postfix\n        longestPalindromeLen\
    \ = len(postfix)\n        break\n    }\n    if longestPalindromeLen == 0 {\n \
    \       return \"\"\n    }\n    // Append to the end of the string reverse of\
    \ a string prefix that comes before the palindromic suffix.\n    suffix := myString[len(myString)-longestPalindromeLen:]\n\
    \    suffix += fmt.Sprintf(\"%c\", myString[len(myString)-longestPalindromeLen-1])\n\
    \    suffix += myString[:len(myString)-longestPalindromeLen]\n    return suffix\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8368zeyb_test.go:14:5: longestPalindrome declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075608
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find the longest postfix that is a palindrome\n   \
    \ longestPalindrome := \"\"\n    for i := len(myString) - 1; i >= 0; i-- {\n \
    \       postfix := myString[:i+1]\n        if isPalindrome(postfix) {\n      \
    \      longestPalindrome = postfix\n            break\n        }\n    }\n\n  \
    \  // Append the reverse of the longest postfix to the end of the string\n   \
    \ result := myString\n    for i := len(longestPalindrome) - 1; i >= 0; i-- {\n\
    \        result = result + longestPalindrome[i]\n    }\n\n    return result\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpv3yjtf3r_test.go:17:12: undefined: isPalindrome

    /tmp/tmpv3yjtf3r_test.go:26:18: invalid operation: result + longestPalindrome[i]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075608
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for _, char := range myString {\n        postfix := \"\"\n        postfix\
    \ += char\n        postfix += string([]rune(myString[len(myString)-len(postfix):]))\n\
    \        postfix += string([]rune(myString[:len(myString)-len(postfix)]))\n  \
    \      postfix += string([]rune(myString[len(myString)-len(postfix):]))\n    \
    \    postfix += string([]rune(myString[:len(myString)-len(postfix)]))\n      \
    \  postfix += string([]rune(myString[len(myString)-len(postfix):]))\n        postfix\
    \ += string([]rune(myString[:len(myString)-len(postfix)]))\n        postfix +=\
    \ string([]rune(myString[len(myString)-len(postfix):]))\n        postfix += string([]rune(myString[:len(myString)-len(postfix)]))\n\
    \        postfix += string([]rune(myString[len(myString)-len(postfix):]))\n  \
    \      postfix += string([]rune(myString[:len(myString)-len(postfix)]))\n    \
    \    postfix += string([]rune(myString[len(myString)-len(postfix):]))\n      \
    \  postfix += string([]rune(myString[:len(myString)-len(postfix)]))\n        postfix\
    \ += string([]rune(myString[len(myString)-len(postfix):]))\n        postfix +=\
    \ string([]rune(myString[:len(myString)-len(postfix)]))\n        postfix += string([]rune(myString[len(myString)-len(postfix):]))\n\
    \        postfix += string([]rune(myString[:len(myString)-len(postfix)]))\n  \
    \      postfix += string([]rune(myString[len(myString)-len(postfix):]))\n    \
    \    postfix += string([]rune(myString[:len(myString)-len(postfix)]))\n      \
    \  postfix += string([]rune(myString[len(myString)-len(postfix):]))\n        postfix\
    \ += string([]rune(myString[:len(myString)-len(postfix)]))\n        postfix +=\
    \ string([]rune(myString[len(myString)-len(postfix):]))\n        postfix += string([]rune(myString[:len(myString)-len(postfix)]))\n\
    \        postfix += string([]rune(myString[len(myString)-len(postfix):]))\n  \
    \      postfix += string([]rune(myString[:len(myString)-len(postfix)]))\n    \
    \    postfix += \nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfrnz3e03_test.go:43:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075607
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for i := 0; i < len(myString); i++ {\n        postfix := myString[i:]\n\
    \        postfix += string(myString[:i])\n        postfix += string(myString[i:len(myString)-1])\n\
    \        postfix += string(myString[len(myString)-1:])\n        postfix += string(myString[:len(myString)-1])\n\
    \        postfix += string(myString[len(myString)-1:])\n        postfix += string(myString[:len(myString)-1])\n\
    \        postfix += string(myString[len(myString)-1:])\n        postfix += string(myString[:len(myString)-1])\n\
    \        postfix += string(myString[len(myString)-1:])\n        postfix += string(myString[:len(myString)-1])\n\
    \        postfix += string(myString[len(myString)-1:])\n        postfix += string(myString[:len(myString)-1])\n\
    \        postfix += string(myString[len(myString)-1:])\n        postfix += string(myString[:len(myString)-1])\n\
    \        postfix += string(myString[len(myString)-1:])\n        postfix += string(myString[:len(myString)-1])\n\
    \        postfix += string(myString[len(myString)-1:])\n        postfix += string(myString[:len(myString)-1])\n\
    \        postfix += string(myString[len(myString)-1:])\n        postfix += string(myString[:len(myString)-1])\n\
    \        postfix += string(myString[len(myString)-1:])\n        postfix += string(myString[:len(myString)-1])\n\
    \        postfix += string(myString[len(myString)-1:])\n        postfix += string(myString[:len(myString)-1])\n\
    \        postfix += string(myString[len(myString)-1:])\n        postfix += string(myString[:len(myString)-1])\n\
    \        postfix += string(myString[len(myString)-1:])\n        postfix += string(myString[:len(myString)-1])\n\
    \        postfix += string(myString[len(myString)-1:])\n        postfix += string(myString[:len(myString)-1])\n\
    \        postfix += string(myString[len(myString)-1:])\n        postfix += string(myString[:len(myString)-1])\n\
    \        postfix += string(myString[len(myString)-1:])\n        postfix += string(myString[:len(myString)-1])\n\
    \        postfix += string(myString[len(myString)-1:])\n        postfix += string(myString[:len(myString)-1])\n\
    \        postfix += string(myString\nfunc TestMake_Palindrome(t *testing.T) {\n\
    \  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3xqicko3_test.go:53:35: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075607
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    longestPalindromeLen := len(myString)\n    for i := 0; i < longestPalindromeLen;\
    \ i++ {\n        prefix := myString[0:i]\n        suffix := myString[i+1:]\n \
    \       postfix := reversePostfix(prefix)\n        if postfix != suffix {\n  \
    \          longestPalindrome = prefix + postfix\n            longestPalindromeLen\
    \ = len(longestPalindrome)\n        }\n    }\n    return longestPalindrome\n}\n\
    \nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpw9qft6ni_test.go:15:26: no new variables on left side of :=

    /tmp/tmpw9qft6ni_test.go:19:20: undefined: reversePostfix

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075608
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for i := 0; i < len(myString); i++ {\n        postfix := myString[i:]\n\
    \        reversedPostfix := myString[:i]\n        if isPalindrome(postfix) {\n\
    \            longestPalindrome = reversedPostfix + longestPalindrome\n       \
    \     longestPalindromeLen = len(longestPalindrome)\n        }\n    }\n    return\
    \ longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbgprklup_test.go:14:5: longestPalindromeLen declared but not used

    /tmp/tmpbgprklup_test.go:18:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075608
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for i := 0; i < len(myString); i++ {\n        postfix := myString[i:]\n\
    \        postfix += myString[:i]\n        postfix += myString[:len(myString)-i]\n\
    \        postfix += myString[len(myString)-1-i:]\n        postfix += myString[len(myString)-2-i:]\n\
    \        postfix += myString[len(myString)-3-i:]\n        postfix += myString[len(myString)-4-i:]\n\
    \        postfix += myString[len(myString)-5-i:]\n        postfix += myString[len(myString)-6-i:]\n\
    \        postfix += myString[len(myString)-7-i:]\n        postfix += myString[len(myString)-8-i:]\n\
    \        postfix += myString[len(myString)-9-i:]\n        postfix += myString[len(myString)-10-i:]\n\
    \        postfix += myString[len(myString)-11-i:]\n        postfix += myString[len(myString)-12-i:]\n\
    \        postfix += myString[len(myString)-13-i:]\n        postfix += myString[len(myString)-14-i:]\n\
    \        postfix += myString[len(myString)-15-i:]\n        postfix += myString[len(myString)-16-i:]\n\
    \        postfix += myString[len(myString)-17-i:]\n        postfix += myString[len(myString)-18-i:]\n\
    \        postfix += myString[len(myString)-19-i:]\n        postfix += myString[len(myString)-20-i:]\n\
    \        postfix += myString[len(myString)-21-i:]\n        postfix += myString[len(myString)-22-i:]\n\
    \        postfix += myString[len(myString)-23-i:]\n        postfix += myString[len(myString)-24-i:]\n\
    \        postfix += myString[len(myString)-25-i:]\n        postfix += myString[len(myString)-26-i:]\n\
    \        postfix += myString[len(myString)-27-i:]\n        postfix += myString[len(myString)-28-i:]\n\
    \        postfix += myString[len(myString)-29-i:]\n        postfix += myString[len(myString)-30-i:]\n\
    \        postfix += myString[len(myString)-31-i:]\n        postfix += myString[len(myString)-32-i:]\n\
    \        postfix += myString[len(myString)-33-i:]\n        postfix += myString\n\
    func TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp2l8gbj8k_test.go:53:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for i := 0; i < len(myString); i++ {\n        postfix := myString[i:]\n\
    \        postfix += myString[:i]\n        postfix += myString[:len(myString)-i]\n\
    \        postfix += myString[len(myString)-1-i:]\n        postfix += myString[len(myString)-2-i:]\n\
    \        postfix += myString[len(myString)-3-i:]\n        postfix += myString[len(myString)-4-i:]\n\
    \        postfix += myString[len(myString)-5-i:]\n        postfix += myString[len(myString)-6-i:]\n\
    \        postfix += myString[len(myString)-7-i:]\n        postfix += myString[len(myString)-8-i:]\n\
    \        postfix += myString[len(myString)-9-i:]\n        postfix += myString[len(myString)-10-i:]\n\
    \        postfix += myString[len(myString)-11-i:]\n        postfix += myString[len(myString)-12-i:]\n\
    \        postfix += myString[len(myString)-13-i:]\n        postfix += myString[len(myString)-14-i:]\n\
    \        postfix += myString[len(myString)-15-i:]\n        postfix += myString[len(myString)-16-i:]\n\
    \        postfix += myString[len(myString)-17-i:]\n        postfix += myString[len(myString)-18-i:]\n\
    \        postfix += myString[len(myString)-19-i:]\n        postfix += myString[len(myString)-20-i:]\n\
    \        postfix += myString[len(myString)-21-i:]\n        postfix += myString[len(myString)-22-i:]\n\
    \        postfix += myString[len(myString)-23-i:]\n        postfix += myString[len(myString)-24-i:]\n\
    \        postfix += myString[len(myString)-25-i:]\n        postfix += myString[len(myString)-26-i:]\n\
    \        postfix += myString[len(myString)-27-i:]\n        postfix += myString[len(myString)-28-i:]\n\
    \        postfix += myString[len(myString)-29-i:]\n        postfix += myString[len(myString)-30-i:]\n\
    \        postfix += myString[len(myString)-31-i:]\n        postfix += myString[len(myString)-32-i:]\n\
    \        postfix += myString[len(myString)-33-i:]\n        postfix += myString\n\
    func TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp2l8gbj8k_test.go:53:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075605
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find longest postfix of myString that is a palindrome.\n\
    \    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n   \
    \     postfix := myString[i:]\n        postfix += myString[:i]\n        if isPalindrome(postfix)\
    \ {\n            longestPalindrome = postfix\n        }\n    }\n\n    // Append\
    \ reverse of longestPalindrome to myString.\n    prefix := myString[:len(longestPalindrome)]\n\
    \    prefix += longestPalindrome\n    return prefix + longestPalindrome\n}\n\n\
    func TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphgalt6ai_test.go:18:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075608
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    longestPalindromeLen := len(myString)\n    for i := 0; i < longestPalindromeLen;\
    \ i++ {\n        longestPalindrome = myString[:longestPalindromeLen-i] + myString[longestPalindromeLen-i:]\
    \ + longestPalindrome\n        if myString[longestPalindromeLen-i] == myString[longestPalindromeLen-i-1]\
    \ {\n            longestPalindromeLen -= 1\n        }\n    }\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph3hledvm_test.go:15:26: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075608
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for i := 0; i < len(myString); i++ {\n        postfix := myString[i:]\n\
    \        prefix := myString[:i]\n        postfix += reverse(prefix)\n        longestPalindrome\
    \ = postfix\n        longestPalindromeLen = len(postfix)\n    }\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2wjb7cs__test.go:14:5: longestPalindromeLen declared but not used

    /tmp/tmp2wjb7cs__test.go:18:20: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075608
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for _, char := range myString {\n        longestPalindromeLen += len(char)\n\
    \        if longestPalindromeLen > len(longestPalindrome) {\n            longestPalindrome\
    \ = char\n            longestPalindromeLen = len(char)\n        }\n    }\n   \
    \ longestPalindromeLen -= len(longestPalindrome)\n    longestPalindrome = longestPalindrome\
    \ + string(myString[len(myString)-longestPalindromeLen:])\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_49hawjf_test.go:16:37: invalid argument: char (variable of type rune)
    for len

    /tmp/tmp_49hawjf_test.go:18:33: cannot use char (variable of type rune) as type
    string in assignment

    /tmp/tmp_49hawjf_test.go:19:40: invalid argument: char (variable of type rune)
    for len

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075608
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    var myStringLen int = len(myString)\n    var myStringPrefix\
    \ string\n    var myStringSuffix string\n    var myStringReversedPrefix string\n\
    \    var myStringReversedSuffix string\n    var myStringReversedSuffixLen int\n\
    \    var myStringReversedSuffixSuffixLen int\n    var myStringReversedSuffixSuffixSuffixLen\
    \ int\n    var myStringReversedSuffixSuffixSuffixSuffixLen int\n    var myStringReversedSuffixSuffixSuffixSuffixSuffixLen\
    \ int\n    var myStringReversedSuffixSuffixSuffixSuffixSuffixSuffixLen int\n \
    \   var myStringReversedSuffixSuffixSuffixSuffixSuffixSuffixSuffixLen int\n  \
    \  var myStringReversedSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLen int\n\
    \    var myStringReversedSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLen\
    \ int\n    var myStringReversedSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLen\
    \ int\n    var myStringReversedSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLen\
    \ int\n    var myStringReversedSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLen\
    \ int\n    var myStringReversedSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLen\
    \ int\n    var myStringReversedSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLen\
    \ int\n    var myStringReversedSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLen\
    \ int\n    var myStringReversedSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLen\
    \ int\n    var myStringReversedSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLen\
    \ int\n    var myStringReversedSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLen\
    \ int\n    var myStringReversedSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLen\
    \ int\n    var myStringReversedSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffix\n\
    func TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_tzyph43_test.go:37:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075608
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for i := 0; i < len(myString); i++ {\n        prefix := myString[:i]\n\
    \        suffix := myString[i:]\n        postfix := reversePostfix(prefix)\n \
    \       if postfix != suffix {\n            longestPalindrome = prefix + postfix\n\
    \            longestPalindromeLen = len(longestPalindrome)\n        }\n    }\n\
    \    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n\
    \  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3rsvz0_g_test.go:14:5: longestPalindromeLen declared but not used

    /tmp/tmp3rsvz0_g_test.go:18:20: undefined: reversePostfix

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075604
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for i := 0; i < len(myString); i++ {\n        postfix := myString[i:]\n\
    \        prefix := myString[:i]\n        postFixLen := len(postfix)\n        prefixLen\
    \ := len(prefix)\n        if postFixLen > longestPalindromeLen {\n           \
    \ longestPalindrome = postfix\n            longestPalindromeLen = postFixLen\n\
    \        }\n        if prefixLen > longestPalindromeLen {\n            longestPalindrome\
    \ = prefix\n            longestPalindromeLen = prefixLen\n        }\n    }\n \
    \   return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n\
    \  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__2\
    \ (0.00s)\n        tmpqdj90dpq_test.go:49: expected 'xyzyx', got 'xyz'\n    ---\
    \ FAIL: TestMake_Palindrome/test_num__4 (0.00s)\n        tmpqdj90dpq_test.go:49:\
    \ expected 'jerryrrej', got 'jerry'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660075609
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for i := 0; i < len(myString); i++ {\n        postfix := myString[i:]\n\
    \        postfix += myString[:i]\n        postfix += myString[:i+1]\n        postfix\
    \ += myString[i+1:]\n        postfix += myString[:i+1]\n        postfix += myString[i+2:]\n\
    \        postfix += myString[:i+1]\n        postfix += myString[i+2:]\n      \
    \  postfix += myString[:i+1]\n        postfix += myString[i+2:]\n        postfix\
    \ += myString[:i+1]\n        postfix += myString[i+2:]\n        postfix += myString[:i+1]\n\
    \        postfix += myString[i+2:]\n        postfix += myString[:i+1]\n      \
    \  postfix += myString[i+2:]\n        postfix += myString[:i+1]\n        postfix\
    \ += myString[i+2:]\n        postfix += myString[:i+1]\n        postfix += myString[i+2:]\n\
    \        postfix += myString[:i+1]\n        postfix += myString[i+2:]\n      \
    \  postfix += myString[:i+1]\n        postfix += myString[i+2:]\n        postfix\
    \ += myString[:i+1]\n        postfix += myString[i+2:]\n        postfix += myString[:i+1]\n\
    \        postfix += myString[i+2:]\n        postfix += myString[:i+1]\n      \
    \  postfix += myString[i+2:]\n        postfix += myString[:i+1]\n        postfix\
    \ += myString[i+2:]\n        postfix += myString[:i+1]\n        postfix += myString[i+2:]\n\
    \        postfix += myString[:i+1]\n        postfix += myString[i+2:]\n      \
    \  postfix += myString[:i+1]\n        postfix += myString[i+2:]\n        postfix\
    \ += myString[:i+1]\n        postfix += myString[i+2:]\n        postfix += myString[:i+1]\n\
    \        postfix += myString[i+2:]\n        postfix += myString[:i+1]\n      \
    \  postfix += myString[i+2:]\n        postfix += myString[:i+1]\n        postfix\
    \ += myString[i+2:]\n        postfix += myString[:i+1]\n        postfix += myString[i+2:]\n\
    \        postfix += \nfunc TestMake_Palindrome(t *testing.T) {\n  candidate :=\
    \ make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp03youzyj_test.go:65:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075608
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLength\
    \ := 0\n    for i := 0; i < len(myString); i++ {\n        postfix := myString[i:]\n\
    \        prefix := myString[:i]\n        postfix = append(postfix, reverseString(prefix)...)\n\
    \        postfix = append(postfix, postfix...)\n        postfix = append(postfix,\
    \ postfix...)\n        if postfix != longestPalindrome {\n            longestPalindrome\
    \ = postfix\n            longestPalindromeLength = len(postfix)\n        }\n \
    \   }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3oo_95es_test.go:14:5: longestPalindromeLength declared but not used

    /tmp/tmp3oo_95es_test.go:18:26: first argument to append must be a slice; have
    postfix (variable of type string)

    /tmp/tmp3oo_95es_test.go:18:35: undefined: reverseString

    /tmp/tmp3oo_95es_test.go:19:26: first argument to append must be a slice; have
    postfix (variable of type string)

    /tmp/tmp3oo_95es_test.go:20:26: first argument to append must be a slice; have
    postfix (variable of type string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075608
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for i := 0; i < len(myString); i++ {\n        postfix := myString[i:]\n\
    \        prefix := myString[:i]\n        postfix = append(postfix, reverseString(prefix)...)\n\
    \        postfix = append(postfix, postfix...)\n        postfix = append(postfix,\
    \ postfix...)\n        postfix = append(postfix, postfix...)\n        postfix\
    \ = append(postfix, postfix...)\n        postfix = append(postfix, postfix...)\n\
    \        postfix = append(postfix, postfix...)\n        postfix = append(postfix,\
    \ postfix...)\n        postfix = append(postfix, postfix...)\n        postfix\
    \ = append(postfix, postfix...)\n        postfix = append(postfix, postfix...)\n\
    \        postfix = append(postfix, postfix...)\n        postfix = append(postfix,\
    \ postfix...)\n        postfix = append(postfix, postfix...)\n        postfix\
    \ = append(postfix, postfix...)\n        postfix = append(postfix, postfix...)\n\
    \        postfix = append(postfix, postfix...)\n        postfix = append(postfix,\
    \ postfix...)\n        postfix = append(postfix, postfix...)\n        postfix\
    \ = append(postfix, postfix...)\n        postfix = append(postfix, postfix...)\n\
    \        postfix = append(postfix, postfix...)\n        postfix = append(postfix,\
    \ postfix...)\n        postfix = append(postfix, postfix...)\n        postfix\
    \ = append(postfix, postfix...)\n        postfix = append(postfix, postfix...)\n\
    \        postfix = append(postfix, postfix...)\n        postfix = append(postfix,\
    \ postfix...)\n        postfix = append(postfix, postfix...)\n        postfix\
    \ = append(postfix, postfix...)\n        postfix = append(postfix, postfix...)\n\
    \        postfix = append(postfix, postfix...)\n        postfix = append(postfix,\
    \ postfix...)\n        postfix = append(postfix, postfix...)\n        postfix\
    \ = append(postfix, postfix...)\n        postfix = append(postfix, postfix...)\n\
    \        postfix = append(postfix, postfix...)\n        postfix = append(postfix,\
    \ postfix...)\n        postfix = append(postfix, postfix...)\n        postfix\
    \ = append(postfix, postfix...)\n        postfix = append(postfix, postfix...)\n\
    \        postfix = append(postfix, postfix...)\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7oey5xfo_test.go:61:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075606
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    longestPalindromeLen := len(myString)\n    for i := 0; i < longestPalindromeLen;\
    \ i++ {\n        longestPalindrome = myString[0:longestPalindromeLen-i] + longestPalindrome\n\
    \    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgmqgktsk_test.go:15:26: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075608
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find longest postfix of myString that is a palindrome.\n\
    \    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n   \
    \     postfix := myString[:i]\n        postfix += myString[len(myString)-i:]\n\
    \        postfix += myString[:len(myString)-i]\n        postfix += myString[len(myString)-len(postfix):]\n\
    \        if postfix != longestPalindrome {\n            longestPalindrome = postfix\n\
    \        }\n    }\n    // Append the reverse of the longest postfix to the end\
    \ of the string.\n    longestPalindrome += myString[len(longestPalindrome):]\n\
    \    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n\
    \  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\npanic: runtime error: slice bounds\
    \ out of range [2:1] [recovered]\n\tpanic: runtime error: slice bounds out of\
    \ range [2:1]\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x513620, 0xc000160000})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x513620,\
    \ 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.make_palindrome(...)\n\t/tmp/tmpf3fg78gj_test.go:25\n\
    command-line-arguments_test.TestMake_Palindrome(0x0?)\n\t/tmp/tmpf3fg78gj_test.go:37\
    \ +0x993\ntesting.tRunner(0xc000103380, 0x528f60)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075609
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Initialize a variable to hold the longest postfix of\
    \ myString that is a palindrome.\n    var longestPalindrome string\n    // Initialize\
    \ a variable to hold the length of the longest postfix of myString that is a palindrome.\n\
    \    var longestPalindromeLength int\n    // Initialize a variable to hold the\
    \ length of the prefix of myString that comes before the longest postfix of myString\
    \ that is a palindrome.\n    var longestPalindromePrefix int\n    // Initialize\
    \ a variable to hold the length of the prefix of myString that comes before the\
    \ longest postfix of myString that is a palindrome.\n    var longestPalindromeSuffixLength\
    \ int\n    // Initialize a variable to hold the length of the suffix of myString\
    \ that comes after the longest postfix of myString that is a palindrome.\n   \
    \ var longestPalindromeSuffixLength int\n    // Initialize a variable to hold\
    \ the length of the suffix of myString that comes after the longest postfix of\
    \ myString that is a palindrome.\n    var longestPalindromeSuffixLength int\n\
    \    // Initialize a variable to hold the length of the prefix of myString that\
    \ comes before the longest postfix of myString that is a palindrome.\n    var\
    \ longestPalindromePrefix int\n    // Initialize a variable to hold the length\
    \ of the prefix of myString that comes before the longest postfix of myString\
    \ that is a palindrome.\n    var longestPalindromeSuffixLength int\n    // Initialize\
    \ a variable to hold the length of the prefix of myString that comes before the\
    \ longest postfix of myString that is a palindrome.\n    var longestPalindromePrefix\
    \ int\n    // Initialize a variable to hold the length of the prefix of myString\
    \ that comes before the longest postfix of myString that is a palindrome.\n  \
    \  var longestPalindromeSuffixLength int\n    // Initialize a variable to hold\
    \ the length of the prefix of myString that comes before the longest postfix of\
    \ myString that is a palindrome.\n    var longestPalindromePrefix int\n    //\
    \ Initialize a variable to hold the length of the prefix of myString that comes\
    \ before the longest postfix of myString that is a palindrome.\n    var longestPalindromeSuffixLength\
    \ int\n    // Initialize a variable to hold the length of the prefix of myString\
    \ that comes before the longest postfix of myString that is a palindrome.\n  \
    \  var longestPalindromePrefix int\n    // Initialize a variable to \nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp89w13_mv_test.go:40:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075608
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for i := 0; i < len(myString); i++ {\n        postfix := myString[i:]\n\
    \        prefix := myString[:i]\n        postfix += make_palindrome_test(postfix)\n\
    \        prefix += make_palindrome_test(prefix)\n        if postfix != prefix\
    \ {\n            longestPalindrome = postfix\n            longestPalindromeLen\
    \ = len(postfix)\n        }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjxkswnzi_test.go:14:5: longestPalindromeLen declared but not used

    /tmp/tmpjxkswnzi_test.go:18:20: undefined: make_palindrome_test

    /tmp/tmpjxkswnzi_test.go:19:19: undefined: make_palindrome_test

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075609
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for _, char := range myString {\n        postfix := \"\"\n        for\
    \ i := 0; i < longestPalindromeLen; i++ {\n            postfix += char\n     \
    \   }\n        postfix += string([]byte{char})\n        postfix += string([]byte{char})\n\
    \        if postfix != longestPalindrome {\n            longestPalindrome = postfix\n\
    \            longestPalindromeLen = len(postfix)\n        }\n    }\n    return\
    \ longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpoae4izoc_test.go:18:13: invalid operation: postfix += char (mismatched
    types string and rune)

    /tmp/tmpoae4izoc_test.go:20:34: cannot use char (variable of type rune) as type
    byte in array or slice literal

    /tmp/tmpoae4izoc_test.go:21:34: cannot use char (variable of type rune) as type
    byte in array or slice literal

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075601
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for i := 0; i < len(myString); i++ {\n        longestPalindromeLen +=\
    \ len(myString) - i\n        longestPalindrome += myString[:i]\n    }\n    for\
    \ i := 0; i < longestPalindromeLen; i++ {\n        longestPalindrome += string(myString[len(myString)-i:len(myString)])\n\
    \    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\npanic: runtime error: slice bounds\
    \ out of range [-1:] [recovered]\n\tpanic: runtime error: slice bounds out of\
    \ range [-1:]\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x513620, 0xc000160000})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x513620,\
    \ 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.make_palindrome(...)\n\t/tmp/tmpf_1ieixw_test.go:20\n\
    command-line-arguments_test.TestMake_Palindrome(0x0?)\n\t/tmp/tmpf_1ieixw_test.go:34\
    \ +0x7e5\ntesting.tRunner(0xc000103380, 0x528f60)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075610
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for _, char := range myString {\n        longestPalindromeLen += len(myString)\
    \ - char\n        if longestPalindromeLen > longestPalindromeLen {\n         \
    \   longestPalindromeLen = longestPalindromeLen\n            longestPalindrome\
    \ = myString\n        }\n    }\n    longestPalindrome += myString[len(myString)\
    \ - longestPalindromeLen:]\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpr5s2fk32_test.go:16:33: invalid operation: len(myString) - char (mismatched
    types int and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075609
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find the longest postfix of supplied string that is\
    \ a palindrome.\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString);\
    \ i++ {\n        longestPalindrome += myString[i]\n    }\n    longestPalindrome\
    \ = longestPalindrome[:len(longestPalindrome)-1]\n\n    // Append to the end of\
    \ the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    prefix := \"\"\n    for i := 0; i < len(longestPalindrome); i++ {\n     \
    \   prefix += longestPalindrome[len(longestPalindrome)-1-i]\n    }\n    return\
    \ prefix + longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n\
    \  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpafanlsih_test.go:16:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmpafanlsih_test.go:23:9: invalid operation: prefix += longestPalindrome[len(longestPalindrome)
    - 1 - i] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075609
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for i := 0; i < len(myString); i++ {\n        postfix := myString[i:]\n\
    \        prefix := myString[:i]\n        if isPalindrome(postfix) {\n        \
    \    longestPalindrome = prefix + longestPalindrome\n            longestPalindromeLen\
    \ = len(longestPalindrome)\n        }\n    }\n    return longestPalindrome\n}\n\
    \nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpm0dtr5je_test.go:14:5: longestPalindromeLen declared but not used

    /tmp/tmpm0dtr5je_test.go:18:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075609
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for i := 0; i < len(myString); i++ {\n        postfix := myString[i:]\n\
    \        prefix := myString[:i]\n        if isPalindrome(postfix) {\n        \
    \    longestPalindrome = append(longestPalindrome, append(prefix, append(postfix,\
    \ reverseString(postfix))...)...)\n            longestPalindromeLen = len(longestPalindrome)\n\
    \        }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_ai98b_6_test.go:14:5: longestPalindromeLen declared but not used

    /tmp/tmp_ai98b_6_test.go:18:12: undefined: isPalindrome

    /tmp/tmp_ai98b_6_test.go:19:40: first argument to append must be a slice; have
    longestPalindrome (variable of type string)

    /tmp/tmp_ai98b_6_test.go:19:66: first argument to append must be a slice; have
    prefix (variable of type string)

    /tmp/tmp_ai98b_6_test.go:19:81: first argument to append must be a slice; have
    postfix (variable of type string)

    /tmp/tmp_ai98b_6_test.go:19:90: undefined: reverseString

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075609
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for i := 0; i < len(myString); i++ {\n        postfix := myString[i:]\n\
    \        prefix := myString[:i]\n        postfix = append(postfix, reverse(prefix))\n\
    \        postfix = append(postfix, postfix...)\n        postfix = append(postfix,\
    \ postfix...)\n        postfix = append(postfix, postfix...)\n        postfix\
    \ = append(postfix, postfix...)\n        postfix = append(postfix, postfix...)\n\
    \        postfix = append(postfix, postfix...)\n        postfix = append(postfix,\
    \ postfix...)\n        postfix = append(postfix, postfix...)\n        postfix\
    \ = append(postfix, postfix...)\n        postfix = append(postfix, postfix...)\n\
    \        postfix = append(postfix, postfix...)\n        postfix = append(postfix,\
    \ postfix...)\n        postfix = append(postfix, postfix...)\n        postfix\
    \ = append(postfix, postfix...)\n        postfix = append(postfix, postfix...)\n\
    \        postfix = append(postfix, postfix...)\n        postfix = append(postfix,\
    \ postfix...)\n        postfix = append(postfix, postfix...)\n        postfix\
    \ = append(postfix, postfix...)\n        postfix = append(postfix, postfix...)\n\
    \        postfix = append(postfix, postfix...)\n        postfix = append(postfix,\
    \ postfix...)\n        postfix = append(postfix, postfix...)\n        postfix\
    \ = append(postfix, postfix...)\n        postfix = append(postfix, postfix...)\n\
    \        postfix = append(postfix, postfix...)\n        postfix = append(postfix,\
    \ postfix...)\n        postfix = append(postfix, postfix...)\n        postfix\
    \ = append(postfix, postfix...)\n        postfix = append(postfix, postfix...)\n\
    \        postfix = append(postfix, postfix...)\n        postfix = append(postfix,\
    \ postfix...)\n        postfix = append(postfix, postfix...)\n        postfix\
    \ = append(postfix, postfix...)\n        postfix = append(postfix, postfix...)\n\
    \        postfix = append(postfix, postfix...)\n        postfix = append(postfix,\
    \ postfix...)\n        postfix = append(postfix, postfix...)\n        postfix\
    \ = append(postfix, postfix...)\n        postfix = append(postfix, postfix...)\n\
    \        postfix = append(postfix, postfix...)\n        \nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_ar32ykb_test.go:61:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075609
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for _, char := range myString {\n        postfix := \"\"\n        for\
    \ i := 0; i < longestPalindromeLen; i++ {\n            postfix += char\n     \
    \   }\n        postfix += string([]rune(char))\n        postfix += string([]rune(reverse(string(char))))\n\
    \        if postfix != longestPalindrome {\n            longestPalindrome = postfix\n\
    \            longestPalindromeLen = len(postfix)\n        }\n    }\n    return\
    \ longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfevjy5it_test.go:18:13: invalid operation: postfix += char (mismatched
    types string and rune)

    /tmp/tmpfevjy5it_test.go:20:34: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpfevjy5it_test.go:21:34: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075610
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for i := 0; i < len(myString); i++ {\n        postfix := myString[longestPalindromeLen:i]\n\
    \        postfix += string(reverse(postfix))\n        if postfix != myString {\n\
    \            longestPalindrome = postfix\n            longestPalindromeLen = len(postfix)\n\
    \        }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdjc15pn9_test.go:17:27: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075610
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find longest postfix of myString that is a palindrome.\n\
    \    // This will be the prefix of the palindrome we are looking for.\n    var\
    \ longestPalindrome string = \"\"\n    for i := 0; i < len(myString); i++ {\n\
    \        longestPalindrome += myString[i]\n    }\n    longestPalindrome += myString[len(myString)-1]\n\
    \n    // Reverse the prefix of the palindrome we are looking for.\n    // This\
    \ will be the suffix of the palindrome we are looking for.\n    var reversedLongestPalindrome\
    \ string = \"\"\n    for i := 0; i < len(longestPalindrome); i++ {\n        reversedLongestPalindrome\
    \ += longestPalindrome[len(longestPalindrome)-1-i]\n    }\n\n    // Append the\
    \ reversedLongestPalindrome to the end of the myString.\n    // This will be the\
    \ palindrome we are looking for.\n    return myString + reversedLongestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppu2b4hzc_test.go:17:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmppu2b4hzc_test.go:19:5: invalid operation: longestPalindrome += myString[len(myString)
    - 1] (mismatched types string and byte)

    /tmp/tmppu2b4hzc_test.go:25:9: invalid operation: reversedLongestPalindrome +=
    longestPalindrome[len(longestPalindrome) - 1 - i] (mismatched types string and
    byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075610
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find longest postfix of myString that is a palindrome.\n\
    \    // This will be the length of the palindrome plus one.\n    longestPalindrome\
    \ := 0\n    for i := 0; i < len(myString); i++ {\n        // Find the longest\
    \ postfix of myString that is a palindrome.\n        // This will be the length\
    \ of the palindrome plus one.\n        longestPalindrome = longestPalindrome +\
    \ len(myString[i:])\n        // If this postfix is a palindrome, return it.\n\
    \        if myString[i:] == myString[:len(myString)-i].reverse() {\n         \
    \   return myString[:longestPalindrome]\n        }\n    }\n    // If no palindrome\
    \ found, return empty string.\n    return \"\"\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbc9mox20_test.go:21:55: myString[:len(myString) - i].reverse undefined
    (type string has no field or method reverse)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075610
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find longest postfix of myString that is a palindrome.\n\
    \    // This will be the length of the longest palindrome prefix.\n    longestPalindromeLen\
    \ := 0\n    for i := len(myString) - 1; i >= 0; i-- {\n        // If current character\
    \ is not a palindrome prefix, skip it.\n        if !isPalindrome(myString[i])\
    \ {\n            continue\n        }\n        // If current character is a palindrome\
    \ prefix, then find out its length.\n        thisLen := len(myString) - i - 1\n\
    \        if thisLen > longestPalindromeLen {\n            longestPalindromeLen\
    \ = thisLen\n        }\n    }\n\n    // If no palindrome prefix found, return\
    \ empty string.\n    if longestPalindromeLen == 0 {\n        return \"\"\n   \
    \ }\n\n    // Append the reverse of the string prefix that comes before the palindromic\
    \ suffix.\n    suffix := myString[longestPalindromeLen:]\n    return myString[:longestPalindromeLen]\
    \ + suffix\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7njs91kl_test.go:18:13: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075610
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLength\
    \ := 0\n    for i := 0; i < len(myString); i++ {\n        postfix := myString[i:]\n\
    \        postfix += myString[:i]\n        postfix += myString[i:]\n        postfix\
    \ += myString[:i]\n        postfix += myString[i:]\n        postfix += myString[:i]\n\
    \        postfix += myString[i:]\n        postfix += myString[:i]\n        postfix\
    \ += myString[i:]\n        postfix += myString[:i]\n        postfix += myString[i:]\n\
    \        postfix += myString[:i]\n        postfix += myString[i:]\n        postfix\
    \ += myString[:i]\n        postfix += myString[i:]\n        postfix += myString[:i]\n\
    \        postfix += myString[i:]\n        postfix += myString[:i]\n        postfix\
    \ += myString[i:]\n        postfix += myString[:i]\n        postfix += myString[i:]\n\
    \        postfix += myString[:i]\n        postfix += myString[i:]\n        postfix\
    \ += myString[:i]\n        postfix += myString[i:]\n        postfix += myString[:i]\n\
    \        postfix += myString[i:]\n        postfix += myString[:i]\n        postfix\
    \ += myString[i:]\n        postfix += myString[:i]\n        postfix += myString[i:]\n\
    \        postfix += myString[:i]\n        postfix += myString[i:]\n        postfix\
    \ += myString[:i]\n        postfix += myString[i:]\n        postfix += myString[:i]\n\
    \        postfix += myString[i:]\n        postfix += myString[:i]\n        postfix\
    \ += myString[i:]\n        postfix += myString[:i]\n        postfix += myString[i:]\n\
    \        postfix += myString[:i]\n        postfix += myString[i:]\n        postfix\
    \ += myString[:i]\n        postfix += myString[i:]\n        postfix += myString[:i]\n\
    \        postfix += myString[i:]\n        postfix += myString[:i]\n        postfix\
    \ += myString[i:]\n        postfix += myString[:i]\n        postfix += myString[i:]\n\
    \        postfix += myString[:i]\n        postfix += myString[i:]\n        postfix\
    \ \nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxhekt225_test.go:70:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075599
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for i := 0; i < len(myString); i++ {\n        postfix := myString[i:]\n\
    \        prefix := myString[:i]\n        postFixLen := len(postfix)\n        prefixLen\
    \ := len(prefix)\n        if postFixLen > longestPalindromeLen {\n           \
    \ longestPalindrome = postfix\n            longestPalindromeLen = postFixLen\n\
    \        }\n        if prefixLen > longestPalindromeLen {\n            longestPalindrome\
    \ = prefix\n            longestPalindromeLen = prefixLen\n        }\n    }\n \
    \   return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n\
    \  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__2\
    \ (0.00s)\n        tmpqdj90dpq_test.go:49: expected 'xyzyx', got 'xyz'\n    ---\
    \ FAIL: TestMake_Palindrome/test_num__4 (0.00s)\n        tmpqdj90dpq_test.go:49:\
    \ expected 'jerryrrej', got 'jerry'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660075609
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find the longest postfix of supplied string that is\
    \ a palindrome.\n    longestPalindrome := \"\"\n    longestPalindromeLen := 0\n\
    \    for i := 0; i < len(myString); i++ {\n        postfix := myString[i:]\n \
    \       postfix += myString[:i]\n        if isPalindrome(postfix) {\n        \
    \    longestPalindrome = postfix\n            longestPalindromeLen = len(postfix)\n\
    \        }\n    }\n    // Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    prefix := myString[:longestPalindromeLen]\n\
    \    prefix += myString[longestPalindromeLen:]\n    return prefix + longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpz_jlskhd_test.go:19:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075610
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLength\
    \ := 0\n    for i := 0; i < len(myString); i++ {\n        postfix := myString[i:]\n\
    \        postfix += myString[:i]\n        postfix += myString[:len(myString)-i]\n\
    \        postfix += myString[len(myString)-i:len(myString)]\n        postfix +=\
    \ myString[len(myString)-1:len(myString)]\n        postfix += myString[:len(myString)-1]\n\
    \        postfix += myString[:len(myString)-2]\n        postfix += myString[:len(myString)-3]\n\
    \        postfix += myString[:len(myString)-4]\n        postfix += myString[:len(myString)-5]\n\
    \        postfix += myString[:len(myString)-6]\n        postfix += myString[:len(myString)-7]\n\
    \        postfix += myString[:len(myString)-8]\n        postfix += myString[:len(myString)-9]\n\
    \        postfix += myString[:len(myString)-10]\n        postfix += myString[:len(myString)-11]\n\
    \        postfix += myString[:len(myString)-12]\n        postfix += myString[:len(myString)-13]\n\
    \        postfix += myString[:len(myString)-14]\n        postfix += myString[:len(myString)-15]\n\
    \        postfix += myString[:len(myString)-16]\n        postfix += myString[:len(myString)-17]\n\
    \        postfix += myString[:len(myString)-18]\n        postfix += myString[:len(myString)-19]\n\
    \        postfix += myString[:len(myString)-20]\n        postfix += myString[:len(myString)-21]\n\
    \        postfix += myString[:len(myString)-22]\n        postfix += myString[:len(myString)-23]\n\
    \        postfix += myString[:len(myString)-24]\n        postfix += myString[:len(myString)-25]\n\
    \        postfix += myString[:len(myString)-26]\n        postfix += myString[:len(myString)-27]\n\
    \        postfix += myString[:len(myString)-28]\n        postfix += myString[:len(myString)-29]\n\
    \        postfix += myString[:len(myString)-30]\n        postfix += myString[:len(myString)-31]\n\
    \        postfix += myString[:len(my\nfunc TestMake_Palindrome(t *testing.T) {\n\
    \  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpog_r2uvs_test.go:52:36: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075609
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // The longest postfix of myString that is a palindrome.\n\
    \    longestPalindrome := \"\"\n    // The string prefix that comes before the\
    \ longest postfix.\n    prefix := \"\"\n    // The string suffix that comes after\
    \ the longest postfix.\n    suffix := \"\"\n    // The length of the longest postfix.\n\
    \    longestPalindromeLen := 0\n    // The length of the string prefix.\n    prefixLen\
    \ := 0\n    // The length of the string suffix.\n    suffixLen := 0\n    // The\
    \ length of the string that comes before the longest postfix.\n    prefixBeforeLongestPalindrome\
    \ := 0\n    // The length of the string that comes after the longest postfix.\n\
    \    suffixAfterLongestPalindrome := 0\n    // The length of the string that comes\
    \ before the longest postfix.\n    prefixBeforeLongestPalindromeLen := 0\n   \
    \ // The length of the string that comes after the longest postfix.\n    suffixAfterLongestPalindromeLen\
    \ := 0\n    // The length of the string that comes before the longest postfix.\n\
    \    prefixBeforeLongestPalindromePos := 0\n    // The length of the string that\
    \ comes after the longest postfix.\n    suffixAfterLongestPalindromePos := 0\n\
    \    // The length of the string that comes before the longest postfix.\n    prefixBeforeLongestPalindromePos\
    \ := 0\n    // The length of the string that comes after the longest postfix.\n\
    \    suffixAfterLongestPalindromePos := 0\n    // The length of the string that\
    \ comes before the longest postfix.\n    prefixBeforeLongestPalindromePos := 0\n\
    \    // The length of the string that comes after the longest postfix.\n    suffixAfterLongestPalindromePos\
    \ := 0\n    // The length of the string that comes before the longest postfix.\n\
    \    prefixBeforeLongestPalindromePos := 0\n    // The length of the string that\
    \ comes after the longest postfix.\n    suffixAfterLongestPalindromePos := 0\n\
    \    // The length of the string that comes before the longest postfix.\n    prefixBeforeLongestPalindromePos\
    \ := 0\n    // The length of the string that comes after the longest postfix.\n\
    \    suffixAfterLongestPalindromePos := 0\n    // The length of the string that\
    \ comes before the longest postfix.\n    prefixBeforeLongest\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5prolw47_test.go:55:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075609
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for _, char := range myString {\n        postfix := \"\"\n        postfix\
    \ += char\n        postfix += char\n        postfix += char\n        postfix +=\
    \ char\n        postfix += char\n        postfix += char\n        postfix += char\n\
    \        postfix += char\n        postfix += char\n        postfix += char\n \
    \       postfix += char\n        postfix += char\n        postfix += char\n  \
    \      postfix += char\n        postfix += char\n        postfix += char\n   \
    \     postfix += char\n        postfix += char\n        postfix += char\n    \
    \    postfix += char\n        postfix += char\n        postfix += char\n     \
    \   postfix += char\n        postfix += char\n        postfix += char\n      \
    \  postfix += char\n        postfix += char\n        postfix += char\n       \
    \ postfix += char\n        postfix += char\n        postfix += char\n        postfix\
    \ += char\n        postfix += char\n        postfix += char\n        postfix +=\
    \ char\n        postfix += char\n        postfix += char\n        postfix += char\n\
    \        postfix += char\n        postfix += char\n        postfix += char\n \
    \       postfix += char\n        postfix += char\n        postfix += char\n  \
    \      postfix += char\n        postfix += char\n        postfix += char\n   \
    \     postfix += char\n        postfix += char\n        postfix += char\n    \
    \    postfix += char\n        postfix += char\n        postfix += char\n     \
    \   postfix += char\n        postfix += char\n        postfix += char\n      \
    \  postfix += char\n        postfix += char\n        postfix += char\n       \
    \ postfix += char\n        postfix += char\n        postfix += char\n        postfix\
    \ += char\n        postfix += char\n        postfix += char\n        postfix +=\
    \ char\n        postfix += char\n        postfix += char\n        postfix += char\n\
    \        postfix += char\n        postfix += char\n        postfix += char\n \
    \       postfix += char\n        postfix += char\n        postfix += char\n  \
    \      postfix += char\n        postfix += char\n        postfix += char\n   \
    \     postfix += char\n        postfix += \nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpg97ezhnv_test.go:97:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075599
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Initialize a palindrome suffix to an empty string.\n\
    \    var palindromeSuffix string = \"\"\n\n    // Find the longest postfix of\
    \ supplied string that is a palindrome.\n    for i := len(myString) - 1; i >=\
    \ 0; i-- {\n        // If this character is a palindrome suffix, append it to\
    \ the palindrome suffix.\n        if myString[i] == myString[len(myString)-i-1]\
    \ {\n            palindromeSuffix += myString[i]\n        }\n    }\n\n    // Append\
    \ the reverse of the palindrome suffix to the end of the supplied string.\n  \
    \  return myString + palindromeSuffix\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpoqiyof4q_test.go:20:13: invalid operation: palindromeSuffix += myString[i]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075610
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for i := 0; i < len(myString); i++ {\n        postfix := myString[i:]\n\
    \        postfix += string(myString[:i])\n        if isPalindrome(postfix) {\n\
    \            longestPalindrome = postfix\n            longestPalindromeLen = len(postfix)\n\
    \        }\n    }\n    return longestPalindrome + string(myString[:longestPalindromeLen])\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp93o1vj8x_test.go:18:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075610
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    longestPalindromeLen := len(myString)\n    for i := 0; i < longestPalindromeLen;\
    \ i++ {\n        prefix := myString[0:i]\n        reverse := myString[i:]\n  \
    \      if isPalindrome(prefix, reverse) {\n            longestPalindrome = prefix\
    \ + reverse\n            longestPalindromeLen = len(longestPalindrome)\n     \
    \   }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvx9fj_i8_test.go:15:26: no new variables on left side of :=

    /tmp/tmpvx9fj_i8_test.go:19:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075610
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for i := 0; i < len(myString); i++ {\n        postfix := myString[i:]\n\
    \        prefix := myString[:i]\n        postfix += reverseString(prefix)\n  \
    \      longestPalindrome = longestPalindrome + postfix\n        if longestPalindromeLen\
    \ < len(postfix) {\n            longestPalindromeLen = len(postfix)\n        }\n\
    \    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpq402znz8_test.go:18:20: undefined: reverseString

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075610
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // This will be the length of the palindrome.\n    longestPalindrome\
    \ := 0\n    for i := len(myString) - 1; i >= 0; i-- {\n        // Find the postfix\
    \ that is a palindrome.\n        // If this postfix is longer than the longest\
    \ palindrome so far,\n        // then update longestPalindrome.\n        if myString[i]\
    \ == myString[len(myString)-i-1] {\n            longestPalindrome++\n        }\
    \ else {\n            break\n        }\n    }\n\n    // Append the reverse of\
    \ the string prefix that comes before the palindromic suffix.\n    // This will\
    \ be the length of the palindrome.\n    prefix := myString[0:longestPalindrome]\n\
    \    reversedPrefix := reverseString(prefix)\n    return prefix + reversedPrefix\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprds1bu5e_test.go:30:23: undefined: reverseString

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075610
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLength\
    \ := 0\n    longestPalindromeLength := len(myString)\n    for i := 0; i < longestPalindromeLength;\
    \ i++ {\n        postfix := myString[longestPalindromeLength - i - 1 : longestPalindromeLength\
    \ - i]\n        if isPalindrome(postfix) {\n            longestPalindrome = postfix\
    \ + longestPalindrome\n            longestPalindromeLength = len(postfix)\n  \
    \      }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwvkhj2x1_test.go:15:29: no new variables on left side of :=

    /tmp/tmpwvkhj2x1_test.go:18:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075610
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for i := 0; i < len(myString); i++ {\n        postfix := myString[i:]\n\
    \        postfix += \"-\"\n        postfix += myString[:i]\n        postfix +=\
    \ \"-\"\n        postfix += myString[i+1:]\n        postfix += \"-\"\n       \
    \ postfix += myString[:i+1]\n        postfix += \"-\"\n        postfix += myString[i+2:]\n\
    \        postfix += \"-\"\n        postfix += myString[:i+2]\n        postfix\
    \ += \"-\"\n        postfix += myString[i+3:]\n        postfix += \"-\"\n    \
    \    postfix += myString[:i+3]\n        postfix += \"-\"\n        postfix += myString[i+4:]\n\
    \        postfix += \"-\"\n        postfix += myString[:i+4]\n        postfix\
    \ += \"-\"\n        postfix += myString[i+5:]\n        postfix += \"-\"\n    \
    \    postfix += myString[:i+5]\n        postfix += \"-\"\n        postfix += myString[i+6:]\n\
    \        postfix += \"-\"\n        postfix += myString[:i+6]\n        postfix\
    \ += \"-\"\n        postfix += myString[i+7:]\n        postfix += \"-\"\n    \
    \    postfix += myString[:i+7]\n        postfix += \"-\"\n        postfix += myString[i+8:]\n\
    \        postfix += \"-\"\n        postfix += myString[:i+8]\n        postfix\
    \ += \"-\"\n        postfix += myString[i+9:]\n        postfix += \"-\"\n    \
    \    postfix += myString[:i+9]\n        postfix += \"-\"\n        postfix += myString[i+10:]\n\
    \        postfix += \"-\"\n        postfix += myString[:i+10]\n        postfix\
    \ += \"-\"\n        postfix += myString[i+11:]\n        postfix += \"-\"\n   \
    \     postfix += myString[:i+11]\n        postfix += \"-\"\n        postfix +=\
    \ myString[i+12:]\n        postfix += \"-\"\n        postfix += myString[:i+12]\n\
    \        postfix += \"-\"\n        postfix += myString[i+13:]\n        postfix\
    \ += \"-\"\n        postfix += myString[:i+13]\n        postfix += \"-\"\n   \
    \     postfix += myString[i+14:]\n        postfix += \"-\"\n        postfix +=\
    \ myString[:i+14]\n        postfix += \"-\"\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpk015p9_p_test.go:77:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075610
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for i := 0; i < len(myString); i++ {\n        postfix := myString[i:]\n\
    \        prefix := myString[:i]\n        postfix += reverseString(prefix)\n  \
    \      longestPalindrome = postfix\n        longestPalindromeLen = len(postfix)\n\
    \    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpy_s278ov_test.go:14:5: longestPalindromeLen declared but not used

    /tmp/tmpy_s278ov_test.go:18:20: undefined: reverseString

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075607
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for i := len(myString); i > 0; i-- {\n        prefix := myString[0:i]\n\
    \        suffix := myString[i:]\n        if isPalindrome(prefix, suffix) {\n \
    \           longestPalindrome = prefix + suffix\n            longestPalindromeLen\
    \ = len(longestPalindrome)\n        }\n    }\n    return longestPalindrome\n}\n\
    \nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp17wpxhzc_test.go:14:5: longestPalindromeLen declared but not used

    /tmp/tmp17wpxhzc_test.go:18:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075611
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Initialize result with empty string.\n    var result\
    \ string = \"\"\n\n    // Initialize a variable to hold the longest postfix of\
    \ supplied string.\n    var longestPostfix string = \"\"\n\n    // Initialize\
    \ a variable to hold the length of the longest postfix of supplied string.\n \
    \   var longestPostfixLength int = 0\n\n    // Initialize a variable to hold the\
    \ length of the supplied string.\n    var stringLength int = len(myString)\n\n\
    \    // Initialize a variable to hold the index of the first character of the\
    \ longest postfix of supplied string.\n    var longestPostfixIndex int = 0\n\n\
    \    // Initialize a variable to hold the index of the first character of the\
    \ supplied string.\n    var stringIndex int = 0\n\n    // Initialize a variable\
    \ to hold the index of the last character of the supplied string.\n    var stringLength\
    \ int = len(myString)\n\n    // Initialize a variable to hold the index of the\
    \ last character of the longest postfix of supplied string.\n    var longestPostfixIndexEnd\
    \ int = 0\n\n    // Initialize a variable to hold the index of the last character\
    \ of the longest postfix of supplied string.\n    var longestPostfixIndexEndLength\
    \ int = 0\n\n    // Initialize a variable to hold the index of the first character\
    \ of the longest postfix of supplied string.\n    var longestPostfixIndexStart\
    \ int = 0\n\n    // Initialize a variable to hold the index of the first character\
    \ of the longest postfix of supplied string.\n    var longestPostfixIndexStartLength\
    \ int = 0\n\n    // Initialize a variable to hold the index of the first character\
    \ of the longest postfix of supplied string.\n    var longestPostfixIndexStartLength\
    \ int = 0\n\n    // Initialize a variable to hold the index of the first character\
    \ of the longest postfix of supplied string.\n    var longestPostfixIndexStartLength\
    \ int = 0\n\n    // Initialize a variable to hold the index of the first character\
    \ of the longest postfix of supplied string.\n    var longestPostfixIndexStartLength\
    \ int = 0\n\n    // Initialize a variable to hold the index of the first character\
    \ of the longest postfix of supplied string.\n    var longestPostfixIndexStartLength\
    \ int = 0\n\n    // Initialize a variable to hold the index of the first character\
    \ of the longest postfix of supplied string.\n    var longestPostfixIndexStartLength\
    \ int = 0\n\n    // Initialize a variable to hold the index of the first character\
    \ of the longest postfix of supplied string.\n    var longestPostfixIndexStartLength\
    \ int = 0\n\n    // Initialize a variable to hold the index of the first character\
    \ of the longest postfix of supplied string.\n    var longestPostfixIndexStartLength\
    \ int = 0\n\n    // Initialize a variable to hold the index of the first character\
    \ of the longest postfix of supplied string.\n    var longestPostfixIndexStartLength\
    \ int = 0\n\n    // Initialize a variable to hold the \nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp61188et2_test.go:71:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075610
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Initialize our result string.\n    var result string\n\
    \n    // Find the longest postfix of supplied string that is a palindrome.\n \
    \   var longestPalindrome string\n    for i := len(myString) - 1; i >= 0; i--\
    \ {\n        // Get the postfix of supplied string that is a palindrome.\n   \
    \     postfix := myString[0:i+1]\n\n        // If the postfix is a palindrome,\
    \ append it to the result string.\n        if isPalindrome(postfix) {\n      \
    \      result = result + postfix + \" \"\n        }\n\n        // If the postfix\
    \ is not a palindrome, find the longest postfix of supplied string that is a palindrome.\n\
    \        if i == 0 {\n            longestPalindrome = postfix\n        }\n   \
    \ }\n\n    // Append the reverse of the string prefix that comes before the palindromic\
    \ suffix.\n    result = result + longestPalindrome + myString[len(longestPalindrome):]\n\
    \n    return result\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpeorxc6of_test.go:23:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075611
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLength\
    \ := 0\n    longestPalindromePrefix := \"\"\n    longestPalindromeSuffix := \"\
    \"\n    longestPalindromePrefixLength := 0\n    longestPalindromeSuffixLength\
    \ := 0\n    for i := 0; i < len(myString); i++ {\n        prefix := myString[:i]\n\
    \        suffix := myString[i:]\n        if isPalindrome(prefix) && isPalindrome(suffix)\
    \ {\n            longestPalindrome = prefix + suffix\n            longestPalindromeLength\
    \ = i\n            longestPalindromePrefix = prefix\n            longestPalindromeSuffix\
    \ = suffix\n            longestPalindromePrefixLength = i\n            longestPalindromeSuffixLength\
    \ = i\n        }\n    }\n    if longestPalindromeLength == 0 {\n        return\
    \ \"\"\n    }\n    return longestPalindrome + longestPalindromePrefix + longestPalindromeSuffix[longestPalindromeLength:]\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbiydqog7_test.go:17:5: longestPalindromePrefixLength declared but not
    used

    /tmp/tmpbiydqog7_test.go:18:5: longestPalindromeSuffixLength declared but not
    used

    /tmp/tmpbiydqog7_test.go:22:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075611
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLength\
    \ := 0\n    for _, char := range myString {\n        postfix := \"\"\n       \
    \ postfix += char\n        postfix += char\n        postfix += char\n        postfix\
    \ += char\n        postfix += char\n        postfix += char\n        postfix +=\
    \ char\n        postfix += char\n        postfix += char\n        postfix += char\n\
    \        postfix += char\n        postfix += char\n        postfix += char\n \
    \       postfix += char\n        postfix += char\n        postfix += char\n  \
    \      postfix += char\n        postfix += char\n        postfix += char\n   \
    \     postfix += char\n        postfix += char\n        postfix += char\n    \
    \    postfix += char\n        postfix += char\n        postfix += char\n     \
    \   postfix += char\n        postfix += char\n        postfix += char\n      \
    \  postfix += char\n        postfix += char\n        postfix += char\n       \
    \ postfix += char\n        postfix += char\n        postfix += char\n        postfix\
    \ += char\n        postfix += char\n        postfix += char\n        postfix +=\
    \ char\n        postfix += char\n        postfix += char\n        postfix += char\n\
    \        postfix += char\n        postfix += char\n        postfix += char\n \
    \       postfix += char\n        postfix += char\n        postfix += char\n  \
    \      postfix += char\n        postfix += char\n        postfix += char\n   \
    \     postfix += char\n        postfix += char\n        postfix += char\n    \
    \    postfix += char\n        postfix += char\n        postfix += char\n     \
    \   postfix += char\n        postfix += char\n        postfix += char\n      \
    \  postfix += char\n        postfix += char\n        postfix += char\n       \
    \ postfix += char\n        postfix += char\n        postfix += char\n        postfix\
    \ += char\n        postfix += char\n        postfix += char\n        postfix +=\
    \ char\n        postfix += char\n        postfix += char\n        postfix += char\n\
    \        postfix += char\n        postfix += char\n        postfix += char\n \
    \       postfix += char\n        postfix += char\n        postfix += char\n  \
    \      postfix += char\n        postfix \nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpwi7ls6qs_test.go:97:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075611
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for i := 0; i < len(myString); i++ {\n        prefix := myString[0:i]\n\
    \        suffix := myString[i:]\n        postfix := reversePostfix(suffix)\n \
    \       postfix += prefix\n        postfix += suffix\n        postfix += reversePostfix(prefix)\n\
    \        postfix += suffix\n        postfix += prefix\n        postfix += suffix\n\
    \        postfix += reversePostfix(prefix)\n        postfix += suffix\n      \
    \  postfix += prefix\n        postfix += suffix\n        postfix += reversePostfix(prefix)\n\
    \        postfix += suffix\n        postfix += prefix\n        postfix += suffix\n\
    \        postfix += reversePostfix(prefix)\n        postfix += suffix\n      \
    \  postfix += prefix\n        postfix += suffix\n        postfix += reversePostfix(prefix)\n\
    \        postfix += suffix\n        postfix += prefix\n        postfix += suffix\n\
    \        postfix += reversePostfix(prefix)\n        postfix += suffix\n      \
    \  postfix += prefix\n        postfix += suffix\n        postfix += reversePostfix(prefix)\n\
    \        postfix += suffix\n        postfix += prefix\n        postfix += suffix\n\
    \        postfix += reversePostfix(prefix)\n        postfix += suffix\n      \
    \  postfix += prefix\n        postfix += suffix\n        postfix += reversePostfix(prefix)\n\
    \        postfix += suffix\n        postfix += prefix\n        postfix += suffix\n\
    \        postfix += reversePostfix(prefix)\n        postfix += suffix\n      \
    \  postfix += prefix\n        postfix += suffix\n        postfix += reversePostfix(prefix)\n\
    \        postfix += suffix\n        postfix += prefix\n        postfix += suffix\n\
    \        postfix += reversePostfix(prefix)\n        postfix += suffix\n      \
    \  postfix += prefix\n        postfix += suffix\n        postfix += reversePostfix(prefix)\n\
    \        postfix += suffix\n        postfix += prefix\n        postfix += suffix\n\
    \        postfix += reversePostfix(prefix)\n        postfix += suffix\n      \
    \  postfix += prefix\n        postfix += suffix\n        postfix += reversePostfix(prefix)\n\
    \        postfix += suffix\n        postfix += prefix\n        postfix += suffix\n\
    \        postfix += reversePostfix(prefix)\n        postfix += suffix\n      \
    \  postfix += prefix\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn2b8qblq_test.go:85:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075611
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for i := 0; i < len(myString); i++ {\n        postfix := myString[i:]\n\
    \        prefix := myString[:i]\n        postfix, prefix := reverseString(postfix),\
    \ reverseString(prefix)\n        if postfix, prefix != \"\" {\n            if\
    \ postfix, prefix != longestPalindrome {\n                longestPalindrome =\
    \ postfix\n                longestPalindromeLen = len(postfix)\n            }\n\
    \        }\n    }\n    if longestPalindromeLen > 0 {\n        return myString\
    \ + longestPalindrome\n    }\n    return myString\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp528ub_6j_test.go:19:12: expected 1 expression

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075611
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for i := 0; i < len(myString); i++ {\n        prefix := myString[:i]\n\
    \        suffix := myString[i:]\n        postfix := reversePostfix(prefix)\n \
    \       postfix += suffix\n        postfix += reversePostfix(suffix)\n       \
    \ postfix += prefix\n        postfix += reversePostfix(prefix)\n        postfix\
    \ += suffix\n        postfix += reversePostfix(suffix)\n        postfix += prefix\n\
    \        postfix += suffix\n        postfix += reversePostfix(prefix)\n      \
    \  postfix += suffix\n        postfix += reversePostfix(suffix)\n        postfix\
    \ += prefix\n        postfix += suffix\n        postfix += reversePostfix(prefix)\n\
    \        postfix += suffix\n        postfix += reversePostfix(suffix)\n      \
    \  postfix += prefix\n        postfix += suffix\n        postfix += reversePostfix(prefix)\n\
    \        postfix += suffix\n        postfix += reversePostfix(suffix)\n      \
    \  postfix += prefix\n        postfix += suffix\n        postfix += reversePostfix(prefix)\n\
    \        postfix += suffix\n        postfix += reversePostfix(suffix)\n      \
    \  postfix += prefix\n        postfix += suffix\n        postfix += reversePostfix(prefix)\n\
    \        postfix += suffix\n        postfix += reversePostfix(suffix)\n      \
    \  postfix += prefix\n        postfix += suffix\n        postfix += reversePostfix(prefix)\n\
    \        postfix += suffix\n        postfix += reversePostfix(suffix)\n      \
    \  postfix += prefix\n        postfix += suffix\n        postfix += reversePostfix(prefix)\n\
    \        postfix += suffix\n        postfix += reversePostfix(suffix)\n      \
    \  postfix += prefix\n        postfix += suffix\n        postfix += reversePostfix(prefix)\n\
    \        postfix += suffix\n        postfix += reversePostfix(suffix)\n      \
    \  postfix += prefix\n        postfix += suffix\n        postfix += reversePostfix(prefix)\n\
    \        postfix += suffix\n        postfix += reversePostfix(suffix)\n      \
    \  postfix += prefix\n        postfix += suffix\n        postfix += reversePostfix(prefix)\n\
    \        postfix += suffix\n        postfix += reversePostfix(suffix)\n      \
    \  postfix += prefix\n        postfix += suffix\n        postfix \nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpoyirqdiz_test.go:78:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075611
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find the longest postfix of supplied string that is\
    \ a palindrome.\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString);\
    \ i++ {\n        longestPalindrome += myString[i]\n    }\n    longestPalindrome\
    \ = longestPalindrome[0:len(longestPalindrome)-1]\n\n    // Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    prefix := \"\"\n    for i := 0; i < len(longestPalindrome); i++ {\n     \
    \   prefix += longestPalindrome[len(longestPalindrome)-1-i]\n    }\n\n    // Return\
    \ palindrome + prefix.\n    return longestPalindrome + prefix\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpllyl3ba0_test.go:16:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmpllyl3ba0_test.go:23:9: invalid operation: prefix += longestPalindrome[len(longestPalindrome)
    - 1 - i] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075611
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for i := 0; i < len(myString); i++ {\n        longestPalindromeLen +=\
    \ len(myString) - i\n        longestPalindrome = myString[:longestPalindromeLen]\
    \ + myString[len(myString) - longestPalindromeLen:] + longestPalindrome\n    }\n\
    \    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n\
    \  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\npanic: runtime error: slice bounds\
    \ out of range [:5] with length 3 [recovered]\n\tpanic: runtime error: slice bounds\
    \ out of range [:5] with length 3\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.make_palindrome(...)\n\t/tmp/tmp0mw9na6l_test.go:17\n\
    command-line-arguments_test.TestMake_Palindrome(0x0?)\n\t/tmp/tmp0mw9na6l_test.go:31\
    \ +0x5ec\ntesting.tRunner(0xc0001924e0, 0x528f60)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075607
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // The longest postfix of myString that is a palindrome.\n\
    \    var longestPalindrome string\n\n    // The string prefix that comes before\
    \ the longest postfix of myString.\n    var prefixToAppend string\n\n    // The\
    \ string suffix that comes after the longest postfix of myString.\n    var suffixToAppend\
    \ string\n\n    // The string prefix that comes before the longest postfix of\
    \ myString.\n    var prefixToAppend string\n\n    // The string suffix that comes\
    \ after the longest postfix of myString.\n    var suffixToAppend string\n\n  \
    \  // The string prefix that comes before the longest postfix of myString.\n \
    \   var prefixToAppend string\n\n    // The string suffix that comes after the\
    \ longest postfix of myString.\n    var suffixToAppend string\n\n    // The string\
    \ prefix that comes before the longest postfix of myString.\n    var prefixToAppend\
    \ string\n\n    // The string suffix that comes after the longest postfix of myString.\n\
    \    var suffixToAppend string\n\n    // The string prefix that comes before the\
    \ longest postfix of myString.\n    var prefixToAppend string\n\n    // The string\
    \ suffix that comes after the longest postfix of myString.\n    var suffixToAppend\
    \ string\n\n    // The string prefix that comes before the longest postfix of\
    \ myString.\n    var prefixToAppend string\n\n    // The string suffix that comes\
    \ after the longest postfix of myString.\n    var suffixToAppend string\n\n  \
    \  // The string prefix that comes before the longest postfix of myString.\n \
    \   var prefixToAppend string\n\n    // The string suffix that comes after the\
    \ longest postfix of myString.\n    var suffixToAppend string\n\n    // The string\
    \ prefix that comes before the longest postfix of myString.\n    var prefixToAppend\
    \ string\n\n    // The string suffix that comes after the longest postfix of myString.\n\
    \    var suffixToAppend string\n\n    // The string prefix that comes before the\
    \ longest postfix of myString.\n    var prefixToAppend string\n\n    // The string\
    \ suffix that comes after the longest postfix of myString.\n    var suffixToAppend\
    \ string\n\n    // The string prefix that comes before the longest postfix of\
    \ myString.\n    var prefixToAppend string\n\n    // The string suffix that comes\
    \ after the longest postfix of myString.\n    var suffixToAppend string\n\n  \
    \  // The string prefix that comes before the longest postfix of myString.\n \
    \   var prefixToAppend string\n\n    // The string suffix that comes after the\
    \ longest postfix of myString.\n    var suffixToAppend string\n\n    // The string\
    \ prefix \nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpkk5ihnyl_test.go:83:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075611
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for i := 0; i < len(myString); i++ {\n        postfix := myString[longestPalindromeLen:i]\n\
    \        postfix += myString[:longestPalindromeLen]\n        postfix += myString[i+longestPalindromeLen:]\n\
    \        postfix += myString[:i]\n        postfix += myString[i+longestPalindromeLen:]\n\
    \        postfix += myString[:longestPalindromeLen]\n        postfix += myString[i+longestPalindromeLen:]\n\
    \        postfix += myString[:i]\n        postfix += myString[i+longestPalindromeLen:]\n\
    \        postfix += myString[:longestPalindromeLen]\n        postfix += myString[i+longestPalindromeLen:]\n\
    \        postfix += myString[:i]\n        postfix += myString[i+longestPalindromeLen:]\n\
    \        postfix += myString[:longestPalindromeLen]\n        postfix += myString[i+longestPalindromeLen:]\n\
    \        postfix += myString[:i]\n        postfix += myString[i+longestPalindromeLen:]\n\
    \        postfix += myString[:longestPalindromeLen]\n        postfix += myString[i+longestPalindromeLen:]\n\
    \        postfix += myString[:i]\n        postfix += myString[i+longestPalindromeLen:]\n\
    \        postfix += myString[:longestPalindromeLen]\n        postfix += myString[i+longestPalindromeLen:]\n\
    \        postfix += myString[:i]\n        postfix += myString[i+longestPalindromeLen:]\n\
    \        postfix += myString[:longestPalindromeLen]\n        postfix += myString[i+longestPalindromeLen:]\n\
    \        postfix += myString[:i]\n        postfix += myString[i+longestPalindromeLen:]\n\
    \        postfix += myString[:longestPalindromeLen]\n        postfix += myString[i+longestPalindromeLen:]\n\
    \        postfix += myString[:i]\n        postfix += myString[i+longestPalindromeLen:]\n\
    \        postfix += myString[:longestPalindromeLen]\n        postfix += myString[i+longestPalindromeLen:]\n\
    \        postfix \nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_hza_cf7_test.go:52:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075611
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for i := 0; i < len(myString); i++ {\n        postfix := myString[i:]\n\
    \        prefix := myString[:i]\n        postfix += make_palindrome_test(postfix)\n\
    \        prefix += make_palindrome_test(prefix)\n        if postfix != prefix\
    \ {\n            longestPalindrome = postfix\n            longestPalindromeLen\
    \ = len(postfix)\n        }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjxkswnzi_test.go:14:5: longestPalindromeLen declared but not used

    /tmp/tmpjxkswnzi_test.go:18:20: undefined: make_palindrome_test

    /tmp/tmpjxkswnzi_test.go:19:19: undefined: make_palindrome_test

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075609
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for i := 0; i < len(myString); i++ {\n        prefix := myString[:i]\n\
    \        suffix := myString[i:]\n        postfix := reverseString(prefix)\n  \
    \      if postfix != suffix {\n            longestPalindrome = postfix + \"-\"\
    \ + suffix\n            longestPalindromeLen = len(postfix)\n        }\n    }\n\
    \    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n\
    \  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp07torvxv_test.go:18:20: undefined: reverseString

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075612
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for _, letter := range myString {\n        longestPalindromeLen += len(letter)\n\
    \        if longestPalindromeLen > len(longestPalindrome) {\n            longestPalindrome\
    \ = letter\n        }\n    }\n    longestPalindromeLen += len(longestPalindrome)\n\
    \    longestPalindrome = longestPalindrome[0 : longestPalindromeLen]\n    longestPalindrome\
    \ = longestPalindrome + make_palindrome(myString[len(longestPalindrome):])\n \
    \   return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n\
    \  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfezfsqrv_test.go:16:37: invalid argument: letter (variable of type rune)
    for len

    /tmp/tmpfezfsqrv_test.go:18:33: cannot use letter (variable of type rune) as type
    string in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075612
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for i := 0; i < len(myString); i++ {\n        postfix := myString[i:]\n\
    \        postfix += string(myString[:i])\n        postfix += string(myString[i+1:])\n\
    \        postfix += string(myString[:len(myString)-i])\n        postfix += string(myString[len(myString)-i:])\n\
    \        postfix += string(myString[:len(myString)-i])\n        postfix += string(myString[len(myString)-i:])\n\
    \        postfix += string(myString[:len(myString)-i])\n        postfix += string(myString[len(myString)-i:])\n\
    \        postfix += string(myString[:len(myString)-i])\n        postfix += string(myString[len(myString)-i:])\n\
    \        postfix += string(myString[:len(myString)-i])\n        postfix += string(myString[len(myString)-i:])\n\
    \        postfix += string(myString[:len(myString)-i])\n        postfix += string(myString[len(myString)-i:])\n\
    \        postfix += string(myString[:len(myString)-i])\n        postfix += string(myString[len(myString)-i:])\n\
    \        postfix += string(myString[:len(myString)-i])\n        postfix += string(myString[len(myString)-i:])\n\
    \        postfix += string(myString[:len(myString)-i])\n        postfix += string(myString[len(myString)-i:])\n\
    \        postfix += string(myString[:len(myString)-i])\n        postfix += string(myString[len(myString)-i:])\n\
    \        postfix += string(myString[:len(myString)-i])\n        postfix += string(myString[len(myString)-i:])\n\
    \        postfix += string(myString[:len(myString)-i])\n        postfix += string(myString[len(myString)-i:])\n\
    \        postfix += string(myString[:len(myString)-i])\n        postfix += string(myString[len(myString)-i:])\n\
    \        postfix += string(myString[:len(myString)-i])\n        postfix += string(myString[len(myString)-i:])\n\
    \        postfix += string(myString[:len(myString)-i])\n        postfix += string(myString[len(myString)-i:])\n\
    \        postfix += string(myString[:len(myString)-i])\n        postfix += string(myString[len(myString)-i:])\n\
    \        postfix += string(myString[:len(myString)-i])\n        postfix += string(\n\
    func TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9dcs3j4r_test.go:53:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075611
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for _, char := range myString {\n        longestPalindromeLen += len(char)\n\
    \        longestPalindrome += string([]byte(char)) + string([]byte(reverse(string(char))))\n\
    \    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0bekov52_test.go:16:37: invalid argument: char (variable of type rune)
    for len

    /tmp/tmp0bekov52_test.go:17:44: cannot convert char (variable of type rune) to
    type []byte

    /tmp/tmp0bekov52_test.go:17:67: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075612
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for _, char := range myString {\n        longestPalindromeLen += len(char)\
    \ + 1 // +1 for the '\\0' char\n        if longestPalindromeLen > len(longestPalindrome)\
    \ {\n            longestPalindrome = char\n            longestPalindromeLen =\
    \ len(char)\n        }\n    }\n    longestPalindromeLen -= 1 // -1 for the '\\\
    0' char\n    longestPalindrome += string(myString[len(myString)-longestPalindromeLen:])\n\
    \    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n\
    \  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprjyl99h2_test.go:16:37: invalid argument: char (variable of type rune)
    for len

    /tmp/tmprjyl99h2_test.go:18:33: cannot use char (variable of type rune) as type
    string in assignment

    /tmp/tmprjyl99h2_test.go:19:40: invalid argument: char (variable of type rune)
    for len

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075612
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for i := 0; i < len(myString); i++ {\n        longestPalindromeLen +=\
    \ len(myString) - i\n        longestPalindrome += myString[longestPalindromeLen:]\n\
    \        longestPalindromeLen -= i\n    }\n    longestPalindrome += myString[longestPalindromeLen:]\n\
    \    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n\
    \  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\npanic: runtime error: slice bounds\
    \ out of range [5:3] [recovered]\n\tpanic: runtime error: slice bounds out of\
    \ range [5:3]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620, 0xc000014360})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.make_palindrome(...)\n\t/tmp/tmp_1q9kczn_test.go:17\n\
    command-line-arguments_test.TestMake_Palindrome(0x0?)\n\t/tmp/tmp_1q9kczn_test.go:33\
    \ +0x659\ntesting.tRunner(0xc0001a01a0, 0x528f60)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075612
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // The longest postfix is found by reversing all characters\
    \ in the string.\n    // The longest postfix is found by reversing all characters\
    \ in the string.\n    // The longest postfix is found by reversing all characters\
    \ in the string.\n    // The longest postfix is found by reversing all characters\
    \ in the string.\n    // The longest postfix is found by reversing all characters\
    \ in the string.\n    // The longest postfix is found by reversing all characters\
    \ in the string.\n    // The longest postfix is found by reversing all characters\
    \ in the string.\n    // The longest postfix is found by reversing all characters\
    \ in the string.\n    // The longest postfix is found by reversing all characters\
    \ in the string.\n    // The longest postfix is found by reversing all characters\
    \ in the string.\n    // The longest postfix is found by reversing all characters\
    \ in the string.\n    // The longest postfix is found by reversing all characters\
    \ in the string.\n    // The longest postfix is found by reversing all characters\
    \ in the string.\n    // The longest postfix is found by reversing all characters\
    \ in the string.\n    // The longest postfix is found by reversing all characters\
    \ in the string.\n    // The longest postfix is found by reversing all characters\
    \ in the string.\n    // The longest postfix is found by reversing all characters\
    \ in the string.\n    // The longest postfix is found by reversing all characters\
    \ in the string.\n    // The longest postfix is found by reversing all characters\
    \ in the string.\n    // The longest postfix is found by reversing all characters\
    \ in the string.\n    // The longest postfix is found by reversing all characters\
    \ in the string.\n    // The longest postfix is found by reversing all characters\
    \ in the string.\n    // The longest postfix is found by reversing all characters\
    \ in the string.\n    // The longest postfix is found by reversing all characters\
    \ in the string.\n    // The longest postfix is found by reversing all characters\
    \ in the string.\n    // The longest postfix is found by reversing all characters\
    \ in the string.\n    // The longest postfix is found by reversing all characters\
    \ in the string.\n    // The longest postfix is found by reversing all characters\
    \ in the string.\n    // The longest postfix is found by reversing all characters\
    \ in the string.\n    // The longest postfix is found by reversing all characters\
    \ in the string.\n    // The longest postfix is found by reversing all characters\
    \ in the string.\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4rk6li66_test.go:46:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075612
- exit_code: null
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix\
    \ of supplied string that is a palindrome.\n    // - Append to the end of the\
    \ string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    longestPalindrome := \"\"\n    longestPalindromeLen := 0\n    for i := len(myString)\
    \ - 1; i >= 0; i-- {\n        postfix := myString[:i+1]\n        postfix += string(myString[len(myString)-i-1:])\n\
    \        if postfix != make_palindrome(postfix) {\n            continue\n    \
    \    }\n        if longestPalindromeLen < len(postfix) {\n            longestPalindrome\
    \ = postfix\n            longestPalindromeLen = len(postfix)\n        }\n    }\n\
    \    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n\
    \  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660075625
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find longest postfix of myString that is a palindrome.\n\
    \    longestPalindrome := \"\"\n    longestPalindromeLen := 0\n    for i := len(myString)\
    \ - 1; i >= 0; i-- {\n        postfix := myString[:i+1]\n        if isPalindrome(postfix)\
    \ {\n            longestPalindrome = postfix\n            longestPalindromeLen\
    \ = len(postfix)\n        }\n    }\n\n    // Append the reverse of the string\
    \ prefix that comes before longestPalindrome.\n    prefix := myString[:longestPalindromeLen]\n\
    \    return prefix + longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp1hur0_g_test.go:18:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075612
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for i := 0; i < len(myString); i++ {\n        postfix := myString[i:]\n\
    \        postfix += string(myString[:i])\n        if isPalindrome(postfix) {\n\
    \            longestPalindrome = postfix\n            longestPalindromeLen = len(postfix)\n\
    \        }\n    }\n    return longestPalindrome + string(myString[:longestPalindromeLen])\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp93o1vj8x_test.go:18:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075610
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find longest postfix of myString that is a palindrome.\n\
    \    longestPalindrome := \"\"\n    longestPalindromeLen := 0\n    for i := len(myString)\
    \ - 1; i >= 0; i-- {\n        postfix := myString[:i+1]\n        if isPalindrome(postfix)\
    \ {\n            longestPalindrome = postfix\n            longestPalindromeLen\
    \ = len(postfix)\n        }\n    }\n\n    // Append reverse of prefix that comes\
    \ before longestPalindrome to myString.\n    prefix := myString[:longestPalindromeLen]\n\
    \    return prefix + reverse(prefix)\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphsac1b4y_test.go:14:5: longestPalindrome declared but not used

    /tmp/tmphsac1b4y_test.go:18:12: undefined: isPalindrome

    /tmp/tmphsac1b4y_test.go:26:21: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075612
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find longest postfix of myString that is a palindrome.\n\
    \    // This will be the length of the palindrome plus one.\n    longestPalindrome\
    \ := 0\n    for i := 0; i < len(myString); i++ {\n        longestPalindrome =\
    \ longestPalindrome*10 + int(myString[i])\n    }\n    longestPalindrome++\n\n\
    \    // Append reverse of myString prefix that comes before longestPalindrome.\n\
    \    result := myString\n    for i := 0; i < longestPalindrome; i++ {\n      \
    \  result = result[0:len(result)-1] + myString[len(myString)-(i+1):len(myString)]\n\
    \    }\n\n    return result\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n \
    \ candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\npanic: runtime error: slice bounds\
    \ out of range [:-1] [recovered]\n\tpanic: runtime error: slice bounds out of\
    \ range [:-1]\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x513620, 0xc000160000})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x513620,\
    \ 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.make_palindrome(...)\n\t/tmp/tmpmizgjxya_test.go:24\n\
    command-line-arguments_test.TestMake_Palindrome(0x0?)\n\t/tmp/tmpmizgjxya_test.go:37\
    \ +0x7da\ntesting.tRunner(0xc000103380, 0x528f60)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075612
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix\
    \ of supplied string that is a palindrome.\n    // - Append to the end of the\
    \ string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    longestPalindrome := \"\"\n    longestPalindromeLen := 0\n    for i := 0;\
    \ i < len(myString); i++ {\n        postfix := myString[i:]\n        postfix +=\
    \ myString[:i]\n        postfix += myString[i:]\n        postfix += myString[:i]\n\
    \        postfix += myString[i:]\n        postfix += myString[:i]\n        postfix\
    \ += myString[i:]\n        postfix += myString[:i]\n        postfix += myString[i:]\n\
    \        postfix += myString[:i]\n        postfix += myString[i:]\n        postfix\
    \ += myString[:i]\n        postfix += myString[i:]\n        postfix += myString[:i]\n\
    \        postfix += myString[i:]\n        postfix += myString[:i]\n        postfix\
    \ += myString[i:]\n        postfix += myString[:i]\n        postfix += myString[i:]\n\
    \        postfix += myString[:i]\n        postfix += myString[i:]\n        postfix\
    \ += myString[:i]\n        postfix += myString[i:]\n        postfix += myString[:i]\n\
    \        postfix += myString[i:]\n        postfix += myString[:i]\n        postfix\
    \ += myString[i:]\n        postfix += myString[:i]\n        postfix += myString[i:]\n\
    \        postfix += myString[:i]\n        postfix += myString[i:]\n        postfix\
    \ += myString[:i]\n        postfix += myString[i:]\n        postfix += myString[:i]\n\
    \        postfix += myString[i:]\n        postfix += myString[:i]\n        postfix\
    \ += myString[i:]\n        postfix += myString[:i]\n        postfix += myString[i:]\n\
    \        postfix += myString[:i]\n        postfix += myString[i:]\n        postfix\
    \ += myString[:i]\n        postfix += myString[i:]\n        postfix += myString[:i]\n\
    \        postfix += myString[i:]\n        postfix += myString[:i]\n        postfix\
    \ \nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmps9yow_aa_test.go:67:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075612
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    longestPalindromeLen := len(myString)\n    for i := 0; i < longestPalindromeLen;\
    \ i++ {\n        postfix := myString[longestPalindromeLen - i:]\n        prefix\
    \ := myString[:longestPalindromeLen - i]\n        if postfix != make_palindrome(prefix)\
    \ {\n            longestPalindrome = myString\n            break\n        }\n\
    \    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3s197k5x_test.go:15:26: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075612
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    var myStringLen int = len(myString)\n    var myStringPrefix\
    \ string\n    var myStringSuffix string\n    var myStringPalindrome string\n \
    \   var myStringPalindromeLen int\n    var myStringPalindromePrefix string\n \
    \   var myStringPalindromeSuffix string\n\n    for i := 0; i < myStringLen; i++\
    \ {\n        myStringPrefix = myString[:i]\n        myStringSuffix = myString[i:]\n\
    \        myStringPalindrome = myStringPrefix + reverse(myStringSuffix) + myStringSuffix\n\
    \        myStringPalindromeLen = len(myStringPalindrome)\n        myStringPalindromePrefix\
    \ = myString[:myStringPalindromeLen]\n        myStringPalindromeSuffix = myString[myStringPalindromeLen:]\n\
    \        if myStringPalindrome == myString {\n            return myStringPalindrome\n\
    \        }\n    }\n    return \"\"\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1k_s98gv_test.go:18:9: myStringPalindromePrefix declared but not used

    /tmp/tmp1k_s98gv_test.go:19:9: myStringPalindromeSuffix declared but not used

    /tmp/tmp1k_s98gv_test.go:24:47: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075612
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Initialize a variable to hold the longest postfix of\
    \ myString\n    // that is a palindrome\n    var longestPalindrome string\n  \
    \  // Initialize a variable to hold the length of the longest postfix of\n   \
    \ // myString that is a palindrome\n    var longestPalindromeLen int\n    // Initialize\
    \ a variable to hold the length of the longest postfix of\n    // myString that\
    \ is a palindrome\n    var longestPalindromeLen int\n    // Initialize a variable\
    \ to hold the length of the longest postfix of\n    // myString that is a palindrome\n\
    \    var longestPalindromeLen int\n    // Initialize a variable to hold the length\
    \ of the longest postfix of\n    // myString that is a palindrome\n    var longestPalindromeLen\
    \ int\n    // Initialize a variable to hold the length of the longest postfix\
    \ of\n    // myString that is a palindrome\n    var longestPalindromeLen int\n\
    \    // Initialize a variable to hold the length of the longest postfix of\n \
    \   // myString that is a palindrome\n    var longestPalindromeLen int\n    //\
    \ Initialize a variable to hold the length of the longest postfix of\n    // myString\
    \ that is a palindrome\n    var longestPalindromeLen int\n    // Initialize a\
    \ variable to hold the length of the longest postfix of\n    // myString that\
    \ is a palindrome\n    var longestPalindromeLen int\n    // Initialize a variable\
    \ to hold the length of the longest postfix of\n    // myString that is a palindrome\n\
    \    var longestPalindromeLen int\n    // Initialize a variable to hold the length\
    \ of the longest postfix of\n    // myString that is a palindrome\n    var longestPalindromeLen\
    \ int\n    // Initialize a variable to hold the length of the longest postfix\
    \ of\n    // myString that is a palindrome\n    var longestPalindromeLen int\n\
    \    // Initialize a variable to hold the length of the longest postfix of\n \
    \   // myString that is a palindrome\n    var longestPalindromeLen int\n    //\
    \ Initialize a variable to hold the length of the longest postfix of\n    // myString\
    \ that is a palindrome\n    var longestPalindromeLen int\n    // Initialize a\
    \ variable to hold the length of the longest postfix of\n    // myString that\
    \ is a palindrome\n    var longestPalindromeLen int\n    // Initialize a variable\
    \ to hold the length of the longest postfix of\n    // myString that is a \nfunc\
    \ TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqmnidg5f_test.go:60:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075612
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for i := 0; i < len(myString); i++ {\n        postfix := myString[i:]\n\
    \        postfix += myString[:i]\n        postfix += myString[:i][len(myString[:i]):]\n\
    \        postfix += myString[:i][len(myString[:i]):]\n        postfix += myString[:i][len(myString[:i]):]\n\
    \        postfix += myString[:i][len(myString[:i]):]\n        postfix += myString[:i][len(myString[:i]):]\n\
    \        postfix += myString[:i][len(myString[:i]):]\n        postfix += myString[:i][len(myString[:i]):]\n\
    \        postfix += myString[:i][len(myString[:i]):]\n        postfix += myString[:i][len(myString[:i]):]\n\
    \        postfix += myString[:i][len(myString[:i]):]\n        postfix += myString[:i][len(myString[:i]):]\n\
    \        postfix += myString[:i][len(myString[:i]):]\n        postfix += myString[:i][len(myString[:i]):]\n\
    \        postfix += myString[:i][len(myString[:i]):]\n        postfix += myString[:i][len(myString[:i]):]\n\
    \        postfix += myString[:i][len(myString[:i]):]\n        postfix += myString[:i][len(myString[:i]):]\n\
    \        postfix += myString[:i][len(myString[:i]):]\n        postfix += myString[:i][len(myString[:i]):]\n\
    \        postfix += myString[:i][len(myString[:i]):]\n        postfix += myString[:i][len(myString[:i]):]\n\
    \        postfix += myString[:i][len(myString[:i]):]\n        postfix += myString[:i][len(myString[:i]):]\n\
    \        postfix += myString[:i][len(myString[:i]):]\n        postfix += myString[:i][len(myString[:i]):]\n\
    \        postfix += myString[:i][len(myString[:i]):]\n        postfix += myString[:i][len(myString[:i]):]\n\
    \        postfix += \nfunc TestMake_Palindrome(t *testing.T) {\n  candidate :=\
    \ make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpol13lmxb_test.go:46:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075612
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find longest postfix of myString that is a palindrome.\n\
    \    // This will be the longest palindrome that begins with a given string.\n\
    \    // Example: myString = \"abba\", longest palindrome is \"abba\".\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen += len(myString) - i\n        longestPalindrome\
    \ += myString[:i]\n    }\n\n    // Append reverse of longest postfix of myString\
    \ that is a palindrome.\n    // Example: myString = \"abba\", longest palindrome\
    \ is \"abba\".\n    longestPalindrome += myString[len(myString) - longestPalindromeLen:]\n\
    \    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n\
    \  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\npanic: runtime error: slice bounds\
    \ out of range [-3:] [recovered]\n\tpanic: runtime error: slice bounds out of\
    \ range [-3:]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620, 0xc000014360})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.make_palindrome(...)\n\t/tmp/tmp5rp8r240_test.go:25\n\
    command-line-arguments_test.TestMake_Palindrome(0x0?)\n\t/tmp/tmp5rp8r240_test.go:38\
    \ +0x5c5\ntesting.tRunner(0xc0001a0340, 0x528f60)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075612
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    // Find longest postfix of myString that is a palindrome.\n\
    \    // This will be the length of the palindrome plus 1.\n    longestPalindrome\
    \ := 0\n    for i := 0; i < len(myString); i++ {\n        postfix := myString[i:]\n\
    \        if isPalindrome(postfix) {\n            longestPalindrome++\n       \
    \ }\n    }\n\n    // Append the reverse of the string prefix that comes before\
    \ the palindromic suffix.\n    // This will be the length of the palindrome minus\
    \ 1.\n    prefix := myString[:longestPalindrome-1]\n    return prefix + reverse(prefix)\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf8f6hys6_test.go:18:12: undefined: isPalindrome

    /tmp/tmpf8f6hys6_test.go:26:21: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075612
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    var myPalindrome string\n    var myPalindromeLen int\n\
    \    var myPalindromePrefix string\n    var myPalindromeSuffix string\n\n    for\
    \ i := 0; i < len(myString); i++ {\n        myPalindromeLen += len(myString) -\
    \ i\n        myPalindromePrefix = myString[0:myPalindromeLen]\n        myPalindromeSuffix\
    \ = myString[myPalindromeLen:]\n        myPalindrome = myPalindromePrefix + myPalindromeSuffix\
    \ + myPalindrome\n    }\n\n    return myPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\npanic: runtime error: slice bounds\
    \ out of range [:5] with length 3 [recovered]\n\tpanic: runtime error: slice bounds\
    \ out of range [:5] with length 3\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.make_palindrome(...)\n\t/tmp/tmp_8px4m8d_test.go:20\n\
    command-line-arguments_test.TestMake_Palindrome(0x0?)\n\t/tmp/tmp_8px4m8d_test.go:37\
    \ +0x572\ntesting.tRunner(0xc00011a680, 0x528f60)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660075612
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for i := 0; i < len(myString); i++ {\n        postfix := myString[i:]\n\
    \        postfix += \"-\"\n        postfix += myString[:i]\n        postfix +=\
    \ \"-\"\n        postfix += myString[:i+1]\n        postfix += \"-\"\n       \
    \ postfix += myString[i+1:]\n        postfix += \"-\"\n        postfix += myString[:i+1]\n\
    \        postfix += \"-\"\n        postfix += myString[i+1:]\n        postfix\
    \ += \"-\"\n        postfix += myString[:i+1]\n        postfix += \"-\"\n    \
    \    postfix += myString[i+1:]\n        postfix += \"-\"\n        postfix += myString[:i+1]\n\
    \        postfix += \"-\"\n        postfix += myString[i+1:]\n        postfix\
    \ += \"-\"\n        postfix += myString[:i+1]\n        postfix += \"-\"\n    \
    \    postfix += myString[i+1:]\n        postfix += \"-\"\n        postfix += myString[:i+1]\n\
    \        postfix += \"-\"\n        postfix += myString[i+1:]\n        postfix\
    \ += \"-\"\n        postfix += myString[:i+1]\n        postfix += \"-\"\n    \
    \    postfix += myString[i+1:]\n        postfix += \"-\"\n        postfix += myString[:i+1]\n\
    \        postfix += \"-\"\n        postfix += myString[i+1:]\n        postfix\
    \ += \"-\"\n        postfix += myString[:i+1]\n        postfix += \"-\"\n    \
    \    postfix += myString[i+1:]\n        postfix += \"-\"\n        postfix += myString[:i+1]\n\
    \        postfix += \"-\"\n        postfix += myString[i+1:]\n        postfix\
    \ += \"-\"\n        postfix += myString[:i+1]\n        postfix += \"-\"\n    \
    \    postfix += myString[i+1:]\n        postfix += \"-\"\n        postfix += myString[:i+1]\n\
    \        postfix += \"-\"\n        postfix += myString[i+1:]\n        postfix\
    \ += \"-\"\n        postfix += myString[:i+1]\n        postfix += \"-\"\n    \
    \    postfix += myString[i+1:]\n        postfix += \"-\"\n        postfix += myString[:i+1]\n\
    \        postfix += \"-\"\n        postfix += myString[i+1:]\n        postfix\
    \ += \"-\"\n        postfix += myString[:i+1]\n        postfix += \"-\"\n    \
    \    \nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpextap05y_test.go:79:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075612
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\nfunc make_palindrome(myString\
    \ string) string {\n    longestPalindrome := \"\"\n    longestPalindromeLen :=\
    \ 0\n    for i := 0; i < len(myString); i++ {\n        postfix := myString[i:]\n\
    \        reversedPostfix := append([]byte(myString[:i]), []byte(postfix)...)\n\
    \        postfix = append(reversedPostfix, byte(myString[i]))\n        postfix\
    \ = append(postfix, byte(myString[len(myString)-i-1]))\n        postfix = append(postfix,\
    \ byte(myString[len(myString)-i]))\n        postfix = append(postfix, byte(myString[len(myString)-i-1]))\n\
    \        postfix = append(postfix, byte(myString[len(myString)-i]))\n        postfix\
    \ = append(postfix, byte(myString[len(myString)-i-1]))\n        postfix = append(postfix,\
    \ byte(myString[len(myString)-i]))\n        postfix = append(postfix, byte(myString[len(myString)-i-1]))\n\
    \        postfix = append(postfix, byte(myString[len(myString)-i]))\n        postfix\
    \ = append(postfix, byte(myString[len(myString)-i-1]))\n        postfix = append(postfix,\
    \ byte(myString[len(myString)-i]))\n        postfix = append(postfix, byte(myString[len(myString)-i-1]))\n\
    \        postfix = append(postfix, byte(myString[len(myString)-i]))\n        postfix\
    \ = append(postfix, byte(myString[len(myString)-i-1]))\n        postfix = append(postfix,\
    \ byte(myString[len(myString)-i]))\n        postfix = append(postfix, byte(myString[len(myString)-i-1]))\n\
    \        postfix = append(postfix, byte(myString[len(myString)-i]))\n        postfix\
    \ = append(postfix, byte(myString[len(myString)-i-1]))\n        postfix = append(postfix,\
    \ byte(myString[len(myString)-i]))\n        postfix = append(postfix, byte(myString[len(myString)-i-1]))\n\
    \        postfix = append(postfix, byte(myString[len(myString)-i]))\n        postfix\
    \ = append(postfix, byte(myString[len(myString)-i-1]))\n        postfix = append(postfix,\
    \ byte(myString[len(myString)-i]))\n        postfix = append(postfix, byte(myString[len(myString)-i-1]))\n\
    \        postfix = append(postfix, \nfunc TestMake_Palindrome(t *testing.T) {\n\
    \  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphbl7_mof_test.go:43:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075612
