language: go_test.go
name: HumanEval_159_eat
results:
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots \nfunc TestEat(t *testing.T) {\n \
    \ candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected:\
    \ []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n\
    \     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual:\
    \ candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5,\
    \ 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5,\
    \ 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpy0hctr6s_test.go:101:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075372
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 {\n        return []int{0, 0}\n    }\n    if need\
    \ < 0 || need > 1000 {\n        return []int{0, 0}\n    }\n    if remaining <\
    \ 0 || remaining > 1000 {\n        return []int{0, 0}\n    }\n    if number ==\
    \ 0 {\n        return []int{0, 0}\n    }\n    if need == 0 {\n        return []int{number,\
    \ 0}\n    }\n    if remaining == 0 {\n        return []int{0, number}\n    }\n\
    \    if number > need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, number}\n    }\n    carrots := 0\n    if number >\
    \ 0 {\n        carrots = number - need\n    }\n    if carrots > 0 {\n        carrots\
    \ = carrots + 1\n    }\n    if carrots > remaining {\n        carrots = remaining\n\
    \    }\n    if carrots == 0 {\n        carrots = 1\n    }\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrot\nfunc\
    \ TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp975noq7d_test.go:101:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075372
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    return []int{carrots, carrots - number}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpbtupbi6n_test.go:52: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=21)\
    \ %!s(int=16)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpbtupbi6n_test.go:52:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=21) %!s(int=17)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpbtupbi6n_test.go:52: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=21) %!s(int=20)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpbtupbi6n_test.go:52: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=18) %!s(int=16)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpbtupbi6n_test.go:52: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=16)\
    \ %!s(int=12)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpbtupbi6n_test.go:52:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=10) %!s(int=6)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075373
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    if number < 0 || number > 1000 {\n        result[0] =\
    \ 0\n        result[1] = 0\n        return result\n    }\n    if need < 0 || need\
    \ > 1000 {\n        result[0] = 0\n        result[1] = 0\n        return result\n\
    \    }\n    if remaining < 0 || remaining > 1000 {\n        result[0] = 0\n  \
    \      result[1] = 0\n        return result\n    }\n    if number == 0 {\n   \
    \     result[0] = 0\n        result[1] = 0\n        return result\n    }\n   \
    \ if need == 0 {\n        result[0] = number\n        result[1] = 0\n        return\
    \ result\n    }\n    if remaining == 0 {\n        result[0] = number\n       \
    \ result[1] = need\n        return result\n    }\n    if number > need {\n   \
    \     result[0] = number\n        result[1] = need\n        return result\n  \
    \  }\n    if number > remaining {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if need > remaining {\n     \
    \   result[0] = need\n        result[1] = remaining\n        return result\n \
    \   }\n    if number > need && number > remaining {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if number > need\
    \ && number > remaining {\n        result[0] = number\n        result[1] = remaining\n\
    \        return result\n    }\n    if need > number && need > remaining {\n  \
    \      result[0] = need\n        result[1] = number\n        return result\n \
    \   }\n    if need > number && need > remaining {\n        result[0] = need\n\
    \        result[1] = remaining\n        return result\n    }\n    if number >\
    \ need && number > remaining {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number > need && number > remaining\
    \ {\n        result[0] = number\n        result[1] = remaining\n        return\
    \ result\n    }\n    if need > number && need > remaining {\n        result[0]\
    \ = need\n        result[1] = number\n        return result\n    }\n    if need\
    \ > number && need > remaining {\n        result[0] = need\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number > need && number >\
    \ remaining {\n        result[0] = number\n        result[1] = need\n        return\
    \ result\n    }\n    if number > need && number > remaining {\n        result[0]\
    \ = number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ need > number && need > remaining {\n        result[0] = need\n        result[1]\
    \ = number\n        return result\n    }\n    if need > number && need > remaining\
    \ {\n        result[0] = need\n        result[1] = remaining\n        return result\n\
    \    }\n    if number > need && number > remaining {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if number > need\
    \ && number > remaining {\n        result[0] = number\n        result[1] = remaining\n\
    \        return result\n    }\n    if need > number && need > remaining {\n  \
    \      result[0] = need\n        result[1] = number\n        return result\n \
    \   }\n    if need > number && \nfunc TestEat(t *testing.T) {\n  candidate :=\
    \ eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpgt7cs5g2_test.go:149:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075372
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    if number < 0 || number > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n        return nil\n    }\n    if need < 0 || need > 1000 {\n\
    \        fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if remaining\
    \ < 0 || remaining > 1000 {\n        fmt.Println(\"Invalid input\")\n        return\
    \ nil\n    }\n    if number == 0 {\n        result[0] = 0\n        result[1] =\
    \ 0\n        return result\n    }\n    if number == need {\n        result[0]\
    \ = number\n        result[1] = 0\n        return result\n    }\n    if number\
    \ > need {\n        fmt.Println(\"Invalid input\")\n        return nil\n    }\n\
    \    if number > remaining {\n        number = remaining\n    }\n    result[0]\
    \ = number\n    result[1] = number\n    return result\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpun2lfdu5_test.go:80: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5)\
    \ %!s(int=5)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpun2lfdu5_test.go:80:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=4)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpun2lfdu5_test.go:80: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpun2lfdu5_test.go:80: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=2) %!s(int=2)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpun2lfdu5_test.go:80: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4)\
    \ %!s(int=4)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpun2lfdu5_test.go:80:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075373
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || need < 0 || remaining < 0 {\n        return []int{0, 0}\n    }\n\
    \    if number == 0 {\n        return []int{need, remaining}\n    }\n    if need\
    \ == remaining {\n        return []int{need, 0}\n    }\n    if need > remaining\
    \ {\n        return []int{need, remaining}\n    }\n    if number > need {\n  \
    \      return []int{0, 0}\n    }\n    carrots := 0\n    carrots += number\n  \
    \  carrots += need\n    carrots += remaining\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots -= number\n    carrots -= number\n    carrots -= number\n\
    \    carrots -= number\n    carrots -= number\n    carrots -= number\n    carrots\
    \ -= number\n    carrots -= number\n    carrots -= number\n    carrots -= number\n\
    \    carrots -= number\n    carrots -= number\n    carrots -= number\n    carrots\
    \ -= number\n    carrots -= number\n    carrots -= number\n    carrots -= number\n\
    \    carrots -= number\n    carrots -= number\n    carrots -= number\n    carrots\
    \ -= number\n    carrots -= number\n    carrots -= number\n    carrots -= number\n\
    \    carrots -= number\n    carrots -= number\n    carrots -= number\n    carrots\
    \ -= number\n    carrots -= number\n    carrots -= number\n    carrots -= number\n\
    \    carrots -= number\n    carrots -= number\n    carrots -= number\n    carrots\
    \ -= number\n    carrots -= number\n    carrots -= number\n    carrots -= number\n\
    \    carrots -= number\n    carrots -= number\n    carrots -= number\n    carrots\
    \ -= number\n    carrots -= number\n    carrots -= number\n    carrots -= number\n\
    \    carrots -= number\n    carrots -= number\n    carrots -= number\n    carrots\
    \ -= number\n    carrots -= number\n    carrots -= number\n    carrots -= number\n\
    \    carrots -= number\n    carrots -= number\n    carrots -= number\n    carrots\
    \ -= number\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4kn911x4_test.go:105:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075372
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 {\n        return []int{0, 0}\n    }\n    if need\
    \ < 0 || need > 1000 {\n        return []int{0, 0}\n    }\n    if remaining <\
    \ 0 || remaining > 1000 {\n        return []int{0, 0}\n    }\n    \n    carrots\
    \ := 0\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots %= 1000\n    \n    if carrots == 0 {\n        carrots = 1000\n  \
    \  }\n    \n    return []int{carrots, carrots - number}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpx1uyz328_test.go:68: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=21)\
    \ %!s(int=16)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpx1uyz328_test.go:68:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=21) %!s(int=17)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpx1uyz328_test.go:68: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=21) %!s(int=20)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpx1uyz328_test.go:68: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=18) %!s(int=16)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpx1uyz328_test.go:68: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=16)\
    \ %!s(int=12)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpx1uyz328_test.go:68:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=10) %!s(int=6)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075373
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    carrots = number - need\n    if carrots < 0 {\n        carrots = 0\n\
    \    }\n    if carrots > remaining {\n        carrots = remaining\n    }\n   \
    \ return []int{carrots, remaining}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpe_vmya84_test.go:56: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=0)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpe_vmya84_test.go:56:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=0) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpe_vmya84_test.go:56: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=0) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpe_vmya84_test.go:56: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=0) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpe_vmya84_test.go:56: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=0)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpe_vmya84_test.go:56:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075373
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ Your code here\n    carrots := 0\n    carrots += number\n    carrots += need\n\
    \    carrots += remaining\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpk90x9nqa_test.go:101:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075372
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    carrots += number\n    if carrots < need {\n        carrots += remaining\n\
    \    }\n    return []int{carrots, remaining}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpo8h6emns_test.go:53: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=15)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpo8h6emns_test.go:53:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=13) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpo8h6emns_test.go:53: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=11) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpo8h6emns_test.go:53: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=7) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpo8h6emns_test.go:53: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=11)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpo8h6emns_test.go:53:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=5) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075373
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots += need\n  \
    \  carrots += remaining\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    return []int{carrots, carrots}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpxhtglt0k_test.go:58: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpxhtglt0k_test.go:58:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=0) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpxhtglt0k_test.go:58: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpxhtglt0k_test.go:58: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpxhtglt0k_test.go:58: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpxhtglt0k_test.go:58:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075373
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    return []int{carrots, carrots - number}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpbtupbi6n_test.go:52: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=21)\
    \ %!s(int=16)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpbtupbi6n_test.go:52:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=21) %!s(int=17)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpbtupbi6n_test.go:52: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=21) %!s(int=20)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpbtupbi6n_test.go:52: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=18) %!s(int=16)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpbtupbi6n_test.go:52: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=16)\
    \ %!s(int=12)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpbtupbi6n_test.go:52:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=10) %!s(int=6)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075373
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    if number > 1000 {\n        fmt.Println(\"Too many carrots, try again\"\
    )\n        return []int{0, 0}\n    }\n    if need > 1000 {\n        fmt.Println(\"\
    Too many carrots, try again\")\n        return []int{0, 0}\n    }\n    if remaining\
    \ > 1000 {\n        fmt.Println(\"Too many carrots, try again\")\n        return\
    \ []int{0, 0}\n    }\n    if number < need {\n        fmt.Println(\"Not enough\
    \ carrots, try again\")\n        return []int{0, 0}\n    }\n    if number == need\
    \ {\n        fmt.Println(\"You already have eaten all the carrots, try again\"\
    )\n        return []int{0, 0}\n    }\n    if number > remaining {\n        fmt.Println(\"\
    Not enough carrots, try again\")\n        return []int{0, 0}\n    }\n    if number\
    \ == remaining {\n        fmt.Println(\"You already have eaten all the carrots,\
    \ try again\")\n        return []int{0, 0}\n    }\n    if number > remaining {\n\
    \        fmt.Println(\"Not enough carrots, try again\")\n        return []int{0,\
    \ 0}\n    }\n    if number == remaining {\n        fmt.Println(\"You already have\
    \ eaten all the carrots, try again\")\n        return []int{0, 0}\n    }\n   \
    \ if number > remaining {\n        fmt.Println(\"Not enough carrots, try again\"\
    )\n        return []int{0, 0}\n    }\n    if number == remaining {\n        fmt.Println(\"\
    You already have eaten all the carrots, try again\")\n        return []int{0,\
    \ 0}\n    }\n    if number > remaining {\n        fmt.Println(\"Not enough carrots,\
    \ try again\")\n        return []int{0, 0}\n    }\n    if number == remaining\
    \ {\n        fmt.Println(\"You already have eaten all the carrots, try again\"\
    )\n        return []int{0, 0}\n    }\n    if number > remaining {\n        fmt.Println(\"\
    Not enough carrots, try again\")\n        return []int{0, 0}\n    }\n    if number\
    \ == remaining {\n        fmt.Println(\"You already have eaten all the carrots,\
    \ try again\")\n        return []int{0, 0}\n    }\n    if number > remaining {\n\
    \        fmt.Println(\"Not enough carrots, try again\")\n        return []int{0,\
    \ 0}\n    }\n    if number == remaining {\n        fmt.Println(\"You already have\
    \ eaten all the carrots, try again\")\n        return []int{0, 0}\n    }\n   \
    \ if number > remaining {\n        fmt.Println(\"Not enough carrots, try again\"\
    )\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4_qkai5m_test.go:98:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075372
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    carrots = number - need\n    if carrots < 0 {\n        carrots = 0\n\
    \    }\n    carrots = carrots + remaining\n    if carrots < 0 {\n        carrots\
    \ = 0\n    }\n    carrots = carrots + 1\n    if carrots < 0 {\n        carrots\
    \ = 0\n    }\n    carrots = carrots + 1\n    if carrots < 0 {\n        carrots\
    \ = 0\n    }\n    carrots = carrots + 1\n    if carrots < 0 {\n        carrots\
    \ = 0\n    }\n    carrots = carrots + 1\n    if carrots < 0 {\n        carrots\
    \ = 0\n    }\n    carrots = carrots + 1\n    if carrots < 0 {\n        carrots\
    \ = 0\n    }\n    carrots = carrots + 1\n    if carrots < 0 {\n        carrots\
    \ = 0\n    }\n    carrots = carrots + 1\n    if carrots < 0 {\n        carrots\
    \ = 0\n    }\n    carrots = carrots + 1\n    if carrots < 0 {\n        carrots\
    \ = 0\n    }\n    carrots = carrots + 1\n    if carrots < 0 {\n        carrots\
    \ = 0\n    }\n    carrots = carrots + 1\n    if carrots < 0 {\n        carrots\
    \ = 0\n    }\n    carrots = carrots + 1\n    if carrots < 0 {\n        carrots\
    \ = 0\n    }\n    carrots = carrots + 1\n    if carrots < 0 {\n        carrots\
    \ = 0\n    }\n    carrots = carrots + 1\n    if carrots < 0 {\n        carrots\
    \ = 0\n    }\n    carrots = carrots + 1\n    if carrots < 0 {\n        carrots\
    \ = 0\n    }\n    carrots = carrots + 1\n    if carrots < 0 {\n        carrots\
    \ = 0\n    }\n    carrots = carrots + 1\n    if carrots < 0 {\n        carrots\
    \ = 0\n    }\n    carrots = carrots + 1\n    if carrots < 0 {\n        carrots\
    \ = 0\n    }\n    carrots = carrots + 1\n    if carrots < 0 {\n        carrots\
    \ = 0\n    }\n    carrots = carrots + 1\n    if carrots < 0 {\n        carrots\
    \ = 0\n    }\n    carrots = carrots + 1\n    if carrots < 0 {\n        carrots\
    \ = 0\n    }\n    carrots = carrots + 1\n    if carrots < 0 {\n        carrots\
    \ = 0\n    }\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n\
    \     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual:\
    \ candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp59dvuz0m_test.go:121:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075372
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    var\
    \ result []int\n    if number < 0 || need < 0 || remaining < 0 {\n        fmt.Println(\"\
    Invalid input\")\n    }\n    if number == 0 {\n        result = append(result,\
    \ 0)\n    } else {\n        var carrots int\n        if number > need {\n    \
    \        carrots = number\n        } else {\n            carrots = need\n    \
    \    }\n        var carrots_left int\n        if carrots > remaining {\n     \
    \       carrots_left = remaining\n        } else {\n            carrots_left =\
    \ carrots\n        }\n        var carrots_eaten int\n        if carrots_left >\
    \ 0 {\n            carrots_eaten = carrots_left - 1\n        } else {\n      \
    \      carrots_eaten = carrots_left\n        }\n        result = append(result,\
    \ carrots_eaten)\n    }\n    return result\n}\n\nfunc TestEat(t *testing.T) {\n\
    \  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected:\
    \ []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n\
    \     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual:\
    \ candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5,\
    \ 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5,\
    \ 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpanx7ons2_test.go:75: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5)]'\n\
    \    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpanx7ons2_test.go:75: expected\
    \ '[%!s(int=12) %!s(int=1)]', got '[%!s(int=7)]'\n    --- FAIL: TestEat/test_num__2\
    \ (0.00s)\n        tmpanx7ons2_test.go:75: expected '[%!s(int=11) %!s(int=0)]',\
    \ got '[%!s(int=9)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpanx7ons2_test.go:75:\
    \ expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=4)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmpanx7ons2_test.go:75: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=4)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpanx7ons2_test.go:75:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075373
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 {\n        return []int{0, 0}\n    }\n    if need\
    \ < 0 || need > 1000 {\n        return []int{0, 0}\n    }\n    if remaining <\
    \ 0 || remaining > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n\
    \    carrots += number\n    carrots += need\n    carrots += remaining\n    carrots\
    \ %= 1000\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots %= 1000\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots %= 1000\n    carrots -= number\n    carrots -= need\n\
    \    carrots -= remaining\n    carrots %= 1000\n    carrots -= number\n    carrots\
    \ -= need\n    carrots -= remaining\n    carrots %= 1000\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    carrots %= 1000\n    carrots\
    \ -= number\n    carrots -= need\n    carrots -= remaining\n    carrots %= 1000\n\
    \    carrots -= number\n    carrots -= need\n    carrots -= remaining\n    carrots\
    \ %= 1000\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots %= 1000\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots %= 1000\n    carrots -= number\n    carrots -= need\n\
    \    carrots -= remaining\n    carrots %= 1000\n    carrots -= number\n    carrots\
    \ -= need\n    carrots -= remaining\n    carrots %= 1000\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    carrots %= 1000\n    carrots\
    \ -= number\n    carrots -= need\n    carrots -= remaining\n    carrots %= 1000\n\
    \    carrots -= number\n    carrots -= need\n    carrots -= remaining\n    carrots\
    \ %= 1000\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots %= 1000\n    carrots -= number\n    car\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmprcn8bg7x_test.go:103:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075372
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ write your code here\n    carrots := 0\n    if number < 0 {\n        return\
    \ []int{0, 0}\n    }\n    if need < 0 {\n        return []int{0, 0}\n    }\n \
    \   if remaining < 0 {\n        return []int{0, 0}\n    }\n    if number == 0\
    \ {\n        return []int{0, 0}\n    }\n    if need == 0 {\n        return []int{0,\
    \ 0}\n    }\n    if remaining == 0 {\n        return []int{0, 0}\n    }\n    if\
    \ number > 1000 {\n        return []int{0, 0}\n    }\n    if need > 1000 {\n \
    \       return []int{0, 0}\n    }\n    if remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    if number == need {\n        return []int{0, 0}\n    }\n    if\
    \ number == remaining {\n        return []int{0, 0}\n    }\n    if number > need\
    \ {\n        return []int{0, 0}\n    }\n    if number > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if need > remaining {\n        return []int{0, 0}\n\
    \    }\n    if number == 0 {\n        return []int{0, 0}\n    }\n    if need ==\
    \ 0 {\n        return []int{0, 0}\n    }\n    if remaining == 0 {\n        return\
    \ []int{0, 0}\n    }\n    if number > 1000 {\n        return []int{0, 0}\n   \
    \ }\n    if need > 1000 {\n        return []int{0, 0}\n    }\n    if remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    if number == need {\n     \
    \   return []int{0, 0}\n    }\n    if number == remaining {\n        return []int{0,\
    \ 0}\n    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if\
    \ number > remaining {\n        return []int{0, 0}\n    }\n    if need > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if number == 0 {\n        return []int{0,\
    \ 0}\n    }\n    if need == 0 {\n        return []int{0, 0}\n    }\n    if remaining\
    \ == 0 {\n        return []int{0, 0}\n    }\n    if number > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    if need > 1000 {\n        return []int{0, 0}\n    }\n\
    \    if remaining > 1000 {\n        return []int{0, 0}\n    }\n    if number ==\
    \ need {\n        return []int{0, 0}\n    }\n    if number == remaining {\n  \
    \      return []int{0, 0}\n    }\n    if number > need {\n        return []int{0,\
    \ 0}\n    }\n    if number > remaining {\n        return []int{0, 0}\n    }\n\
    \    if need > remaining {\n        return []int{0, 0}\n    }\n    if number ==\
    \ 0 {\n        return []int{\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7egum58n_test.go:139:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075372
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ Your code here\n    carrots := 0\n    carrots = number\n    carrots = carrots\
    \ - need\n    carrots = carrots - remaining\n    carrots = carrots + 1\n    return\
    \ []int{carrots, remaining}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate :=\
    \ eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmplzwuk4_w_test.go:54: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=-10)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmplzwuk4_w_test.go:54:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=-12) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmplzwuk4_w_test.go:54: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=-18) %!s(int=10)]'\n    --- FAIL:\
    \ TestEat/test_num__3 (0.00s)\n        tmplzwuk4_w_test.go:54: expected '[%!s(int=7)\
    \ %!s(int=0)]', got '[%!s(int=-13) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmplzwuk4_w_test.go:54: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=-7) %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n\
    \        tmplzwuk4_w_test.go:54: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=-1)\
    \ %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075373
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    if number < 0 {\n        return []int{0, 0}\n    }\n    if need <\
    \ 0 {\n        return []int{0, 0}\n    }\n    if remaining < 0 {\n        return\
    \ []int{0, 0}\n    }\n    if number == 0 {\n        return []int{0, 0}\n    }\n\
    \    if need == 0 {\n        return []int{number, 0}\n    }\n    if remaining\
    \ == 0 {\n        return []int{number, 0}\n    }\n    if number > 1000 {\n   \
    \     return []int{0, 0}\n    }\n    if need > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    if remaining > 1000 {\n        return []int{0, 0}\n    }\n  \
    \  if number == need {\n        return []int{number, 0}\n    }\n    if number\
    \ > need {\n        return []int{0, 0}\n    }\n    if number > remaining {\n \
    \       return []int{0, 0}\n    }\n    if need > remaining {\n        return []int{0,\
    \ 0}\n    }\n    if number == remaining {\n        return []int{number, 0}\n \
    \   }\n    if number > remaining {\n        return []int{0, 0}\n    }\n    if\
    \ number == 0 {\n        return []int{0, 0}\n    }\n    if need == 0 {\n     \
    \   return []int{number, 0}\n    }\n    if remaining == 0 {\n        return []int{number,\
    \ 0}\n    }\n    if number > 1000 {\n        return []int{0, 0}\n    }\n    if\
    \ need > 1000 {\n        return []int{0, 0}\n    }\n    if remaining > 1000 {\n\
    \        return []int{0, 0}\n    }\n    if number == need {\n        return []int{number,\
    \ 0}\n    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if\
    \ number > remaining {\n        return []int{0, 0}\n    }\n    if need > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if number == remaining {\n       \
    \ return []int{number, 0}\n    }\n    if number > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if number == 0 {\n        return []int{0, 0}\n    }\n\
    \    if need == 0 {\n        return []int{number, 0}\n    }\n    if remaining\
    \ == 0 {\n        return []int{number, 0}\n    }\n    if number > 1000 {\n   \
    \     return []int{0, 0}\n    }\n    if need > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    if remaining > 1000 {\n        return []int{0, 0}\n    }\n  \
    \  if number == need {\n        return []int{number, 0}\n    }\n    if number\
    \ > need {\n        return []int{0, 0}\n    }\n    if number > remaining {\n \
    \       return []int{0, 0}\n    }\n    if need > remaining {\n        return []int{0,\
    \ 0}\n    }\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpsulyriat_test.go:139:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075372
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots +=\
    \ number\n    carrots += need\n    carrots += remaining\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp465lejp9_test.go:100:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075372
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    var\
    \ result []int\n    if number > 1000 || need > 1000 || remaining > 1000 {\n  \
    \      fmt.Println(\"Invalid input\")\n    }\n    if number <= need {\n      \
    \  result = append(result, number)\n    } else {\n        result = append(result,\
    \ need)\n    }\n    if number > 0 {\n        result = append(result, number-need)\n\
    \    }\n    if remaining > 0 {\n        result = append(result, need-remaining)\n\
    \    }\n    return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmppepol1vw_test.go:63: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5)\
    \ %!s(int=-1) %!s(int=-4)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n     \
    \   tmppepol1vw_test.go:63: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4)\
    \ %!s(int=-4) %!s(int=-1)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n     \
    \   tmppepol1vw_test.go:63: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1)\
    \ %!s(int=-9) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n      \
    \  tmppepol1vw_test.go:63: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2)\
    \ %!s(int=-9) %!s(int=6)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n      \
    \  tmppepol1vw_test.go:63: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4)\
    \ %!s(int=-1) %!s(int=-2)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n     \
    \   tmppepol1vw_test.go:63: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4)\
    \ %!s(int=-1) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075373
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    meals := 0\n    for carrots < number {\n  \
    \      if carrots >= need {\n            meals++\n            carrots -= need\n\
    \        } else {\n            carrots += remaining\n        }\n    }\n    return\
    \ []int{meals, carrots}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpn3rris32_test.go:61: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=0)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpn3rris32_test.go:61:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=0) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpn3rris32_test.go:61: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=0) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpn3rris32_test.go:61: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=0) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpn3rris32_test.go:61: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=0)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpn3rris32_test.go:61:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=4)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075373
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    var\
    \ result []int\n    if number <= 0 {\n        return nil\n    }\n    if need <=\
    \ 0 {\n        return nil\n    }\n    if remaining <= 0 {\n        return nil\n\
    \    }\n    if number > need {\n        return nil\n    }\n    if number > remaining\
    \ {\n        number = remaining\n    }\n    if number > 0 {\n        result =\
    \ append(result, number)\n    }\n    if number < need {\n        number = need\n\
    \    }\n    if number < remaining {\n        number = remaining\n    }\n    if\
    \ number < 0 {\n        number = remaining\n    }\n    if number > 0 {\n     \
    \   result = append(result, number)\n    }\n    return result\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpzs215q24_test.go:79: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpzs215q24_test.go:79:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpzs215q24_test.go:79: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpzs215q24_test.go:79: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=2) %!s(int=11)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpzs215q24_test.go:79: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpzs215q24_test.go:79:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=5)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075373
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    if number < 0 || number > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n        return nil\n    }\n    if need < 0 || need > 1000 {\n\
    \        fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if remaining\
    \ < 0 || remaining > 1000 {\n        fmt.Println(\"Invalid input\")\n        return\
    \ nil\n    }\n    if number == 0 {\n        result[0] = 0\n        result[1] =\
    \ 0\n        return result\n    }\n    if need == 0 {\n        result[0] = 0\n\
    \        result[1] = 0\n        return result\n    }\n    if remaining == 0 {\n\
    \        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number > need {\n        fmt.Println(\"Invalid input\")\n     \
    \   return nil\n    }\n    if number > remaining {\n        fmt.Println(\"Invalid\
    \ input\")\n        return nil\n    }\n    if number == need {\n        result[0]\
    \ = number\n        result[1] = need\n        return result\n    }\n    if number\
    \ == remaining {\n        result[0] = number\n        result[1] = remaining\n\
    \        return result\n    }\n    if number > remaining {\n        result[0]\
    \ = number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ number == need {\n        result[0] = number\n        result[1] = need\n   \
    \     return result\n    }\n    if number == remaining {\n        result[0] =\
    \ number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ number > need {\n        result[0] = number\n        result[1] = need\n    \
    \    return result\n    }\n    if number > remaining {\n        result[0] = number\n\
    \        result[1] = remaining\n        return result\n    }\n    if number ==\
    \ need {\n        result[0] = number\n        result[1] = need\n        return\
    \ result\n    }\n    if number == remaining {\n        result[0] = number\n  \
    \      result[1] = remaining\n        return result\n    }\n    if number > need\
    \ {\n        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number > remaining {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number == need {\n       \
    \ result[0] = number\n        result[1] = need\n        return result\n    }\n\
    \    if number == remaining {\n        result[0] = number\n        result[1] =\
    \ remaining\n        return result\n    }\n    if number > need {\n        result[0]\
    \ = number\n        result[1] = need\n        return result\n    }\n    if number\
    \ > remaining {\n        result[0] = number\n        result[1] = remaining\n \
    \       return result\n    }\n    if number == need {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if number == remaining\
    \ {\n        result[0] = number\n        result[1] = remaining\n        return\
    \ result\n    }\n    if number > need {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number > remaining {\n        result[0]\
    \ = number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ number == need {\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n\
    \     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual:\
    \ candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp1vmq9r1a_test.go:160:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075372
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    if number < 0 || number > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n        return nil\n    }\n    if need < 0 || need > 1000 {\n\
    \        fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if remaining\
    \ < 0 || remaining > 1000 {\n        fmt.Println(\"Invalid input\")\n        return\
    \ nil\n    }\n    if number == 0 {\n        result[0] = 0\n        result[1] =\
    \ 0\n        return result\n    }\n    if need == 0 {\n        result[0] = 0\n\
    \        result[1] = 0\n        return result\n    }\n    if remaining == 0 {\n\
    \        result[0] = number\n        result[1] = number\n        return result\n\
    \    }\n    if number > need {\n        fmt.Println(\"Invalid input\")\n     \
    \   return nil\n    }\n    if number > remaining {\n        fmt.Println(\"Invalid\
    \ input\")\n        return nil\n    }\n    if number == need {\n        result[0]\
    \ = number\n        result[1] = number\n        return result\n    }\n    if number\
    \ == remaining {\n        result[0] = number\n        result[1] = number\n   \
    \     return result\n    }\n    if number > remaining {\n        fmt.Println(\"\
    Invalid input\")\n        return nil\n    }\n    if number == need {\n       \
    \ result[0] = number\n        result[1] = number\n        return result\n    }\n\
    \    if number == remaining {\n        result[0] = number\n        result[1] =\
    \ number\n        return result\n    }\n    if number > need {\n        fmt.Println(\"\
    Invalid input\")\n        return nil\n    }\n    if number == need {\n       \
    \ result[0] = number\n        result[1] = number\n        return result\n    }\n\
    \    if number == remaining {\n        result[0] = number\n        result[1] =\
    \ number\n        return result\n    }\n    if number > need {\n        fmt.Println(\"\
    Invalid input\")\n        return nil\n    }\n    if number == need {\n       \
    \ result[0] = number\n        result[1] = number\n        return result\n    }\n\
    \    if number == remaining {\n        result[0] = number\n        result[1] =\
    \ number\n        return result\n    }\n    if number > need {\n        fmt.Println(\"\
    Invalid input\")\n        return nil\n    }\n    if number == need {\n       \
    \ result[0] = number\n        result[1] = number\n        return result\n    }\n\
    \    if number == remaining {\n        result[0] = number\n        result[1] =\
    \ number\n        return result\n    }\n    if number > need {\n        fmt.Println(\"\
    Invalid input\")\n        return nil\n    }\n    if number == need {\n       \
    \ result[0] = number\n        result[1] = number\n        return result\n    }\n\
    \    if number == remaining {\n        result[0] = number\n        result[1] =\
    \ number\n        return result\n    }\n    if number > need {\n        fmt.Println(\"\
    Invalid input\")\n        return nil\n    }\n    if number == need {\n       \
    \ result[0] = number\n        result[1] = number\n        return result\n    }\n\
    \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpkuzb_f09_test.go:153:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075373
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    var carrots []int\n    if number\
    \ > need {\n        carrots = append(carrots, number)\n        number = need\n\
    \    } else {\n        carrots = append(carrots, 0)\n    }\n    if number > remaining\
    \ {\n        carrots = append(carrots, number)\n        number = remaining\n \
    \   } else {\n        carrots = append(carrots, 0)\n    }\n    return carrots\n\
    }\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpks2lltlm_test.go:64: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpks2lltlm_test.go:64:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=0) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpks2lltlm_test.go:64: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpks2lltlm_test.go:64: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpks2lltlm_test.go:64: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpks2lltlm_test.go:64:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=4)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075374
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number == 0 {\n        return []int{0, 0}\n    }\n    if need == 0 {\n     \
    \   return []int{number, 0}\n    }\n    if remaining == 0 {\n        return []int{0,\
    \ number}\n    }\n    if number > need {\n        return []int{0, number}\n  \
    \  }\n    if number > remaining {\n        return []int{number, 0}\n    }\n  \
    \  if number == need {\n        return []int{number, number}\n    }\n    if number\
    \ == remaining {\n        return []int{number, number}\n    }\n    if number >\
    \ remaining {\n        return []int{0, number}\n    }\n    if number > need {\n\
    \        return []int{0, number}\n    }\n    if number == 0 {\n        return\
    \ []int{0, number}\n    }\n    if number == need {\n        return []int{number,\
    \ 0}\n    }\n    if number == remaining {\n        return []int{number, number}\n\
    \    }\n    if number > need {\n        return []int{0, number}\n    }\n    if\
    \ number > remaining {\n        return []int{0, number}\n    }\n    if number\
    \ == 0 {\n        return []int{0, number}\n    }\n    if number == need {\n  \
    \      return []int{number, 0}\n    }\n    if number == remaining {\n        return\
    \ []int{number, number}\n    }\n    if number > need {\n        return []int{0,\
    \ number}\n    }\n    if number > remaining {\n        return []int{0, number}\n\
    \    }\n    if number == 0 {\n        return []int{0, number}\n    }\n    if number\
    \ == need {\n        return []int{number, 0}\n    }\n    if number == remaining\
    \ {\n        return []int{number, number}\n    }\n    if number > need {\n   \
    \     return []int{0, number}\n    }\n    if number > remaining {\n        return\
    \ []int{0, number}\n    }\n    if number == 0 {\n        return []int{0, number}\n\
    \    }\n    if number == need {\n        return []int{number, 0}\n    }\n    if\
    \ number == remaining {\n        return []int{number, number}\n    }\n    if number\
    \ > need {\n        return []int{0, number}\n    }\n    if number > remaining\
    \ {\n        return []int{0, number}\n    }\n    if number == 0 {\n        return\
    \ []int{0, number}\n    }\n    if number == need {\n        return []int{number,\
    \ 0}\n    }\n    if number == remaining {\n        return []int{number, number}\n\
    \    }\n    if number > need {\n        return []int{0, number}\n    }\n    if\
    \ number > remaining {\n        return []int{0, number}\n    }\n    if number\
    \ == 0 {\n        return []int{0, number}\n    }\n    if number == need {\n  \
    \      return []int{number, 0}\n    }\n    if number == remaining {\n        return\
    \ []int{number, number}\n    }\n    if number > \nfunc TestEat(t *testing.T) {\n\
    \  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected:\
    \ []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n\
    \     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual:\
    \ candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5,\
    \ 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5,\
    \ 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_ljjdzj7_test.go:139:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075373
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    if number < 0 || number > 1000 {\n        return nil\n    }\n    if\
    \ need < 0 || need > 1000 {\n        return nil\n    }\n    if remaining < 0 ||\
    \ remaining > 1000 {\n        return nil\n    }\n    if number == 0 {\n      \
    \  return nil\n    }\n    if number > need {\n        return nil\n    }\n    if\
    \ number > remaining {\n        carrots = number\n    } else {\n        carrots\
    \ = remaining\n    }\n    return []int{carrots, number-carrots}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpsg878fj2_test.go:69: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=-5)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpsg878fj2_test.go:69:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=-5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpsg878fj2_test.go:69: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=-9)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpsg878fj2_test.go:69: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=-3)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpsg878fj2_test.go:69: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=-3)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpsg878fj2_test.go:69:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075375
- exit_code: 2
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    if number < 0 || number > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n        return nil\n    }\n    if need < 0 || need > 1000 {\n\
    \        fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if remaining\
    \ < 0 || remaining > 1000 {\n        fmt.Println(\"Invalid input\")\n        return\
    \ nil\n    }\n    if number == 0 {\n        result[0] = 0\n        result[1] =\
    \ 0\n        return result\n    }\n    if remaining < need {\n        result[0]\
    \ = number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ number < need {\n        result[0] = number\n        result[1] = need\n    \
    \    return result\n    }\n    if number > need {\n        result[0] = need\n\
    \        result[1] = number\n        return result\n    }\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpk4s7ykkt_test.go:60:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075374
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots += need\n  \
    \  carrots += remaining\n    carrots -= (number + need)\n    carrots -= (remaining\
    \ + number)\n    carrots -= (number + need + remaining)\n    carrots -= (number\
    \ + need + remaining + number)\n    carrots -= (number + need + remaining + number)\n\
    \    carrots -= (number + need + remaining + number)\n    carrots -= (number +\
    \ need + remaining + number)\n    carrots -= (number + need + remaining + number)\n\
    \    carrots -= (number + need + remaining + number)\n    carrots -= (number +\
    \ need + remaining + number)\n    carrots -= (number + need + remaining + number)\n\
    \    carrots -= (number + need + remaining + number)\n    carrots -= (number +\
    \ need + remaining + number)\n    carrots -= (number + need + remaining + number)\n\
    \    carrots -= (number + need + remaining + number)\n    carrots -= (number +\
    \ need + remaining + number)\n    carrots -= (number + need + remaining + number)\n\
    \    carrots -= (number + need + remaining + number)\n    carrots -= (number +\
    \ need + remaining + number)\n    carrots -= (number + need + remaining + number)\n\
    \    carrots -= (number + need + remaining + number)\n    carrots -= (number +\
    \ need + remaining + number)\n    carrots -= (number + need + remaining + number)\n\
    \    carrots -= (number + need + remaining + number)\n    carrots -= (number +\
    \ need + remaining + number)\n    carrots -= (number + need + remaining + number)\n\
    \    carrots -= (number + need + remaining + number)\n    carrots -= (number +\
    \ need + remaining + number)\n    carrots -= (number + need + remaining + number)\n\
    \    carrots -= (number + need + remaining + number)\n    carrots -= (number +\
    \ need + remaining + number)\n    carrots -= (number + need + remaining + number)\n\
    \    carrots -= (number + need + remaining + number)\n    carrots -= (number +\
    \ need + \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_5kwesgj_test.go:68:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075373
- exit_code: 2
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    if number < 0 || number > 1000 || need < 0 || need >\
    \ 1000 || remaining < 0 || remaining > 1000 {\n        fmt.Println(\"Invalid input\"\
    )\n    }\n    if number == 0 {\n        result[0] = 0\n        result[1] = 0\n\
    \        return result\n    }\n    if remaining == 0 {\n        result[0] = number\n\
    \        result[1] = 0\n        return result\n    }\n    if number > remaining\
    \ {\n        result[0] = number\n        result[1] = remaining\n        return\
    \ result\n    }\n    if need > remaining {\n        result[0] = remaining\n  \
    \      result[1] = need\n        return result\n    }\n    if number == need {\n\
    \        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number > need {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number == remaining {\n       \
    \ result[0] = number\n        result[1] = remaining\n        return result\n \
    \   }\n    if number > remaining {\n        result[0] = remaining\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number == 0 {\n        result[0]\
    \ = 0\n        result[1] = 0\n        return result\n    }\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzqtigoa4_test.go:76:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075374
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ write your code here\n    result := make([]int, 2)\n    carrots := 0\n    for\
    \ carrots < need {\n        if carrots >= number {\n            result[0] = carrots\n\
    \            result[1] = remaining\n            return result\n        }\n   \
    \     carrots += number\n        remaining -= number\n    }\n    result[0] = carrots\n\
    \    result[1] = remaining\n    return result\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpx9aer3iz_test.go:62: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5)\
    \ %!s(int=5)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpx9aer3iz_test.go:62:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpx9aer3iz_test.go:62: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpx9aer3iz_test.go:62: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=2) %!s(int=3)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpx9aer3iz_test.go:62: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4)\
    \ %!s(int=3)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpx9aer3iz_test.go:62:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=-3)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075375
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ Your code here\n    carrots := 0\n    carrots = number - need\n    carrots =\
    \ carrots + remaining\n    carrots = carrots + 1\n    carrots = carrots + 1\n\
    \    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots +\
    \ 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrot\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn3wkhkt__test.go:85:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075373
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    carrots = number\n    carrots = carrots - need\n    carrots = carrots\
    \ - remaining\n    carrots = carrots + need\n    carrots = carrots + remaining\n\
    \    return []int{carrots, remaining}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpiuomtdqv_test.go:54: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpiuomtdqv_test.go:54:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpiuomtdqv_test.go:54: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpiuomtdqv_test.go:54: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=2) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpiuomtdqv_test.go:54: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpiuomtdqv_test.go:54:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075375
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    var\
    \ result []int\n    if number < 0 || number > 1000 || need < 0 || need > 1000\
    \ || remaining < 0 || remaining > 1000 {\n        fmt.Println(\"Invalid input\"\
    )\n    }\n    if number == 0 {\n        result = append(result, 0)\n    } else\
    \ {\n        var carrots int\n        if number > need {\n            carrots\
    \ = number\n        } else {\n            carrots = need\n        }\n        if\
    \ carrots > remaining {\n            carrots = remaining\n        }\n        result\
    \ = append(result, carrots)\n    }\n    return result\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp8f7k7mrn_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)]'\n\
    \    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp8f7k7mrn_test.go:66: expected\
    \ '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8)]'\n    --- FAIL: TestEat/test_num__2\
    \ (0.00s)\n        tmp8f7k7mrn_test.go:66: expected '[%!s(int=11) %!s(int=0)]',\
    \ got '[%!s(int=10)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmp8f7k7mrn_test.go:66:\
    \ expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=5)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp8f7k7mrn_test.go:66: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=5)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp8f7k7mrn_test.go:66:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075375
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    var\
    \ carrots []int\n    var hungry bool\n    var eaten int\n    var carrots_left\
    \ int\n    var meals_left int\n    var meals_eaten int\n    var meals_left int\n\
    \    var meals_eaten int\n    var meals_left int\n    var meals_eaten int\n  \
    \  var meals_left int\n    var meals_eaten int\n    var meals_left int\n    var\
    \ meals_eaten int\n    var meals_left int\n    var meals_eaten int\n    var meals_left\
    \ int\n    var meals_eaten int\n    var meals_left int\n    var meals_eaten int\n\
    \    var meals_left int\n    var meals_eaten int\n    var meals_left int\n   \
    \ var meals_eaten int\n    var meals_left int\n    var meals_eaten int\n    var\
    \ meals_left int\n    var meals_eaten int\n    var meals_left int\n    var meals_eaten\
    \ int\n    var meals_left int\n    var meals_eaten int\n    var meals_left int\n\
    \    var meals_eaten int\n    var meals_left int\n    var meals_eaten int\n  \
    \  var meals_left int\n    var meals_eaten int\n    var meals_left int\n    var\
    \ meals_eaten int\n    var meals_left int\n    var meals_eaten int\n    var meals_left\
    \ int\n    var meals_eaten int\n    var meals_left int\n    var meals_eaten int\n\
    \    var meals_left int\n    var meals_eaten int\n    var meals_left int\n   \
    \ var meals_eaten int\n    var meals_left int\n    var meals_eaten int\n    var\
    \ meals_left int\n    var meals_eaten int\n    var meals_left int\n    var meals_eaten\
    \ int\n    var meals_left int\n    var meals_eaten int\n    var meals_left int\n\
    \    var meals_eaten int\n    var meals_left int\n    var meals_eaten int\n  \
    \  var meals_left int\n    var meals_eaten int\n    var meals_left int\n    var\
    \ meals_eaten int\n    var meals_left int\n    var meals_eaten int\n    var meals_left\
    \ int\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpt6u9dpr1_test.go:96:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075373
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 {\n        return []int{0, 0}\n    }\n    if need\
    \ < 0 || need > 1000 {\n        return []int{0, 0}\n    }\n    if remaining <\
    \ 0 || remaining > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n\
    \    carrots += number\n    carrots += need\n    carrots -= remaining\n    if\
    \ carrots < 0 {\n        carrots = 0\n    }\n    return []int{carrots, remaining}\n\
    }\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp4a65j9ag_test.go:64: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=1)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp4a65j9ag_test.go:64:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=3) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp4a65j9ag_test.go:64: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp4a65j9ag_test.go:64: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=8) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp4a65j9ag_test.go:64: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=2)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp4a65j9ag_test.go:64:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=8) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075376
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    return []int{carrots,\
    \ carrots - carrots % 1000}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate :=\
    \ eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpbymp6tml_test.go:55: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=21)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpbymp6tml_test.go:55:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=21) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpbymp6tml_test.go:55: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=21) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpbymp6tml_test.go:55: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=18) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpbymp6tml_test.go:55: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=16)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpbymp6tml_test.go:55:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075376
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots +=\
    \ number\n    carrots += need\n    if carrots > remaining {\n        carrots =\
    \ remaining\n    }\n    return []int{carrots, remaining}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpjlpij576_test.go:57: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpjlpij576_test.go:57:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpjlpij576_test.go:57: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpjlpij576_test.go:57: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpjlpij576_test.go:57: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpjlpij576_test.go:57:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075376
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ Your code here\n    carrots := 0\n    carrots = number - need\n    if carrots\
    \ < 0 {\n        carrots = 0\n    }\n    if carrots > remaining {\n        carrots\
    \ = remaining\n    }\n    carrots = carrots + 1\n    carrots = carrots + 1\n \
    \   carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots +\
    \ 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = car\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp2cmcgrr2_test.go:88:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075375
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots +=\
    \ number\n    carrots += need\n    carrots += remaining\n    if carrots > 1000\
    \ {\n        carrots = 1000\n    }\n    carrots = carrots - number\n    carrots\
    \ = carrots - need\n    carrots = carrots - remaining\n    if carrots < 0 {\n\
    \        carrots = 0\n    }\n    carrots = carrots / 2\n    carrots = carrots\
    \ * 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots\
    \ * 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots\
    \ * 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots\
    \ * 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots\
    \ * 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots\
    \ * 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots\
    \ * 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots\
    \ * 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots\
    \ * 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots\
    \ * 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots\
    \ * 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots\
    \ * 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots\
    \ * 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots\
    \ * 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots\
    \ * 2\n    carrots = car\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpkatsavfe_test.go:88:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075375
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    if number < 0 || number > 1000 || need < 0 || need >\
    \ 1000 || remaining < 0 || remaining > 1000 {\n        fmt.Println(\"Invalid input\"\
    )\n    }\n    if number == 0 {\n        result[0] = 0\n        result[1] = 0\n\
    \        return result\n    }\n    if need == 0 {\n        result[0] = number\n\
    \        result[1] = 0\n        return result\n    }\n    if remaining == 0 {\n\
    \        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number > need {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number > remaining {\n        result[0]\
    \ = number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ need > remaining {\n        result[0] = need\n        result[1] = remaining\n\
    \        return result\n    }\n    if number == need {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if number == remaining\
    \ {\n        result[0] = number\n        result[1] = remaining\n        return\
    \ result\n    }\n    if need == remaining {\n        result[0] = need\n      \
    \  result[1] = remaining\n        return result\n    }\n    if number > need {\n\
    \        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number > remaining {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if need > remaining {\n     \
    \   result[0] = need\n        result[1] = remaining\n        return result\n \
    \   }\n    if number == need {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number == remaining {\n       \
    \ result[0] = number\n        result[1] = remaining\n        return result\n \
    \   }\n    if need == remaining {\n        result[0] = need\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number > need {\n        result[0]\
    \ = number\n        result[1] = need\n        return result\n    }\n    if number\
    \ > remaining {\n        result[0] = number\n        result[1] = remaining\n \
    \       return result\n    }\n    if need > remaining {\n        result[0] = need\n\
    \        result[1] = remaining\n        return result\n    }\n    if number ==\
    \ need {\n        result[0] = number\n        result[1] = need\n        return\
    \ result\n    }\n    if number == remaining {\n        result[0] = number\n  \
    \      result[1] = remaining\n        return result\n    }\n    if need == remaining\
    \ {\n        result[0] = need\n        result[1] = remaining\n        return result\n\
    \    }\n    if number > need {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number > remaining {\n        result[0]\
    \ = number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ need > remaining {\n        result[0] = need\n        result[1] = remaining\n\
    \        return result\n    }\n    if number == need {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if number == remaining\
    \ {\n        result[0] = number\n        result[1] = remaining\n        return\
    \ result\n    }\n    if need == remaining {\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp96iohasy_test.go:162:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075375
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || need < 0 || remaining < 0 {\n        return []int{0, 0}\n    }\n\
    \    carrots := 0\n    carrots = number\n    carrots = carrots - need\n    carrots\
    \ = carrots - remaining\n    carrots = carrots + need\n    carrots = carrots +\
    \ remaining\n    carrots = carrots + need\n    carrots = carrots + remaining\n\
    \    carrots = carrots + need\n    carrots = carrots + remaining\n    carrots\
    \ = carrots + need\n    carrots = carrots + remaining\n    carrots = carrots +\
    \ need\n    carrots = carrots + remaining\n    carrots = carrots + need\n    carrots\
    \ = carrots + remaining\n    carrots = carrots + need\n    carrots = carrots +\
    \ remaining\n    carrots = carrots + need\n    carrots = carrots + remaining\n\
    \    carrots = carrots + need\n    carrots = carrots + remaining\n    carrots\
    \ = carrots + need\n    carrots = carrots + remaining\n    carrots = carrots +\
    \ need\n    carrots = carrots + remaining\n    carrots = carrots + need\n    carrots\
    \ = carrots + remaining\n    carrots = carrots + need\n    carrots = carrots +\
    \ remaining\n    carrots = carrots + need\n    carrots = carrots + remaining\n\
    \    carrots = carrots + need\n    carrots = carrots + remaining\n    carrots\
    \ = carrots + need\n    carrots = carrots + remaining\n    carrots = carrots +\
    \ need\n    carrots = carrots + remaining\n    carrots = carrots + need\n    carrots\
    \ = carrots + remaining\n    carrots = carrots + need\n    carrots = carrots +\
    \ remaining\n    carrots = carrots + need\n    carrots = carrots + remaining\n\
    \    carrots = carrots + need\n    carrots = carrots + remaining\n    carrots\
    \ = carrots + need\n    carrots = carrots + remaining\n    carrots = carrots +\
    \ need\n    carrots = carrots + remaining\n    carrots = carrots + need\n    carrots\
    \ = carrots + remaining\n    carrots = carrots + need\n    carrots = carrots +\
    \ remaining\n    carrots = carrots + need\n    carrot\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpiu6vobz9_test.go:86:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075375
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || need < 0 || remaining < 0 {\n        return []int{0, 0}\n    }\n\
    \    carrots := 0\n    if number < need {\n        carrots = number\n    } else\
    \ {\n        carrots = need\n    }\n    if carrots > remaining {\n        carrots\
    \ = remaining\n    }\n    carrots = carrots + number\n    carrots = carrots +\
    \ number\n    carrots = carrots + number\n    carrots = carrots + number\n   \
    \ carrots = carrots + number\n    carrots = carrots + number\n    carrots = carrots\
    \ + number\n    carrots = carrots + number\n    carrots = carrots + number\n \
    \   carrots = carrots + number\n    carrots = carrots + number\n    carrots =\
    \ carrots + number\n    carrots = carrots + number\n    carrots = carrots + number\n\
    \    carrots = carrots + number\n    carrots = carrots + number\n    carrots =\
    \ carrots + number\n    carrots = carrots + number\n    carrots = carrots + number\n\
    \    carrots = carrots + number\n    carrots = carrots + number\n    carrots =\
    \ carrots + number\n    carrots = carrots + number\n    carrots = carrots + number\n\
    \    carrots = carrots + number\n    carrots = carrots + number\n    carrots =\
    \ carrots + number\n    carrots = carrots + number\n    carrots = carrots + number\n\
    \    carrots = carrots + number\n    carrots = carrots + number\n    carrots =\
    \ carrots + number\n    carrots = carrots + number\n    carrots = carrots + number\n\
    \    carrots = carrots + number\n    carrots = carrots + number\n    carrots =\
    \ carrots + number\n    carrots = carrots + number\n    carrots = carrots + number\n\
    \    carrots = carrots + number\n    carrots = carrots + number\n    carrots =\
    \ carrots + number\n    carrots = carrots + number\n    carrots = carrots + number\n\
    \    carrots = carrots + number\n    carrots = carrots + number\n    carrots =\
    \ carrots + number\n    carrots = carrots + number\n    carrots = carrots + number\n\
    \    carrots = carrots + number\nfunc TestEat(t *testing.T) {\n  candidate :=\
    \ eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpysan49mj_test.go:89:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075375
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    if carrots > 1000 {\n        carrots = 1000\n    }\n    if carrots < 0 {\n\
    \        carrots = 0\n    }\n    carrots = carrots / 2\n    carrots = carrots\
    \ * 2\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpl85ai8q0_test.go:89:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075375
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 {\n        return []int{0, 0}\n    }\n    if need\
    \ < 0 || need > 1000 {\n        return []int{0, 0}\n    }\n    if remaining <\
    \ 0 || remaining > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n\
    \    carrots += number\n    carrots += need\n    carrots += remaining\n    if\
    \ carrots > 1000 {\n        carrots = 1000\n    }\n    if carrots < 0 {\n    \
    \    carrots = 0\n    }\n    return []int{carrots, carrots - carrots}\n}\n\nfunc\
    \ TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpjl4qhcpc_test.go:67: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=21)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpjl4qhcpc_test.go:67:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=21) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpjl4qhcpc_test.go:67: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=21) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpjl4qhcpc_test.go:67: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=18) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpjl4qhcpc_test.go:67: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=16)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpjl4qhcpc_test.go:67:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075376
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots +=\
    \ number\n    carrots += need\n    carrots += remaining\n    return []int{carrots,\
    \ carrots - number}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpp69eq_2u_test.go:55: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=21)\
    \ %!s(int=16)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpp69eq_2u_test.go:55:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=21) %!s(int=17)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpp69eq_2u_test.go:55: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=21) %!s(int=20)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpp69eq_2u_test.go:55: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=18) %!s(int=16)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpp69eq_2u_test.go:55: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=16)\
    \ %!s(int=12)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpp69eq_2u_test.go:55:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=10) %!s(int=6)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075376
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots += number\n    carrots += need\n    carrots += remaining\n    carrots\
    \ += number\n    carrots += need\n    carrots += remaining\n    carrots += number\n\
    \    carrots += need\n    carrots += remaining\n    carrots += number\n    carrots\
    \ += need\n    carrots += remaining\n    carrots += number\n    carrots += need\n\
    \    carrots += remaining\n    carrots += number\n    carrots += need\n    carrots\
    \ += remaining\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots += number\n    carrots += need\n    carrots += remaining\n    carrots\
    \ += number\n    carrots += need\n    carrots += remaining\n    carrots += number\n\
    \    carrots += need\n    carrots += remaining\n    carrots += number\n    carrots\
    \ += need\n    carrots += remaining\n    carrots += number\n    carrots += need\n\
    \    carrots += remaining\n    carrots += number\n    carrots += need\n    carrots\
    \ += remaining\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots += number\n    carrots += need\n    carrots += remaining\n    carrots\
    \ += number\n    carrots += need\n    carrots += remaining\n    carrots += number\n\
    \    carrots += need\n    carrots += remaining\n    carrots += number\n    carrots\
    \ += need\n    carrots += remaining\n    carrots += number\n    carrots += need\n\
    \    carrots += remaining\n    carrots += number\n    carrots += need\n    carrots\
    \ += remaining\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots += number\n    carrots += need\n    carrots += remaining\n    carrots\
    \ += number\n    carrots += need\n    carrots += remaining\n    carrots += number\n\
    \    carrots += need\n    carrots += remaining\n    carrots += number\n    carrots\
    \ += need\n    carrots += remaining\n    carrots += number\n    carrots += need\n\
    \    carrots += remaining\n    carrots += number\n    carrots += need\n    carrots\
    \ += remaining\n    \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n\
    \     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual:\
    \ candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxt7vvloc_test.go:113:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075375
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots +=\
    \ number\n    carrots += need\n    carrots += remaining\n    if carrots < 0 {\n\
    \        carrots = 0\n    }\n    if carrots > 1000 {\n        carrots = 1000\n\
    \    }\n    carrots = carrots / 3\n    carrots = carrots * 3\n    carrots = carrots\
    \ + 1\n    carrots = carrots / 3\n    carrots = carrots * 3\n    carrots = carrots\
    \ + 1\n    carrots = carrots / 3\n    carrots = carrots * 3\n    carrots = carrots\
    \ + 1\n    carrots = carrots / 3\n    carrots = carrots * 3\n    carrots = carrots\
    \ + 1\n    carrots = carrots / 3\n    carrots = carrots * 3\n    carrots = carrots\
    \ + 1\n    carrots = carrots / 3\n    carrots = carrots * 3\n    carrots = carrots\
    \ + 1\n    carrots = carrots / 3\n    carrots = carrots * 3\n    carrots = carrots\
    \ + 1\n    carrots = carrots / 3\n    carrots = carrots * 3\n    carrots = carrots\
    \ + 1\n    carrots = carrots / 3\n    carrots = carrots * 3\n    carrots = carrots\
    \ + 1\n    carrots = carrots / 3\n    carrots = carrots * 3\n    carrots = carrots\
    \ + 1\n    carrots = carrots / 3\n    carrots = carrots * 3\n    carrots = carrots\
    \ + 1\n    carrots = carrots / 3\n    carrots = carrots * 3\n    carrots = carrots\
    \ + 1\n    carrots = carrots / 3\n    carrots = carrots * 3\n    carrots = carrots\
    \ + 1\n    carrots = carrots / 3\n    carrots = carrots * 3\n    carrots = carrots\
    \ + 1\n    carrots = carrots / 3\n    carrots = carrots * 3\n    carrots = carrots\
    \ + 1\n    carrots = carrots / 3\n    carrots = carrots * 3\n    carrots = car\n\
    func TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8xi3ficr_test.go:88:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075375
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    carrots = number - need\n    if carrots < 0 {\n        carrots = 0\n\
    \    }\n    if carrots > remaining {\n        carrots = remaining\n    }\n   \
    \ return []int{carrots, remaining}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpe_vmya84_test.go:56: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=0)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpe_vmya84_test.go:56:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=0) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpe_vmya84_test.go:56: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=0) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpe_vmya84_test.go:56: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=0) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpe_vmya84_test.go:56: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=0)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpe_vmya84_test.go:56:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075373
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    if number <= 0 {\n        fmt.Println(\"Invalid input\"\
    )\n        return nil\n    }\n    if need <= 0 {\n        fmt.Println(\"Invalid\
    \ input\")\n        return nil\n    }\n    if remaining <= 0 {\n        fmt.Println(\"\
    Invalid input\")\n        return nil\n    }\n    if number > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n        return nil\n    }\n    if need > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n        return nil\n    }\n    if remaining > 1000 {\n     \
    \   fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if number <\
    \ need {\n        fmt.Println(\"Invalid input\")\n        return nil\n    }\n\
    \    if number == need {\n        result[0] = number\n        result[1] = remaining\n\
    \        return result\n    }\n    if number > need {\n        fmt.Println(\"\
    Invalid input\")\n        return nil\n    }\n    if number == 0 {\n        result[0]\
    \ = number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ number > 0 {\n        result[0] = number\n        result[1] = remaining\n  \
    \  }\n    return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Invalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid input\n\
    Invalid input\n--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpzb457468_test.go:95: expected '[%!s(int=11) %!s(int=4)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpzb457468_test.go:95: expected\
    \ '[%!s(int=12) %!s(int=1)]', got '[]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n\
    \        tmpzb457468_test.go:95: expected '[%!s(int=11) %!s(int=0)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmpzb457468_test.go:95: expected\
    \ '[%!s(int=7) %!s(int=0)]', got '[]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpzb457468_test.go:95: expected '[%!s(int=9) %!s(int=2)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpzb457468_test.go:95: expected\
    \ '[%!s(int=5) %!s(int=0)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660075376
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots +=\
    \ number\n    carrots += need\n    carrots += remaining\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp465lejp9_test.go:100:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075372
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    if number < 0 || number > 1000 || need < 0 || need >\
    \ 1000 || remaining < 0 || remaining > 1000 {\n        fmt.Println(\"Invalid input\"\
    )\n        return nil\n    }\n    if number == 0 {\n        result[0] = 0\n  \
    \      result[1] = 0\n        return result\n    }\n    if need == 0 {\n     \
    \   result[0] = number\n        result[1] = 0\n        return result\n    }\n\
    \    if remaining == 0 {\n        result[0] = number\n        result[1] = need\n\
    \        return result\n    }\n    if number > need {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if number > remaining\
    \ {\n        result[0] = number\n        result[1] = remaining\n        return\
    \ result\n    }\n    if need > remaining {\n        result[0] = need\n       \
    \ result[1] = remaining\n        return result\n    }\n    if number == need {\n\
    \        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number == remaining {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if need == remaining {\n    \
    \    result[0] = need\n        result[1] = remaining\n        return result\n\
    \    }\n    if number > need {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number > remaining {\n        result[0]\
    \ = number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ need > remaining {\n        result[0] = need\n        result[1] = remaining\n\
    \        return result\n    }\n    if number == need {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if number == remaining\
    \ {\n        result[0] = number\n        result[1] = remaining\n        return\
    \ result\n    }\n    if need == remaining {\n        result[0] = need\n      \
    \  result[1] = remaining\n        return result\n    }\n    if number > need {\n\
    \        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number > remaining {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if need > remaining {\n     \
    \   result[0] = need\n        result[1] = remaining\n        return result\n \
    \   }\n    if number == need {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number == remaining {\n       \
    \ result[0] = number\n        result[1] = remaining\n        return result\n \
    \   }\n    if need == remaining {\n        result[0] = need\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number > need {\n        result[0]\
    \ = number\n        result[1] = need\n        return result\n    }\n    if number\
    \ > remaining {\n        result[0] = number\n        result[1] = remaining\n \
    \       return result\n    }\n    if need > remaining {\n        result[0] = need\n\
    \        result[1] = remaining\n        return result\n    }\n    if number ==\
    \ need {\n        result[0] = number\n        result[1] = need\n        return\
    \ result\n    }\n    if number == remaining {\n        result[0] = number\n  \
    \      result[1] = remaining\n        return result\n    }\n    if need \nfunc\
    \ TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmprs656ulj_test.go:163:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075375
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots += need\n  \
    \  carrots += remaining\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrot\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpj7j3y1th_test.go:101:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075375
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ Your code here\n    carrots := 0\n    carrots = number\n    carrots = carrots\
    \ - need\n    carrots = carrots - remaining\n    carrots = carrots + need\n  \
    \  carrots = carrots + remaining\n    carrots = carrots + need\n    carrots =\
    \ carrots + remaining\n    carrots = carrots + need\n    carrots = carrots + remaining\n\
    \    carrots = carrots + need\n    carrots = carrots + remaining\n    carrots\
    \ = carrots + need\n    carrots = carrots + remaining\n    carrots = carrots +\
    \ need\n    carrots = carrots + remaining\n    carrots = carrots + need\n    carrots\
    \ = carrots + remaining\n    carrots = carrots + need\n    carrots = carrots +\
    \ remaining\n    carrots = carrots + need\n    carrots = carrots + remaining\n\
    \    carrots = carrots + need\n    carrots = carrots + remaining\n    carrots\
    \ = carrots + need\n    carrots = carrots + remaining\n    carrots = carrots +\
    \ need\n    carrots = carrots + remaining\n    carrots = carrots + need\n    carrots\
    \ = carrots + remaining\n    carrots = carrots + need\n    carrots = carrots +\
    \ remaining\n    carrots = carrots + need\n    carrots = carrots + remaining\n\
    \    carrots = carrots + need\n    carrots = carrots + remaining\n    carrots\
    \ = carrots + need\n    carrots = carrots + remaining\n    carrots = carrots +\
    \ need\n    carrots = carrots + remaining\n    carrots = carrots + need\n    carrots\
    \ = carrots + remaining\n    carrots = carrots + need\n    carrots = carrots +\
    \ remaining\n    carrots = carrots + need\n    carrots = carrots + remaining\n\
    \    carrots = carrots + need\n    carrots = carrots + remaining\n    carrots\
    \ = carrots + need\n    carrots = carrots + remaining\n    carrots = carrots +\
    \ need\n    carrots = carrots + remaining\n    carrots = carrots + need\n    carrots\
    \ = carrots + remaining\n    carrots = carrots + need\n    carrots = carrots +\
    \ remaining\n    carrots = carrots + need\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6xpp6jbz_test.go:85:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075375
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || number < 0 {\n        return []int{0, 0}\n    }\n    if need\
    \ > 1000 || need < 0 {\n        return []int{0, 0}\n    }\n    if remaining >\
    \ 1000 || remaining < 0 {\n        return []int{0, 0}\n    }\n    if number ==\
    \ 0 {\n        return []int{0, 0}\n    }\n    if need == 0 {\n        return []int{number,\
    \ 0}\n    }\n    if remaining == 0 {\n        return []int{number, 0}\n    }\n\
    \    if number < need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots += number\n\
    \    carrots += need\n    carrots += remaining\n    carrots += number\n    carrots\
    \ += need\n    carrots += remaining\n    carrots += number\n    carrots += need\n\
    \    carrots += remaining\n    carrots += number\n    carrots += need\n    carrots\
    \ += remaining\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots += number\n    carrots += need\n    carrots += remaining\n    carrots\
    \ += number\n    carrots += need\n    carrots += remaining\n    carrots += number\n\
    \    carrots += need\n    carrots += remaining\n    carrots += number\n    carrots\
    \ += need\n    carrots += remaining\n    carrots += number\n    carrots += need\n\
    \    carrots += remaining\n    carrots += number\n    carrots += need\n    carrots\
    \ += remaining\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots += number\n    carrots += need\n    carrots += remaining\n    carrots\
    \ += number\n    carrots += need\n    carrots += remaining\n    carrots += number\n\
    \    carrots += need\n    carrots += remaining\n    carrots += number\n    carrots\
    \ += need\n    carrots += remaining\n    carrots += number\n    carrots += need\n\
    \    carrots += remaining\n    carrots += number\n    carrots += need\n    carrots\
    \ += remaining\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots += number\n    carrots += need\n    carrots += remaining\n    carrots\
    \ += number\n    carrots += need\n    carrots += remaining\n    carrots += number\n\
    \    carrot\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpskl1k1_w_test.go:117:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075375
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number == 0 {\n        return []int{0, 0}\n    }\n    if number < 0 {\n    \
    \    return []int{0, 0}\n    }\n    if need < 0 {\n        return []int{0, 0}\n\
    \    }\n    if remaining < 0 {\n        return []int{0, 0}\n    }\n    if number\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    if need > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    if remaining > 1000 {\n        return []int{0, 0}\n\
    \    }\n    if number == need {\n        return []int{number, 0}\n    }\n    if\
    \ number > need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if number == remaining {\n       \
    \ return []int{number, 0}\n    }\n    if number > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if number == remaining {\n        return []int{number,\
    \ 0}\n    }\n    if number > remaining {\n        return []int{0, 0}\n    }\n\
    \    if number == remaining {\n        return []int{number, 0}\n    }\n    if\
    \ number > remaining {\n        return []int{0, 0}\n    }\n    if number == remaining\
    \ {\n        return []int{number, 0}\n    }\n    if number > remaining {\n   \
    \     return []int{0, 0}\n    }\n    if number == remaining {\n        return\
    \ []int{number, 0}\n    }\n    if number > remaining {\n        return []int{0,\
    \ 0}\n    }\n    if number == remaining {\n        return []int{number, 0}\n \
    \   }\n    if number > remaining {\n        return []int{0, 0}\n    }\n    if\
    \ number == remaining {\n        return []int{number, 0}\n    }\n    if number\
    \ > remaining {\n        return []int{0, 0}\n    }\n    if number == remaining\
    \ {\n        return []int{number, 0}\n    }\n    if number > remaining {\n   \
    \     return []int{0, 0}\n    }\n    if number == remaining {\n        return\
    \ []int{number, 0}\n    }\n    if number > remaining {\n        return []int{0,\
    \ 0}\n    }\n    if number == remaining {\n        return []int{number, 0}\n \
    \   }\n    if number > remaining {\n        return []int{0, 0}\n    }\n    if\
    \ number == remaining {\n        return []int{number, 0}\n    }\n    if number\
    \ > remaining {\n        return []int{0, 0}\n    }\n    if number == remaining\
    \ {\n        return []int{number, 0}\n    }\n    if number > remaining {\n   \
    \     return []int{0, 0}\n    }\n    if number == remaining {\n        return\
    \ []int{number, 0}\n    }\n    if number > remaining {\n        return []int{0,\
    \ 0}\n    }\n    if number == remaining {\n        return []int{number, 0}\n\n\
    func TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4g9dv1es_test.go:138:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075376
- exit_code: 2
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    if number > 1000 || need > 1000 || remaining > 1000 {\n\
    \        fmt.Println(\"Invalid input\")\n    }\n    if number == 0 {\n       \
    \ result[0] = 0\n        result[1] = 0\n        return result\n    }\n    if remaining\
    \ == 0 {\n        result[0] = number\n        result[1] = need\n        return\
    \ result\n    }\n    if number < need {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number > remaining {\n        result[0]\
    \ = number\n        result[1] = remaining\n        return result\n    }\n    carrots\
    \ := 0\n    if number > need {\n        carrots = number - need\n    }\n    if\
    \ carrots > 0 {\n        result[0] = carrots\n        result[1] = number\n   \
    \     return result\n    }\n    if number < remaining {\n        carrots = remaining\
    \ - number\n    }\n    if carrots > 0 {\n        result[0] = carrots\n       \
    \ result[1] = remaining\n        return result\n    }\n    if number == remaining\
    \ {\n        carrots = number - remaining\n    }\n    if carrots > 0 {\n     \
    \   result[0] = carrots\n        result[1] = number\n        return result\n \
    \   }\n    if number == 0 {\n        result[0] = 0\n        result[1] = 0\n  \
    \      return result\n    }\n}\n\nfunc TestEat(t *testing.T) {\n  candidate :=\
    \ eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpd0ekf5jm_test.go:81:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075376
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ Your code here\n    carrots := 0\n    carrots += number\n    carrots += need\n\
    \    carrots += remaining\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpk90x9nqa_test.go:101:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075372
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    \n    carrots := 0\n    carrots\
    \ += number\n    carrots += need\n    carrots += remaining\n    \n    carrots\
    \ = carrots % 100\n    \n    if carrots == 0 {\n        carrots = 100\n    }\n\
    \    \n    return []int{carrots, carrots - carrots % 100}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpyb9f01oh_test.go:63: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=21)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpyb9f01oh_test.go:63:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=21) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpyb9f01oh_test.go:63: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=21) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpyb9f01oh_test.go:63: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=18) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpyb9f01oh_test.go:63: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=16)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpyb9f01oh_test.go:63:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075377
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots +=\
    \ number\n    carrots += need\n    carrots += remaining\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp465lejp9_test.go:100:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075372
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    if number < 0 || number > 1000 {\n        fmt.Println(\"Invalid input\"\
    )\n        return []int{}\n    }\n    if need < 0 || need > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n        return []int{}\n    }\n    if remaining < 0 || remaining\
    \ > 1000 {\n        fmt.Println(\"Invalid input\")\n        return []int{}\n \
    \   }\n    if number == 0 {\n        return []int{0, 0}\n    }\n    if number\
    \ == need {\n        return []int{number, 0}\n    }\n    if number > need {\n\
    \        return []int{0, 0}\n    }\n    if remaining == 0 {\n        return []int{number,\
    \ 0}\n    }\n    if remaining == need {\n        return []int{number, 0}\n   \
    \ }\n    if remaining > need {\n        return []int{0, 0}\n    }\n    if number\
    \ > remaining {\n        carrots = number\n    }\n    if number < remaining {\n\
    \        carrots = remaining\n    }\n    if carrots == 0 {\n        return []int{number,\
    \ 0}\n    }\n    if carrots == number {\n        return []int{number, 0}\n   \
    \ }\n    if carrots == remaining {\n        return []int{number, 0}\n    }\n \
    \   if carrots > remaining {\n        carrots = remaining\n    }\n    if carrots\
    \ < number {\n        carrots = number\n    }\n    if carrots == 0 {\n       \
    \ return []int{number, 0}\n    }\n    if carrots == number {\n        return []int{number,\
    \ 0}\n    }\n    if carrots == remaining {\n        return []int{number, 0}\n\
    \    }\n    if carrots > remaining {\n        carrots = remaining\n    }\n   \
    \ if carrots < number {\n        carrots = number\n    }\n    if carrots == 0\
    \ {\n        return []int{number, 0}\n    }\n    if carrots == number {\n    \
    \    return []int{number, 0}\n    }\n    if carrots == remaining {\n        return\
    \ []int{number, 0}\n    }\n    if carrots > remaining {\n        carrots = remaining\n\
    \    }\n    if carrots < number {\n        carrots = number\n    }\n    if carrots\
    \ == 0 {\n        return []int{number, 0}\n    }\n    if carrots == number {\n\
    \        return []int{number, 0}\n    }\n    if carrots == remaining {\n     \
    \   return []int{number, 0}\n    }\n    if carrots > remaining {\n        carrots\
    \ = remaining\n    }\n    if carrots < number {\n        carrots = number\n  \
    \  }\n    if carrots == 0 {\n        return []int{number, 0}\n    }\n    if carrots\
    \ == number {\n        return []int{number, 0}\n    }\n    if \nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpe8iqr3vs_test.go:131:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075376
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ Your code here\n    carrots := 0\n    if number < need {\n        carrots =\
    \ number\n    } else {\n        carrots = need\n    }\n    if carrots > remaining\
    \ {\n        carrots = remaining\n    }\n    return []int{carrots, remaining}\n\
    }\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp70tcaq30_test.go:58: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp70tcaq30_test.go:58:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp70tcaq30_test.go:58: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp70tcaq30_test.go:58: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=2) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp70tcaq30_test.go:58: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp70tcaq30_test.go:58:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075377
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots +=\
    \ number\n    carrots += need\n    carrots += remaining\n    if carrots > 1000\
    \ {\n        carrots = 1000\n    }\n    carrots = carrots - number\n    carrots\
    \ = carrots - need\n    carrots = carrots - remaining\n    if carrots < 0 {\n\
    \        carrots = 0\n    }\n    return []int{carrots, carrots}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp7g4aiar5_test.go:64: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp7g4aiar5_test.go:64:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=0) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp7g4aiar5_test.go:64: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp7g4aiar5_test.go:64: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp7g4aiar5_test.go:64: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp7g4aiar5_test.go:64:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075377
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots += need\n  \
    \  carrots += remaining\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots -= number\n    carrots -= need\n    carrots -= remaining\n    carrots\
    \ -= number\n    carrots -= need\n    carrots -= remaining\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    carrots -= number\n    carrots\
    \ -= need\n    carrots -= remaining\n    carrots -= number\n    carrots -= need\n\
    \    carrots -= remaining\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots -= number\n    carrots -= need\n    carrots -= remaining\n    carrots\
    \ -= number\n    carrots -= need\n    carrots -= remaining\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    carrots -= number\n    carrots\
    \ -= need\n    carrots -= remaining\n    carrots -= number\n    carrots -= need\n\
    \    carrots -= remaining\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots -= number\n    carrots -= need\n    carrots -= remaining\n    carrots\
    \ -= number\n    carrots -= need\n    carrots -= remaining\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    carrots -= number\n    carrots\
    \ -= need\n    carrots -= remaining\n    carrots -= number\n    carrots -= need\n\
    \    carrots -= remaining\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrot\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpttqvbf9l_test.go:101:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075376
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 {\n        return []int{0, 0}\n    }\n    if need\
    \ < 0 || need > 1000 {\n        return []int{0, 0}\n    }\n    if remaining <\
    \ 0 || remaining > 1000 {\n        return []int{0, 0}\n    }\n    if number ==\
    \ 0 {\n        return []int{0, 0}\n    }\n    if need == 0 {\n        return []int{number,\
    \ 0}\n    }\n    if remaining == 0 {\n        return []int{number, 0}\n    }\n\
    \    if number > need {\n        return []int{0, 0}\n    }\n    if number == need\
    \ {\n        return []int{number, 0}\n    }\n    if number > remaining {\n   \
    \     return []int{0, 0}\n    }\n    if number == remaining {\n        return\
    \ []int{number, 0}\n    }\n    if number > need {\n        return []int{0, 0}\n\
    \    }\n    if number == need {\n        return []int{number, 0}\n    }\n    if\
    \ number > remaining {\n        return []int{0, 0}\n    }\n    if number == remaining\
    \ {\n        return []int{number, 0}\n    }\n    if number > need {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n        return []int{number, 0}\n\
    \    }\n    if number > remaining {\n        return []int{0, 0}\n    }\n    if\
    \ number == remaining {\n        return []int{number, 0}\n    }\n    if number\
    \ > need {\n        return []int{0, 0}\n    }\n    if number == need {\n     \
    \   return []int{number, 0}\n    }\n    if number > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if number == remaining {\n        return []int{number,\
    \ 0}\n    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if\
    \ number == need {\n        return []int{number, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if number == remaining {\n       \
    \ return []int{number, 0}\n    }\n    if number > need {\n        return []int{0,\
    \ 0}\n    }\n    if number == need {\n        return []int{number, 0}\n    }\n\
    \    if number > remaining {\n        return []int{0, 0}\n    }\n    if number\
    \ == remaining {\n        return []int{number, 0}\n    }\n    if number > need\
    \ {\n        return []int{0, 0}\n    }\n    if number == need {\n        return\
    \ []int{number, 0}\n    }\n    if number > remaining {\n        return []int{0,\
    \ 0}\n    }\n    if number == remaining {\n        return []int{number, 0}\n \
    \   }\n    if number > need {\n        return []int{0, 0}\n    }\n    if number\
    \ == need {\n        return []int{number, 0}\n    }\n    if number \nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpm17kxs1n_test.go:136:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075376
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    return []int{carrots, carrots - number}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpbtupbi6n_test.go:52: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=21)\
    \ %!s(int=16)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpbtupbi6n_test.go:52:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=21) %!s(int=17)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpbtupbi6n_test.go:52: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=21) %!s(int=20)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpbtupbi6n_test.go:52: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=18) %!s(int=16)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpbtupbi6n_test.go:52: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=16)\
    \ %!s(int=12)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpbtupbi6n_test.go:52:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=10) %!s(int=6)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075373
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    return []int{carrots, carrots - number}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpbtupbi6n_test.go:52: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=21)\
    \ %!s(int=16)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpbtupbi6n_test.go:52:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=21) %!s(int=17)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpbtupbi6n_test.go:52: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=21) %!s(int=20)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpbtupbi6n_test.go:52: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=18) %!s(int=16)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpbtupbi6n_test.go:52: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=16)\
    \ %!s(int=12)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpbtupbi6n_test.go:52:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=10) %!s(int=6)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075373
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 {\n        return []int{0, 0}\n    }\n    if need\
    \ < 0 || need > 1000 {\n        return []int{0, 0}\n    }\n    if remaining <\
    \ 0 || remaining > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n\
    \    if number > need {\n        carrots = number-need\n    } else {\n       \
    \ carrots = need\n    }\n    if carrots > remaining {\n        carrots = remaining\n\
    \    }\n    return []int{carrots, remaining}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpgjvjjehs_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpgjvjjehs_test.go:66:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpgjvjjehs_test.go:66: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpgjvjjehs_test.go:66: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpgjvjjehs_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=5)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpgjvjjehs_test.go:66:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075377
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ Your code here\n    carrots := 0\n    carrots += number\n    carrots += need\n\
    \    carrots += remaining\n    carrots = carrots % 100\n    carrots = carrots\
    \ / 100\n    carrots = carrots + 1\n    carrots = carrots % 100\n    carrots =\
    \ carrots / 100\n    carrots = carrots + 1\n    carrots = carrots % 100\n    carrots\
    \ = carrots / 100\n    carrots = carrots + 1\n    carrots = carrots % 100\n  \
    \  carrots = carrots / 100\n    carrots = carrots + 1\n    carrots = carrots %\
    \ 100\n    carrots = carrots / 100\n    carrots = carrots + 1\n    carrots = carrots\
    \ % 100\n    carrots = carrots / 100\n    carrots = carrots + 1\n    carrots =\
    \ carrots % 100\n    carrots = carrots / 100\n    carrots = carrots + 1\n    carrots\
    \ = carrots % 100\n    carrots = carrots / 100\n    carrots = carrots + 1\n  \
    \  carrots = carrots % 100\n    carrots = carrots / 100\n    carrots = carrots\
    \ + 1\n    carrots = carrots % 100\n    carrots = carrots / 100\n    carrots =\
    \ carrots + 1\n    carrots = carrots % 100\n    carrots = carrots / 100\n    carrots\
    \ = carrots + 1\n    carrots = carrots % 100\n    carrots = carrots / 100\n  \
    \  carrots = carrots + 1\n    carrots = carrots % 100\n    carrots = carrots /\
    \ 100\n    carrots = carrots + 1\n    carrots = carrots % 100\n    carrots = carrots\
    \ / 100\n    carrots = carrots + 1\n    carrots = carrots % 100\n    carrots =\
    \ carrots / 100\n    carrots = carrots + 1\n    carrots = carrots % 100\n    carrots\
    \ = carrots / 100\n    carrots = carrots + 1\n    carrots = carrots % 100\n  \
    \  carrots = carrots / 100\n    carrots = carrots + 1\n    carrots = carrot\n\
    func TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyfqkeddb_test.go:84:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075376
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number <= 0 || need <= 0 || remaining <= 0 {\n        return []int{0, 0}\n \
    \   }\n    carrots := 0\n    carrots += number\n    carrots += need\n    carrots\
    \ += remaining\n    if carrots > 1000 {\n        carrots = 1000\n    }\n    return\
    \ []int{carrots, carrots - carrots}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpabm04397_test.go:58: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=21)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpabm04397_test.go:58:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=21) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpabm04397_test.go:58: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=21) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpabm04397_test.go:58: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=18) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpabm04397_test.go:58: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=16)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpabm04397_test.go:58:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075377
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 {\n        return []int{0, 0}\n    }\n    if need\
    \ < 0 || need > 1000 {\n        return []int{0, 0}\n    }\n    if remaining <\
    \ 0 || remaining > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n\
    \    carrots += number\n    carrots += need\n    carrots += remaining\n    if\
    \ carrots > 1000 {\n        carrots = 1000\n    }\n    carrots = carrots / 2\n\
    \    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots +\
    \ 1\n    carrots = carrots / 2\n    carrots = carrots + 1\n    carrots = carrots\
    \ / 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots\
    \ + 1\n    carrots = carrots / 2\n    carrots = carrots + 1\n    carrots = carrots\
    \ / 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots\
    \ + 1\n    carrots = carrots / 2\n    carrots = carrots + 1\n    carrots = carrots\
    \ / 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots\
    \ + 1\n    carrots = carrots / 2\n    carrots = carrots + 1\n    carrots = carrots\
    \ / 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots\
    \ + 1\n    carrots = carrots / 2\n    carrots = carrots + 1\n    carrots = carrots\
    \ / 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots\
    \ + 1\n    carrots = carrots / 2\n    carrots = carrots + 1\n    carrots = carrots\
    \ / 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots\
    \ + 1\n    carrots = carrots / 2\n    carrots = carrots + 1\n    carrots = carrots\
    \ / 2\n    carrots = carrots + 1\n    carrots = carrots / 2\n    carrots = carrots\
    \ + 1\n    carrots = carrots / \nfunc TestEat(t *testing.T) {\n  candidate :=\
    \ eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9e_fh4su_test.go:90:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075376
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots +=\
    \ number\n    carrots += need\n    carrots += remaining\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp465lejp9_test.go:100:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075372
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots = carrots % 100\n    carrots = carrots / 100\n    carrots = carrots\
    \ * 100\n    carrots = carrots + 100\n    carrots = carrots % 100\n    carrots\
    \ = carrots / 100\n    carrots = carrots * 100\n    carrots = carrots + 100\n\
    \    carrots = carrots % 100\n    carrots = carrots / 100\n    carrots = carrots\
    \ * 100\n    carrots = carrots + 100\n    carrots = carrots % 100\n    carrots\
    \ = carrots / 100\n    carrots = carrots * 100\n    carrots = carrots + 100\n\
    \    carrots = carrots % 100\n    carrots = carrots / 100\n    carrots = carrots\
    \ * 100\n    carrots = carrots + 100\n    carrots = carrots % 100\n    carrots\
    \ = carrots / 100\n    carrots = carrots * 100\n    carrots = carrots + 100\n\
    \    carrots = carrots % 100\n    carrots = carrots / 100\n    carrots = carrots\
    \ * 100\n    carrots = carrots + 100\n    carrots = carrots % 100\n    carrots\
    \ = carrots / 100\n    carrots = carrots * 100\n    carrots = carrots + 100\n\
    \    carrots = carrots % 100\n    carrots = carrots / 100\n    carrots = carrots\
    \ * 100\n    carrots = carrots + 100\n    carrots = carrots % 100\n    carrots\
    \ = carrots / 100\n    carrots = carrots * 100\n    carrots = carrots + 100\n\
    \    carrots = carrots % 100\n    carrots = carrots / 100\n    carrots = carrots\
    \ * 100\n    carrots = carrots + 100\n    carrots = carrots % 100\n    carrots\
    \ = carrots / 100\n    carrots = carrots * 100\n    carrots = carrots + 100\n\
    \    carrots = carrots % 100\n    carrots = carrots / 100\n    carrots = carrots\
    \ * 100\n    carrots = carrots + 100\n    carrots = carrot\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpcbsd7wuq_test.go:84:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075376
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    var\
    \ result []int\n    if number < 0 || number > 1000 {\n        fmt.Println(\"Invalid\
    \ input\")\n        return nil\n    }\n    if need < 0 || need > 1000 {\n    \
    \    fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if remaining\
    \ < 0 || remaining > 1000 {\n        fmt.Println(\"Invalid input\")\n        return\
    \ nil\n    }\n    if number == 0 {\n        return nil\n    }\n    if number >=\
    \ need {\n        result = []int{number, 0}\n    } else {\n        result = []int{0,\
    \ remaining}\n    }\n    return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpiv_afyth_test.go:69: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=0)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpiv_afyth_test.go:69:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=0) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpiv_afyth_test.go:69: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=0) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpiv_afyth_test.go:69: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=0) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpiv_afyth_test.go:69: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=0)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpiv_afyth_test.go:69:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075377
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    meals :=\
    \ 0\n    for i := 0; i < number; i++ {\n        if carrots >= remaining {\n  \
    \          meals++\n            carrots -= remaining\n        }\n        carrots++\n\
    \    }\n    if carrots > 0 {\n        meals++\n    }\n    return []int{meals,\
    \ carrots}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n\
    \     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual:\
    \ candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp51y4h_sm_test.go:63: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=1)\
    \ %!s(int=5)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp51y4h_sm_test.go:63:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=1) %!s(int=4)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp51y4h_sm_test.go:63: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp51y4h_sm_test.go:63: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=1) %!s(int=2)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp51y4h_sm_test.go:63: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=1)\
    \ %!s(int=4)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp51y4h_sm_test.go:63:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075377
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    if number > 1000 {\n        fmt.Println(\"Not enough carrots to eat\"\
    )\n        return []int{0, 0}\n    }\n    if need > 1000 {\n        fmt.Println(\"\
    Not enough carrots to eat\")\n        return []int{0, 0}\n    }\n    if remaining\
    \ > 1000 {\n        fmt.Println(\"Not enough carrots to eat\")\n        return\
    \ []int{0, 0}\n    }\n    if number > 0 {\n        carrots = number\n    }\n \
    \   if need > 0 {\n        carrots = carrots + need\n    }\n    if remaining >\
    \ 0 {\n        carrots = carrots + remaining\n    }\n    if carrots > 1000 {\n\
    \        carrots = 1000\n    }\n    carrots = carrots - 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvjyleysm_test.go:93:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075377
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots += need\n  \
    \  carrots += remaining\n    return []int{carrots, carrots - number}\n}\n\nfunc\
    \ TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpw32tuihl_test.go:55: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=21)\
    \ %!s(int=16)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpw32tuihl_test.go:55:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=21) %!s(int=17)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpw32tuihl_test.go:55: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=21) %!s(int=20)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpw32tuihl_test.go:55: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=18) %!s(int=16)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpw32tuihl_test.go:55: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=16)\
    \ %!s(int=12)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpw32tuihl_test.go:55:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=10) %!s(int=6)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075378
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    if number < 0 || number > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n        return nil\n    }\n    if need < 0 || need > 1000 {\n\
    \        fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if remaining\
    \ < 0 || remaining > 1000 {\n        fmt.Println(\"Invalid input\")\n        return\
    \ nil\n    }\n    if number == 0 {\n        result[0] = 0\n        result[1] =\
    \ 0\n        return result\n    }\n    if need == 0 {\n        result[0] = number\n\
    \        result[1] = 0\n        return result\n    }\n    if remaining == 0 {\n\
    \        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number > need {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number > remaining {\n        result[0]\
    \ = number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ need > remaining {\n        result[0] = need\n        result[1] = remaining\n\
    \        return result\n    }\n    if number == need {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if number == remaining\
    \ {\n        result[0] = number\n        result[1] = remaining\n        return\
    \ result\n    }\n    if need == remaining {\n        result[0] = need\n      \
    \  result[1] = remaining\n        return result\n    }\n    if number > need {\n\
    \        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number > remaining {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if need > remaining {\n     \
    \   result[0] = need\n        result[1] = remaining\n        return result\n \
    \   }\n    if number == need {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number == remaining {\n       \
    \ result[0] = number\n        result[1] = remaining\n        return result\n \
    \   }\n    if need == remaining {\n        result[0] = need\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number > need {\n        result[0]\
    \ = number\n        result[1] = need\n        return result\n    }\n    if number\
    \ > remaining {\n        result[0] = number\n        result[1] = remaining\n \
    \       return result\n    }\n    if need > remaining {\n        result[0] = need\n\
    \        result[1] = remaining\n        return result\n    }\n    if number ==\
    \ need {\n        result[0] = number\n        result[1] = need\n        return\
    \ result\n    }\n    if number == remaining {\n        result[0] = number\n  \
    \      result[1] = remaining\n        return result\n    }\n    if need == remaining\
    \ {\n        result[0] = need\n        result[1] = remaining\n        return result\n\
    \    }\n    if number > need {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number > remaining {\n        result[0]\
    \ = number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ need > remaining {\n        result[0] = need\n        result[1] = remaining\n\
    \        return result\n    }\n    if number == need {\n        result[0] = \n\
    func TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5ls3z68g_test.go:162:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075377
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    carrots = number\n    carrots = carrots - need\n    carrots = carrots\
    \ - remaining\n    carrots = carrots + 1\n    return []int{carrots, remaining}\n\
    }\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpi6jr4vp0_test.go:53: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=-10)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpi6jr4vp0_test.go:53:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=-12) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpi6jr4vp0_test.go:53: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=-18) %!s(int=10)]'\n    --- FAIL:\
    \ TestEat/test_num__3 (0.00s)\n        tmpi6jr4vp0_test.go:53: expected '[%!s(int=7)\
    \ %!s(int=0)]', got '[%!s(int=-13) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmpi6jr4vp0_test.go:53: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=-7) %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n\
    \        tmpi6jr4vp0_test.go:53: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=-1)\
    \ %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075378
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    var\
    \ carrots int\n    var meals int\n    var hungry bool\n    var result []int\n\
    \    if number < 0 || number > 1000 {\n        fmt.Println(\"Invalid input\")\n\
    \        return nil\n    }\n    if need < 0 || need > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n        return nil\n    }\n    if remaining < 0 || remaining\
    \ > 1000 {\n        fmt.Println(\"Invalid input\")\n        return nil\n    }\n\
    \    carrots = number\n    meals = need\n    hungry = true\n    result = make([]int,\
    \ 2)\n    result[0] = carrots\n    result[1] = remaining\n    while hungry {\n\
    \        if carrots >= meals {\n            carrots -= meals\n            meals\
    \ = 0\n            result[0] += meals\n        } else {\n            meals +=\
    \ 1\n            result[1] -= carrots\n            hungry = false\n        }\n\
    \    }\n    return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpwqhbvj30_test.go:49:11: expected '';'', found hungry

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075377
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    var\
    \ carrots []int\n    if number < 0 || number > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n        return carrots\n    }\n    if need < 0 || need > 1000\
    \ {\n        fmt.Println(\"Invalid input\")\n        return carrots\n    }\n \
    \   if remaining < 0 || remaining > 1000 {\n        fmt.Println(\"Invalid input\"\
    )\n        return carrots\n    }\n    if number == 0 {\n        fmt.Println(\"\
    Invalid input\")\n        return carrots\n    }\n    if need == 0 {\n        fmt.Println(\"\
    Invalid input\")\n        return carrots\n    }\n    if remaining == 0 {\n   \
    \     fmt.Println(\"Invalid input\")\n        return carrots\n    }\n    if number\
    \ > need {\n        fmt.Println(\"Invalid input\")\n        return carrots\n \
    \   }\n    if number > remaining {\n        fmt.Println(\"Invalid input\")\n \
    \       return carrots\n    }\n    if need > remaining {\n        fmt.Println(\"\
    Invalid input\")\n        return carrots\n    }\n    if number == need {\n   \
    \     fmt.Println(\"Invalid input\")\n        return carrots\n    }\n    if number\
    \ == remaining {\n        fmt.Println(\"Invalid input\")\n        return carrots\n\
    \    }\n    if number > remaining {\n        fmt.Println(\"Invalid input\")\n\
    \        return carrots\n    }\n    if number > need {\n        fmt.Println(\"\
    Invalid input\")\n        return carrots\n    }\n    if number > 0 {\n       \
    \ carrots = append(carrots, number)\n    }\n    if need > 0 {\n        carrots\
    \ = append(carrots, need)\n    }\n    if remaining > 0 {\n        carrots = append(carrots,\
    \ remaining)\n    }\n    return carrots\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\n\
    This is not an answer to the question. Also the code does not compile.\n<|/ c\
    \ |>\n<| c |>\nI edited the answer to make it compile. Thanks for pointing out\
    \ the mistake.\n<|/ c |>\n<| c |>\nI edited the answer to make it compile. Thanks\
    \ for pointing out the mistake.\n<|/ c |>\n<| c |>\nI edited the answer to make\
    \ it compile. Thanks for pointing out the mistake.\n<|/ c |>\n<| c |>\nI edited\
    \ the answer to make it compile. Thanks for pointing out the mistake.\n<|/ c |>\n\
    <| a dscore=0 |>\n<code>\npackage eat_test\n\nimport (\n    \"testing\"\nfunc\
    \ TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp806pwyzc_test.go:91:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075377
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    if number < 0 {\n        return []int{0, 0}\n    }\n    if need <\
    \ 0 {\n        return []int{0, 0}\n    }\n    if remaining < 0 {\n        return\
    \ []int{0, 0}\n    }\n    if number == 0 {\n        return []int{0, 0}\n    }\n\
    \    if need == 0 {\n        return []int{number, 0}\n    }\n    if remaining\
    \ == 0 {\n        return []int{number, 0}\n    }\n    if number > remaining {\n\
    \        return []int{0, 0}\n    }\n    if need > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n        return []int{number, 0}\n\
    \    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if number\
    \ > remaining {\n        return []int{0, 0}\n    }\n    if need > remaining {\n\
    \        return []int{0, 0}\n    }\n    if number == need {\n        return []int{number,\
    \ 0}\n    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if\
    \ number > remaining {\n        return []int{0, 0}\n    }\n    if need > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if number == need {\n        return\
    \ []int{number, 0}\n    }\n    if number > need {\n        return []int{0, 0}\n\
    \    }\n    if number > remaining {\n        return []int{0, 0}\n    }\n    if\
    \ need > remaining {\n        return []int{0, 0}\n    }\n    if number == need\
    \ {\n        return []int{number, 0}\n    }\n    if number > need {\n        return\
    \ []int{0, 0}\n    }\n    if number > remaining {\n        return []int{0, 0}\n\
    \    }\n    if need > remaining {\n        return []int{0, 0}\n    }\n    if number\
    \ == need {\n        return []int{number, 0}\n    }\n    if number > need {\n\
    \        return []int{0, 0}\n    }\n    if number > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if need > remaining {\n        return []int{0, 0}\n\
    \    }\n    if number == need {\n        return []int{number, 0}\n    }\n    if\
    \ number > need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if need > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n        return []int{number, 0}\n\
    \    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if number\
    \ > remaining {\n        return []int{0, 0}\n    }\n    if need > remaining {\n\
    \        return []int{0, 0}\n    }\n    if number == need {\n        return []\n\
    func TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7ijvsj3z_test.go:137:18: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075377
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    var\
    \ result []int\n    if number < 0 || number > 1000 {\n        return nil\n   \
    \ }\n    if need < 0 || need > 1000 {\n        return nil\n    }\n    if remaining\
    \ < 0 || remaining > 1000 {\n        return nil\n    }\n    if number == 0 {\n\
    \        return nil\n    }\n    if number >= need {\n        result = []int{0,\
    \ 0}\n        return result\n    }\n    if number < need {\n        result = []int{0,\
    \ 0}\n        return result\n    }\n    if number > remaining {\n        result\
    \ = []int{0, 0}\n        return result\n    }\n    result = []int{0, 0}\n    if\
    \ number > 0 {\n        result[0] = (number - 1)\n    }\n    if number > 0 {\n\
    \        result[1] = (number - 1)\n    }\n    return result\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp3xdflkje_test.go:80: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp3xdflkje_test.go:80:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=0) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp3xdflkje_test.go:80: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp3xdflkje_test.go:80: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp3xdflkje_test.go:80: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp3xdflkje_test.go:80:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075378
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots = carrots % 1000\n    carrots = carrots / 1000\n    carrots = carrots\
    \ + 1\n    carrots = carrots % 1000\n    carrots = carrots / 1000\n    carrots\
    \ = carrots + 1\n    carrots = carrots % 1000\n    carrots = carrots / 1000\n\
    \    carrots = carrots + 1\n    carrots = carrots % 1000\n    carrots = carrots\
    \ / 1000\n    carrots = carrots + 1\n    carrots = carrots % 1000\n    carrots\
    \ = carrots / 1000\n    carrots = carrots + 1\n    carrots = carrots % 1000\n\
    \    carrots = carrots / 1000\n    carrots = carrots + 1\n    carrots = carrots\
    \ % 1000\n    carrots = carrots / 1000\n    carrots = carrots + 1\n    carrots\
    \ = carrots % 1000\n    carrots = carrots / 1000\n    carrots = carrots + 1\n\
    \    carrots = carrots % 1000\n    carrots = carrots / 1000\n    carrots = carrots\
    \ + 1\n    carrots = carrots % 1000\n    carrots = carrots / 1000\n    carrots\
    \ = carrots + 1\n    carrots = carrots % 1000\n    carrots = carrots / 1000\n\
    \    carrots = carrots + 1\n    carrots = carrots % 1000\n    carrots = carrots\
    \ / 1000\n    carrots = carrots + 1\n    carrots = carrots % 1000\n    carrots\
    \ = carrots / 1000\n    carrots = carrots + 1\n    carrots = carrots % 1000\n\
    \    carrots = carrots / 1000\n    carrots = carrots + 1\n    carrots = carrots\
    \ % 1000\n    carrots = carrots / 1000\n    carrots = carrots + 1\n    carrots\
    \ = carrots % 1000\n    carrots = carrots / 1000\n    carrots = carrots + 1\n\
    \    carrots = carrots % 1000\n    carrots = carrots / 1000\n    carrots = carrots\
    \ + 1\n    carrots = carrots % 1000\n    \nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpopuxy4pz_test.go:84:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075377
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    if number < 0 {\n        return []int{0, 0}\n    }\n    if need <\
    \ 0 {\n        return []int{0, 0}\n    }\n    if remaining < 0 {\n        return\
    \ []int{0, 0}\n    }\n    if number == 0 {\n        return []int{0, 0}\n    }\n\
    \    if need == 0 {\n        return []int{number, 0}\n    }\n    if remaining\
    \ == 0 {\n        return []int{number, 0}\n    }\n    if number > remaining {\n\
    \        return []int{0, 0}\n    }\n    if need > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n        return []int{number, 0}\n\
    \    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if number\
    \ == 0 {\n        return []int{0, 0}\n    }\n    if need == 0 {\n        return\
    \ []int{number, 0}\n    }\n    if remaining == 0 {\n        return []int{number,\
    \ 0}\n    }\n    if number > remaining {\n        return []int{0, 0}\n    }\n\
    \    if need > remaining {\n        return []int{0, 0}\n    }\n    if number ==\
    \ need {\n        return []int{number, 0}\n    }\n    if number > need {\n   \
    \     return []int{0, 0}\n    }\n    if number == 0 {\n        return []int{0,\
    \ 0}\n    }\n    if need == 0 {\n        return []int{number, 0}\n    }\n    if\
    \ remaining == 0 {\n        return []int{number, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if need > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n        return []int{number, 0}\n\
    \    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if number\
    \ == 0 {\n        return []int{0, 0}\n    }\n    if need == 0 {\n        return\
    \ []int{number, 0}\n    }\n    if remaining == 0 {\n        return []int{number,\
    \ 0}\n    }\n    if number > remaining {\n        return []int{0, 0}\n    }\n\
    \    if need > remaining {\n        return []int{0, 0}\n    }\n    if number ==\
    \ need {\n        return []int{number, 0}\n    }\n    if number > need {\n   \
    \     return []int{0, 0}\n    }\n    if number == 0 {\n        return []int{0,\
    \ 0}\n    }\n    if need == 0 {\n        return []int{number, 0}\n    }\n    if\
    \ remaining == 0 {\n        return []int{number, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if need > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n        return []int{number, 0}\n\
    \    }\n    if number > need {\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpomc8qk1u_test.go:140:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075377
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ write your code here\n    carrots := 0\n    carrots = number - need\n    if\
    \ carrots < 0 {\n        carrots = 0\n    }\n    if carrots > remaining {\n  \
    \      carrots = remaining\n    }\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = car\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzu5eyski_test.go:88:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075377
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    var\
    \ result []int\n    if number <= 0 {\n        return nil\n    }\n    if need <=\
    \ 0 {\n        return nil\n    }\n    if remaining <= 0 {\n        return nil\n\
    \    }\n    if number > need {\n        return nil\n    }\n    if number > remaining\
    \ {\n        number = remaining\n    }\n    if number > 0 {\n        result =\
    \ append(result, number)\n    }\n    if number < need {\n        number = need\n\
    \    }\n    if number < remaining {\n        number = remaining\n    }\n    if\
    \ number < 0 {\n        number = remaining\n    }\n    if number > 0 {\n     \
    \   result = append(result, number)\n    }\n    return result\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpzs215q24_test.go:79: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpzs215q24_test.go:79:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpzs215q24_test.go:79: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpzs215q24_test.go:79: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=2) %!s(int=11)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpzs215q24_test.go:79: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpzs215q24_test.go:79:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=5)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075373
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    if number < 0 || number > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n    }\n    if need < 0 || need > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n    }\n    if remaining < 0 || remaining > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n    }\n    if number == 0 {\n        result[0] = number\n  \
    \      result[1] = remaining\n        return result\n    }\n    if need == 0 {\n\
    \        result[0] = number\n        result[1] = remaining\n        return result\n\
    \    }\n    if remaining == 0 {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number > need {\n        result[0]\
    \ = number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ number == need {\n        result[0] = number\n        result[1] = remaining\n\
    \        return result\n    }\n    if number > remaining {\n        result[0]\
    \ = number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ number == remaining {\n        result[0] = number\n        result[1] = remaining\n\
    \        return result\n    }\n    if number > 0 && number < need {\n        result[0]\
    \ = number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ number == 0 && need > remaining {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number == 0 && need == remaining\
    \ {\n        result[0] = number\n        result[1] = remaining\n        return\
    \ result\n    }\n    if number == 0 && need > 0 && remaining > 0 {\n        result[0]\
    \ = number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ number == 0 && need == 0 && remaining > 0 {\n        result[0] = number\n  \
    \      result[1] = remaining\n        return result\n    }\n    if number == 0\
    \ && need > 0 && remaining == 0 {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number == 0 && need == 0 &&\
    \ remaining == 0 {\n        result[0] = number\n        result[1] = remaining\n\
    \        return result\n    }\n    if number > 0 && number < need && remaining\
    \ > 0 {\n        result[0] = number\n        result[1] = remaining\n        return\
    \ result\n    }\n    if number == 0 && need > 0 && remaining == 0 {\n        result[0]\
    \ = number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ number == 0 && need == 0 && remaining > 0 {\n        result[0] = number\n  \
    \      result[1] = remaining\n        return result\n    }\n    if number == 0\
    \ && need > 0 && remaining == 0 {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number > 0 && number < need\
    \ && remaining == 0 {\n        result[0] = number\n        result[1] = remaining\n\
    \        return result\n    }\n    if number > 0 && number < need && remaining\
    \ > 0 {\n        result[0] = number\n        result[1] = remaining\n        return\
    \ result\n    }\n    if number == 0 && need > 0 && remaining > 0 {\n        result[0]\
    \ = number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ number == 0 && \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n\
    \     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual:\
    \ candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp42yojiia_test.go:143:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075377
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 {\n        return []int{0, 0}\n    }\n    if need\
    \ < 0 || need > 1000 {\n        return []int{0, 0}\n    }\n    if remaining <\
    \ 0 || remaining > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n\
    \    if number > need {\n        carrots = number-need\n    } else {\n       \
    \ carrots = need\n    }\n    if carrots > remaining {\n        carrots = remaining\n\
    \    }\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    \nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmph6wrpmcx_test.go:92:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075377
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ Your code here\n    carrots := 0\n    carrots += number\n    carrots += need\n\
    \    carrots += remaining\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpk90x9nqa_test.go:101:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075372
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n\n    carrots := 0\n    carrots\
    \ += number\n    carrots += need\n    carrots += remaining\n    carrots += number\n\
    \    carrots += need\n    carrots += remaining\n    carrots += number\n    carrots\
    \ += need\n    carrots += remaining\n    carrots += number\n    carrots += need\n\
    \    carrots += remaining\n    carrots += number\n    carrots += need\n    carrots\
    \ += remaining\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots += number\n    carrots += need\n    carrots += remaining\n    carrots\
    \ += number\n    carrots += need\n    carrots += remaining\n    carrots += number\n\
    \    carrots += need\n    carrots += remaining\n    carrots += number\n    carrots\
    \ += need\n    carrots += remaining\n    carrots += number\n    carrots += need\n\
    \    carrots += remaining\n    carrots += number\n    carrots += need\n    carrots\
    \ += remaining\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots += number\n    carrots += need\n    carrots += remaining\n    carrots\
    \ += number\n    carrots += need\n    carrots += remaining\n    carrots += number\n\
    \    carrots += need\n    carrots += remaining\n    carrots += number\n    carrots\
    \ += need\n    carrots += remaining\n    carrots += number\n    carrots += need\n\
    \    carrots += remaining\n    carrots += number\n    carrots += need\n    carrots\
    \ += remaining\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots += number\n    carrots += need\n    carrots += remaining\n    carrots\
    \ += number\n    carrots += need\n    carrots += remaining\n    carrots += number\n\
    \    carrots += need\n    carrots += remaining\n    carrots += number\n    carrots\
    \ += need\n    carrots += remaining\n    carrots += number\n    carrots += need\n\
    \    carrots += remaining\n    carrots += number\n    carrots += need\n    carrots\
    \ += remaining\n    carrots += number\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmput62w00l_test.go:112:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075377
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 {\n        return []int{0, 0}\n    }\n    if need\
    \ < 0 || need > 1000 {\n        return []int{0, 0}\n    }\n    if remaining <\
    \ 0 || remaining > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n\
    \    carrots = number\n    carrots = carrots - need\n    carrots = carrots - remaining\n\
    \    carrots = carrots + 1\n    return []int{carrots, remaining}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpjqmyj2pp_test.go:62: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=-10)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpjqmyj2pp_test.go:62:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=-12) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpjqmyj2pp_test.go:62: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=-18) %!s(int=10)]'\n    --- FAIL:\
    \ TestEat/test_num__3 (0.00s)\n        tmpjqmyj2pp_test.go:62: expected '[%!s(int=7)\
    \ %!s(int=0)]', got '[%!s(int=-13) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmpjqmyj2pp_test.go:62: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=-7) %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n\
    \        tmpjqmyj2pp_test.go:62: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=-1)\
    \ %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075378
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 {\n        return []int{0, 0}\n    }\n    if need\
    \ < 0 || need > 1000 {\n        return []int{0, 0}\n    }\n    if remaining <\
    \ 0 || remaining > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n\
    \    if number > need {\n        carrots = number-need\n    } else {\n       \
    \ carrots = need\n    }\n    if carrots > remaining {\n        carrots = remaining\n\
    \    }\n    return []int{carrots, remaining}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpgjvjjehs_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpgjvjjehs_test.go:66:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpgjvjjehs_test.go:66: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpgjvjjehs_test.go:66: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpgjvjjehs_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=5)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpgjvjjehs_test.go:66:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075377
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ write your code here\n    carrots := 0\n    carrots += number\n    carrots +=\
    \ need\n    carrots -= remaining\n    return []int{carrots, remaining}\n}\n\n\
    func TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpi28olq7h_test.go:53: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=1)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpi28olq7h_test.go:53:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=3) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpi28olq7h_test.go:53: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpi28olq7h_test.go:53: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=8) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpi28olq7h_test.go:53: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=2)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpi28olq7h_test.go:53:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=8) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075379
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots +=\
    \ number\n    carrots += need\n    carrots -= remaining\n    carrots %= 1000\n\
    \    return []int{carrots, carrots - carrots % 1000}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmplviy_uop_test.go:56: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=1)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmplviy_uop_test.go:56:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=3) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmplviy_uop_test.go:56: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmplviy_uop_test.go:56: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=8) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmplviy_uop_test.go:56: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=2)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmplviy_uop_test.go:56:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=8) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075379
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    var\
    \ result []int\n    if number > 1000 || need > 1000 || remaining > 1000 {\n  \
    \      fmt.Println(\"Invalid input\")\n    } else {\n        if number <= need\
    \ {\n            result = append(result, number)\n        } else {\n         \
    \   result = append(result, need)\n        }\n    }\n    return result\n}\n\n\
    func TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp3z_urokl_test.go:58: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5)]'\n\
    \    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp3z_urokl_test.go:58: expected\
    \ '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4)]'\n    --- FAIL: TestEat/test_num__2\
    \ (0.00s)\n        tmp3z_urokl_test.go:58: expected '[%!s(int=11) %!s(int=0)]',\
    \ got '[%!s(int=1)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmp3z_urokl_test.go:58:\
    \ expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp3z_urokl_test.go:58: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=4)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp3z_urokl_test.go:58:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075379
- exit_code: 2
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    if number < 0 || number > 1000 || need < 0 || need >\
    \ 1000 || remaining < 0 || remaining > 1000 {\n        fmt.Println(\"Invalid input\"\
    )\n        return nil\n    }\n    if number == 0 {\n        result[0] = 0\n  \
    \      result[1] = 0\n        return result\n    }\n    if number == need {\n\
    \        result[0] = number\n        result[1] = 0\n        return result\n  \
    \  }\n    if number > need {\n        result[0] = number\n        result[1] =\
    \ remaining\n        return result\n    }\n    if number < need {\n        result[0]\
    \ = need\n        result[1] = number\n        return result\n    }\n}\n\nfunc\
    \ TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp6on5eco_test.go:52:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075379
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    result := []int{0, 0}\n    if number < 0 || number > 1000 || need\
    \ < 0 || need > 1000 || remaining < 0 || remaining > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n    }\n    if number == 0 {\n        fmt.Println(\"You already\
    \ have eaten all carrots, you now have no more carrots to eat\")\n    }\n    if\
    \ need == 0 {\n        fmt.Println(\"You need more carrots to eat, you're already\
    \ at your limit\")\n    }\n    if remaining == 0 {\n        fmt.Println(\"You\
    \ don't have any more carrots to eat\")\n    }\n    if number > need {\n     \
    \   fmt.Println(\"You can't eat more carrots than you have\")\n    }\n    if number\
    \ > remaining {\n        fmt.Println(\"You don't have enough carrots to eat\"\
    )\n    }\n    if number == need {\n        fmt.Println(\"You eat all carrots you\
    \ have left\")\n    }\n    if number == remaining {\n        fmt.Println(\"You\
    \ eat all carrots you have left\")\n    }\n    if number < need {\n        fmt.Println(\"\
    You eat all carrots you have left\")\n    }\n    if number < remaining {\n   \
    \     fmt.Println(\"You eat all carrots you have left\")\n    }\n    if number\
    \ == need && number == remaining {\n        fmt.Println(\"You eat all carrots\
    \ you have left\")\n    }\n    if number == need {\n        fmt.Println(\"You\
    \ eat all carrots you have left\")\n    }\n    if number == remaining {\n    \
    \    fmt.Println(\"You eat all carrots you have left\")\n    }\n    if number\
    \ > need {\n        fmt.Println(\"You eat all carrots you have left\")\n    }\n\
    \    if number > remaining {\n        fmt.Println(\"You eat all carrots you have\
    \ left\")\n    }\n    if number == need && number == remaining {\n        fmt.Println(\"\
    You eat all carrots you have left\")\n    }\n    if number == need {\n       \
    \ fmt.Println(\"You eat all carrots you have left\")\n    }\n    if number ==\
    \ remaining {\n        fmt.Println(\"You eat all carrots you have left\")\n  \
    \  }\n    if number < need {\n        fmt.Println(\"You eat all carrots you have\
    \ left\")\n    }\n    if number < remaining {\n        fmt.Println(\"You eat all\
    \ carrots you have left\")\n    }\n    if number == need && number == remaining\
    \ {\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpsi3f3j32_test.go:90:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075378
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number <= 0 {\n        return []int{0, 0}\n    }\n    if need <= 0 {\n     \
    \   return []int{0, 0}\n    }\n    if remaining <= 0 {\n        return []int{0,\
    \ 0}\n    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if\
    \ number > remaining {\n        return []int{0, 0}\n    }\n    if number < remaining\
    \ {\n        return []int{0, 0}\n    }\n    if number == need {\n        return\
    \ []int{number, 0}\n    }\n    if number == remaining {\n        return []int{0,\
    \ number}\n    }\n    if number > remaining {\n        return []int{0, 0}\n  \
    \  }\n    if number < need {\n        return []int{0, 0}\n    }\n    if number\
    \ < remaining {\n        return []int{0, 0}\n    }\n    if number == 0 {\n   \
    \     return []int{0, 0}\n    }\n    if number == 1 {\n        return []int{0,\
    \ 0}\n    }\n    if number == 2 {\n        return []int{0, 0}\n    }\n    if number\
    \ == 3 {\n        return []int{0, 0}\n    }\n    if number == 4 {\n        return\
    \ []int{0, 0}\n    }\n    if number == 5 {\n        return []int{0, 0}\n    }\n\
    \    if number == 6 {\n        return []int{0, 0}\n    }\n    if number == 7 {\n\
    \        return []int{0, 0}\n    }\n    if number == 8 {\n        return []int{0,\
    \ 0}\n    }\n    if number == 9 {\n        return []int{0, 0}\n    }\n    if number\
    \ == 10 {\n        return []int{0, 0}\n    }\n    if number == 11 {\n        return\
    \ []int{0, 0}\n    }\n    if number == 12 {\n        return []int{0, 0}\n    }\n\
    \    if number == 13 {\n        return []int{0, 0}\n    }\n    if number == 14\
    \ {\n        return []int{0, 0}\n    }\n    if number == 15 {\n        return\
    \ []int{0, 0}\n    }\n    if number == 16 {\n        return []int{0, 0}\n    }\n\
    \    if number == 17 {\n        return []int{0, 0}\n    }\n    if number == 18\
    \ {\n        return []int{0, 0}\n    }\n    if number == 19 {\n        return\
    \ []int{0, 0}\n    }\n    if number == 20 {\n        return []int{0, 0}\n    }\n\
    \    if number == 21 {\n        return []int{0, 0}\n    }\n    if number == 22\
    \ {\n        return []int{0, 0}\n    }\n    if number == 23 {\n        return\
    \ []int{0, 0}\n    }\n    if number == 24 {\n        return []int{0, 0}\n    }\n\
    \    if number == 25 {\n        return []int{0, 0}\n    }\n    if number \nfunc\
    \ TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpv0ozgi09_test.go:139:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075378
- exit_code: 2
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ write your code here\n    result := make([]int, 2)\n    if number < 0 || number\
    \ > 1000 {\n        fmt.Println(\"Invalid input\")\n    }\n    if need < 0 ||\
    \ need > 1000 {\n        fmt.Println(\"Invalid input\")\n    }\n    if remaining\
    \ < 0 || remaining > 1000 {\n        fmt.Println(\"Invalid input\")\n    }\n \
    \   if number == 0 {\n        result[0] = 0\n        result[1] = 0\n        return\
    \ result\n    }\n    if number < need {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number > need {\n        result[0]\
    \ = need\n        result[1] = number\n        return result\n    }\n    if number\
    \ == need {\n        result[0] = number\n        result[1] = remaining\n     \
    \   return result\n    }\n    if number > remaining {\n        result[0] = number\n\
    \        result[1] = remaining\n        return result\n    }\n    if number <\
    \ remaining {\n        result[0] = remaining\n        result[1] = number\n   \
    \     return result\n    }\n}\n\nfunc TestEat(t *testing.T) {\n  candidate :=\
    \ eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfjtimv7s_test.go:68:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075379
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots =\
    \ number\n    if carrots > need {\n        carrots = need\n    }\n    if carrots\
    \ < remaining {\n        carrots = remaining\n    }\n    carrots = carrots - need\n\
    \    carrots = carrots + number\n    carrots = carrots + need\n    carrots = carrots\
    \ + number\n    carrots = carrots + need\n    carrots = carrots + number\n   \
    \ carrots = carrots + need\n    carrots = carrots + number\n    carrots = carrots\
    \ + need\n    carrots = carrots + number\n    carrots = carrots + need\n    carrots\
    \ = carrots + number\n    carrots = carrots + need\n    carrots = carrots + number\n\
    \    carrots = carrots + need\n    carrots = carrots + number\n    carrots = carrots\
    \ + need\n    carrots = carrots + number\n    carrots = carrots + need\n    carrots\
    \ = carrots + number\n    carrots = carrots + need\n    carrots = carrots + number\n\
    \    carrots = carrots + need\n    carrots = carrots + number\n    carrots = carrots\
    \ + need\n    carrots = carrots + number\n    carrots = carrots + need\n    carrots\
    \ = carrots + number\n    carrots = carrots + need\n    carrots = carrots + number\n\
    \    carrots = carrots + need\n    carrots = carrots + number\n    carrots = carrots\
    \ + need\n    carrots = carrots + number\n    carrots = carrots + need\n    carrots\
    \ = carrots + number\n    carrots = carrots + need\n    carrots = carrots + number\n\
    \    carrots = carrots + need\n    carrots = carrots + number\n    carrots = carrots\
    \ + need\n    carrots = carrots + number\n    carrots = carrots + need\n    carrots\
    \ = carrots + number\n    carrots = carrots + need\n    carrots = carrots + number\n\
    \    carrots = carrots + need\n    carrots = carrots + number\n    carrots = carrot\n\
    func TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0vns8r6x_test.go:87:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075378
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 {\n        return []int{0, 0}\n    }\n    if need\
    \ < 0 || need > 1000 {\n        return []int{0, 0}\n    }\n    if remaining <\
    \ 0 || remaining > 1000 {\n        return []int{0, 0}\n    }\n    if number ==\
    \ 0 {\n        return []int{0, 0}\n    }\n    if need == 0 {\n        return []int{number,\
    \ 0}\n    }\n    if remaining == 0 {\n        return []int{0, number}\n    }\n\
    \    if number > need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, number}\n    }\n    if need > remaining {\n     \
    \   return []int{0, 0}\n    }\n    if number == need {\n        return []int{number,\
    \ 0}\n    }\n    if number == remaining {\n        return []int{0, number}\n \
    \   }\n    if number > need {\n        return []int{0, 0}\n    }\n    if number\
    \ > remaining {\n        return []int{0, number}\n    }\n    if need > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if number == need {\n        return\
    \ []int{number, 0}\n    }\n    if number == remaining {\n        return []int{0,\
    \ number}\n    }\n    if number > need {\n        return []int{0, 0}\n    }\n\
    \    if number > remaining {\n        return []int{0, number}\n    }\n    if need\
    \ > remaining {\n        return []int{0, 0}\n    }\n    if number == need {\n\
    \        return []int{number, 0}\n    }\n    if number == remaining {\n      \
    \  return []int{0, number}\n    }\n    if number > need {\n        return []int{0,\
    \ 0}\n    }\n    if number > remaining {\n        return []int{0, number}\n  \
    \  }\n    if need > remaining {\n        return []int{0, 0}\n    }\n    if number\
    \ == need {\n        return []int{number, 0}\n    }\n    if number == remaining\
    \ {\n        return []int{0, number}\n    }\n    if number > need {\n        return\
    \ []int{0, 0}\n    }\n    if number > remaining {\n        return []int{0, number}\n\
    \    }\n    if need > remaining {\n        return []int{0, 0}\n    }\n    if number\
    \ == need {\n        return []int{number, 0}\n    }\n    if number == remaining\
    \ {\n        return []int{0, number}\n    }\n    if number > need {\n        return\
    \ []int{0, 0}\n    }\n    if number > remaining {\n        return []int{0, number}\n\
    \    }\n    if need > remaining {\n        return []int{0, 0}\n    }\n    if number\
    \ == need {\n        return []int{number, 0}\n    }\n    if number == remaining\
    \ {\n        return []int{0, number}\n    }\n    if number \nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp90v9zn87_test.go:136:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075378
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    if number < 0 {\n        return []int{0, 0}\n    }\n    if need <\
    \ 0 {\n        return []int{0, 0}\n    }\n    if remaining < 0 {\n        return\
    \ []int{0, 0}\n    }\n    if number == 0 {\n        return []int{0, 0}\n    }\n\
    \    if need == 0 {\n        return []int{number, 0}\n    }\n    if remaining\
    \ == 0 {\n        return []int{number, 0}\n    }\n    if number > remaining {\n\
    \        return []int{0, 0}\n    }\n    if need > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n        return []int{number, 0}\n\
    \    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if number\
    \ == 0 {\n        return []int{0, 0}\n    }\n    if need == 0 {\n        return\
    \ []int{number, 0}\n    }\n    if remaining == 0 {\n        return []int{number,\
    \ 0}\n    }\n    if number > remaining {\n        return []int{0, 0}\n    }\n\
    \    if need > remaining {\n        return []int{0, 0}\n    }\n    if number ==\
    \ need {\n        return []int{number, 0}\n    }\n    if number > need {\n   \
    \     return []int{0, 0}\n    }\n    if number == 0 {\n        return []int{0,\
    \ 0}\n    }\n    if need == 0 {\n        return []int{number, 0}\n    }\n    if\
    \ remaining == 0 {\n        return []int{number, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if need > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n        return []int{number, 0}\n\
    \    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if number\
    \ == 0 {\n        return []int{0, 0}\n    }\n    if need == 0 {\n        return\
    \ []int{number, 0}\n    }\n    if remaining == 0 {\n        return []int{number,\
    \ 0}\n    }\n    if number > remaining {\n        return []int{0, 0}\n    }\n\
    \    if need > remaining {\n        return []int{0, 0}\n    }\n    if number ==\
    \ need {\n        return []int{number, 0}\n    }\n    if number > need {\n   \
    \     return []int{0, 0}\n    }\n    if number == 0 {\n        return []int{0,\
    \ 0}\n    }\n    if need == 0 {\n        return []int{number, 0}\n    }\n    if\
    \ remaining == 0 {\n        return []int{number, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if need > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n        return []int{number, 0}\n\
    \    }\n    if number > need {\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpomc8qk1u_test.go:140:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075377
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 {\n        return []int{0, 0}\n    }\n    if need\
    \ < 0 || need > 1000 {\n        return []int{0, 0}\n    }\n    if remaining <\
    \ 0 || remaining > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n\
    \    carrots = number\n    carrots = carrots - need\n    carrots = carrots + remaining\n\
    \    carrots = carrots + 1\n    carrots = carrots - 1\n    carrots = carrots +\
    \ 1\n    carrots = carrots - 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ - 1\n    carrots = carrots + 1\n    carrots = carrots - 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots - 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ - 1\n    carrots = carrots + 1\n    carrots = carrots - 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots - 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ - 1\n    carrots = carrots + 1\n    carrots = carrots - 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots - 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ - 1\n    carrots = carrots + 1\n    carrots = carrots - 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots - 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ - 1\n    carrots = carrots + 1\n    carrots = carrots - 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots - 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ - 1\n    carrots = carrots + 1\n    carrots = carrots - 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots - 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ - 1\n    carrots = carrots + 1\n    carrots = carrots - 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots - 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ - \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpkn2zzr4b_test.go:88:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075379
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ Your code here\n    carrots := 0\n    carrots += number\n    carrots += need\n\
    \    carrots += remaining\n    if carrots < 0 {\n        carrots = 0\n    }\n\
    \    if carrots > 1000 {\n        carrots = 1000\n    }\n    return []int{carrots,\
    \ carrots - carrots - need}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate :=\
    \ eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmplj_r_h3r_test.go:59: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=21)\
    \ %!s(int=-6)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmplj_r_h3r_test.go:59:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=21) %!s(int=-8)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmplj_r_h3r_test.go:59: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=21) %!s(int=-10)]'\n    --- FAIL:\
    \ TestEat/test_num__3 (0.00s)\n        tmplj_r_h3r_test.go:59: expected '[%!s(int=7)\
    \ %!s(int=0)]', got '[%!s(int=18) %!s(int=-11)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmplj_r_h3r_test.go:59: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=16) %!s(int=-5)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n\
    \        tmplj_r_h3r_test.go:59: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=10)\
    \ %!s(int=-5)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075380
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 {\n        return []int{0, 0}\n    }\n    if need\
    \ < 0 || need > 1000 {\n        return []int{0, 0}\n    }\n    if remaining <\
    \ 0 || remaining > 1000 {\n        return []int{0, 0}\n    }\n    \n    var carrots\
    \ []int\n    var carrots_left int\n    \n    if number == 0 {\n        carrots\
    \ = []int{0, 0}\n        carrots_left = 0\n    } else {\n        carrots = append(carrots,\
    \ number%10)\n        carrots_left = number/10\n    }\n    \n    if carrots_left\
    \ == 0 {\n        carrots = append(carrots, 0)\n        carrots_left = 1\n   \
    \ }\n    \n    if carrots_left > need {\n        carrots = append(carrots, 0)\n\
    \        carrots_left = need\n    }\n    \n    if carrots_left > remaining {\n\
    \        carrots = append(carrots, 0)\n        carrots_left = remaining\n    }\n\
    \    \n    return carrots\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp5tqry8ub_test.go:84: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp5tqry8ub_test.go:84:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp5tqry8ub_test.go:84: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp5tqry8ub_test.go:84: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp5tqry8ub_test.go:84: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp5tqry8ub_test.go:84:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075380
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 {\n        return []int{0, 0}\n    }\n    if need\
    \ < 0 || need > 1000 {\n        return []int{0, 0}\n    }\n    if remaining <\
    \ 0 || remaining > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n\
    \    carrots = number\n    carrots = carrots - need\n    carrots = carrots - remaining\n\
    \    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots +\
    \ 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8_r8av_k_test.go:88:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075379
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots \nfunc TestEat(t *testing.T) {\n \
    \ candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected:\
    \ []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n\
    \     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual:\
    \ candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5,\
    \ 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5,\
    \ 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpy0hctr6s_test.go:101:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075372
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ Your code here\n    carrots := 0\n    if number < need {\n        carrots =\
    \ number\n    } else {\n        carrots = need\n    }\n    if carrots > remaining\
    \ {\n        carrots = remaining\n    }\n    carrots = carrots + number\n    carrots\
    \ = carrots - need\n    carrots = carrots + number\n    carrots = carrots - need\n\
    \    carrots = carrots + number\n    carrots = carrots - need\n    carrots = carrots\
    \ + number\n    carrots = carrots - need\n    carrots = carrots + number\n   \
    \ carrots = carrots - need\n    carrots = carrots + number\n    carrots = carrots\
    \ - need\n    carrots = carrots + number\n    carrots = carrots - need\n    carrots\
    \ = carrots + number\n    carrots = carrots - need\n    carrots = carrots + number\n\
    \    carrots = carrots - need\n    carrots = carrots + number\n    carrots = carrots\
    \ - need\n    carrots = carrots + number\n    carrots = carrots - need\n    carrots\
    \ = carrots + number\n    carrots = carrots - need\n    carrots = carrots + number\n\
    \    carrots = carrots - need\n    carrots = carrots + number\n    carrots = carrots\
    \ - need\n    carrots = carrots + number\n    carrots = carrots - need\n    carrots\
    \ = carrots + number\n    carrots = carrots - need\n    carrots = carrots + number\n\
    \    carrots = carrots - need\n    carrots = carrots + number\n    carrots = carrots\
    \ - need\n    carrots = carrots + number\n    carrots = carrots - need\n    carrots\
    \ = carrots + number\n    carrots = carrots - need\n    carrots = carrots + number\n\
    \    carrots = carrots - need\n    carrots = carrots + number\n    carrots = carrots\
    \ - need\n    carrots = carrots + number\n    carrots = carrots - need\n    carrots\
    \ = carrots + number\n    carrots = carrots - need\n    carrots = carrots + number\n\
    \    carrots = carrots - need\n    carrots = carrots + number\n    carrots = \n\
    func TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpym6pt9jg_test.go:89:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075379
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || need < 0 || remaining < 0 {\n        return []int{0, 0}\n    }\n\
    \    if number == 0 {\n        return []int{0, 0}\n    }\n    if remaining ==\
    \ 0 {\n        return []int{number, 0}\n    }\n    if number > need {\n      \
    \  return []int{0, 0}\n    }\n    if number > remaining {\n        return []int{number,\
    \ 0}\n    }\n    if number == need {\n        return []int{number, 0}\n    }\n\
    \    if number == remaining {\n        return []int{number, 0}\n    }\n    if\
    \ number > remaining {\n        return []int{0, 0}\n    }\n    if number > need\
    \ {\n        return []int{0, 0}\n    }\n    if number == 0 {\n        return []int{0,\
    \ 0}\n    }\n    if number > 0 {\n        return []int{0, 0}\n    }\n    if number\
    \ == 0 {\n        return []int{0, 0}\n    }\n    if number > 0 {\n        return\
    \ []int{0, 0}\n    }\n    if number == 0 {\n        return []int{0, 0}\n    }\n\
    \    if number > 0 {\n        return []int{0, 0}\n    }\n    if number == 0 {\n\
    \        return []int{0, 0}\n    }\n    if number > 0 {\n        return []int{0,\
    \ 0}\n    }\n    if number == 0 {\n        return []int{0, 0}\n    }\n    if number\
    \ > 0 {\n        return []int{0, 0}\n    }\n    if number == 0 {\n        return\
    \ []int{0, 0}\n    }\n    if number > 0 {\n        return []int{0, 0}\n    }\n\
    \    if number == 0 {\n        return []int{0, 0}\n    }\n    if number > 0 {\n\
    \        return []int{0, 0}\n    }\n    if number == 0 {\n        return []int{0,\
    \ 0}\n    }\n    if number > 0 {\n        return []int{0, 0}\n    }\n    if number\
    \ == 0 {\n        return []int{0, 0}\n    }\n    if number > 0 {\n        return\
    \ []int{0, 0}\n    }\n    if number == 0 {\n        return []int{0, 0}\n    }\n\
    \    if number > 0 {\n        return []int{0, 0}\n    }\n    if number == 0 {\n\
    \        return []int{0, 0}\n    }\n    if number > 0 {\n        return []int{0,\
    \ 0}\n    }\n    if number == 0 {\n        return []int{0, 0}\n    }\n    if number\
    \ > 0 {\n        return []int{0, 0}\n    }\n    if number == 0 {\n        return\
    \ []int{0, 0}\n    }\n    if number > 0 {\n        return []int{0, 0}\n    }\n\
    \    if number == 0 {\n        return []int{0, 0}\n    }\n    if number > 0 {\n\
    \        return []int{0, 0}\n    }\n    if number == 0 {\n        return []int{0,\
    \ 0}\n    }\n    if number > 0 {\n        return []\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpj78ohnw5_test.go:142:18: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075379
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    if carrots > 1000 {\n        carrots = 1000\n    }\n    return []int{carrots,\
    \ carrots - carrots - number}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpziob0sjx_test.go:55: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=21)\
    \ %!s(int=-5)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpziob0sjx_test.go:55:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=21) %!s(int=-4)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpziob0sjx_test.go:55: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=21) %!s(int=-1)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpziob0sjx_test.go:55: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=18) %!s(int=-2)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpziob0sjx_test.go:55: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=16)\
    \ %!s(int=-4)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpziob0sjx_test.go:55:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=10) %!s(int=-4)]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075380
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 {\n        return []int{0, 0}\n    }\n    if need\
    \ < 0 || need > 1000 {\n        return []int{0, 0}\n    }\n    if remaining <\
    \ 0 || remaining > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n\
    \    carrots += number\n    carrots += need\n    carrots += remaining\n    carrots\
    \ %= 1000\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots %= 1000\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots %= 1000\n    carrots -= number\n    carrots -= need\n\
    \    carrots -= remaining\n    carrots %= 1000\n    carrots -= number\n    carrots\
    \ -= need\n    carrots -= remaining\n    carrots %= 1000\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    carrots %= 1000\n    carrots\
    \ -= number\n    carrots -= need\n    carrots -= remaining\n    carrots %= 1000\n\
    \    carrots -= number\n    carrots -= need\n    carrots -= remaining\n    carrots\
    \ %= 1000\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots %= 1000\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots %= 1000\n    carrots -= number\n    carrots -= need\n\
    \    carrots -= remaining\n    carrots %= 1000\n    carrots -= number\n    carrots\
    \ -= need\n    carrots -= remaining\n    carrots %= 1000\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    carrots %= 1000\n    carrots\
    \ -= number\n    carrots -= need\n    carrots -= remaining\n    carrots %= 1000\n\
    \    carrots -= number\n    carrots -= need\n    carrots -= remaining\n    carrots\
    \ %= 1000\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots %= 1000\n    carrots -= number\n    car\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmprcn8bg7x_test.go:103:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075372
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    carrots = number\n    carrots = carrots - need\n    carrots = carrots\
    \ - remaining\n    if carrots < 0 {\n        carrots = 0\n    }\n    return []int{carrots,\
    \ remaining}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n\
    \     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual:\
    \ candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpkkcrqtkd_test.go:55: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=0)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpkkcrqtkd_test.go:55:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=0) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpkkcrqtkd_test.go:55: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=0) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpkkcrqtkd_test.go:55: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=0) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpkkcrqtkd_test.go:55: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=0)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpkkcrqtkd_test.go:55:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075380
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 {\n        return []int{0, 0}\n    }\n    if need\
    \ < 0 || need > 1000 {\n        return []int{0, 0}\n    }\n    if remaining <\
    \ 0 || remaining > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n\
    \    meals := 0\n    if number > need {\n        meals = number\n        carrots\
    \ = need\n    } else {\n        meals = need\n        carrots = remaining\n  \
    \  }\n    carrots = carrots + meals\n    carrots = carrots + meals\n    carrots\
    \ = carrots + meals\n    carrots = carrots + meals\n    carrots = carrots + meals\n\
    \    carrots = carrots + meals\n    carrots = carrots + meals\n    carrots = carrots\
    \ + meals\n    carrots = carrots + meals\n    carrots = carrots + meals\n    carrots\
    \ = carrots + meals\n    carrots = carrots + meals\n    carrots = carrots + meals\n\
    \    carrots = carrots + meals\n    carrots = carrots + meals\n    carrots = carrots\
    \ + meals\n    carrots = carrots + meals\n    carrots = carrots + meals\n    carrots\
    \ = carrots + meals\n    carrots = carrots + meals\n    carrots = carrots + meals\n\
    \    carrots = carrots + meals\n    carrots = carrots + meals\n    carrots = carrots\
    \ + meals\n    carrots = carrots + meals\n    carrots = carrots + meals\n    carrots\
    \ = carrots + meals\n    carrots = carrots + meals\n    carrots = carrots + meals\n\
    \    carrots = carrots + meals\n    carrots = carrots + meals\n    carrots = carrots\
    \ + meals\n    carrots = carrots + meals\n    carrots = carrots + meals\n    carrots\
    \ = carrots + meals\n    carrots = carrots + meals\n    carrots = carrots + meals\n\
    \    carrots = carrots + meals\n    carrots = carrots + meals\n    carrots = carrots\
    \ + meals\n    carrots = carrots + meals\n    carrot\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmprq9eblma_test.go:87:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075379
- exit_code: 2
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    if number\
    \ == 0 {\n        return []int{0, 0}\n    }\n    if number < need {\n        carrots\
    \ = number\n    } else {\n        carrots = need\n    }\n    if carrots > remaining\
    \ {\n        carrots = remaining\n    }\n    carrots = carrots + eat(number -\
    \ carrots, need, remaining)\n    return []int{carrots, carrots - carrots}\n}\n\
    \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphjn6grn4_test.go:42:15: invalid operation: carrots + eat(number - carrots,
    need, remaining) (mismatched types int and []int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075379
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ Your code here\n    carrots := 0\n    carrots = number\n    carrots = carrots\
    \ - need\n    carrots = carrots + remaining\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n\
    \     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual:\
    \ candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpy0i66ct9_test.go:85:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075379
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    carrots = number\n    if carrots > remaining {\n        carrots =\
    \ remaining\n    }\n    carrots = carrots - need\n    carrots = carrots + need\n\
    \    return []int{carrots, remaining}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp6l7sdts3_test.go:55: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp6l7sdts3_test.go:55:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp6l7sdts3_test.go:55: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp6l7sdts3_test.go:55: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=2) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp6l7sdts3_test.go:55: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp6l7sdts3_test.go:55:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075381
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ Your code here\n    carrots := 0\n    carrots += number\n    carrots += need\n\
    \    carrots += remaining\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpk90x9nqa_test.go:101:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075372
- exit_code: 2
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    if number < 0 || number > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n        return nil\n    }\n    if need < 0 || need > 1000 {\n\
    \        fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if remaining\
    \ < 0 || remaining > 1000 {\n        fmt.Println(\"Invalid input\")\n        return\
    \ nil\n    }\n    if number == 0 {\n        result[0] = 0\n        result[1] =\
    \ 0\n        return result\n    }\n    if number < need {\n        result[0] =\
    \ number\n        result[1] = 0\n        return result\n    }\n    if number >\
    \ remaining {\n        result[0] = number\n        result[1] = remaining\n   \
    \     return result\n    }\n    if number == need {\n        result[0] = number\n\
    \        result[1] = remaining\n        return result\n    }\n    if number >\
    \ need {\n        result[0] = need\n        result[1] = number-need\n        return\
    \ result\n    }\n    if number == remaining {\n        result[0] = need\n    \
    \    result[1] = number-need\n        return result\n    }\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpr99mzhks_test.go:70:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075380
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    if carrots < 0 {\n        carrots = 0\n    }\n    if carrots > 1000 {\n \
    \       carrots = 1000\n    }\n    if carrots < 0 {\n        carrots = 0\n   \
    \ }\n    if carrots > 1000 {\n        carrots = 1000\n    }\n    if carrots <\
    \ 0 {\n        carrots = 0\n    }\n    if carrots > 1000 {\n        carrots =\
    \ 1000\n    }\n    if carrots < 0 {\n        carrots = 0\n    }\n    if carrots\
    \ > 1000 {\n        carrots = 1000\n    }\n    if carrots < 0 {\n        carrots\
    \ = 0\n    }\n    if carrots > 1000 {\n        carrots = 1000\n    }\n    if carrots\
    \ < 0 {\n        carrots = 0\n    }\n    if carrots > 1000 {\n        carrots\
    \ = 1000\n    }\n    if carrots < 0 {\n        carrots = 0\n    }\n    if carrots\
    \ > 1000 {\n        carrots = 1000\n    }\n    if carrots < 0 {\n        carrots\
    \ = 0\n    }\n    if carrots > 1000 {\n        carrots = 1000\n    }\n    if carrots\
    \ < 0 {\n        carrots = 0\n    }\n    if carrots > 1000 {\n        carrots\
    \ = 1000\n    }\n    if carrots < 0 {\n        carrots = 0\n    }\n    if carrots\
    \ > 1000 {\n        carrots = 1000\n    }\n    if carrots < 0 {\n        carrots\
    \ = 0\n    }\n    if carrots > 1000 {\n        carrots = 1000\n    }\n    if carrots\
    \ < 0 {\n        carrots = 0\n    }\n    if carrots > 1000 {\n        carrots\
    \ = 1000\n    }\n    if carrots < 0 {\n        carrots = 0\n    }\n    if carrots\
    \ > 1000 {\n        carrots = 1000\n    }\n    if carrots < 0 {\n        carrots\
    \ = 0\n    }\n    if carrots > 1000 {\n        carrots = 1000\n    }\n    if carrots\
    \ < 0 {\n        carrots = 0\n    }\n    if carrots > 1000 {\n        carrots\
    \ = 1000\n    }\n    if carrots < 0 {\n        carrots = 0\n    }\n    if carrots\
    \ > 1000 {\n        carrots = 1000\n    }\n    if carrots < 0 {\n        carrots\
    \ = 0\n    }\n    if carrots > 1000 {\n        carrots = 1000\n    }\n    if carrots\
    \ < 0 {\n        carrots = 0\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp983llynq_test.go:136:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075380
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    var result []int\n    if number\
    \ >= need {\n        result = append(result, number)\n    }\n    if number < need\
    \ {\n        result = append(result, need-number)\n    }\n    if number < remaining\
    \ {\n        result = append(result, number)\n    }\n    return result\n}\n\n\
    func TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmphmcv6f53_test.go:61: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=1)\
    \ %!s(int=5)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmphmcv6f53_test.go:61:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=4)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmphmcv6f53_test.go:61: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=9) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmphmcv6f53_test.go:61: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=9) %!s(int=2)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmphmcv6f53_test.go:61: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=1)\
    \ %!s(int=4)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmphmcv6f53_test.go:61:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075381
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ write your code here\n    result := make([]int, 2)\n    if number < 0 || number\
    \ > 1000 {\n        result[0] = 0\n        result[1] = 0\n        return result\n\
    \    }\n    if need < 0 || need > 1000 {\n        result[0] = 0\n        result[1]\
    \ = 0\n        return result\n    }\n    if remaining < 0 || remaining > 1000\
    \ {\n        result[0] = 0\n        result[1] = 0\n        return result\n   \
    \ }\n    if number == 0 {\n        result[0] = 0\n        result[1] = 0\n    \
    \    return result\n    }\n    if need == 0 {\n        result[0] = number\n  \
    \      result[1] = 0\n        return result\n    }\n    if remaining == 0 {\n\
    \        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number > need {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number > remaining {\n        result[0]\
    \ = number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ need > remaining {\n        result[0] = need\n        result[1] = remaining\n\
    \        return result\n    }\n    if number == need {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if number == remaining\
    \ {\n        result[0] = number\n        result[1] = remaining\n        return\
    \ result\n    }\n    if need == remaining {\n        result[0] = need\n      \
    \  result[1] = remaining\n        return result\n    }\n    if number > need {\n\
    \        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number > remaining {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if need > remaining {\n     \
    \   result[0] = need\n        result[1] = remaining\n        return result\n \
    \   }\n    if number == need {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number == remaining {\n       \
    \ result[0] = number\n        result[1] = remaining\n        return result\n \
    \   }\n    if need == remaining {\n        result[0] = need\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number > need {\n        result[0]\
    \ = number\n        result[1] = need\n        return result\n    }\n    if number\
    \ > remaining {\n        result[0] = number\n        result[1] = remaining\n \
    \       return result\n    }\n    if need > remaining {\n        result[0] = need\n\
    \        result[1] = remaining\n        return result\n    }\n    if number ==\
    \ need {\n        result[0] = number\n        result[1] = need\n        return\
    \ result\n    }\n    if number == remaining {\n        result[0] = number\n  \
    \      result[1] = remaining\n        return result\n    }\n    if need == remaining\
    \ {\n        result[0] = need\n        result[1] = remaining\n        return result\n\
    \    }\n    if number > need {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number > remaining {\n        result[0]\
    \ = number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ need > remaining {\n        result[0] = need\n        result[1] = remaining\n\
    \        return result\n    }\n    if number == need {\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpc5hy6kni_test.go:166:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075380
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    var result []int\n    if number\
    \ == 0 {\n        result = []int{0, 0}\n    } else {\n        if number > remaining\
    \ {\n            result = []int{number, 0}\n        } else {\n            result\
    \ = []int{0, number - remaining}\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpvazkou64_test.go:61: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=0)\
    \ %!s(int=-5)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpvazkou64_test.go:61:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=0) %!s(int=-5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpvazkou64_test.go:61: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=0) %!s(int=-9)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpvazkou64_test.go:61: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=0) %!s(int=-3)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpvazkou64_test.go:61: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=0)\
    \ %!s(int=-3)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpvazkou64_test.go:61:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075381
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots -= number\n    carrots -= need\n    carrots -= remaining\n    carrots\
    \ -= number\n    carrots -= need\n    carrots -= remaining\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    carrots -= number\n    carrots\
    \ -= need\n    carrots -= remaining\n    carrots -= number\n    carrots -= need\n\
    \    carrots -= remaining\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots -= number\n    carrots -= need\n    carrots -= remaining\n    carrots\
    \ -= number\n    carrots -= need\n    carrots -= remaining\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    carrots -= number\n    carrots\
    \ -= need\n    carrots -= remaining\n    carrots -= number\n    carrots -= need\n\
    \    carrots -= remaining\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots -= number\n    carrots -= need\n    carrots -= remaining\n    carrots\
    \ -= number\n    carrots -= need\n    carrots -= remaining\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    carrots -= number\n    carrots\
    \ -= need\n    carrots -= remaining\n    carrots -= number\n    carrots -= need\n\
    \    carrots -= remaining\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots -= number\n    carrots -= need\n    carrots -= remaining\n    carrots\
    \ -= number\n    carrots -= need\n    carrots -= remaining\n    carrots \nfunc\
    \ TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpr2iwr2xj_test.go:101:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075380
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    var\
    \ result []int\n    if number > 1000 || need > 1000 || remaining > 1000 {\n  \
    \      fmt.Println(\"Invalid input\")\n    }\n    if number == 0 {\n        result\
    \ = []int{0, 0}\n    }\n    if number < need {\n        result = []int{number,\
    \ 0}\n    }\n    if number < remaining {\n        result = []int{number, need}\n\
    \    }\n    return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpk0udnzf9_test.go:61: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5)\
    \ %!s(int=6)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpk0udnzf9_test.go:61:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=8)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpk0udnzf9_test.go:61: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpk0udnzf9_test.go:61: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=2) %!s(int=11)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpk0udnzf9_test.go:61: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4)\
    \ %!s(int=5)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpk0udnzf9_test.go:61:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075381
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    var result []int\n    if number\
    \ > remaining {\n        number = remaining\n    }\n    if need > remaining {\n\
    \        need = remaining\n    }\n    if number > 0 {\n        result = append(result,\
    \ number)\n    }\n    if need > 0 {\n        result = append(result, need)\n \
    \   }\n    return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp71jm_kd2_test.go:64: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5)\
    \ %!s(int=6)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp71jm_kd2_test.go:64:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=8)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp71jm_kd2_test.go:64: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp71jm_kd2_test.go:64: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=2) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp71jm_kd2_test.go:64: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4)\
    \ %!s(int=5)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp71jm_kd2_test.go:64:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075381
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    if carrots > 1000 {\n        carrots = 1000\n    }\n    return []int{carrots,\
    \ carrots - carrots - need}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate :=\
    \ eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpsvv7k2lt_test.go:55: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=21)\
    \ %!s(int=-6)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpsvv7k2lt_test.go:55:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=21) %!s(int=-8)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpsvv7k2lt_test.go:55: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=21) %!s(int=-10)]'\n    --- FAIL:\
    \ TestEat/test_num__3 (0.00s)\n        tmpsvv7k2lt_test.go:55: expected '[%!s(int=7)\
    \ %!s(int=0)]', got '[%!s(int=18) %!s(int=-11)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmpsvv7k2lt_test.go:55: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=16) %!s(int=-5)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n\
    \        tmpsvv7k2lt_test.go:55: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=10)\
    \ %!s(int=-5)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075381
- exit_code: 2
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    if number <= 0 {\n        result[0] = 0\n        result[1]\
    \ = 0\n        return result\n    }\n    if need <= 0 {\n        result[0] = 0\n\
    \        result[1] = 0\n        return result\n    }\n    if remaining <= 0 {\n\
    \        result[0] = 0\n        result[1] = 0\n        return result\n    }\n\
    \    if number > need {\n        result[0] = number\n        result[1] = 0\n \
    \       return result\n    }\n    if number > remaining {\n        result[0] =\
    \ number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ number == need {\n        result[0] = number\n        result[1] = remaining\n\
    \        return result\n    }\n    if number == remaining {\n        result[0]\
    \ = number\n        result[1] = 0\n        return result\n    }\n    if number\
    \ > remaining {\n        result[0] = number\n        result[1] = remaining\n \
    \       return result\n    }\n    if number == 0 {\n        result[0] = number\n\
    \        result[1] = 0\n        return result\n    }\n    if number > 0 {\n  \
    \      result[0] = number\n        result[1] = 0\n        return result\n    }\n\
    }\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpi8eafsgv_test.go:78:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075381
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    var\
    \ result []int\n    if number < 0 || number > 1000 {\n        fmt.Println(\"Invalid\
    \ input\")\n        return nil\n    }\n    if need < 0 || need > 1000 {\n    \
    \    fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if remaining\
    \ < 0 || remaining > 1000 {\n        fmt.Println(\"Invalid input\")\n        return\
    \ nil\n    }\n    if number == 0 {\n        return nil\n    }\n    if number >\
    \ need {\n        fmt.Println(\"Invalid input\")\n        return nil\n    }\n\
    \    if number > remaining {\n        fmt.Println(\"Invalid input\")\n       \
    \ return nil\n    }\n    if number == need {\n        return nil\n    }\n    if\
    \ number > remaining {\n        fmt.Println(\"Invalid input\")\n        return\
    \ nil\n    }\n    if number == 0 {\n        return nil\n    }\n    if number >\
    \ need {\n        fmt.Println(\"Invalid input\")\n        return nil\n    }\n\
    \    if number > remaining {\n        fmt.Println(\"Invalid input\")\n       \
    \ return nil\n    }\n    if number == need {\n        return nil\n    }\n    if\
    \ number > remaining {\n        fmt.Println(\"Invalid input\")\n        return\
    \ nil\n    }\n    if number == 0 {\n        return nil\n    }\n    if number >\
    \ need {\n        fmt.Println(\"Invalid input\")\n        return nil\n    }\n\
    \    if number > remaining {\n        fmt.Println(\"Invalid input\")\n       \
    \ return nil\n    }\n    if number == need {\n        return nil\n    }\n    if\
    \ number > remaining {\n        fmt.Println(\"Invalid input\")\n        return\
    \ nil\n    }\n    if number == 0 {\n        return nil\n    }\n    if number >\
    \ need {\n        fmt.Println(\"Invalid input\")\n        return nil\n    }\n\
    \    if number > remaining {\n        fmt.Println(\"Invalid input\")\n       \
    \ return nil\n    }\n    if number == need {\n        return nil\n    }\n    if\
    \ number > remaining {\n        fmt.Println(\"Invalid input\")\n        return\
    \ nil\n    }\n    if number == 0 {\n        return nil\n    }\n    if number >\
    \ need {\n        fmt.Println(\"Invalid input\")\n        return nil\n    }\n\
    \    if number > remaining {\n        fmt.Println(\"Invalid input\")\n       \
    \ return nil\n    }\n    if number == need {\n        return nil\n    }\n    if\
    \ number > remaining {\n        fmt.Println(\"Invalid input\")\n        return\
    \ nil\n    }\n    if number == 0 {\n        return nil\n    }\n    if number >\
    \ need {\n        fmt.Println(\"Invalid input\")\n        return nil\n    }\n\
    \    if number > remaining {\n        fmt.Println(\"Invalid input\")\n       \
    \ return nil\n    }\n    if number == \nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpehh5cgfp_test.go:142:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075380
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    if number < 0 || number > 1000 {\n        result[0] =\
    \ 0\n        result[1] = 0\n        return result\n    }\n    if need < 0 || need\
    \ > 1000 {\n        result[0] = 0\n        result[1] = 0\n        return result\n\
    \    }\n    if remaining < 0 || remaining > 1000 {\n        result[0] = 0\n  \
    \      result[1] = 0\n        return result\n    }\n    if number == 0 {\n   \
    \     result[0] = number\n        result[1] = remaining\n        return result\n\
    \    }\n    if need == 0 {\n        result[0] = number\n        result[1] = remaining\n\
    \        return result\n    }\n    if remaining == 0 {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if number > need\
    \ {\n        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number > remaining {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if need > remaining {\n     \
    \   result[0] = need\n        result[1] = remaining\n        return result\n \
    \   }\n    if number > need && number > remaining {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if need > number\
    \ && need > remaining {\n        result[0] = need\n        result[1] = number\n\
    \        return result\n    }\n    if number > need && number > remaining {\n\
    \        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if need > number && need > remaining {\n        result[0] = need\n\
    \        result[1] = number\n        return result\n    }\n    if number > need\
    \ && number > remaining {\n        result[0] = number\n        result[1] = need\n\
    \        return result\n    }\n    if need > number && need > remaining {\n  \
    \      result[0] = need\n        result[1] = number\n        return result\n \
    \   }\n    if number > need && number > remaining {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if need > number\
    \ && need > remaining {\n        result[0] = need\n        result[1] = number\n\
    \        return result\n    }\n    if number > need && number > remaining {\n\
    \        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if need > number && need > remaining {\n        result[0] = need\n\
    \        result[1] = number\n        return result\n    }\n    if number > need\
    \ && number > remaining {\n        result[0] = number\n        result[1] = need\n\
    \        return result\n    }\n    if need > number && need > remaining {\n  \
    \      result[0] = need\n        result[1] = number\n        return result\n \
    \   }\n    if number > need && number > remaining {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if need > number\
    \ && need > remaining {\n        result[0] = need\n        result[1] = number\n\
    \        return result\n    }\n    if number > need && number > remaining {\n\
    \        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if need > number && \nfunc TestEat(t *testing.T) {\n  candidate :=\
    \ eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpkaxhuxc4_test.go:149:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075380
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 {\n        return []int{0, 0}\n    }\n    if need\
    \ < 0 || need > 1000 {\n        return []int{0, 0}\n    }\n    if remaining <\
    \ 0 || remaining > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n\
    \    carrots += number\n    carrots += need\n    carrots += remaining\n    carrots\
    \ = carrots % 100\n    carrots = carrots / 100\n    carrots = carrots + 1\n  \
    \  carrots = carrots % 100\n    carrots = carrots / 100\n    carrots = carrots\
    \ + 1\n    carrots = carrots % 100\n    carrots = carrots / 100\n    carrots =\
    \ carrots + 1\n    carrots = carrots % 100\n    carrots = carrots / 100\n    carrots\
    \ = carrots + 1\n    carrots = carrots % 100\n    carrots = carrots / 100\n  \
    \  carrots = carrots + 1\n    carrots = carrots % 100\n    carrots = carrots /\
    \ 100\n    carrots = carrots + 1\n    carrots = carrots % 100\n    carrots = carrots\
    \ / 100\n    carrots = carrots + 1\n    carrots = carrots % 100\n    carrots =\
    \ carrots / 100\n    carrots = carrots + 1\n    carrots = carrots % 100\n    carrots\
    \ = carrots / 100\n    carrots = carrots + 1\n    carrots = carrots % 100\n  \
    \  carrots = carrots / 100\n    carrots = carrots + 1\n    carrots = carrots %\
    \ 100\n    carrots = carrots / 100\n    carrots = carrots + 1\n    carrots = carrots\
    \ % 100\n    carrots = carrots / 100\n    carrots = carrots + 1\n    carrots =\
    \ carrots % 100\n    carrots = carrots / 100\n    carrots = carrots + 1\n    carrots\
    \ = carrots % 100\n    carrots = carrots / 100\n    carrots = carrots + 1\n  \
    \  carrots = carrots % 100\n    carrots = carrots / 100\n    carrots = carrots\
    \ + 1\n    carrots = carrots % 100\n    carrots = carrot\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8s3j2bya_test.go:87:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075380
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    var\
    \ result []int\n    if number < 0 || number > 1000 {\n        fmt.Println(\"Invalid\
    \ input\")\n        return nil\n    }\n    if need < 0 || need > 1000 {\n    \
    \    fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if remaining\
    \ < 0 || remaining > 1000 {\n        fmt.Println(\"Invalid input\")\n        return\
    \ nil\n    }\n    if number == 0 {\n        return nil\n    }\n    if number >\
    \ need {\n        fmt.Println(\"Invalid input\")\n        return nil\n    }\n\
    \    if number > remaining {\n        fmt.Println(\"Invalid input\")\n       \
    \ return nil\n    }\n    if number == need {\n        return nil\n    }\n    if\
    \ number == remaining {\n        return nil\n    }\n    if number > 1000 {\n \
    \       fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if need\
    \ > 1000 {\n        fmt.Println(\"Invalid input\")\n        return nil\n    }\n\
    \    if remaining > 1000 {\n        fmt.Println(\"Invalid input\")\n        return\
    \ nil\n    }\n    if number == 0 || need == 0 || remaining == 0 {\n        return\
    \ nil\n    }\n    if number > need {\n        fmt.Println(\"Invalid input\")\n\
    \        return nil\n    }\n    if number > remaining {\n        fmt.Println(\"\
    Invalid input\")\n        return nil\n    }\n    if number == need {\n       \
    \ return nil\n    }\n    if number == remaining {\n        return nil\n    }\n\
    \    if number > 1000 {\n        fmt.Println(\"Invalid input\")\n        return\
    \ nil\n    }\n    if need > 1000 {\n        fmt.Println(\"Invalid input\")\n \
    \       return nil\n    }\n    if remaining > 1000 {\n        fmt.Println(\"Invalid\
    \ input\")\n        return nil\n    }\n    if number == 0 || need == 0 || remaining\
    \ == 0 {\n        return nil\n    }\n    if number > need {\n        fmt.Println(\"\
    Invalid input\")\n        return nil\n    }\n    if number > remaining {\n   \
    \     fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if number\
    \ == need {\n        return nil\n    }\n    if number == remaining {\n       \
    \ return nil\n    }\n    if number > 1000 {\n        fmt.Println(\"Invalid input\"\
    )\n        return nil\n    }\n    if need > 1000 {\n        fmt.Println(\"Invalid\
    \ input\")\n        return nil\n    }\n    if remaining > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n        return nil\n    }\n    if number == 0 || need == 0 ||\
    \ remaining == 0 {\n        return nil\n    }\n    if number > need {\n      \
    \  fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if number >\
    \ remaining {\n        fmt.Println(\"Invalid input\")\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7q0os0zd_test.go:136:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075380
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    return []int{carrots,\
    \ carrots - carrots % 1000}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate :=\
    \ eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpbymp6tml_test.go:55: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=21)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpbymp6tml_test.go:55:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=21) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpbymp6tml_test.go:55: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=21) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpbymp6tml_test.go:55: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=18) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpbymp6tml_test.go:55: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=16)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpbymp6tml_test.go:55:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075376
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    if number < 0 || number > 1000 || need < 0 || need >\
    \ 1000 || remaining < 0 || remaining > 1000 {\n        fmt.Println(\"Invalid input\"\
    )\n        return nil\n    }\n    if number == 0 {\n        result[0] = 0\n  \
    \      result[1] = 0\n        return result\n    }\n    if need == 0 {\n     \
    \   result[0] = 0\n        result[1] = number\n        return result\n    }\n\
    \    if remaining == 0 {\n        result[0] = number\n        result[1] = need\n\
    \        return result\n    }\n    if number > need {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if number > remaining\
    \ {\n        result[0] = number\n        result[1] = remaining\n        return\
    \ result\n    }\n    if need > remaining {\n        result[0] = need\n       \
    \ result[1] = remaining\n        return result\n    }\n    if number == need {\n\
    \        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number == remaining {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if need == remaining {\n    \
    \    result[0] = need\n        result[1] = remaining\n        return result\n\
    \    }\n    if number > need {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number > remaining {\n        result[0]\
    \ = number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ need > remaining {\n        result[0] = need\n        result[1] = remaining\n\
    \        return result\n    }\n    if number == need {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if number == remaining\
    \ {\n        result[0] = number\n        result[1] = remaining\n        return\
    \ result\n    }\n    if need == remaining {\n        result[0] = need\n      \
    \  result[1] = remaining\n        return result\n    }\n    if number > need {\n\
    \        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number > remaining {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if need > remaining {\n     \
    \   result[0] = need\n        result[1] = remaining\n        return result\n \
    \   }\n    if number == need {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number == remaining {\n       \
    \ result[0] = number\n        result[1] = remaining\n        return result\n \
    \   }\n    if need == remaining {\n        result[0] = need\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number > need {\n        result[0]\
    \ = number\n        result[1] = need\n        return result\n    }\n    if number\
    \ > remaining {\n        result[0] = number\n        result[1] = remaining\n \
    \       return result\n    }\n    if need > remaining {\n        result[0] = need\n\
    \        result[1] = remaining\n        return result\n    }\n    if number ==\
    \ need {\n        result[0] = number\n        result[1] = need\n        return\
    \ result\n    }\n    if number == remaining {\n        result[0] = number\n  \
    \      result[1] = remaining\n        return result\n    }\n    if need \nfunc\
    \ TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmptf_zxuai_test.go:163:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075380
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    if number < 0 || number > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n        return nil\n    }\n    if need < 0 || need > 1000 {\n\
    \        fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if remaining\
    \ < 0 || remaining > 1000 {\n        fmt.Println(\"Invalid input\")\n        return\
    \ nil\n    }\n    if number == 0 {\n        result[0] = 0\n        result[1] =\
    \ 0\n        return result\n    }\n    if number == need {\n        result[0]\
    \ = number\n        result[1] = 0\n        return result\n    }\n    if number\
    \ > need {\n        fmt.Println(\"Invalid input\")\n        return nil\n    }\n\
    \    if number == remaining {\n        result[0] = number\n        result[1] =\
    \ remaining\n        return result\n    }\n    if number < remaining {\n     \
    \   result[0] = number\n        result[1] = remaining\n        return result\n\
    \    }\n    if number == remaining {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number < remaining {\n   \
    \     result[0] = number\n        result[1] = remaining\n        return result\n\
    \    }\n    if number == remaining {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number < remaining {\n   \
    \     result[0] = number\n        result[1] = remaining\n        return result\n\
    \    }\n    if number == remaining {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number < remaining {\n   \
    \     result[0] = number\n        result[1] = remaining\n        return result\n\
    \    }\n    if number == remaining {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number < remaining {\n   \
    \     result[0] = number\n        result[1] = remaining\n        return result\n\
    \    }\n    if number == remaining {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number < remaining {\n   \
    \     result[0] = number\n        result[1] = remaining\n        return result\n\
    \    }\n    if number == remaining {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number < remaining {\n   \
    \     result[0] = number\n        result[1] = remaining\n        return result\n\
    \    }\n    if number == remaining {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number < remaining {\n   \
    \     result[0] = number\n        result[1] = remaining\n        return result\n\
    \    }\n    if number == remaining {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number < remaining {\n   \
    \     result[0] = number\n        result[1] = remaining\n        return result\n\
    \    }\n    if number == remaining {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number < remaining {\n   \
    \     result[0] = number\n        result[1] = remaining\n        return result\n\
    \    }\n    if number == remaining {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number < remaining {\nfunc\
    \ TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxrqnhq05_test.go:160:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075380
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    carrots = number\n    if carrots > remaining {\n        carrots =\
    \ remaining\n    }\n    carrots = carrots - need\n    carrots = carrots + need\n\
    \    carrots = carrots + need\n    carrots = carrots + need\n    carrots = carrots\
    \ + need\n    carrots = carrots + need\n    carrots = carrots + need\n    carrots\
    \ = carrots + need\n    carrots = carrots + need\n    carrots = carrots + need\n\
    \    carrots = carrots + need\n    carrots = carrots + need\n    carrots = carrots\
    \ + need\n    carrots = carrots + need\n    carrots = carrots + need\n    carrots\
    \ = carrots + need\n    carrots = carrots + need\n    carrots = carrots + need\n\
    \    carrots = carrots + need\n    carrots = carrots + need\n    carrots = carrots\
    \ + need\n    carrots = carrots + need\n    carrots = carrots + need\n    carrots\
    \ = carrots + need\n    carrots = carrots + need\n    carrots = carrots + need\n\
    \    carrots = carrots + need\n    carrots = carrots + need\n    carrots = carrots\
    \ + need\n    carrots = carrots + need\n    carrots = carrots + need\n    carrots\
    \ = carrots + need\n    carrots = carrots + need\n    carrots = carrots + need\n\
    \    carrots = carrots + need\n    carrots = carrots + need\n    carrots = carrots\
    \ + need\n    carrots = carrots + need\n    carrots = carrots + need\n    carrots\
    \ = carrots + need\n    carrots = carrots + need\n    carrots = carrots + need\n\
    \    carrots = carrots + need\n    carrots = carrots + need\n    carrots = carrots\
    \ + need\n    carrots = carrots + need\n    carrots = carrots + need\n    carrots\
    \ = carrots + need\n    carrots = carrots + need\n    carrots = carrots + need\n\
    \    carrots = carrots + need\n    carrots = carrots + need\n    carrots = carrots\
    \ + need\n    carrots = carrots + \nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpv1honrhq_test.go:86:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075381
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    carrots := 0\n    if number < 0 || number > 1000 {\n\
    \        fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if need\
    \ < 0 || need > 1000 {\n        fmt.Println(\"Invalid input\")\n        return\
    \ nil\n    }\n    if remaining < 0 || remaining > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n        return nil\n    }\n    if number == 0 {\n        result[0]\
    \ = 0\n        result[1] = 0\n        return result\n    }\n    if need == 0 {\n\
    \        result[0] = 0\n        result[1] = 0\n        return result\n    }\n\
    \    if remaining == 0 {\n        result[0] = number\n        result[1] = need\n\
    \        return result\n    }\n    if number > need {\n        fmt.Println(\"\
    Invalid input\")\n        return nil\n    }\n    if number > remaining {\n   \
    \     fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if number\
    \ == need {\n        result[0] = number\n        result[1] = need\n        return\
    \ result\n    }\n    if number == remaining {\n        result[0] = number\n  \
    \      result[1] = need\n        return result\n    }\n    if number > need {\n\
    \        fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if number\
    \ > remaining {\n        fmt.Println(\"Invalid input\")\n        return nil\n\
    \    }\n    if number == need {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number == remaining {\n       \
    \ result[0] = number\n        result[1] = need\n        return result\n    }\n\
    \    if number > need {\n        fmt.Println(\"Invalid input\")\n        return\
    \ nil\n    }\n    if number > remaining {\n        fmt.Println(\"Invalid input\"\
    )\n        return nil\n    }\n    if number == need {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if number == remaining\
    \ {\n        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number > need {\n        fmt.Println(\"Invalid input\")\n     \
    \   return nil\n    }\n    if number > remaining {\n        fmt.Println(\"Invalid\
    \ input\")\n        return nil\n    }\n    if number == need {\n        result[0]\
    \ = number\n        result[1] = need\n        return result\n    }\n    if number\
    \ == remaining {\n        result[0] = number\n        result[1] = need\n     \
    \   return result\n    }\n    if number > need {\n        fmt.Println(\"Invalid\
    \ input\")\n        return nil\n    }\n    if number > remaining {\n        fmt.Println(\"\
    Invalid input\")\n        return nil\n    }\n    if number == need {\n       \
    \ result[0] = number\n        result[1] = need\n        return result\n    }\n\
    \    if number == remaining {\n        result[0] = number\n        result[1] =\
    \ need\n        return result\n    }\n    if number > need {\n        fmt.Print\n\
    func TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp72fys7b7_test.go:148:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075381
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ write your code here\n    carrots := 0\n    carrots += number\n    carrots +=\
    \ need\n    carrots += remaining\n    carrots %= 1000\n    carrots %= 1000\n \
    \   carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpg3jtvjqa_test.go:101:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075381
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    if number < 0 || number > 1000 {\n        fmt.Println(\"Invalid input\"\
    )\n        return []int{}\n    }\n    if need < 0 || need > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n        return []int{}\n    }\n    if remaining < 0 || remaining\
    \ > 1000 {\n        fmt.Println(\"Invalid input\")\n        return []int{}\n \
    \   }\n    if number == 0 {\n        return []int{0, 0}\n    }\n    if number\
    \ == need {\n        return []int{0, 0}\n    }\n    if number > need {\n     \
    \   return []int{0, 0}\n    }\n    if remaining == 0 {\n        return []int{number,\
    \ 0}\n    }\n    if remaining == need {\n        return []int{number, 0}\n   \
    \ }\n    if remaining > need {\n        return []int{number, 0}\n    }\n    if\
    \ number > remaining {\n        return []int{number, 0}\n    }\n    if number\
    \ == remaining {\n        return []int{number, 0}\n    }\n    if number < remaining\
    \ {\n        return []int{number, 0}\n    }\n    if number > remaining {\n   \
    \     return []int{number, 0}\n    }\n    if number == remaining {\n        return\
    \ []int{number, 0}\n    }\n    if number < remaining {\n        return []int{number,\
    \ 0}\n    }\n    if number == remaining {\n        return []int{number, 0}\n \
    \   }\n    if number < remaining {\n        return []int{number, 0}\n    }\n \
    \   if number == remaining {\n        return []int{number, 0}\n    }\n    if number\
    \ < remaining {\n        return []int{number, 0}\n    }\n    if number == remaining\
    \ {\n        return []int{number, 0}\n    }\n    if number < remaining {\n   \
    \     return []int{number, 0}\n    }\n    if number == remaining {\n        return\
    \ []int{number, 0}\n    }\n    if number < remaining {\n        return []int{number,\
    \ 0}\n    }\n    if number == remaining {\n        return []int{number, 0}\n \
    \   }\n    if number < remaining {\n        return []int{number, 0}\n    }\n \
    \   if number == remaining {\n        return []int{number, 0}\n    }\n    if number\
    \ < remaining {\n        return []int{number, 0}\n    }\n    if number == remaining\
    \ {\n        return []int{number, 0}\n    }\n    if number < remaining {\n   \
    \     return []int{number, 0}\n    }\n    if number == remaining {\n        return\
    \ []int{number, 0}\n    }\n    if number < remaining {\n        return []int{number,\
    \ 0}\n    }\n    if number == remaining {\n        return []int{number, 0}\n \
    \   }\n    if number < remaining {\n        return []int{number, 0}\n    }\n \
    \   if number == remaining {\n        return []int{number, 0}\n    }\n    if number\
    \ < remaining \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n\
    \     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual:\
    \ candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjwrr25dp_test.go:134:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075381
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots +=\
    \ number\n    carrots += need\n    carrots += remaining\n    carrots += number\n\
    \    carrots += need\n    carrots += remaining\n    carrots += number\n    carrots\
    \ += need\n    carrots += remaining\n    carrots += number\n    carrots += need\n\
    \    carrots += remaining\n    carrots += number\n    carrots += need\n    carrots\
    \ += remaining\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots += number\n    carrots += need\n    carrots += remaining\n    carrots\
    \ += number\n    carrots += need\n    carrots += remaining\n    carrots += number\n\
    \    carrots += need\n    carrots += remaining\n    carrots += number\n    carrots\
    \ += need\n    carrots += remaining\n    carrots += number\n    carrots += need\n\
    \    carrots += remaining\n    carrots += number\n    carrots += need\n    carrots\
    \ += remaining\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots += number\n    carrots += need\n    carrots += remaining\n    carrots\
    \ += number\n    carrots += need\n    carrots += remaining\n    carrots += number\n\
    \    carrots += need\n    carrots += remaining\n    carrots += number\n    carrots\
    \ += need\n    carrots += remaining\n    carrots += number\n    carrots += need\n\
    \    carrots += remaining\n    carrots += number\n    carrots += need\n    carrots\
    \ += remaining\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots += number\n    carrots += need\n    carrots += remaining\n    carrots\
    \ += number\n    carrots += need\n    carrots += remaining\n    carrots += number\n\
    \    carrots += need\n    carrots += remaining\n    carrots += number\n    carrots\
    \ += need\n    carrots += remaining\n    carrots += number\n    carrots += need\n\
    \    carrots += remaining\n    carrots += number\n    carrots += need\n    carrots\
    \ += remaining\n    carrots += number\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpje5_5vpr_test.go:111:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075381
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    if carrots < 0 {\n        carrots = 0\n    }\n    if carrots > 1000 {\n \
    \       carrots = 1000\n    }\n    if carrots < 0 {\n        carrots = 0\n   \
    \ }\n    if carrots > 1000 {\n        carrots = 1000\n    }\n    if carrots <\
    \ 0 {\n        carrots = 0\n    }\n    if carrots > 1000 {\n        carrots =\
    \ 1000\n    }\n    if carrots < 0 {\n        carrots = 0\n    }\n    if carrots\
    \ > 1000 {\n        carrots = 1000\n    }\n    if carrots < 0 {\n        carrots\
    \ = 0\n    }\n    if carrots > 1000 {\n        carrots = 1000\n    }\n    if carrots\
    \ < 0 {\n        carrots = 0\n    }\n    if carrots > 1000 {\n        carrots\
    \ = 1000\n    }\n    if carrots < 0 {\n        carrots = 0\n    }\n    if carrots\
    \ > 1000 {\n        carrots = 1000\n    }\n    if carrots < 0 {\n        carrots\
    \ = 0\n    }\n    if carrots > 1000 {\n        carrots = 1000\n    }\n    if carrots\
    \ < 0 {\n        carrots = 0\n    }\n    if carrots > 1000 {\n        carrots\
    \ = 1000\n    }\n    if carrots < 0 {\n        carrots = 0\n    }\n    if carrots\
    \ > 1000 {\n        carrots = 1000\n    }\n    if carrots < 0 {\n        carrots\
    \ = 0\n    }\n    if carrots > 1000 {\n        carrots = 1000\n    }\n    if carrots\
    \ < 0 {\n        carrots = 0\n    }\n    if carrots > 1000 {\n        carrots\
    \ = 1000\n    }\n    if carrots < 0 {\n        carrots = 0\n    }\n    if carrots\
    \ > 1000 {\n        carrots = 1000\n    }\n    if carrots < 0 {\n        carrots\
    \ = 0\n    }\n    if carrots > 1000 {\n        carrots = 1000\n    }\n    if carrots\
    \ < 0 {\n        carrots = 0\n    }\n    if carrots > 1000 {\n        carrots\
    \ = 1000\n    }\n    if carrots < 0 {\n        carrots = 0\n    }\n    if carrots\
    \ > 1000 {\n        carrots = 1000\n    }\n    if carrots < 0 {\n        carrots\
    \ = 0\n    }\n    if carrots > 1000 {\n        carrots = 1000\n    }\n    if carrots\
    \ < 0 {\n        carrots = 0\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp983llynq_test.go:136:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075380
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    carrots := 0\n    if number < 0 || number > 1000 {\n\
    \        result[0] = 0\n        result[1] = 0\n        return result\n    }\n\
    \    if need < 0 || need > 1000 {\n        result[0] = 0\n        result[1] =\
    \ 0\n        return result\n    }\n    if remaining < 0 || remaining > 1000 {\n\
    \        result[0] = 0\n        result[1] = 0\n        return result\n    }\n\
    \    if number == 0 {\n        result[0] = 0\n        result[1] = 0\n        return\
    \ result\n    }\n    if need == 0 {\n        result[0] = number\n        result[1]\
    \ = 0\n        return result\n    }\n    if remaining == 0 {\n        result[0]\
    \ = number\n        result[1] = need\n        return result\n    }\n    if number\
    \ > need {\n        result[0] = number\n        result[1] = need\n        return\
    \ result\n    }\n    if number > remaining {\n        result[0] = number\n   \
    \     result[1] = remaining\n        return result\n    }\n    if need > remaining\
    \ {\n        result[0] = need\n        result[1] = remaining\n        return result\n\
    \    }\n    if number > 0 && need > 0 && remaining > 0 {\n        result[0] =\
    \ number\n        result[1] = need\n        return result\n    }\n    if number\
    \ > 0 && need > 0 && remaining == 0 {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number > 0 && need == 0 && remaining\
    \ > 0 {\n        result[0] = number\n        result[1] = remaining\n        return\
    \ result\n    }\n    if number > 0 && need == 0 && remaining == 0 {\n        result[0]\
    \ = number\n        result[1] = 0\n        return result\n    }\n    if number\
    \ > 0 && need > 0 && remaining > 0 {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number > 0 && need > 0 && remaining\
    \ == 0 {\n        result[0] = number\n        result[1] = need\n        return\
    \ result\n    }\n    if number > 0 && need == 0 && remaining > 0 {\n        result[0]\
    \ = number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ number > 0 && need == 0 && remaining == 0 {\n        result[0] = number\n  \
    \      result[1] = 0\n        return result\n    }\n    if number > 0 && need\
    \ > 0 && remaining > 0 {\n        result[0] = number\n        result[1] = need\n\
    \        return result\n    }\n    if number > 0 && need > 0 && remaining == 0\
    \ {\n        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number > 0 && need == 0 && remaining > 0 {\n        result[0] =\
    \ number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ number > 0 && need == 0 && remaining == 0 {\n        result[0] = number\n  \
    \      result[1] = 0\n        return result\n    }\n    if number > 0 && need\
    \ > 0 && remaining > 0 {\n        result[0] = number\n        result[1] = need\n\
    \        return result\n    }\n    if number > 0 && need > 0 && remaining == 0\
    \ {\n        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number > 0 && need == \nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqh8y8c92_test.go:145:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075381
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots += number\n    carrots += need\n    carrots += remaining\n    carrots\
    \ += number\n    carrots += need\n    carrots += remaining\n    carrots += number\n\
    \    carrots += need\n    carrots += remaining\n    carrots += number\n    carrots\
    \ += need\n    carrots += remaining\n    carrots += number\n    carrots += need\n\
    \    carrots += remaining\n    carrots += number\n    carrots += need\n    carrots\
    \ += remaining\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots += number\n    carrots += need\n    carrots += remaining\n    carrots\
    \ += number\n    carrots += need\n    carrots += remaining\n    carrots += number\n\
    \    carrots += need\n    carrots += remaining\n    carrots += number\n    carrots\
    \ += need\n    carrots += remaining\n    carrots += number\n    carrots += need\n\
    \    carrots += remaining\n    carrots += number\n    carrots += need\n    carrots\
    \ += remaining\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots += number\n    carrots += need\n    carrots += remaining\n    carrots\
    \ += number\n    carrots += need\n    carrots += remaining\n    carrots += number\n\
    \    carrots += need\n    carrots += remaining\n    carrots += number\n    carrots\
    \ += need\n    carrots += remaining\n    carrots += number\n    carrots += need\n\
    \    carrots += remaining\n    carrots += number\n    carrots += need\n    carrots\
    \ += remaining\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots += number\n    carrots += need\n    carrots += remaining\n    carrots\
    \ += number\n    carrots += need\n    carrots += remaining\n    carrots += number\n\
    \    carrots += need\n    carrots += remaining\n    carrots += number\n    carrots\
    \ += need\n    carrots += remaining\n    carrots += number\n    carrots += need\n\
    \    carrots += remaining\n    carrots += number\n    carrots += need\n    carrots\
    \ += remaining\n    \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n\
    \     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual:\
    \ candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxt7vvloc_test.go:113:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075375
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots +=\
    \ number\n    carrots += need\n    carrots += remaining\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp465lejp9_test.go:100:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075372
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 {\n        return []int{0, 0}\n    }\n    if need\
    \ < 0 || need > 1000 {\n        return []int{0, 0}\n    }\n    if remaining <\
    \ 0 || remaining > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n\
    \    carrots += number\n    carrots += need\n    carrots += remaining\n    carrots\
    \ %= 1000\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots %= 1000\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots %= 1000\n    carrots -= number\n    carrots -= need\n\
    \    carrots -= remaining\n    carrots %= 1000\n    carrots -= number\n    carrots\
    \ -= need\n    carrots -= remaining\n    carrots %= 1000\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    carrots %= 1000\n    carrots\
    \ -= number\n    carrots -= need\n    carrots -= remaining\n    carrots %= 1000\n\
    \    carrots -= number\n    carrots -= need\n    carrots -= remaining\n    carrots\
    \ %= 1000\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots %= 1000\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots %= 1000\n    carrots -= number\n    carrots -= need\n\
    \    carrots -= remaining\n    carrots %= 1000\n    carrots -= number\n    carrots\
    \ -= need\n    carrots -= remaining\n    carrots %= 1000\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    carrots %= 1000\n    carrots\
    \ -= number\n    carrots -= need\n    carrots -= remaining\n    carrots %= 1000\n\
    \    carrots -= number\n    carrots -= need\n    carrots -= remaining\n    carrots\
    \ %= 1000\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots %= 1000\n    carrots -= number\n    car\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmprcn8bg7x_test.go:103:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075372
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    var\
    \ result []int\n    if number < 0 || number > 1000 {\n        fmt.Println(\"Invalid\
    \ input\")\n    }\n    if need < 0 || need > 1000 {\n        fmt.Println(\"Invalid\
    \ input\")\n    }\n    if remaining < 0 || remaining > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n    }\n    if number == 0 {\n        return nil\n    }\n   \
    \ if number < need {\n        fmt.Println(\"Invalid input\")\n    }\n    if number\
    \ > remaining {\n        fmt.Println(\"Invalid input\")\n    }\n    if number\
    \ == need {\n        return nil\n    }\n    if number > need {\n        number\
    \ = need\n    }\n    if number > remaining {\n        number = remaining\n   \
    \ }\n    if number == 0 {\n        return nil\n    }\n    if number < need {\n\
    \        fmt.Println(\"Invalid input\")\n    }\n    if number > remaining {\n\
    \        fmt.Println(\"Invalid input\")\n    }\n    if number == need {\n    \
    \    return nil\n    }\n    if number > need {\n        number = need\n    }\n\
    \    if number > remaining {\n        number = remaining\n    }\n    if number\
    \ == 0 {\n        return nil\n    }\n    if number < need {\n        fmt.Println(\"\
    Invalid input\")\n    }\n    if number > remaining {\n        fmt.Println(\"Invalid\
    \ input\")\n    }\n    if number == need {\n        return nil\n    }\n    if\
    \ number > need {\n        number = need\n    }\n    if number > remaining {\n\
    \        number = remaining\n    }\n    if number == 0 {\n        return nil\n\
    \    }\n    if number < need {\n        fmt.Println(\"Invalid input\")\n    }\n\
    \    if number > remaining {\n        fmt.Println(\"Invalid input\")\n    }\n\
    \    if number == need {\n        return nil\n    }\n    if number > need {\n\
    \        number = need\n    }\n    if number > remaining {\n        number = remaining\n\
    \    }\n    if number == 0 {\n        return nil\n    }\n    if number < need\
    \ {\n        fmt.Println(\"Invalid input\")\n    }\n    if number > remaining\
    \ {\n        fmt.Println(\"Invalid input\")\n    }\n    if number == need {\n\
    \        return nil\n    }\n    if number > need {\n        number = need\n  \
    \  }\n    if number > remaining {\n        number = remaining\n    }\n    if number\
    \ == 0 {\n        return nil\n    }\n    if number < need {\n        fmt.Println(\"\
    Invalid input\")\n    }\n    if number > remaining {\n        fmt.Println(\"Invalid\
    \ input\")\n    }\n    if number == need {\n        return nil\n    }\n    if\
    \ number > need {\n        number = need\n    }\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphx36vby2_test.go:143:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075381
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots +=\
    \ number\n    carrots += need\n    carrots += remaining\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp465lejp9_test.go:100:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075372
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 {\n        return []int{0, 0}\n    }\n    if need\
    \ < 0 || need > 1000 {\n        return []int{0, 0}\n    }\n    if remaining <\
    \ 0 || remaining > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n\
    \    carrots += number\n    carrots += need\n    carrots -= remaining\n    return\
    \ []int{carrots, remaining}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate :=\
    \ eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpwf5rbxjc_test.go:61: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=1)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpwf5rbxjc_test.go:61:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=3) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpwf5rbxjc_test.go:61: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpwf5rbxjc_test.go:61: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=8) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpwf5rbxjc_test.go:61: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=2)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpwf5rbxjc_test.go:61:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=8) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075382
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    var\
    \ result []int\n    if number < 0 || number > 1000 || need < 0 || need > 1000\
    \ || remaining < 0 || remaining > 1000 {\n        fmt.Println(\"Invalid input\"\
    )\n        return nil\n    }\n    if number == 0 {\n        result = append(result,\
    \ 0)\n        return result\n    }\n    if need == 0 {\n        result = append(result,\
    \ number)\n        return result\n    }\n    if remaining == 0 {\n        result\
    \ = append(result, number)\n        return result\n    }\n    if number > need\
    \ {\n        fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if\
    \ number > remaining {\n        fmt.Println(\"Invalid input\")\n        return\
    \ nil\n    }\n    if number == need {\n        result = append(result, number)\n\
    \        return result\n    }\n    if number == remaining {\n        result =\
    \ append(result, number)\n        return result\n    }\n    if number > remaining\
    \ {\n        fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if\
    \ number == need {\n        result = append(result, number)\n        return result\n\
    \    }\n    if number == remaining {\n        result = append(result, number)\n\
    \        return result\n    }\n    if number > need {\n        fmt.Println(\"\
    Invalid input\")\n        return nil\n    }\n    if number == need {\n       \
    \ result = append(result, number)\n        return result\n    }\n    if number\
    \ == remaining {\n        result = append(result, number)\n        return result\n\
    \    }\n    if number > need {\n        fmt.Println(\"Invalid input\")\n     \
    \   return nil\n    }\n    if number == need {\n        result = append(result,\
    \ number)\n        return result\n    }\n    if number == remaining {\n      \
    \  result = append(result, number)\n        return result\n    }\n    if number\
    \ > need {\n        fmt.Println(\"Invalid input\")\n        return nil\n    }\n\
    \    if number == need {\n        result = append(result, number)\n        return\
    \ result\n    }\n    if number == remaining {\n        result = append(result,\
    \ number)\n        return result\n    }\n    if number > need {\n        fmt.Println(\"\
    Invalid input\")\n        return nil\n    }\n    if number == need {\n       \
    \ result = append(result, number)\n        return result\n    }\n    if number\
    \ == remaining {\n        result = append(result, number)\n        return result\n\
    \    }\n    if number > need {\n        fmt.Println(\"Invalid input\")\n     \
    \   return nil\n    }\n    if number == need {\n        result = append(result,\
    \ number)\n        return result\n    }\n    if number == remaining {\n      \
    \  result = append(result, number)\n        return result\n    }\n    if number\
    \ > need {\n        fmt.Println(\"Invalid input\")\n        return nil\n    }\n\
    \    if number == need {\n        result = append(result, number)\n        return\
    \ result\n    }\n    if number == remaining {\n        result = append(result,\
    \ number)\n        return result\n    }\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9dioaq_f_test.go:144:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075381
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ write your code here\n    carrots := 0\n    carrots += number\n    carrots +=\
    \ need\n    carrots += remaining\n    return []int{carrots, carrots - number}\n\
    }\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmptfw_ka1i_test.go:53: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=21)\
    \ %!s(int=16)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmptfw_ka1i_test.go:53:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=21) %!s(int=17)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmptfw_ka1i_test.go:53: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=21) %!s(int=20)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmptfw_ka1i_test.go:53: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=18) %!s(int=16)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmptfw_ka1i_test.go:53: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=16)\
    \ %!s(int=12)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmptfw_ka1i_test.go:53:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=10) %!s(int=6)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075382
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ write your code here\n    carrots := 0\n    carrots += number\n    carrots +=\
    \ need\n    carrots += remaining\n    carrots = carrots % 1000\n    carrots =\
    \ carrots / 1000\n    carrots = carrots + 1\n    carrots = carrots % 1000\n  \
    \  carrots = carrots / 1000\n    carrots = carrots + 1\n    carrots = carrots\
    \ % 1000\n    carrots = carrots / 1000\n    carrots = carrots + 1\n    carrots\
    \ = carrots % 1000\n    carrots = carrots / 1000\n    carrots = carrots + 1\n\
    \    carrots = carrots % 1000\n    carrots = carrots / 1000\n    carrots = carrots\
    \ + 1\n    carrots = carrots % 1000\n    carrots = carrots / 1000\n    carrots\
    \ = carrots + 1\n    carrots = carrots % 1000\n    carrots = carrots / 1000\n\
    \    carrots = carrots + 1\n    carrots = carrots % 1000\n    carrots = carrots\
    \ / 1000\n    carrots = carrots + 1\n    carrots = carrots % 1000\n    carrots\
    \ = carrots / 1000\n    carrots = carrots + 1\n    carrots = carrots % 1000\n\
    \    carrots = carrots / 1000\n    carrots = carrots + 1\n    carrots = carrots\
    \ % 1000\n    carrots = carrots / 1000\n    carrots = carrots + 1\n    carrots\
    \ = carrots % 1000\n    carrots = carrots / 1000\n    carrots = carrots + 1\n\
    \    carrots = carrots % 1000\n    carrots = carrots / 1000\n    carrots = carrots\
    \ + 1\n    carrots = carrots % 1000\n    carrots = carrots / 1000\n    carrots\
    \ = carrots + 1\n    carrots = carrots % 1000\n    carrots = carrots / 1000\n\
    \    carrots = carrots + 1\n    carrots = carrots % 1000\n    carrots = carrots\
    \ / 1000\n    carrots = carrots + 1\n    carrots = carrots % 1000\n    carrots\
    \ = carrots / 1000\n    carrots = carrots + 1\n    carrots = carrot\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmprcnpp6al_test.go:84:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075382
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    return []int{carrots, carrots - number}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpbtupbi6n_test.go:52: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=21)\
    \ %!s(int=16)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpbtupbi6n_test.go:52:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=21) %!s(int=17)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpbtupbi6n_test.go:52: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=21) %!s(int=20)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpbtupbi6n_test.go:52: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=18) %!s(int=16)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpbtupbi6n_test.go:52: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=16)\
    \ %!s(int=12)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpbtupbi6n_test.go:52:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=10) %!s(int=6)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075373
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ Your code here\n    carrots := 0\n    if number < need {\n        carrots =\
    \ number\n    } else {\n        carrots = need\n    }\n    carrots = carrots -\
    \ remaining\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    \nfunc TestEat(t *testing.T) {\n\
    \  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected:\
    \ []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n\
    \     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual:\
    \ candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5,\
    \ 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5,\
    \ 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3hxv1wsn_test.go:88:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075382
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    if number > 1000 || need > 1000 || remaining > 1000 {\n\
    \        fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if number\
    \ == 0 {\n        result[0] = 0\n        result[1] = 0\n        return result\n\
    \    }\n    if need == 0 {\n        result[0] = number\n        result[1] = 0\n\
    \        return result\n    }\n    if remaining == 0 {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if number > need\
    \ {\n        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number > remaining {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if need > remaining {\n     \
    \   result[0] = need\n        result[1] = remaining\n        return result\n \
    \   }\n    if number > need && number > remaining {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if need > number\
    \ && need > remaining {\n        result[0] = need\n        result[1] = number\n\
    \        return result\n    }\n    if number > need && number > remaining {\n\
    \        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if need > number && need > remaining {\n        result[0] = need\n\
    \        result[1] = number\n        return result\n    }\n    if number > need\
    \ && number > remaining {\n        result[0] = number\n        result[1] = need\n\
    \        return result\n    }\n    if need > number && need > remaining {\n  \
    \      result[0] = need\n        result[1] = number\n        return result\n \
    \   }\n    if number > need && number > remaining {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if need > number\
    \ && need > remaining {\n        result[0] = need\n        result[1] = number\n\
    \        return result\n    }\n    if number > need && number > remaining {\n\
    \        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if need > number && need > remaining {\n        result[0] = need\n\
    \        result[1] = number\n        return result\n    }\n    if number > need\
    \ && number > remaining {\n        result[0] = number\n        result[1] = need\n\
    \        return result\n    }\n    if need > number && need > remaining {\n  \
    \      result[0] = need\n        result[1] = number\n        return result\n \
    \   }\n    if number > need && number > remaining {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if need > number\
    \ && need > remaining {\n        result[0] = need\n        result[1] = number\n\
    \        return result\n    }\n    if number > need && number > remaining {\n\
    \        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if need > number && need > remaining {\n        result[0] = need\n\
    \        result[1] = number\n        return result\n    }\n    if number > need\
    \ && number > remaining {\n        result[0] = number\n        result[1] = need\n\
    \        return result\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n\
    \     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual:\
    \ candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpgpo3pe81_test.go:146:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075382
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots \nfunc TestEat(t *testing.T) {\n \
    \ candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected:\
    \ []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n\
    \     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual:\
    \ candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5,\
    \ 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5,\
    \ 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpy0hctr6s_test.go:101:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075372
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ write your code here\n    carrots := 0\n    carrots += number\n    carrots +=\
    \ need\n    carrots += remaining\n    carrots %= 1000\n    carrots %= 1000\n \
    \   carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpg3jtvjqa_test.go:101:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075381
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ Your code here\n    carrots := 0\n    carrots += number\n    carrots += need\n\
    \    carrots -= remaining\n    return []int{carrots, remaining}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpl_apfr6i_test.go:53: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=1)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpl_apfr6i_test.go:53:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=3) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpl_apfr6i_test.go:53: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpl_apfr6i_test.go:53: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=8) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpl_apfr6i_test.go:53: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=2)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpl_apfr6i_test.go:53:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=8) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075383
- exit_code: 2
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    if number < 0 || number > 1000 || need < 0 || need >\
    \ 1000 || remaining < 0 || remaining > 1000 {\n        fmt.Println(\"Invalid input\"\
    )\n    }\n    if number == 0 {\n        result[0] = 0\n        result[1] = 0\n\
    \        return result\n    }\n    if number > need {\n        result[0] = number\n\
    \        result[1] = remaining\n        return result\n    }\n    if number <\
    \ need {\n        result[0] = need\n        result[1] = number\n        return\
    \ result\n    }\n    if number == need {\n        result[0] = number\n       \
    \ result[1] = remaining\n        return result\n    }\n    if number > remaining\
    \ {\n        result[0] = number\n        result[1] = remaining\n        return\
    \ result\n    }\n    if number < remaining {\n        result[0] = remaining\n\
    \        result[1] = number\n        return result\n    }\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpe5kl73bd_test.go:61:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075382
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ Your code here\n    carrots := 0\n    carrots = number\n    carrots = carrots\
    \ - need\n    carrots = carrots - remaining\n    carrots = carrots + need\n  \
    \  carrots = carrots + remaining\n    carrots = carrots + need\n    carrots =\
    \ carrots + remaining\n    carrots = carrots + need\n    carrots = carrots + remaining\n\
    \    carrots = carrots + need\n    carrots = carrots + remaining\n    carrots\
    \ = carrots + need\n    carrots = carrots + remaining\n    carrots = carrots +\
    \ need\n    carrots = carrots + remaining\n    carrots = carrots + need\n    carrots\
    \ = carrots + remaining\n    carrots = carrots + need\n    carrots = carrots +\
    \ remaining\n    carrots = carrots + need\n    carrots = carrots + remaining\n\
    \    carrots = carrots + need\n    carrots = carrots + remaining\n    carrots\
    \ = carrots + need\n    carrots = carrots + remaining\n    carrots = carrots +\
    \ need\n    carrots = carrots + remaining\n    carrots = carrots + need\n    carrots\
    \ = carrots + remaining\n    carrots = carrots + need\n    carrots = carrots +\
    \ remaining\n    carrots = carrots + need\n    carrots = carrots + remaining\n\
    \    carrots = carrots + need\n    carrots = carrots + remaining\n    carrots\
    \ = carrots + need\n    carrots = carrots + remaining\n    carrots = carrots +\
    \ need\n    carrots = carrots + remaining\n    carrots = carrots + need\n    carrots\
    \ = carrots + remaining\n    carrots = carrots + need\n    carrots = carrots +\
    \ remaining\n    carrots = carrots + need\n    carrots = carrots + remaining\n\
    \    carrots = carrots + need\n    carrots = carrots + remaining\n    carrots\
    \ = carrots + need\n    carrots = carrots + remaining\n    carrots = carrots +\
    \ need\n    carrots = carrots + remaining\n    carrots = carrots + need\n    carrots\
    \ = carrots + remaining\n    carrots = carrots + need\n    carrots = carrots +\
    \ remaining\n    carrots = carrots + need\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6xpp6jbz_test.go:85:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075375
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    if number < 0 || number > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n        return nil\n    }\n    if need < 0 || need > 1000 {\n\
    \        fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if remaining\
    \ < 0 || remaining > 1000 {\n        fmt.Println(\"Invalid input\")\n        return\
    \ nil\n    }\n    if number == 0 {\n        result[0] = 0\n        result[1] =\
    \ 0\n        return result\n    }\n    if need == 0 {\n        result[0] = 0\n\
    \        result[1] = 0\n        return result\n    }\n    if remaining == 0 {\n\
    \        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number > need {\n        fmt.Println(\"Invalid input\")\n     \
    \   return nil\n    }\n    if number > remaining {\n        fmt.Println(\"Invalid\
    \ input\")\n        return nil\n    }\n    if number == need {\n        result[0]\
    \ = number\n        result[1] = need\n        return result\n    }\n    if number\
    \ == remaining {\n        result[0] = number\n        result[1] = remaining\n\
    \        return result\n    }\n    if number > remaining {\n        fmt.Println(\"\
    Invalid input\")\n        return nil\n    }\n    if number == need {\n       \
    \ result[0] = number\n        result[1] = need\n        return result\n    }\n\
    \    if number == remaining {\n        result[0] = number\n        result[1] =\
    \ remaining\n        return result\n    }\n    if number > need {\n        fmt.Println(\"\
    Invalid input\")\n        return nil\n    }\n    if number == need {\n       \
    \ result[0] = number\n        result[1] = need\n        return result\n    }\n\
    \    if number == remaining {\n        result[0] = number\n        result[1] =\
    \ remaining\n        return result\n    }\n    if number > need {\n        fmt.Println(\"\
    Invalid input\")\n        return nil\n    }\n    if number == need {\n       \
    \ result[0] = number\n        result[1] = need\n        return result\n    }\n\
    \    if number == remaining {\n        result[0] = number\n        result[1] =\
    \ remaining\n        return result\n    }\n    if number > need {\n        fmt.Println(\"\
    Invalid input\")\n        return nil\n    }\n    if number == need {\n       \
    \ result[0] = number\n        result[1] = need\n        return result\n    }\n\
    \    if number == remaining {\n        result[0] = number\n        result[1] =\
    \ remaining\n        return result\n    }\n    if number > need {\n        fmt.Println(\"\
    Invalid input\")\n        return nil\n    }\n    if number == need {\n       \
    \ result[0] = number\n        result[1] = need\n        return result\n    }\n\
    \    if number == remaining {\n        result[0] = number\n        result[1] =\
    \ remaining\n        return result\n    }\n    if number > need {\n        fmt.Println(\"\
    Invalid input\")\n        return nil\n    }\n    if number == need {\n       \
    \ result[0] = number\n        result[1] = need\n        return result\n    }\n\
    \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmap_q07x_test.go:153:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075382
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots += number\n    carrots += need\n    carrots += remaining\n    carrots\
    \ += number\n    carrots += need\n    carrots += remaining\n    carrots += number\n\
    \    carrots += need\n    carrots += remaining\n    carrots += number\n    carrots\
    \ += need\n    carrots += remaining\n    carrots += number\n    carrots += need\n\
    \    carrots += remaining\n    carrots += number\n    carrots += need\n    carrots\
    \ += remaining\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots += number\n    carrots += need\n    carrots += remaining\n    carrots\
    \ += number\n    carrots += need\n    carrots += remaining\n    carrots += number\n\
    \    carrots += need\n    carrots += remaining\n    carrots += number\n    carrots\
    \ += need\n    carrots += remaining\n    carrots += number\n    carrots += need\n\
    \    carrots += remaining\n    carrots += number\n    carrots += need\n    carrots\
    \ += remaining\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots += number\n    carrots += need\n    carrots += remaining\n    carrots\
    \ += number\n    carrots += need\n    carrots += remaining\n    carrots += number\n\
    \    carrots += need\n    carrots += remaining\n    carrots += number\n    carrots\
    \ += need\n    carrots += remaining\n    carrots += number\n    carrots += need\n\
    \    carrots += remaining\n    carrots += number\n    carrots += need\n    carrots\
    \ += remaining\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots += number\n    carrots += need\n    carrots += remaining\n    carrots\
    \ += number\n    carrots += need\n    carrots += remaining\n    carrots += number\n\
    \    carrots += need\n    carrots += remaining\n    carrots += number\n    carrots\
    \ += need\n    carrots += remaining\n    carrots += number\n    carrots += need\n\
    \    carrots += remaining\n    carrots += number\n    carrots += need\n    carrots\
    \ += remaining\n    \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n\
    \     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual:\
    \ candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxt7vvloc_test.go:113:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075375
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 {\n        return []int{0, 0}\n    }\n    if need\
    \ < 0 || need > 1000 {\n        return []int{0, 0}\n    }\n    if remaining <\
    \ 0 || remaining > 1000 {\n        return []int{0, 0}\n    }\n    if number ==\
    \ 0 {\n        return []int{0, 0}\n    }\n    if need == 0 {\n        return []int{number,\
    \ 0}\n    }\n    if remaining == 0 {\n        return []int{number, number}\n \
    \   }\n    if number > need {\n        return []int{0, 0}\n    }\n    if number\
    \ == need {\n        return []int{number, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, number}\n    }\n    if number == remaining {\n  \
    \      return []int{number, number}\n    }\n    if number > remaining {\n    \
    \    return []int{0, number}\n    }\n    if number == remaining {\n        return\
    \ []int{number, number}\n    }\n    if number > need {\n        return []int{0,\
    \ 0}\n    }\n    if number == need {\n        return []int{number, 0}\n    }\n\
    \    if number > remaining {\n        return []int{0, number}\n    }\n    if number\
    \ == remaining {\n        return []int{number, number}\n    }\n    if number >\
    \ need {\n        return []int{0, 0}\n    }\n    if number == need {\n       \
    \ return []int{number, 0}\n    }\n    if number > remaining {\n        return\
    \ []int{0, number}\n    }\n    if number == remaining {\n        return []int{number,\
    \ number}\n    }\n    if number > need {\n        return []int{0, 0}\n    }\n\
    \    if number == need {\n        return []int{number, 0}\n    }\n    if number\
    \ > remaining {\n        return []int{0, number}\n    }\n    if number == remaining\
    \ {\n        return []int{number, number}\n    }\n    if number > need {\n   \
    \     return []int{0, 0}\n    }\n    if number == need {\n        return []int{number,\
    \ 0}\n    }\n    if number > remaining {\n        return []int{0, number}\n  \
    \  }\n    if number == remaining {\n        return []int{number, number}\n   \
    \ }\n    if number > need {\n        return []int{0, 0}\n    }\n    if number\
    \ == need {\n        return []int{number, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, number}\n    }\n    if number == remaining {\n  \
    \      return []int{number, number}\n    }\n    if number > need {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n        return []int{number, 0}\n\
    \    }\n    if number > remaining {\n        return []int{0, number}\n    }\n\
    \    if number == remaining {\n        return []int{number, number}\n    }\n \
    \   if number \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n\
    \     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual:\
    \ candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4x574r4s_test.go:136:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075382
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || need < 0 || remaining < 0 {\n        return []int{0, 0}\n    }\n\
    \    carrots := 0\n    if number < need {\n        carrots = number\n    } else\
    \ {\n        carrots = need\n    }\n    if carrots > remaining {\n        carrots\
    \ = remaining\n    }\n    return []int{carrots, remaining}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpqzzhe5mn_test.go:60: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpqzzhe5mn_test.go:60:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpqzzhe5mn_test.go:60: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpqzzhe5mn_test.go:60: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=2) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpqzzhe5mn_test.go:60: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpqzzhe5mn_test.go:60:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075383
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number == 0 {\n        return []int{0, 0}\n    }\n    if need == 0 {\n     \
    \   return []int{number, 0}\n    }\n    if remaining <= 0 {\n        return []int{0,\
    \ number}\n    }\n    result := make([]int, 2)\n    result[0] = number\n    result[1]\
    \ = remaining\n    if number > need {\n        result[0] = need\n        result[1]\
    \ = number\n    }\n    if number > remaining {\n        result[0] = remaining\n\
    \        result[1] = need\n    }\n    return result\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpkx5nhvkh_test.go:68: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpkx5nhvkh_test.go:68:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpkx5nhvkh_test.go:68: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpkx5nhvkh_test.go:68: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=2) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpkx5nhvkh_test.go:68: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpkx5nhvkh_test.go:68:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=5)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075383
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    carrots = number\n    carrots = carrots - need\n    carrots = carrots\
    \ - remaining\n    carrots = carrots + need\n    carrots = carrots + remaining\n\
    \    return []int{carrots, remaining}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpiuomtdqv_test.go:54: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpiuomtdqv_test.go:54:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpiuomtdqv_test.go:54: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpiuomtdqv_test.go:54: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=2) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpiuomtdqv_test.go:54: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpiuomtdqv_test.go:54:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075375
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    if carrots < 0 {\n        carrots = 0\n    }\n    if carrots > 1000 {\n \
    \       carrots = 1000\n    }\n    return []int{carrots, carrots - number}\n}\n\
    \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpgowh4iil_test.go:58: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=21)\
    \ %!s(int=16)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpgowh4iil_test.go:58:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=21) %!s(int=17)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpgowh4iil_test.go:58: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=21) %!s(int=20)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpgowh4iil_test.go:58: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=18) %!s(int=16)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpgowh4iil_test.go:58: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=16)\
    \ %!s(int=12)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpgowh4iil_test.go:58:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=10) %!s(int=6)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075383
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    if number < 0 || number > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n        return nil\n    }\n    if need < 0 || need > 1000 {\n\
    \        fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if remaining\
    \ < 0 || remaining > 1000 {\n        fmt.Println(\"Invalid input\")\n        return\
    \ nil\n    }\n    if number == 0 {\n        result[0] = 0\n        result[1] =\
    \ 0\n        return result\n    }\n    if need == 0 {\n        result[0] = number\n\
    \        result[1] = 0\n        return result\n    }\n    if remaining == 0 {\n\
    \        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number > need {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number > remaining {\n        result[0]\
    \ = number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ need > remaining {\n        result[0] = need\n        result[1] = remaining\n\
    \        return result\n    }\n    if number > need && number > remaining {\n\
    \        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number > need && number > remaining {\n        result[0] = number\n\
    \        result[1] = remaining\n        return result\n    }\n    if need > number\
    \ && need > remaining {\n        result[0] = need\n        result[1] = remaining\n\
    \        return result\n    }\n    if need > number && need > remaining {\n  \
    \      result[0] = need\n        result[1] = remaining\n        return result\n\
    \    }\n    if number > need && number > remaining {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if number > need\
    \ && number > remaining {\n        result[0] = number\n        result[1] = remaining\n\
    \        return result\n    }\n    if need > number && need > remaining {\n  \
    \      result[0] = need\n        result[1] = remaining\n        return result\n\
    \    }\n    if need > number && need > remaining {\n        result[0] = need\n\
    \        result[1] = remaining\n        return result\n    }\n    if number >\
    \ need && number > remaining {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number > need && number > remaining\
    \ {\n        result[0] = number\n        result[1] = remaining\n        return\
    \ result\n    }\n    if need > number && need > remaining {\n        result[0]\
    \ = need\n        result[1] = remaining\n        return result\n    }\n    if\
    \ need > number && need > remaining {\n        result[0] = need\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number > need && number >\
    \ remaining {\n        result[0] = number\n        result[1] = need\n        return\
    \ result\n    }\n    if number > need && number > remaining {\n        result[0]\
    \ = number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ need > number && need > remaining {\n        result[0] = need\n        result[1]\
    \ = remaining\n        return result\n    }\n    if need \nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpta384jp7_test.go:146:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075382
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    if number > 1000 || need > 1000 || remaining > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    if number == 0 {\n        return []int{0, 0}\n    }\n\
    \    if need == 0 {\n        return []int{number, 0}\n    }\n    if remaining\
    \ == 0 {\n        return []int{number, number}\n    }\n    if number > need {\n\
    \        return []int{0, 0}\n    }\n    if number > remaining {\n        return\
    \ []int{number, number}\n    }\n    if need > remaining {\n        return []int{0,\
    \ 0}\n    }\n    if number == need {\n        return []int{number, number}\n \
    \   }\n    if number > need {\n        return []int{0, 0}\n    }\n    if number\
    \ > remaining {\n        return []int{number, number}\n    }\n    if need > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if number == need {\n        return\
    \ []int{number, number}\n    }\n    if number > need {\n        return []int{0,\
    \ 0}\n    }\n    if number > remaining {\n        return []int{number, number}\n\
    \    }\n    if need > remaining {\n        return []int{0, 0}\n    }\n    if number\
    \ == need {\n        return []int{number, number}\n    }\n    if number > need\
    \ {\n        return []int{0, 0}\n    }\n    if number > remaining {\n        return\
    \ []int{number, number}\n    }\n    if need > remaining {\n        return []int{0,\
    \ 0}\n    }\n    if number == need {\n        return []int{number, number}\n \
    \   }\n    if number > need {\n        return []int{0, 0}\n    }\n    if number\
    \ > remaining {\n        return []int{number, number}\n    }\n    if need > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if number == need {\n        return\
    \ []int{number, number}\n    }\n    if number > need {\n        return []int{0,\
    \ 0}\n    }\n    if number > remaining {\n        return []int{number, number}\n\
    \    }\n    if need > remaining {\n        return []int{0, 0}\n    }\n    if number\
    \ == need {\n        return []int{number, number}\n    }\n    if number > need\
    \ {\n        return []int{0, 0}\n    }\n    if number > remaining {\n        return\
    \ []int{number, number}\n    }\n    if need > remaining {\n        return []int{0,\
    \ 0}\n    }\n    if number == need {\n        return []int{number, number}\n \
    \   }\n    if number > need {\n        return []int{0, 0}\n    }\n    if number\
    \ > remaining {\n        return []int{number, number}\n    }\n    if need > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if number == need {\n        return\
    \ []int{number, \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n\
    \     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual:\
    \ candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpf3bock0p_test.go:135:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075382
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots = carrots % 1000\n    carrots = carrots / 1000\n    carrots = carrots\
    \ + 1\n    carrots = carrots % 1000\n    carrots = carrots / 1000\n    carrots\
    \ = carrots + 1\n    carrots = carrots % 1000\n    carrots = carrots / 1000\n\
    \    carrots = carrots + 1\n    carrots = carrots % 1000\n    carrots = carrots\
    \ / 1000\n    carrots = carrots + 1\n    carrots = carrots % 1000\n    carrots\
    \ = carrots / 1000\n    carrots = carrots + 1\n    carrots = carrots % 1000\n\
    \    carrots = carrots / 1000\n    carrots = carrots + 1\n    carrots = carrots\
    \ % 1000\n    carrots = carrots / 1000\n    carrots = carrots + 1\n    carrots\
    \ = carrots % 1000\n    carrots = carrots / 1000\n    carrots = carrots + 1\n\
    \    carrots = carrots % 1000\n    carrots = carrots / 1000\n    carrots = carrots\
    \ + 1\n    carrots = carrots % 1000\n    carrots = carrots / 1000\n    carrots\
    \ = carrots + 1\n    carrots = carrots % 1000\n    carrots = carrots / 1000\n\
    \    carrots = carrots + 1\n    carrots = carrots % 1000\n    carrots = carrots\
    \ / 1000\n    carrots = carrots + 1\n    carrots = carrots % 1000\n    carrots\
    \ = carrots / 1000\n    carrots = carrots + 1\n    carrots = carrots % 1000\n\
    \    carrots = carrots / 1000\n    carrots = carrots + 1\n    carrots = carrots\
    \ % 1000\n    carrots = carrots / 1000\n    carrots = carrots + 1\n    carrots\
    \ = carrots % 1000\n    carrots = carrots / 1000\n    carrots = carrots + 1\n\
    \    carrots = carrots % 1000\n    carrots = carrots / 1000\n    carrots = carrots\
    \ + 1\n    carrots = carrots % 1000\n    \nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpopuxy4pz_test.go:84:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075377
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    var\
    \ result []int\n    if number < 0 || number > 1000 {\n        fmt.Println(\"Invalid\
    \ input\")\n        return nil\n    }\n    if need < 0 || need > 1000 {\n    \
    \    fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if remaining\
    \ < 0 || remaining > 1000 {\n        fmt.Println(\"Invalid input\")\n        return\
    \ nil\n    }\n    if number == 0 {\n        fmt.Println(\"Invalid input\")\n \
    \       return nil\n    }\n    if number > need {\n        fmt.Println(\"Invalid\
    \ input\")\n        return nil\n    }\n    if number > remaining {\n        fmt.Println(\"\
    Invalid input\")\n        return nil\n    }\n    if number == need {\n       \
    \ fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if number ==\
    \ remaining {\n        fmt.Println(\"Invalid input\")\n        return nil\n  \
    \  }\n    if number > 1000 {\n        fmt.Println(\"Invalid input\")\n       \
    \ return nil\n    }\n    if number > 1000 {\n        fmt.Println(\"Invalid input\"\
    )\n        return nil\n    }\n    if number > 1000 {\n        fmt.Println(\"Invalid\
    \ input\")\n        return nil\n    }\n    if number > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n        return nil\n    }\n    if number > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n        return nil\n    }\n    if number > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n        return nil\n    }\n    if number > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n        return nil\n    }\n    if number > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n        return nil\n    }\n    if number > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n        return nil\n    }\n    if number > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n        return nil\n    }\n    if number > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n        return nil\n    }\n    if number > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n        return nil\n    }\n    if number > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n        return nil\n    }\n    if number > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n        return nil\n    }\n    if number > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n        return nil\n    }\n    if number > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n        return nil\n    }\n    if number > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n        return nil\n    }\n    if number > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n        return nil\n    }\n    if number > 1000 {\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpm6fge4zn_test.go:133:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075382
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    var\
    \ result []int\n    if number < 0 || number > 1000 {\n        fmt.Println(\"Invalid\
    \ input\")\n        return nil\n    }\n    if need < 0 || need > 1000 {\n    \
    \    fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if remaining\
    \ < 0 || remaining > 1000 {\n        fmt.Println(\"Invalid input\")\n        return\
    \ nil\n    }\n    if number == 0 {\n        return nil\n    }\n    if number >\
    \ need {\n        fmt.Println(\"Invalid input\")\n        return nil\n    }\n\
    \    if number > remaining {\n        fmt.Println(\"Invalid input\")\n       \
    \ return nil\n    }\n    if number == need {\n        return nil\n    }\n    if\
    \ number == remaining {\n        return nil\n    }\n    if number > 1000 {\n \
    \       fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if need\
    \ > 1000 {\n        fmt.Println(\"Invalid input\")\n        return nil\n    }\n\
    \    if remaining > 1000 {\n        fmt.Println(\"Invalid input\")\n        return\
    \ nil\n    }\n    if number > 0 {\n        result = append(result, number)\n \
    \   }\n    if need > 0 {\n        result = append(result, need)\n    }\n    if\
    \ remaining > 0 {\n        result = append(result, remaining)\n    }\n    return\
    \ result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Invalid input\n--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0\
    \ (0.00s)\n        tmpa4okjmw0_test.go:99: expected '[%!s(int=11) %!s(int=4)]',\
    \ got '[%!s(int=5) %!s(int=6) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1\
    \ (0.00s)\n        tmpa4okjmw0_test.go:99: expected '[%!s(int=12) %!s(int=1)]',\
    \ got '[%!s(int=4) %!s(int=8) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__2\
    \ (0.00s)\n        tmpa4okjmw0_test.go:99: expected '[%!s(int=11) %!s(int=0)]',\
    \ got '[%!s(int=1) %!s(int=10) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpa4okjmw0_test.go:99: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=2) %!s(int=11) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmpa4okjmw0_test.go:99: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=4) %!s(int=5) %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5\
    \ (0.00s)\n        tmpa4okjmw0_test.go:99: expected '[%!s(int=5) %!s(int=0)]',\
    \ got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075383
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    carrots = number - need\n    if carrots < 0 {\n        carrots = 0\n\
    \    }\n    if carrots > remaining {\n        carrots = remaining\n    }\n   \
    \ carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n\
    \    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots +\
    \ 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    \nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdgp6o4kz_test.go:88:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075382
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    if number < 0 || number > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n        return nil\n    }\n    if need < 0 || need > 1000 {\n\
    \        fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if remaining\
    \ < 0 || remaining > 1000 {\n        fmt.Println(\"Invalid input\")\n        return\
    \ nil\n    }\n    if number == 0 {\n        result[0] = 0\n        result[1] =\
    \ 0\n        return result\n    }\n    if need == 0 {\n        result[0] = 0\n\
    \        result[1] = 0\n        return result\n    }\n    if remaining == 0 {\n\
    \        result[0] = number\n        result[1] = 0\n        return result\n  \
    \  }\n    if number > need {\n        fmt.Println(\"Invalid input\")\n       \
    \ return nil\n    }\n    if number > remaining {\n        fmt.Println(\"Invalid\
    \ input\")\n        return nil\n    }\n    if number == need {\n        result[0]\
    \ = number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ number == remaining {\n        result[0] = number\n        result[1] = need\n\
    \        return result\n    }\n    if number > need {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if number > remaining\
    \ {\n        result[0] = number\n        result[1] = remaining\n        return\
    \ result\n    }\n    if number == need && number == remaining {\n        result[0]\
    \ = number\n        result[1] = need\n        return result\n    }\n    if number\
    \ == need && number > remaining {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number > need && number == remaining\
    \ {\n        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number > need && number > remaining {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if number == need\
    \ && number > remaining {\n        result[0] = number\n        result[1] = need\n\
    \        return result\n    }\n    if number > need && number == remaining {\n\
    \        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number > need && number > remaining {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if number == need\
    \ && number > remaining {\n        result[0] = number\n        result[1] = need\n\
    \        return result\n    }\n    if number > need && number == remaining {\n\
    \        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number > need && number > remaining {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if number == need\
    \ && number > remaining {\n        result[0] = number\n        result[1] = need\n\
    \        return result\n    }\n    if number > need && number == remaining {\n\
    \        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number > need && number > remaining {\n        result[0] = \nfunc\
    \ TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0dy7jzs9_test.go:145:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075382
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    if number\
    \ > remaining {\n        carrots = number\n    } else {\n        carrots = remaining\n\
    \    }\n    carrots = carrots + need\n    carrots = carrots - carrots % 10\n \
    \   carrots = carrots / 10\n    carrots = carrots + 1\n    carrots = carrots -\
    \ carrots % 10\n    carrots = carrots / 10\n    carrots = carrots + 1\n    carrots\
    \ = carrots - carrots % 10\n    carrots = carrots / 10\n    carrots = carrots\
    \ + 1\n    carrots = carrots - carrots % 10\n    carrots = carrots / 10\n    carrots\
    \ = carrots + 1\n    carrots = carrots - carrots % 10\n    carrots = carrots /\
    \ 10\n    carrots = carrots + 1\n    carrots = carrots - carrots % 10\n    carrots\
    \ = carrots / 10\n    carrots = carrots + 1\n    carrots = carrots - carrots %\
    \ 10\n    carrots = carrots / 10\n    carrots = carrots + 1\n    carrots = carrots\
    \ - carrots % 10\n    carrots = carrots / 10\n    carrots = carrots + 1\n    carrots\
    \ = carrots - carrots % 10\n    carrots = carrots / 10\n    carrots = carrots\
    \ + 1\n    carrots = carrots - carrots % 10\n    carrots = carrots / 10\n    carrots\
    \ = carrots + 1\n    carrots = carrots - carrots % 10\n    carrots = carrots /\
    \ 10\n    carrots = carrots + 1\n    carrots = carrots - carrots % 10\n    carrots\
    \ = carrots / 10\n    carrots = carrots + 1\n    carrots = carrots - carrots %\
    \ 10\n    carrots = carrots / 10\n    carrots = carrots + 1\n    carrots = carrots\
    \ - carrots % 10\n    carrots = carrots / 10\n    carrots = carrots + 1\n    carrots\
    \ = carrots - carrot\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n\
    \     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual:\
    \ candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpg8k1b0je_test.go:80:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075382
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 {\n        return []int{0, 0}\n    }\n    if need\
    \ < 0 || need > 1000 {\n        return []int{0, 0}\n    }\n    if remaining <\
    \ 0 || remaining > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n\
    \    carrots += number\n    carrots += need\n    carrots += remaining\n    carrots\
    \ = carrots % 100\n    carrots = carrots / 100\n    carrots = carrots * 100\n\
    \    carrots = carrots + 100\n    carrots = carrots / 10\n    carrots = carrots\
    \ * 10\n    carrots = carrots + 10\n    carrots = carrots / 1\n    carrots = carrots\
    \ * 1\n    carrots = carrots + 1\n    carrots = carrots / 0\n    carrots = carrots\
    \ * 0\n    carrots = carrots + 0\n    carrots = carrots / -1\n    carrots = carrots\
    \ * -1\n    carrots = carrots + -1\n    carrots = carrots / -2\n    carrots =\
    \ carrots * -2\n    carrots = carrots + -2\n    carrots = carrots / -3\n    carrots\
    \ = carrots * -3\n    carrots = carrots + -3\n    carrots = carrots / -4\n   \
    \ carrots = carrots * -4\n    carrots = carrots + -4\n    carrots = carrots /\
    \ -5\n    carrots = carrots * -5\n    carrots = carrots + -5\n    carrots = carrots\
    \ / -6\n    carrots = carrots * -6\n    carrots = carrots + -6\n    carrots =\
    \ carrots / -7\n    carrots = carrots * -7\n    carrots = carrots + -7\n    carrots\
    \ = carrots / -8\n    carrots = carrots * -8\n    carrots = carrots + -8\n   \
    \ carrots = carrots / -9\n    carrots = carrots * -9\n    carrots = carrots +\
    \ -9\n    carrots = carrots / -10\n    carrots = carrots * -10\n    carrots =\
    \ carrots + -10\n    carrots = carrots / -11\n    carrots = carrots * -11\n  \
    \  carrots = carrots + -11\n    carrots = carrots / -12\n    carrots = carrots\
    \ * -12\n    carrot\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n\
    \     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual:\
    \ candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmplp5aujm3_test.go:89:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075382
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || need < 0 || remaining < 0 {\n        return []int{0, 0}\n    }\n\
    \    if number == 0 {\n        return []int{0, 0}\n    }\n    if number > 1000\
    \ || need > 1000 || remaining > 1000 {\n        return []int{0, 0}\n    }\n  \
    \  carrots := 0\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots %= 1000\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots %= 1000\n    carrots -= number\n    carrots -= need\n\
    \    carrots -= remaining\n    carrots %= 1000\n    carrots -= number\n    carrots\
    \ -= need\n    carrots -= remaining\n    carrots %= 1000\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    carrots %= 1000\n    carrots\
    \ -= number\n    carrots -= need\n    carrots -= remaining\n    carrots %= 1000\n\
    \    carrots -= number\n    carrots -= need\n    carrots -= remaining\n    carrots\
    \ %= 1000\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots %= 1000\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots %= 1000\n    carrots -= number\n    carrots -= need\n\
    \    carrots -= remaining\n    carrots %= 1000\n    carrots -= number\n    carrots\
    \ -= need\n    carrots -= remaining\n    carrots %= 1000\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    carrots %= 1000\n    carrots\
    \ -= number\n    carrots -= need\n    carrots -= remaining\n    carrots %= 1000\n\
    \    carrots -= number\n    carrots -= need\n    carrots -= remaining\n    carrots\
    \ %= 1000\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots %= 1000\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots %= 1000\n    carrots -= number\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmplb1t4u5d_test.go:102:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075382
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    if number < 0 || number > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n    }\n    if need < 0 || need > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n    }\n    if remaining < 0 || remaining > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n    }\n    if number == 0 {\n        result[0] = 0\n       \
    \ result[1] = 0\n        return result\n    }\n    if need == 0 {\n        result[0]\
    \ = 0\n        result[1] = 0\n        return result\n    }\n    if remaining ==\
    \ 0 {\n        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number > need {\n        fmt.Println(\"Invalid input\")\n    }\n\
    \    if number > remaining {\n        fmt.Println(\"Invalid input\")\n    }\n\
    \    if number == need {\n        result[0] = number\n        result[1] = need\n\
    \        return result\n    }\n    if number == remaining {\n        result[0]\
    \ = number\n        result[1] = need\n        return result\n    }\n    if number\
    \ > remaining {\n        result[0] = number\n        result[1] = need\n      \
    \  return result\n    }\n    if number == need {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if number == remaining\
    \ {\n        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number > need {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number == need {\n        result[0]\
    \ = number\n        result[1] = need\n        return result\n    }\n    if number\
    \ == remaining {\n        result[0] = number\n        result[1] = need\n     \
    \   return result\n    }\n    if number > need {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if number == need\
    \ {\n        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number == remaining {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number > need {\n        result[0]\
    \ = number\n        result[1] = need\n        return result\n    }\n    if number\
    \ == need {\n        result[0] = number\n        result[1] = need\n        return\
    \ result\n    }\n    if number == remaining {\n        result[0] = number\n  \
    \      result[1] = need\n        return result\n    }\n    if number > need {\n\
    \        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number == need {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number == remaining {\n       \
    \ result[0] = number\n        result[1] = need\n        return result\n    }\n\
    \    if number > need {\n        result[0] = number\n        result[1] = need\n\
    \        return result\n    }\n    if number == need {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if number == remaining\
    \ {\n        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number > \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmppsok9hdq_test.go:159:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075383
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    var\
    \ result []int\n    if number < 0 || number > 1000 {\n        fmt.Println(\"Invalid\
    \ input\")\n        return nil\n    }\n    if need < 0 || need > 1000 {\n    \
    \    fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if remaining\
    \ < 0 || remaining > 1000 {\n        fmt.Println(\"Invalid input\")\n        return\
    \ nil\n    }\n    if number == 0 {\n        return nil\n    }\n    if remaining\
    \ == 0 {\n        return nil\n    }\n    if number >= need {\n        result =\
    \ []int{number, 0}\n    } else {\n        result = []int{0, remaining}\n    }\n\
    \    return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpq5qsnl_a_test.go:72: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=0)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpq5qsnl_a_test.go:72:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=0) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpq5qsnl_a_test.go:72: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=0) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpq5qsnl_a_test.go:72: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=0) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpq5qsnl_a_test.go:72: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=0)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpq5qsnl_a_test.go:72:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075383
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    if number\
    \ > remaining {\n        carrots = number\n    } else {\n        carrots = remaining\n\
    \    }\n    carrots = carrots + need\n    carrots = carrots - carrots % 5\n  \
    \  carrots = carrots + carrots % 5\n    carrots = carrots + carrots % 5\n    carrots\
    \ = carrots + carrots % 5\n    carrots = carrots + carrots % 5\n    carrots =\
    \ carrots + carrots % 5\n    carrots = carrots + carrots % 5\n    carrots = carrots\
    \ + carrots % 5\n    carrots = carrots + carrots % 5\n    carrots = carrots +\
    \ carrots % 5\n    carrots = carrots + carrots % 5\n    carrots = carrots + carrots\
    \ % 5\n    carrots = carrots + carrots % 5\n    carrots = carrots + carrots %\
    \ 5\n    carrots = carrots + carrots % 5\n    carrots = carrots + carrots % 5\n\
    \    carrots = carrots + carrots % 5\n    carrots = carrots + carrots % 5\n  \
    \  carrots = carrots + carrots % 5\n    carrots = carrots + carrots % 5\n    carrots\
    \ = carrots + carrots % 5\n    carrots = carrots + carrots % 5\n    carrots =\
    \ carrots + carrots % 5\n    carrots = carrots + carrots % 5\n    carrots = carrots\
    \ + carrots % 5\n    carrots = carrots + carrots % 5\n    carrots = carrots +\
    \ carrots % 5\n    carrots = carrots + carrots % 5\n    carrots = carrots + carrots\
    \ % 5\n    carrots = carrots + carrots % 5\n    carrots = carrots + carrots %\
    \ 5\n    carrots = carrots + carrots % 5\n    carrots = carrots + carrots % 5\n\
    \    carrots = carrots + carrots % 5\n    \nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8eueissk_test.go:72:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075383
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 {\n        return []int{0, 0}\n    }\n    if need\
    \ < 0 || need > 1000 {\n        return []int{0, 0}\n    }\n    if remaining <\
    \ 0 || remaining > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n\
    \    carrots += number\n    carrots += need\n    carrots -= remaining\n    if\
    \ carrots < 0 {\n        carrots = 0\n    }\n    return []int{carrots, carrots\
    \ - carrots}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n\
    \     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual:\
    \ candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpspqiwfc6_test.go:64: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=1)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpspqiwfc6_test.go:64:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=3) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpspqiwfc6_test.go:64: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpspqiwfc6_test.go:64: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=8) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpspqiwfc6_test.go:64: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=2)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpspqiwfc6_test.go:64:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=8) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075384
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 {\n        return []int{0, 0}\n    }\n    if need\
    \ < 0 || need > 1000 {\n        return []int{0, 0}\n    }\n    if remaining <\
    \ 0 || remaining > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n\
    \    carrots = number\n    carrots = carrots - need\n    carrots = carrots - remaining\n\
    \    carrots = carrots + 1\n    return []int{carrots, remaining}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpjqmyj2pp_test.go:62: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=-10)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpjqmyj2pp_test.go:62:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=-12) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpjqmyj2pp_test.go:62: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=-18) %!s(int=10)]'\n    --- FAIL:\
    \ TestEat/test_num__3 (0.00s)\n        tmpjqmyj2pp_test.go:62: expected '[%!s(int=7)\
    \ %!s(int=0)]', got '[%!s(int=-13) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmpjqmyj2pp_test.go:62: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=-7) %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n\
    \        tmpjqmyj2pp_test.go:62: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=-1)\
    \ %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075378
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    var\
    \ carrots []int\n    if number < 0 || number > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n        return carrots\n    }\n    if need < 0 || need > 1000\
    \ {\n        fmt.Println(\"Invalid input\")\n        return carrots\n    }\n \
    \   if remaining < 0 || remaining > 1000 {\n        fmt.Println(\"Invalid input\"\
    )\n        return carrots\n    }\n    if number == 0 {\n        return carrots\n\
    \    }\n    if need == 0 {\n        return carrots\n    }\n    if remaining ==\
    \ 0 {\n        return carrots\n    }\n    if number > need {\n        fmt.Println(\"\
    Invalid input\")\n        return carrots\n    }\n    if number > remaining {\n\
    \        fmt.Println(\"Invalid input\")\n        return carrots\n    }\n    if\
    \ number == need {\n        carrots = append(carrots, number)\n        return\
    \ carrots\n    }\n    if number == remaining {\n        carrots = append(carrots,\
    \ number)\n        return carrots\n    }\n    carrots = append(carrots, number)\n\
    \    carrots = append(carrots, need)\n    carrots = append(carrots, remaining)\n\
    \    return carrots\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Invalid input\n--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0\
    \ (0.00s)\n        tmp7yr9akwk_test.go:89: expected '[%!s(int=11) %!s(int=4)]',\
    \ got '[%!s(int=5) %!s(int=6) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1\
    \ (0.00s)\n        tmp7yr9akwk_test.go:89: expected '[%!s(int=12) %!s(int=1)]',\
    \ got '[%!s(int=4) %!s(int=8) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__2\
    \ (0.00s)\n        tmp7yr9akwk_test.go:89: expected '[%!s(int=11) %!s(int=0)]',\
    \ got '[%!s(int=1) %!s(int=10) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp7yr9akwk_test.go:89: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=2) %!s(int=11) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp7yr9akwk_test.go:89: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=4) %!s(int=5) %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5\
    \ (0.00s)\n        tmp7yr9akwk_test.go:89: expected '[%!s(int=5) %!s(int=0)]',\
    \ got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075384
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots = carrots % 1000\n    carrots = carrots / 1000\n    carrots = carrots\
    \ + 1\n    carrots = carrots % 1000\n    carrots = carrots / 1000\n    carrots\
    \ = carrots + 1\n    carrots = carrots % 1000\n    carrots = carrots / 1000\n\
    \    carrots = carrots + 1\n    carrots = carrots % 1000\n    carrots = carrots\
    \ / 1000\n    carrots = carrots + 1\n    carrots = carrots % 1000\n    carrots\
    \ = carrots / 1000\n    carrots = carrots + 1\n    carrots = carrots % 1000\n\
    \    carrots = carrots / 1000\n    carrots = carrots + 1\n    carrots = carrots\
    \ % 1000\n    carrots = carrots / 1000\n    carrots = carrots + 1\n    carrots\
    \ = carrots % 1000\n    carrots = carrots / 1000\n    carrots = carrots + 1\n\
    \    carrots = carrots % 1000\n    carrots = carrots / 1000\n    carrots = carrots\
    \ + 1\n    carrots = carrots % 1000\n    carrots = carrots / 1000\n    carrots\
    \ = carrots + 1\n    carrots = carrots % 1000\n    carrots = carrots / 1000\n\
    \    carrots = carrots + 1\n    carrots = carrots % 1000\n    carrots = carrots\
    \ / 1000\n    carrots = carrots + 1\n    carrots = carrots % 1000\n    carrots\
    \ = carrots / 1000\n    carrots = carrots + 1\n    carrots = carrots % 1000\n\
    \    carrots = carrots / 1000\n    carrots = carrots + 1\n    carrots = carrots\
    \ % 1000\n    carrots = carrots / 1000\n    carrots = carrots + 1\n    carrots\
    \ = carrots % 1000\n    carrots = carrots / 1000\n    carrots = carrots + 1\n\
    \    carrots = carrots % 1000\n    carrots = carrots / 1000\n    carrots = carrots\
    \ + 1\n    carrots = carrots % 1000\n    \nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpopuxy4pz_test.go:84:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075377
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots -= number\n    carrots -= need\n    carrots -= remaining\n    carrots\
    \ -= number\n    carrots -= need\n    carrots -= remaining\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    carrots -= number\n    carrots\
    \ -= need\n    carrots -= remaining\n    carrots -= number\n    carrots -= need\n\
    \    carrots -= remaining\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots -= number\n    carrots -= need\n    carrots -= remaining\n    carrots\
    \ -= number\n    carrots -= need\n    carrots -= remaining\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    carrots -= number\n    carrots\
    \ -= need\n    carrots -= remaining\n    carrots -= number\n    carrots -= need\n\
    \    carrots -= remaining\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots -= number\n    carrots -= need\n    carrots -= remaining\n    carrots\
    \ -= number\n    carrots -= need\n    carrots -= remaining\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    carrots -= number\n    carrots\
    \ -= need\n    carrots -= remaining\n    carrots -= number\n    carrots -= need\n\
    \    carrots -= remaining\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots -= number\n    carrots -= need\n    carrots -= remaining\n    carrots\
    \ -= number\n    carrots -= need\n    carrots -= remaining\n    carrots \nfunc\
    \ TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpr2iwr2xj_test.go:101:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075380
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    var\
    \ carrots []int\n    if number < 0 || number > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n        return carrots\n    }\n    if need < 0 || need > 1000\
    \ {\n        fmt.Println(\"Invalid input\")\n        return carrots\n    }\n \
    \   if remaining < 0 || remaining > 1000 {\n        fmt.Println(\"Invalid input\"\
    )\n        return carrots\n    }\n    if number == 0 {\n        fmt.Println(\"\
    Invalid input\")\n        return carrots\n    }\n    if need == 0 {\n        fmt.Println(\"\
    Invalid input\")\n        return carrots\n    }\n    if remaining == 0 {\n   \
    \     fmt.Println(\"Invalid input\")\n        return carrots\n    }\n    if number\
    \ > need {\n        fmt.Println(\"Invalid input\")\n        return carrots\n \
    \   }\n    if number > remaining {\n        fmt.Println(\"Invalid input\")\n \
    \       return carrots\n    }\n    if number > 0 {\n        carrots = append(carrots,\
    \ number)\n    }\n    if need > 0 {\n        carrots = append(carrots, need)\n\
    \    }\n    if remaining > 0 {\n        carrots = append(carrots, remaining)\n\
    \    }\n    return carrots\n}\n\nfunc TestEat(t *testing.T) {\n  candidate :=\
    \ eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Invalid input\n--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0\
    \ (0.00s)\n        tmpk_ko1fw9_test.go:90: expected '[%!s(int=11) %!s(int=4)]',\
    \ got '[%!s(int=5) %!s(int=6) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1\
    \ (0.00s)\n        tmpk_ko1fw9_test.go:90: expected '[%!s(int=12) %!s(int=1)]',\
    \ got '[%!s(int=4) %!s(int=8) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__2\
    \ (0.00s)\n        tmpk_ko1fw9_test.go:90: expected '[%!s(int=11) %!s(int=0)]',\
    \ got '[%!s(int=1) %!s(int=10) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpk_ko1fw9_test.go:90: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=2) %!s(int=11) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmpk_ko1fw9_test.go:90: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=4) %!s(int=5) %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5\
    \ (0.00s)\n        tmpk_ko1fw9_test.go:90: expected '[%!s(int=5) %!s(int=0)]',\
    \ got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075384
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    meals := 0\n    if number > need {\n      \
    \  meals = number\n        carrots = need\n    } else {\n        meals = need\n\
    \        carrots = number\n    }\n    carrots -= remaining\n    meals -= carrots\n\
    \    carrots = carrots % 100\n    meals = meals % 100\n    carrots = carrots /\
    \ 100\n    meals = meals / 100\n    carrots = carrots + meals\n    meals = meals\
    \ + carrots\n    carrots = carrots % 100\n    meals = meals % 100\n    carrots\
    \ = carrots / 100\n    meals = meals / 100\n    carrots = carrots + meals\n  \
    \  meals = meals + carrots\n    carrots = carrots % 100\n    meals = meals % 100\n\
    \    carrots = carrots / 100\n    meals = meals / 100\n    carrots = carrots +\
    \ meals\n    meals = meals + carrots\n    carrots = carrots % 100\n    meals =\
    \ meals % 100\n    carrots = carrots / 100\n    meals = meals / 100\n    carrots\
    \ = carrots + meals\n    meals = meals + carrots\n    carrots = carrots % 100\n\
    \    meals = meals % 100\n    carrots = carrots / 100\n    meals = meals / 100\n\
    \    carrots = carrots + meals\n    meals = meals + carrots\n    carrots = carrots\
    \ % 100\n    meals = meals % 100\n    carrots = carrots / 100\n    meals = meals\
    \ / 100\n    carrots = carrots + meals\n    meals = meals + carrots\n    carrots\
    \ = carrots % 100\n    meals = meals % 100\n    carrots = carrots / 100\n    meals\
    \ = meals / 100\n    carrots = carrots + meals\n    meals = meals + carrots\n\
    \    carrots = carrots % 100\n    meal\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjkvbuh3i_test.go:85:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075383
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    if number < 0 || number > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n        return nil\n    }\n    if need < 0 || need > 1000 {\n\
    \        fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if remaining\
    \ < 0 || remaining > 1000 {\n        fmt.Println(\"Invalid input\")\n        return\
    \ nil\n    }\n    if number == 0 {\n        result[0] = 0\n        result[1] =\
    \ 0\n        return result\n    }\n    if need == 0 {\n        result[0] = 0\n\
    \        result[1] = 0\n        return result\n    }\n    if remaining == 0 {\n\
    \        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number > need {\n        fmt.Println(\"Invalid input\")\n     \
    \   return nil\n    }\n    if number > remaining {\n        fmt.Println(\"Invalid\
    \ input\")\n        return nil\n    }\n    if number == need {\n        result[0]\
    \ = number\n        result[1] = need\n        return result\n    }\n    if number\
    \ == remaining {\n        result[0] = number\n        result[1] = need\n     \
    \   return result\n    }\n    if number > remaining {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if number == need\
    \ {\n        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number == remaining {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number > need {\n        result[0]\
    \ = number\n        result[1] = need\n        return result\n    }\n    if number\
    \ == need {\n        result[0] = number\n        result[1] = need\n        return\
    \ result\n    }\n    if number == remaining {\n        result[0] = number\n  \
    \      result[1] = need\n        return result\n    }\n    if number > need {\n\
    \        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number == need {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number == remaining {\n       \
    \ result[0] = number\n        result[1] = need\n        return result\n    }\n\
    \    if number > need {\n        result[0] = number\n        result[1] = need\n\
    \        return result\n    }\n    if number == need {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if number == remaining\
    \ {\n        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number > need {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number == need {\n        result[0]\
    \ = number\n        result[1] = need\n        return result\n    }\n    if number\
    \ == remaining {\n        result[0] = number\n        result[1] = need\n     \
    \   return result\n    }\n    if number > need {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if number == need\
    \ {\n        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number == remaining {\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmptor1ktvc_test.go:160:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075383
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    carrots = number - need\n    if carrots < 0 {\n        carrots = 0\n\
    \    }\n    if carrots > remaining {\n        carrots = remaining\n    }\n   \
    \ carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n\
    \    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots +\
    \ 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    \nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdgp6o4kz_test.go:88:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075382
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    var\
    \ result []int\n    if number < 0 || number > 1000 {\n        return nil\n   \
    \ }\n    if need < 0 || need > 1000 {\n        return nil\n    }\n    if remaining\
    \ < 0 || remaining > 1000 {\n        return nil\n    }\n    if number == 0 {\n\
    \        return nil\n    }\n    if number > need {\n        return nil\n    }\n\
    \    if number > remaining {\n        number = remaining\n    }\n    if number\
    \ < need {\n        number = need\n    }\n    if number < remaining {\n      \
    \  number = remaining\n    }\n    for i := 0; i < number; i++ {\n        result\
    \ = append(result, i)\n    }\n    return result\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp9qlraflk_test.go:76: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=0)\
    \ %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=7)\
    \ %!s(int=8) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n       \
    \ tmp9qlraflk_test.go:76: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=0)\
    \ %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=7)\
    \ %!s(int=8)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n        tmp9qlraflk_test.go:76:\
    \ expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=0) %!s(int=1) %!s(int=2)\
    \ %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=9)]'\n\
    \    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmp9qlraflk_test.go:76: expected\
    \ '[%!s(int=7) %!s(int=0)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=7) %!s(int=8) %!s(int=9) %!s(int=10)]'\n\
    \    --- FAIL: TestEat/test_num__4 (0.00s)\n        tmp9qlraflk_test.go:76: expected\
    \ '[%!s(int=9) %!s(int=2)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4) %!s(int=5) %!s(int=6)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n\
    \        tmp9qlraflk_test.go:76: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0)\
    \ %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660075384
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots \nfunc TestEat(t *testing.T) {\n \
    \ candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected:\
    \ []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n\
    \     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual:\
    \ candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5,\
    \ 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5,\
    \ 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpy0hctr6s_test.go:101:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075372
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || need < 0 || remaining < 0 {\n        return []int{0, 0}\n    }\n\
    \    if number == 0 {\n        return []int{need, remaining}\n    }\n    if need\
    \ == 0 {\n        return []int{number, remaining}\n    }\n    if remaining ==\
    \ 0 {\n        return []int{number, need}\n    }\n    if number > need {\n   \
    \     return []int{0, 0}\n    }\n    if number > remaining {\n        return []int{number,\
    \ 0}\n    }\n    if need > remaining {\n        return []int{0, need}\n    }\n\
    \    if number > need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if need > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if number > need {\n        return []int{0, 0}\n   \
    \ }\n    if number > remaining {\n        return []int{0, 0}\n    }\n    if need\
    \ > remaining {\n        return []int{0, 0}\n    }\n    if number > need {\n \
    \       return []int{0, 0}\n    }\n    if number > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if need > remaining {\n        return []int{0, 0}\n\
    \    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if number\
    \ > remaining {\n        return []int{0, 0}\n    }\n    if need > remaining {\n\
    \        return []int{0, 0}\n    }\n    if number > need {\n        return []int{0,\
    \ 0}\n    }\n    if number > remaining {\n        return []int{0, 0}\n    }\n\
    \    if need > remaining {\n        return []int{0, 0}\n    }\n    if number >\
    \ need {\n        return []int{0, 0}\n    }\n    if number > remaining {\n   \
    \     return []int{0, 0}\n    }\n    if need > remaining {\n        return []int{0,\
    \ 0}\n    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if\
    \ number > remaining {\n        return []int{0, 0}\n    }\n    if need > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if number > need {\n        return\
    \ []int{0, 0}\n    }\n    if number > remaining {\n        return []int{0, 0}\n\
    \    }\n    if need > remaining {\n        return []int{0, 0}\n    }\n    if number\
    \ > need {\n        return []int{0, 0}\n    }\n    if number > remaining {\n \
    \       return []int{0, 0}\n    }\n    if need > remaining {\n        return []int{0,\
    \ 0}\n    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if\
    \ number > remaining {\n        return []int{0, 0}\n    }\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpp96r5dfw_test.go:136:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075383
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    if carrots > 1000 {\n        carrots = 1000\n    }\n    if carrots < 0 {\n\
    \        carrots = 0\n    }\n    return []int{carrots, carrots - carrots}\n}\n\
    \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpuud6svri_test.go:58: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=21)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpuud6svri_test.go:58:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=21) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpuud6svri_test.go:58: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=21) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpuud6svri_test.go:58: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=18) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpuud6svri_test.go:58: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=16)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpuud6svri_test.go:58:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075384
- exit_code: 2
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || need < 0 || remaining < 0 {\n        return []int{0, 0}\n    }\n\
    \    result := make([]int, 2)\n    if number == 0 {\n        result[0] = 0\n \
    \       result[1] = 0\n        return result\n    }\n    if number > need {\n\
    \        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number > remaining {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number < need {\n        result[0]\
    \ = need\n        result[1] = number\n        return result\n    }\n    if number\
    \ < remaining {\n        result[0] = remaining\n        result[1] = number\n \
    \       return result\n    }\n}\n\nfunc TestEat(t *testing.T) {\n  candidate :=\
    \ eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpk_q2t_xm_test.go:56:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075383
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    return []int{carrots, carrots - number}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpbtupbi6n_test.go:52: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=21)\
    \ %!s(int=16)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpbtupbi6n_test.go:52:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=21) %!s(int=17)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpbtupbi6n_test.go:52: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=21) %!s(int=20)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpbtupbi6n_test.go:52: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=18) %!s(int=16)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpbtupbi6n_test.go:52: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=16)\
    \ %!s(int=12)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpbtupbi6n_test.go:52:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=10) %!s(int=6)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075373
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    if number\
    \ > remaining {\n        carrots = number\n    } else {\n        carrots = remaining\n\
    \    }\n    carrots = carrots + need\n    carrots = carrots - carrots % 10\n \
    \   carrots = carrots / 10\n    carrots = carrots + 1\n    carrots = carrots -\
    \ carrots % 10\n    carrots = carrots / 10\n    carrots = carrots + 1\n    carrots\
    \ = carrots - carrots % 10\n    carrots = carrots / 10\n    carrots = carrots\
    \ + 1\n    carrots = carrots - carrots % 10\n    carrots = carrots / 10\n    carrots\
    \ = carrots + 1\n    carrots = carrots - carrots % 10\n    carrots = carrots /\
    \ 10\n    carrots = carrots + 1\n    carrots = carrots - carrots % 10\n    carrots\
    \ = carrots / 10\n    carrots = carrots + 1\n    carrots = carrots - carrots %\
    \ 10\n    carrots = carrots / 10\n    carrots = carrots + 1\n    carrots = carrots\
    \ - carrots % 10\n    carrots = carrots / 10\n    carrots = carrots + 1\n    carrots\
    \ = carrots - carrots % 10\n    carrots = carrots / 10\n    carrots = carrots\
    \ + 1\n    carrots = carrots - carrots % 10\n    carrots = carrots / 10\n    carrots\
    \ = carrots + 1\n    carrots = carrots - carrots % 10\n    carrots = carrots /\
    \ 10\n    carrots = carrots + 1\n    carrots = carrots - carrots % 10\n    carrots\
    \ = carrots / 10\n    carrots = carrots + 1\n    carrots = carrots - carrots %\
    \ 10\n    carrots = carrots / 10\n    carrots = carrots + 1\n    carrots = carrots\
    \ - carrots % 10\n    carrots = carrots / 10\n    carrots = carrots + 1\n    carrots\
    \ = carrots - carrot\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n\
    \     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual:\
    \ candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpg8k1b0je_test.go:80:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075382
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots +=\
    \ number\n    carrots += need\n    if carrots > remaining {\n        carrots =\
    \ remaining\n    }\n    return []int{carrots, remaining}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpjlpij576_test.go:57: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpjlpij576_test.go:57:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpjlpij576_test.go:57: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpjlpij576_test.go:57: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpjlpij576_test.go:57: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpjlpij576_test.go:57:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075376
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ write your code here\n    carrots := 0\n    carrots = number\n    carrots =\
    \ carrots - need\n    carrots = carrots - remaining\n    carrots = carrots + need\n\
    \    carrots = carrots + remaining\n    carrots = carrots + need\n    carrots\
    \ = carrots + remaining\n    carrots = carrots + need\n    carrots = carrots +\
    \ remaining\n    carrots = carrots + need\n    carrots = carrots + remaining\n\
    \    carrots = carrots + need\n    carrots = carrots + remaining\n    carrots\
    \ = carrots + need\n    carrots = carrots + remaining\n    carrots = carrots +\
    \ need\n    carrots = carrots + remaining\n    carrots = carrots + need\n    carrots\
    \ = carrots + remaining\n    carrots = carrots + need\n    carrots = carrots +\
    \ remaining\n    carrots = carrots + need\n    carrots = carrots + remaining\n\
    \    carrots = carrots + need\n    carrots = carrots + remaining\n    carrots\
    \ = carrots + need\n    carrots = carrots + remaining\n    carrots = carrots +\
    \ need\n    carrots = carrots + remaining\n    carrots = carrots + need\n    carrots\
    \ = carrots + remaining\n    carrots = carrots + need\n    carrots = carrots +\
    \ remaining\n    carrots = carrots + need\n    carrots = carrots + remaining\n\
    \    carrots = carrots + need\n    carrots = carrots + remaining\n    carrots\
    \ = carrots + need\n    carrots = carrots + remaining\n    carrots = carrots +\
    \ need\n    carrots = carrots + remaining\n    carrots = carrots + need\n    carrots\
    \ = carrots + remaining\n    carrots = carrots + need\n    carrots = carrots +\
    \ remaining\n    carrots = carrots + need\n    carrots = carrots + remaining\n\
    \    carrots = carrots + need\n    carrots = carrots + remaining\n    carrots\
    \ = carrots + need\n    carrots = carrots + remaining\n    carrots = carrots +\
    \ need\n    carrots = carrots + remaining\n    carrots = carrots + need\n    carrots\
    \ = carrots + remaining\n    carrots = carrots + need\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpe6o8hldc_test.go:85:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075383
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || number < 0 {\n        return []int{0, 0}\n    }\n    if need\
    \ > 1000 || need < 0 {\n        return []int{0, 0}\n    }\n    if remaining >\
    \ 1000 || remaining < 0 {\n        return []int{0, 0}\n    }\n    if number ==\
    \ 0 {\n        return []int{0, 0}\n    }\n    if number > need {\n        return\
    \ []int{0, 0}\n    }\n    if remaining < need {\n        return []int{0, 0}\n\
    \    }\n    if number > remaining {\n        return []int{number, 0}\n    }\n\
    \    if number < remaining {\n        return []int{0, number}\n    }\n    return\
    \ []int{number, number}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpy0224uuw_test.go:72: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=0)\
    \ %!s(int=5)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpy0224uuw_test.go:72:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=0) %!s(int=4)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpy0224uuw_test.go:72: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=0) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpy0224uuw_test.go:72: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpy0224uuw_test.go:72: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=0)\
    \ %!s(int=4)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpy0224uuw_test.go:72:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075384
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return an array of [ total number of eaten carrots after your meals,\n// the\
    \ number of carrots left after your meals ]\n// if there are not enough remaining\
    \ carrots, you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots +=\
    \ number\n    carrots += need\n    carrots += remaining\n    carrots %= 1000\n\
    \    carrots -= number\n    carrots -= need\n    carrots -= remaining\n    carrots\
    \ %= 1000\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots %= 1000\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots %= 1000\n    carrots -= number\n    carrots -= need\n\
    \    carrots -= remaining\n    carrots %= 1000\n    carrots -= number\n    carrots\
    \ -= need\n    carrots -= remaining\n    carrots %= 1000\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    carrots %= 1000\n    carrots\
    \ -= number\n    carrots -= need\n    carrots -= remaining\n    carrots %= 1000\n\
    \    carrots -= number\n    carrots -= need\n    carrots -= remaining\n    carrots\
    \ %= 1000\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots %= 1000\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots %= 1000\n    carrots -= number\n    carrots -= need\n\
    \    carrots -= remaining\n    carrots %= 1000\n    carrots -= number\n    carrots\
    \ -= need\n    carrots -= remaining\n    carrots %= 1000\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    carrots %= 1000\n    carrots\
    \ -= number\n    carrots -= need\n    carrots -= remaining\n    carrots %= 1000\n\
    \    carrots -= number\n    carrots -= need\n    carrots -= remaining\n    carrots\
    \ %= 1000\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots %= 1000\n    \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_zy77ouq_test.go:100:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075383
