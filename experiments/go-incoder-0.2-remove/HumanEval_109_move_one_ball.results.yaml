language: go_test.go
name: HumanEval_109_move_one_ball
results:
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // We are allowed to perform right shift operation any number of times.\n \
    \   // One right shift operation means shifting all elements of the array by one\n\
    \    // position in the right direction. The last element of the array will be\
    \ moved to\n    // the starting position in the array i.e. 0th index.\n    //\
    \ If it is possible to obtain the sorted array by performing the above operation\n\
    \    // then return True else return False.\n    \n    // We are allowed to perform\
    \ right shift operation any number of times.\n    // One right shift operation\
    \ means shifting all elements of the array by one\n    // position in the right\
    \ direction. The last element of the array will be moved to\n    // the starting\
    \ position in the array i.e. 0th index.\n    // If it is possible to obtain the\
    \ sorted array by performing the above operation\n    // then return True else\
    \ return False.\n    \n    // We are allowed to perform right shift operation\
    \ any number of times.\n    // One right shift operation means shifting all elements\
    \ of the array by one\n    // position in the right direction. The last element\
    \ of the array will be moved to\n    // the starting position in the array i.e.\
    \ 0th index.\n    // If it is possible to obtain the sorted array by performing\
    \ the above operation\n    // then return True else return False.\n    \n    //\
    \ We are allowed to perform right shift operation any number of times.\n    //\
    \ One right shift operation means shifting all elements of the array by one\n\
    \    // position in the right direction. The last element of the array will be\
    \ moved to\n    // the starting position in the array i.e. 0th index.\n    //\
    \ If it is possible to obtain the sorted array by performing the above operation\n\
    \    // then return True else return False.\n    \n    // We are allowed to perform\
    \ right shift operation any number of times.\n    // One right shift operation\
    \ means shifting all elements of the array by one\n    // position in the right\
    \ direction. The last element of the array will be moved to\n    // the starting\
    \ position in the array i.e. 0th index.\n    // If it is possible to obtain the\
    \ sorted array by performing the above operation\n    // then return True else\
    \ return False.\n    \n    // We are allowed to perform right shift operation\
    \ any number of times.\n    // One right shift operation means shifting all elements\
    \ of the array by one\n    // position in the right direction. The last element\
    \ of the array will be moved to\n    // the starting position in the array i.e.\
    \ 0th index.\n    // If it is possible to obtain the sorted array by performing\
    \ the above operation\n    // then return True else return False.\n    \n    //\
    \ We are allowed to perform right shift operation any number of times.\n    //\
    \ One right shift operation means shifting all elements of the array by one\n\
    \    // position in the right direction. The last element of the array will be\
    \ \nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpcr82gyef_test.go:75:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074466
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    // Write your code here\n    if len(arr) == 0 {\n       \
    \ return true\n    }\n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp45bl_nqa_test.go:279:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074466
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[i+1] {\n            arr[i], arr[i+1] = arr[i+1], arr[i]\n     \
    \       shift -= 1\n        }\n    }\n    \n    if shift > 0 {\n        return\
    \ move_one_ball(arr[:shift])\n    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [5] with length 5 [recovered]\n\tpanic: runtime error: index out of range\
    \ [5] with length 5\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball({0xc0000c4640?, 0xc0000f8aa8?,\
    \ 0x4b3193?})\n\t/tmp/tmpmpz6dmbl_test.go:33 +0xa8\ncommand-line-arguments_test.TestMove_One_Ball(0x0?)\n\
    \t/tmp/tmpmpz6dmbl_test.go:53 +0xa8\ntesting.tRunner(0xc0001a01a0, 0x527f40)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074468
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            arr[i], arr[shift] = arr[shift], arr[i]\n\
    \            shift -= 1\n        }\n    }\n    \n    return len(arr) == shift\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmptabr5pnu_test.go:59: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmptabr5pnu_test.go:59:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660074468
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := len(arr) - 1\n    for i := len(arr) - 1; i > 0; i-- {\n        if arr[i]\
    \ > arr[i-1] {\n            arr[i], arr[i-1] = arr[i-1], arr[i]\n        }\n \
    \   }\n    return arr[0] == 0\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n \
    \ candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0jftagk5_test.go:30:5: i declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074467
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    arr[0],\
    \ arr[shift] = arr[shift], arr[0]\n    \n    return move_one_ball(arr)\n}\n\n\
    func TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpnkx_39bj_test.go:25 +0xaa fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef70a\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074469
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    arr[0],\
    \ arr[shift] = arr[shift], arr[0]\n    \n    return move_one_ball(arr)\n}\n\n\
    func TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpnkx_39bj_test.go:25 +0xaa fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef70a\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074469
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    // Write your code here\n    if len(arr) == 0 {\n       \
    \ return true\n    }\n    \n    arr := append(arr, 0)\n    \n    for i := len(arr)\
    \ - 1; i >= 0; i-- {\n        arr[i] = arr[i] + 1\n    }\n    \n    for i := 0;\
    \ i < len(arr); i++ {\n        if arr[i] > arr[i+1] {\n            return false\n\
    \        }\n    }\n    \n    return true\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2zzn0ef9_test.go:31:9: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074467
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        arr[i]\
    \ = arr[i] >> 1\n        \n        if arr[i] > 0 {\n            arr[i] = arr[i]\
    \ << 1\n            arr[i] |= arr[shift] >> 1\n            arr[i] = arr[i] >>\
    \ 1\n            arr[i] = arr[i] << 1\n            arr[i] = arr[i] >> 1\n    \
    \        arr[i] = arr[i] << 1\n            arr[i] = arr[i] >> 1\n            arr[i]\
    \ = arr[i] << 1\n            arr[i] = arr[i] >> 1\n            arr[i] = arr[i]\
    \ << 1\n            arr[i] = arr[i] >> 1\n            arr[i] = arr[i] << 1\n \
    \           arr[i] = arr[i] >> 1\n            arr[i] = arr[i] << 1\n         \
    \   arr[i] = arr[i] >> 1\n            arr[i] = arr[i] << 1\n            arr[i]\
    \ = arr[i] >> 1\n            arr[i] = arr[i] << 1\n            arr[i] = arr[i]\
    \ >> 1\n            arr[i] = arr[i] << 1\n            arr[i] = arr[i] >> 1\n \
    \           arr[i] = arr[i] << 1\n            arr[i] = arr[i] >> 1\n         \
    \   arr[i] = arr[i] << 1\n            arr[i] = arr[i] >> 1\n            arr[i]\
    \ = arr[i] << 1\n            arr[i] = arr[i] >> 1\n            arr[i] = arr[i]\
    \ << 1\n            arr[i] = arr[i] >> 1\n            arr[i] = arr[i] << 1\n \
    \           arr[i] = arr[i] >> 1\n            arr[i] = arr[i] << 1\n         \
    \   arr[i] = arr[i] >> 1\n            arr[i] = arr[i] << 1\n            arr[i]\
    \ = arr[i] >> 1\n            arr[i] = arr[i] << 1\n            arr[i] = arr[i]\
    \ >> 1\n            arr[i] = arr[i] << 1\n            arr[i] = arr[i] >> 1\n \
    \           arr[i] = arr[i] << 1\n            arr[i] = arr[i] >> 1\n         \
    \   arr[i] = arr[i] << 1\n            arr[i] = arr[i] >> 1\n            arr[i]\
    \ = arr[i] << 1\n            arr[i] = arr[i] >> 1\n            arr[i] = arr[i]\
    \ << 1\n            arr[i] = arr[i] >> 1\n            arr[i] = arr[i] << 1\n \
    \           arr[i] = arr[i] >> 1\n            arr[i] = arr[i] << 1\n         \
    \   arr[i] = arr[i] >> 1\n            arr[i] = arr[i] << 1\n            arr[i]\
    \ = arr[i] >> 1\n            arr[i] = arr[i] << 1\n            arr[i] = arr[i]\
    \ >> 1\n            arr[i] = arr[i] << 1\n            arr[i] = arr[i] >> 1\n \
    \           arr[i] = arr[i] \nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9mp6ouae_test.go:94:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074466
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for i < j {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            i++\n            j--\n        }\n    }\n\
    \    \n    return arr[0] == arr[len(arr)-1]\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp1vdp1mjt_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp1vdp1mjt_test.go:64:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074468
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[i+1] {\n            arr[i], arr[i+1] = arr[i+1], arr[i]\n     \
    \       shift -= 1\n        }\n    }\n    \n    return len(arr) == shift\n}\n\n\
    func TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [5] with length 5 [recovered]\n\tpanic: runtime error: index out of range\
    \ [5] with length 5\n\ngoroutine 20 [running]:\ntesting.tRunner.func1.2({0x512620,\
    \ 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512620, 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpwlh_bw86_test.go:33\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpwlh_bw86_test.go:49\
    \ +0x51f\ntesting.tRunner(0xc0001036c0, 0x527f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074468
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // We are going to perform right shift operation on arr[0] i.e. arr[0]\n  \
    \  // and arr[1] i.e. arr[1]. \n    // We will keep track of the number of right\
    \ shift operations performed.\n    // We will keep track of the number of elements\
    \ in the array i.e. N\n    // and we will keep track of the number of elements\
    \ in the array which we\n    // are going to move i.e. N-1\n    \n    // We will\
    \ keep track of the number of right shift operations performed.\n    var shiftCount\
    \ int = 0\n    \n    // We will keep track of the number of elements in the array\
    \ i.e. N\n    // and we will keep track of the number of elements in the array\
    \ which we\n    // are going to move i.e. N-1\n    var moveCount int = len(arr)\
    \ - 1\n    \n    // We will keep track of the number of elements in the array\
    \ which we\n    // are going to move i.e. N-1\n    var movedCount int = 0\n  \
    \  \n    // We will keep track of the number of elements in the array which we\n\
    \    // are going to move i.e. N-1\n    var movedElements int = 0\n    \n    //\
    \ We will keep track of the number of elements in the array which we\n    // are\
    \ going to move i.e. N-1\n    var movedElements2 int = 0\n    \n    // We will\
    \ keep track of the number of elements in the array which we\n    // are going\
    \ to move i.e. N-1\n    var movedElements3 int = 0\n    \n    // We will keep\
    \ track of the number of elements in the array which we\n    // are going to move\
    \ i.e. N-1\n    var movedElements4 int = 0\n    \n    // We will keep track of\
    \ the number of elements in the array which we\n    // are going to move i.e.\
    \ N-1\n    var movedElements5 int = 0\n    \n    // We will keep track of the\
    \ number of elements in the array which we\n    // are going to move i.e. N-1\n\
    \    var movedElements6 int = 0\n    \n    // We will keep track of the number\
    \ of elements in the array which we\n    // are going to move i.e. N-1\n    var\
    \ movedElements7 int = 0\n    \n    // We will keep track of the number of elements\
    \ in the array which we\n    // are going to move i.e. N-1\n    var movedElements8\
    \ int = 0\n    \n    // We will keep track of the number of elements in the array\
    \ which we\n    // are going to move i.e. N-1\n    var movedElements9 int = 0\n\
    \    \n    // We will keep track of the number of elements in the array which\
    \ we\n    // are going to move i.e. N-1\n    var movedElements10 int = 0\n   \
    \ \n    // We will keep track of the number of elements in the array which we\n\
    \nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpynstpkz7_test.go:91:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074466
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else if arr[i] < arr[j] {\n            i++\n        } else {\n\
    \            j--\n        }\n        if i == j {\n            break\n        }\n\
    \    }\n    return false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpjkzrgsjo_test.go:34\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpjkzrgsjo_test.go:59\
    \ +0x532\ntesting.tRunner(0xc0001924e0, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074468
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        arr[i]\
    \ = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n      \
    \  arr[i] = arr[i]>>1\n    }\n    \n    for i := 0; i < shift; i++ {\n       \
    \ arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n    }\n    \n    return arr[0]\
    \ == 0\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpeuab3460_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpeuab3460_test.go:64:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074468
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            arr[i], arr[shift] = arr[shift], arr[i]\n\
    \            shift -= 1\n        }\n    }\n    \n    return arr[0] == 0\n}\n\n\
    func TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpnsvv_7fa_test.go:59: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpnsvv_7fa_test.go:59:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074468
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  arr := arr[:len(arr)-1]\n    arr[len(arr)-1] = arr[0]\n    arr[0] = arr[len(arr)-1]\n\
    \    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[i+1] {\n \
    \           return false\n        }\n    }\n    return true\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp30cdo1h1_test.go:30:9: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074467
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            i++\n            j--\n        }\n      \
    \  if i == j {\n            break\n        }\n    }\n    \n    return true\n}\n\
    \nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpxz663act_test.go:34\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpxz663act_test.go:59\
    \ +0x525\ntesting.tRunner(0xc0001964e0, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074468
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := len(arr) - 1\n    j := 0\n    \n    for {\n        if i == 0 {\n     \
    \       break\n        }\n        \n        if arr[i] > arr[j] {\n           \
    \ arr[i], arr[j] = arr[j], arr[i]\n            i++\n            j++\n        }\
    \ else {\n            arr[i], arr[j] = arr[j], arr[i]\n            i--\n     \
    \       j--\n        }\n    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\n\
    goroutine 18 [running]:\ntesting.tRunner.func1.2({0x513620, 0xc00014e000})\n\t\
    /home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x513620,\
    \ 0xc00014e000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmp6s9ki8q2_test.go:38\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmp6s9ki8q2_test.go:59\
    \ +0x599\ntesting.tRunner(0xc00011b040, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074468
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        } else {\n          \
    \  arr[i], arr[shift] = arr[shift], arr[i]\n        }\n    }\n    \n    return\
    \ len(arr) == shift\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp03b0pdw3_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp03b0pdw3_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074468
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            break\n        }\n    }\n    \n    return\
    \ true\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x512620,\
    \ 0xc0001ce000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512620, 0xc0001ce000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmps1em46oh_test.go:34\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmps1em46oh_test.go:55\
    \ +0x4d2\ntesting.tRunner(0xc00019aea0, 0x527f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074468
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    return\
    \ arr[0] != arr[shift]\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmpjik721b2_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmpjik721b2_test.go:58:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074468
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    arr[0],\
    \ arr[shift] = arr[shift], arr[0]\n    \n    return move_one_ball(arr)\n}\n\n\
    func TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpnkx_39bj_test.go:25 +0xaa fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef70a\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074469
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for i < j {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        }\n    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpnpsbn5_a_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpnpsbn5_a_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074468
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    // Write your code here\n    if len(arr) == 0 {\n       \
    \ return true\n    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i\
    \ < len(arr); i++ {\n        if arr[i] > arr[shift] {\n            shift -= 1\n\
    \        }\n    }\n    \n    arr[0] = arr[shift]\n    \n    return move_one_ball(arr[1:])\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmp9xcc5zcz_test.go:61: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmp9xcc5zcz_test.go:61:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074468
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            break\n        }\n    }\n    \n    return\
    \ arr[0] == arr[len(arr)-1]\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 20 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpdqlwsmro_test.go:34\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpdqlwsmro_test.go:55\
    \ +0x53f\ntesting.tRunner(0xc000103520, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074468
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            i++\n            j--\n        }\n      \
    \  if i == j {\n            break\n        }\n    }\n    return true\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpv81crjqd_test.go:34\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpv81crjqd_test.go:58\
    \ +0x525\ntesting.tRunner(0xc0001a0340, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074469
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            i++\n            j--\n        }\n      \
    \  if i == j {\n            break\n        }\n    }\n    return true\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpv81crjqd_test.go:34\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpv81crjqd_test.go:58\
    \ +0x525\ntesting.tRunner(0xc0001a0340, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074469
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            i++\n            j--\n        }\n      \
    \  if i == j {\n            break\n        }\n    }\n    return true\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpv81crjqd_test.go:34\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpv81crjqd_test.go:58\
    \ +0x525\ntesting.tRunner(0xc0001a0340, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074469
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    arr[0]\
    \ = arr[shift]\n    \n    return move_one_ball(arr[1:])\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmph6703f_f_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmph6703f_f_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074469
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else if arr[i] < arr[j] {\n            i++\n        } else {\n\
    \            j--\n        }\n        if i == j {\n            break\n        }\n\
    \    }\n    return false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpjkzrgsjo_test.go:34\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpjkzrgsjo_test.go:59\
    \ +0x532\ntesting.tRunner(0xc0001924e0, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074468
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for i < j {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        }\n    }\n    \n    return arr[0] == arr[len(arr)-1]\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmppibeqx10_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmppibeqx10_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074469
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for i < j {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        }\n    }\n    \n    return arr[i] == arr[j]\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__3\
    \ (0.00s)\n        tmpf0qbld_7_test.go:61: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074469
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i]\
    \ = arr[i+1]\n    }\n    \n    arr[0] = arr[len(arr) - 1]\n    \n    return move_one_ball(arr)\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 34 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpcp0ma2th_test.go:25 +0x88 fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef6e8\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpcp0ma2th_test.go:38 +0x5e fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpcp0ma2th_test.go:38 +0x5e fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpcp0ma2th_test.go:38 +0x5e fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpcp0ma2th_test.go:38 +0x5e fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpcp0ma2th_test.go:38 +0x5e fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpcp0ma2th_test.go:38 +0x5e fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpcp0ma2th_test.go:38 +0x5e fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpcp0ma2th_test.go:38 +0x5e fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpcp0ma2th_test.go:38 +0x5e fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tm"
  timestamp: 1660074471
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i]\
    \ = arr[i+1]\n    }\n    \n    arr[0] = arr[0]\n    \n    return move_one_ball(arr)\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpru4s0cub_test.go:25 +0x85 fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef6e5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpru4s0cub_test.go:38 +0x56 fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6b6\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpru4s0cub_test.go:38 +0x56 fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6b6\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpru4s0cub_test.go:38 +0x56 fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6b6\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpru4s0cub_test.go:38 +0x56 fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6b6\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpru4s0cub_test.go:38 +0x56 fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6b6\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpru4s0cub_test.go:38 +0x56 fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6b6\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpru4s0cub_test.go:38 +0x56 fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6b6\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpru4s0cub_test.go:38 +0x56 fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6b6\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpru4s0cub_test.go:38 +0x56 fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6b6\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074471
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    if\
    \ shift > 0 {\n        return false\n    }\n    \n    arr[0] = arr[shift]\n  \
    \  \n    return true\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp_vr8hfo5_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp_vr8hfo5_test.go:64:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074470
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for i < j {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        }\n    }\n    \n    return arr[i] == arr[j]\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__3\
    \ (0.00s)\n        tmpf0qbld_7_test.go:61: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074469
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return move_one_ball(arr)\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160390\
    \ stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmp4im1g6f2_test.go:25 +0x72 fp=0xc0201603a0 sp=0xc020160398\
    \ pc=0x4ef6d2\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp4im1g6f2_test.go:36 +0x54 fp=0xc0201603c8 sp=0xc0201603a0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp4im1g6f2_test.go:36 +0x54 fp=0xc0201603f0 sp=0xc0201603c8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp4im1g6f2_test.go:36 +0x54 fp=0xc020160418 sp=0xc0201603f0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp4im1g6f2_test.go:36 +0x54 fp=0xc020160440 sp=0xc020160418\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp4im1g6f2_test.go:36 +0x54 fp=0xc020160468 sp=0xc020160440\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp4im1g6f2_test.go:36 +0x54 fp=0xc020160490 sp=0xc020160468\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp4im1g6f2_test.go:36 +0x54 fp=0xc0201604b8 sp=0xc020160490\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp4im1g6f2_test.go:36 +0x54 fp=0xc0201604e0 sp=0xc0201604b8\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp4im1g6f2_test.go:36 +0x54 fp=0xc020160508 sp=0xc0201604e0\
    \ pc=0x4ef6b4\ncommand-line-arguments_test.move_one_ball({0xc04015fe40?, 0x0?,\
    \ 0x0?})\n\t/tm"
  timestamp: 1660074471
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for i < j {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        }\n    }\n    \n    return arr[0] == arr[len(arr)-1]\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmppibeqx10_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmppibeqx10_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074469
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // We need to move the last element to the 0th position\n    arr[len(arr)-1]\
    \ = arr[0]\n    \n    // We need to move the 0th element to the last position\n\
    \    arr[0] = arr[len(arr)-1]\n    \n    // We need to move the 1st element to\
    \ the 2nd position\n    arr[1] = arr[2]\n    \n    // We need to move the 2nd\
    \ element to the 3rd position\n    arr[2] = arr[3]\n    \n    // We need to move\
    \ the 3rd element to the 4th position\n    arr[3] = arr[4]\n    \n    // We need\
    \ to move the 4th element to the 5th position\n    arr[4] = arr[5]\n    \n   \
    \ // We need to move the 5th element to the 6th position\n    arr[5] = arr[6]\n\
    \    \n    // We need to move the 6th element to the 7th position\n    arr[6]\
    \ = arr[7]\n    \n    // We need to move the 7th element to the 8th position\n\
    \    arr[7] = arr[8]\n    \n    // We need to move the 8th element to the 9th\
    \ position\n    arr[8]= arr[9]\n    \n    // We need to move the 9th element to\
    \ the 10th position\n    arr[9]= arr[10]\n    \n    // We need to move the 10th\
    \ element to the 11th position\n    arr[10]= arr[11]\n    \n    // We need to\
    \ move the 11th element to the 12th position\n    arr[11]= arr[12]\n    \n   \
    \ // We need to move the 12th element to the 13th position\n    arr[12]= arr[13]\n\
    \    \n    // We need to move the 13th element to the 14th position\n    arr[13]=\
    \ arr[14]\n    \n    // We need to move the 14th element to the 15th position\n\
    \    arr[14]= arr[15]\n    \n    // We need to move the 15th element to the 16th\
    \ position\n    arr[15]= arr[16]\n    \n    // We need to move the 16th element\
    \ to the 17th position\n    arr[16]= arr[17]\n    \n    // We need to move the\
    \ 17th element to the 18th position\n    arr[17]= arr[18]\n    \n    // We need\
    \ to move the 18th element to the 19th position\n    arr[18]= arr[19]\n    \n\
    \    // We need to move the 19th element to the 20th position\n    arr[19]= arr[20]\n\
    \    \n    // We need to move the 20th element to the 21st position\n    arr[20]=\
    \ arr[21]\n    \n    // \nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_owgqwwa_test.go:97:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074469
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // We are going to perform right shift operation on arr[0]\n    // and arr[1]\n\
    \    arr[0] >>= 1\n    arr[1] >>= 1\n    \n    // We are going to perform right\
    \ shift operation on arr[0]\n    // and arr[1]\n    arr[0] >>= 1\n    arr[1] >>=\
    \ 1\n    \n    // We are going to perform right shift operation on arr[0]\n  \
    \  // and arr[1]\n    arr[0] >>= 1\n    arr[1] >>= 1\n    \n    // We are going\
    \ to perform right shift operation on arr[0]\n    // and arr[1]\n    arr[0] >>=\
    \ 1\n    arr[1] >>= 1\n    \n    // We are going to perform right shift operation\
    \ on arr[0]\n    // and arr[1]\n    arr[0] >>= 1\n    arr[1] >>= 1\n    \n   \
    \ // We are going to perform right shift operation on arr[0]\n    // and arr[1]\n\
    \    arr[0] >>= 1\n    arr[1] >>= 1\n    \n    // We are going to perform right\
    \ shift operation on arr[0]\n    // and arr[1]\n    arr[0] >>= 1\n    arr[1] >>=\
    \ 1\n    \n    // We are going to perform right shift operation on arr[0]\n  \
    \  // and arr[1]\n    arr[0] >>= 1\n    arr[1] >>= 1\n    \n    // We are going\
    \ to perform right shift operation on arr[0]\n    // and arr[1]\n    arr[0] >>=\
    \ 1\n    arr[1] >>= 1\n    \n    // We are going to perform right shift operation\
    \ on arr[0]\n    // and arr[1]\n    arr[0] >>= 1\n    arr[1] >>= 1\n    \n   \
    \ // We are going to perform right shift operation on arr[0]\n    // and arr[1]\n\
    \    arr[0] >>= 1\n    arr[1] >>= 1\n    \n    // We are going to perform right\
    \ shift operation on arr[0]\n    // and arr[1]\n    arr[0] >>= 1\n    arr[1] >>=\
    \ 1\n    \n    // We are going to perform right shift operation on arr[0]\n  \
    \  // and arr[1]\n    arr[0] >>= 1\n    arr[1] >>= 1\n    \n    // We are going\
    \ to perform right shift operation on arr[0]\n    // and arr[1]\n    arr[0] >>=\
    \ 1\n    arr[1] >>= 1\n    \n    // We are going to perform right shift operation\
    \ on arr[0]\n    // and arr[1]\n    arr[0] >>= 1\n    arr[1] >>= 1\n    \n   \
    \ // We are going to perform \nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpf48ft9zb_test.go:106:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074469
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    // Write your code here\n    if len(arr) == 0 {\n       \
    \ return true\n    }\n    \n    i := 0\n    j := len(arr) - 1\n    \n    for i\
    \ < j {\n        if arr[i] > arr[j] {\n            arr[i], arr[j] = arr[j], arr[i]\n\
    \            i++\n            j--\n        }\n    }\n    \n    return false\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpuuv_3n8y_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpuuv_3n8y_test.go:62:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074470
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    arr[0],\
    \ arr[shift] = arr[shift], arr[0]\n    \n    return move_one_ball(arr)\n}\n\n\
    func TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpnkx_39bj_test.go:25 +0xaa fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef70a\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074469
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            i++\n            j--\n        }\n      \
    \  if i == j {\n            break\n        }\n    }\n    return true\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpv81crjqd_test.go:34\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpv81crjqd_test.go:58\
    \ +0x525\ntesting.tRunner(0xc0001a0340, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074469
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // The first element of the array is moved to the 0th position\n    arr[0]\
    \ = arr[len(arr) - 1]\n    \n    // The last element of the array is moved to\
    \ the 1st position\n    arr[len(arr) - 1] = arr[0]\n    \n    // The array is\
    \ now sorted in non-decreasing order\n    for i := 1; i < len(arr); i++ {\n  \
    \      if arr[i] > arr[i-1] {\n            return false\n        }\n    }\n  \
    \  return true\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp_b0wwder_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp_b0wwder_test.go:62:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074470
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        arr[i]\
    \ = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n      \
    \  arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8ztob929_test.go:94:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074469
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    arr[0]\
    \ = arr[shift]\n    \n    return move_one_ball(arr[1:])\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmph6703f_f_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmph6703f_f_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074469
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        arr[i]\
    \ = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n      \
    \  arr[i] = arr[i]>>1\n    }\n    \n    if arr[0] != 0 {\n        return false\n\
    \    }\n    \n    for i := 0; i < shift; i++ {\n        arr[i] = arr[i]>>1\n \
    \   }\n    \n    return true\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpx2a_1f8y_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpx2a_1f8y_test.go:67:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074470
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[i+1] {\n            arr[i], arr[i+1] = arr[i+1], arr[i]\n     \
    \       shift -= 1\n        }\n    }\n    \n    if shift > 0 {\n        return\
    \ move_one_ball(arr[:shift])\n    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [5] with length 5 [recovered]\n\tpanic: runtime error: index out of range\
    \ [5] with length 5\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball({0xc0000c4640?, 0xc0000f8aa8?,\
    \ 0x4b3193?})\n\t/tmp/tmpmpz6dmbl_test.go:33 +0xa8\ncommand-line-arguments_test.TestMove_One_Ball(0x0?)\n\
    \t/tmp/tmpmpz6dmbl_test.go:53 +0xa8\ntesting.tRunner(0xc0001a01a0, 0x527f40)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074468
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for i < j {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        }\n    }\n    \n    return arr[i] == arr[0]\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpk27qrxex_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpk27qrxex_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074470
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            arr[i], arr[shift] = arr[shift], arr[i]\n\
    \            shift -= 1\n        }\n    }\n    \n    return len(arr) == shift\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmptabr5pnu_test.go:59: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmptabr5pnu_test.go:59:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660074468
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    // Your code here\n    \n    // Your code here\n    \n  \
    \  // Your code here\n    \n    // Your code here\n    \n    // Your code here\n\
    \    \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // \nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvps_i3qo_test.go:173:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074469
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  arr := arr[:len(arr)-1]\n    \n    for i := len(arr) - 1; i > 0; i-- {\n  \
    \      arr[i] = arr[i-1]\n    }\n    \n    return arr[0] == 0\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzongjppo_test.go:30:9: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074470
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // We have two pointers left and right to traverse the given array\n    //\
    \ We will move the left pointer until it reaches the last element of the array\n\
    \    // and move the right pointer until it reaches the 0th element of the array\n\
    \    // We will keep track of how many times the right pointer has moved\n   \
    \ // We will keep track of how many times the left pointer has moved\n    // We\
    \ will keep track of how many times the right pointer has moved and\n    // left\
    \ pointer has moved respectively\n    // We will keep track of how many times\
    \ the right pointer has moved and\n    // left pointer has moved respectively\n\
    \    // We will keep track of how many times the right pointer has moved and\n\
    \    // left pointer has moved respectively\n    // We will keep track of how\
    \ many times the right pointer has moved and\n    // left pointer has moved respectively\n\
    \    // We will keep track of how many times the right pointer has moved and\n\
    \    // left pointer has moved respectively\n    // We will keep track of how\
    \ many times the right pointer has moved and\n    // left pointer has moved respectively\n\
    \    // We will keep track of how many times the right pointer has moved and\n\
    \    // left pointer has moved respectively\n    // We will keep track of how\
    \ many times the right pointer has moved and\n    // left pointer has moved respectively\n\
    \    // We will keep track of how many times the right pointer has moved and\n\
    \    // left pointer has moved respectively\n    // We will keep track of how\
    \ many times the right pointer has moved and\n    // left pointer has moved respectively\n\
    \    // We will keep track of how many times the right pointer has moved and\n\
    \    // left pointer has moved respectively\n    // We will keep track of how\
    \ many times the right pointer has moved and\n    // left pointer has moved respectively\n\
    \    // We will keep track of how many times the right pointer has moved and\n\
    \    // left pointer has moved respectively\n    // We will keep track of how\
    \ many times the right pointer has moved and\n    // left pointer has moved respectively\n\
    \    // We will keep track of how many times the right pointer has moved and\n\
    \    // left pointer has moved respectively\n    // We will keep track of how\
    \ many times the right pointer has moved and\n    // left pointer has moved respectively\n\
    \    // We will keep track of how many times the right pointer has moved and\n\
    \    // left pointer has moved respectively\n    // We will keep track of how\
    \ many times the right pointer has moved and\n    // \nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp299mn1uh_test.go:71:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074469
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  arr := arr[:len(arr)/2]\n    \n    i := 0\n    j := len(arr) - 1\n    \n  \
    \  for i < j {\n        if arr[i] > arr[j] {\n            arr[i], arr[j] = arr[j],\
    \ arr[i]\n            i++\n            j--\n        }\n    }\n    \n    return\
    \ arr == arr[:len(arr)/2]\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpl7x71u5o_test.go:30:9: no new variables on left side of :=

    /tmp/tmpl7x71u5o_test.go:43:12: invalid operation: arr == arr[:len(arr) / 2] (slice
    can only be compared to nil)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074470
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            i++\n            j--\n        }\n      \
    \  if i == j {\n            break\n        }\n    }\n    return true\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpv81crjqd_test.go:34\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpv81crjqd_test.go:58\
    \ +0x525\ntesting.tRunner(0xc0001a0340, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074469
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    // Write your code here\n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4zxsx5jo_test.go:281:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074469
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for i < j {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        }\n    }\n    \n    return arr[0] == arr[j]\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpwjnvhxw4_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpwjnvhxw4_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074470
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    return\
    \ arr[0] != arr[shift]\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmpjik721b2_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmpjik721b2_test.go:58:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074468
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            i++\n            j--\n        }\n      \
    \  if i == j {\n            break\n        }\n    }\n    return true\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpv81crjqd_test.go:34\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpv81crjqd_test.go:58\
    \ +0x525\ntesting.tRunner(0xc0001a0340, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074469
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        arr[i]\
    \ = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n      \
    \  arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpkvt243rl_test.go:94:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074469
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  arr2 := make([]int, len(arr))\n    \n    for i := 0; i < len(arr); i++ {\n\
    \        arr2[i] = arr[i]\n    }\n    \n    for i := len(arr) - 1; i > 0; i--\
    \ {\n        arr2[i] = arr2[i-1]\n    }\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        if arr[i] > arr2[0] {\n            return false\n        }\n    }\n\
    \    \n    return true\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp8kpfn_fv_test.go:66: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp8kpfn_fv_test.go:66:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmp8kpfn_fv_test.go:66: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074471
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := len(arr) - 1\n    j := 0\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            break\n        }\n    }\n    \n    return\
    \ len(arr) == i\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp8a1a28k4_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp8a1a28k4_test.go:63:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074471
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else if arr[i] < arr[j] {\n            i++\n        } else {\n\
    \            j--\n        }\n        if i == j {\n            break\n        }\n\
    \    }\n    return true\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmp35g5us13_test.go:34\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmp35g5us13_test.go:59\
    \ +0x525\ntesting.tRunner(0xc0001a0340, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074471
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // We have two pointers left and right to traverse the given array.\n    //\
    \ left pointer will point to the first element of the given array and right\n\
    \    // pointer will point to the last element of the given array.\n    left :=\
    \ 0\n    right := len(arr) - 1\n    \n    // We will keep track of the number\
    \ of right shift operations performed.\n    shift := 0\n    \n    // We will keep\
    \ track of the number of right shift operations performed.\n    shift := 0\n \
    \   \n    // We will keep track of the number of right shift operations performed.\n\
    \    shift := 0\n    \n    // We will keep track of the number of right shift\
    \ operations performed.\n    shift := 0\n    \n    // We will keep track of the\
    \ number of right shift operations performed.\n    shift := 0\n    \n    // We\
    \ will keep track of the number of right shift operations performed.\n    shift\
    \ := 0\n    \n    // We will keep track of the number of right shift operations\
    \ performed.\n    shift := 0\n    \n    // We will keep track of the number of\
    \ right shift operations performed.\n    shift := 0\n    \n    // We will keep\
    \ track of the number of right shift operations performed.\n    shift := 0\n \
    \   \n    // We will keep track of the number of right shift operations performed.\n\
    \    shift := 0\n    \n    // We will keep track of the number of right shift\
    \ operations performed.\n    shift := 0\n    \n    // We will keep track of the\
    \ number of right shift operations performed.\n    shift := 0\n    \n    // We\
    \ will keep track of the number of right shift operations performed.\n    shift\
    \ := 0\n    \n    // We will keep track of the number of right shift operations\
    \ performed.\n    shift := 0\n    \n    // We will keep track of the number of\
    \ right shift operations performed.\n    shift := 0\n    \n    // We will keep\
    \ track of the number of right shift operations performed.\n    shift := 0\n \
    \   \n    // We will keep track of the number of right shift operations performed.\n\
    \    shift := 0\n    \n    // We will keep track of the number of right shift\
    \ operations performed.\n    shift := 0\n    \n    // We will keep track of the\
    \ number of right shift operations performed.\n    shift := 0\n    \n    // We\
    \ will keep track of the number of right shift operations performed.\n    shift\
    \ := 0\n    \n    // We will keep track of the number of right shift operations\
    \ performed.\n    shift := 0\n    \n    // We will keep track of the number of\
    \ right shift operations performed.\n    shift := 0\n    \n    // We will keep\
    \ track\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp368ldget_test.go:103:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074470
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    return\
    \ arr[0] != arr[shift]\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmpjik721b2_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmpjik721b2_test.go:58:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074468
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    // Write your code here\n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4zxsx5jo_test.go:281:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074469
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            if i == j {\n                return false\n\
    \            }\n            i++\n            j--\n        }\n    }\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmp685y4k9g_test.go:34\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmp685y4k9g_test.go:57\
    \ +0x532\ntesting.tRunner(0xc0001a01a0, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074471
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := len(arr) - 1\n    j := len(arr) - 1\n    \n    for {\n        if arr[i]\
    \ > arr[j] {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n \
    \           j--\n        } else {\n            break\n        }\n    }\n    \n\
    \    return false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate :=\
    \ move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpw319rbhh_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpw319rbhh_test.go:63:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074471
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    arr[0]\
    \ = arr[shift]\n    arr[shift] = 0\n    \n    return move_one_ball(arr)\n}\n\n\
    func TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpjhxyr4em_test.go:25 +0xae fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef70e\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpjhxyr4em_test.go:41 +0x79 fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6d9\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpjhxyr4em_test.go:41 +0x79 fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6d9\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpjhxyr4em_test.go:41 +0x79 fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6d9\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpjhxyr4em_test.go:41 +0x79 fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6d9\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpjhxyr4em_test.go:41 +0x79 fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6d9\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpjhxyr4em_test.go:41 +0x79 fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6d9\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpjhxyr4em_test.go:41 +0x79 fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6d9\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpjhxyr4em_test.go:41 +0x79 fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6d9\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpjhxyr4em_test.go:41 +0x79 fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6d9\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074472
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := len(arr) - 1\n    j := 0\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j++\n        } else if arr[i] < arr[j] {\n            arr[i], arr[j] = arr[j],\
    \ arr[i]\n            j--\n        } else {\n            return true\n       \
    \ }\n    }\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\n\
    goroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620, 0xc000014360})\n\t\
    /home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpvz3tdp3l_test.go:34\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpvz3tdp3l_test.go:54\
    \ +0x559\ntesting.tRunner(0xc000192680, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074471
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            i++\n            j--\n        }\n      \
    \  if i == j {\n            break\n        }\n    }\n    return true\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpv81crjqd_test.go:34\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpv81crjqd_test.go:58\
    \ +0x525\ntesting.tRunner(0xc0001a0340, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074469
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        } else {\n          \
    \  arr[i], arr[shift] = arr[shift], arr[i]\n            shift -= 1\n        }\n\
    \    }\n    \n    return len(arr) == shift\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpha_hw9in_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpha_hw9in_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074471
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  arr := arr[:len(arr)-1]\n    \n    for i := 0; i < len(arr); i++ {\n      \
    \  arr[i] = arr[i] + 1\n    }\n    \n    return move_one_ball(arr)\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp48frg3h9_test.go:30:9: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074471
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            i++\n            j--\n        }\n      \
    \  if i == j {\n            break\n        }\n    }\n    return true\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpv81crjqd_test.go:34\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpv81crjqd_test.go:58\
    \ +0x525\ntesting.tRunner(0xc0001a0340, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074469
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        arr[i]\
    \ = arr[i + shift]\n    }\n    \n    return move_one_ball(arr[:shift]) && move_one_ball(arr[shift:])\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [5] with length 5 [recovered]\n\tpanic: runtime error: index out of range\
    \ [5] with length 5\n\ngoroutine 20 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball({0xc0000bf640?, 0xc00012d128?,\
    \ 0x4b3193?})\n\t/tmp/tmpajlv96gk_test.go:33 +0xd1\ncommand-line-arguments_test.TestMove_One_Ball(0x0?)\n\
    \t/tmp/tmpajlv96gk_test.go:46 +0xa8\ntesting.tRunner(0xc000103520, 0x528f40)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074471
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := len(arr) - 1\n    for i := len(arr) - 1; i > 0; i-- {\n        if arr[i]\
    \ > arr[i-1] {\n            arr[i], arr[i-1] = arr[i-1], arr[i]\n        }\n \
    \   }\n    return arr[0] == arr[len(arr)-1]\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpop_7ceib_test.go:30:5: i declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074471
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // We will keep track of the number of right shift operations performed\n \
    \   // and will keep track of the current position in the array i.e. arr[i]\n\
    \    // where i is the current position of the element in the array.\n    var\
    \ right_shift_count = 0\n    var current_position = 0\n    \n    // We will keep\
    \ track of the number of right shift operations performed\n    // and will keep\
    \ track of the current position in the array i.e. arr[i]\n    // where i is the\
    \ current position of the element in the array.\n    var right_shift_count = 0\n\
    \    var current_position = 0\n    \n    // We will keep track of the number of\
    \ right shift operations performed\n    // and will keep track of the current\
    \ position in the array i.e. arr[i]\n    // where i is the current position of\
    \ the element in the array.\n    var right_shift_count = 0\n    var current_position\
    \ = 0\n    \n    // We will keep track of the number of right shift operations\
    \ performed\n    // and will keep track of the current position in the array i.e.\
    \ arr[i]\n    // where i is the current position of the element in the array.\n\
    \    var right_shift_count = 0\n    var current_position = 0\n    \n    // We\
    \ will keep track of the number of right shift operations performed\n    // and\
    \ will keep track of the current position in the array i.e. arr[i]\n    // where\
    \ i is the current position of the element in the array.\n    var right_shift_count\
    \ = 0\n    var current_position = 0\n    \n    // We will keep track of the number\
    \ of right shift operations performed\n    // and will keep track of the current\
    \ position in the array i.e. arr[i]\n    // where i is the current position of\
    \ the element in the array.\n    var right_shift_count = 0\n    var current_position\
    \ = 0\n    \n    // We will keep track of the number of right shift operations\
    \ performed\n    // and will keep track of the current position in the array i.e.\
    \ arr[i]\n    // where i is the current position of the element in the array.\n\
    \    var right_shift_count = 0\n    var current_position = 0\n    \n    // We\
    \ will keep track of the number of right shift operations performed\n    // and\
    \ will keep track of the current position in the array i.e. arr[i]\n    // where\
    \ i is the current position of the element in the array.\n    var right_shift_count\
    \ = 0\n    var current_position = 0\n    \n    // We will keep track of the number\
    \ of right shift operations performed\n    // and will keep track of the current\
    \ position in the array i.e. arr[i]\n    // where i is the current position of\
    \ the element in the array.\n    var right_shift_count = 0\n    var current_position\
    \ = 0\n    \n    // We will keep track of the number of right shift operations\
    \ performed\n    // and will keep track of the current position in the array i.e.\
    \ arr[i]\n    // where i is the current position of the element in the array.\n\
    \    var right_shift_count = 0\n    var current_position = 0\n    \n    // We\
    \ will keep track of the number of right shift operations \nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp439gyfja_test.go:91:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074471
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            i++\n            j--\n        }\n      \
    \  if i == j {\n            break\n        }\n    }\n    return true\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpv81crjqd_test.go:34\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpv81crjqd_test.go:58\
    \ +0x525\ntesting.tRunner(0xc0001a0340, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074469
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for i < j {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        }\n    }\n    \n    return arr[i] == arr[j]\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__3\
    \ (0.00s)\n        tmpf0qbld_7_test.go:61: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074469
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    arr[0],\
    \ arr[shift] = arr[shift], arr[0]\n    \n    return move_one_ball(arr)\n}\n\n\
    func TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpnkx_39bj_test.go:25 +0xaa fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef70a\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074469
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for i < j {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        }\n    }\n    \n    return arr[0] == arr[len(arr)-1]\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmppibeqx10_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmppibeqx10_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074469
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // We will keep track of the number of right shift operations performed so\
    \ far\n    // and will perform the right shift operation only if the number of\
    \ right\n    // shift operations performed so far is even.\n    rightShiftCount\
    \ := 0\n    \n    // We will keep track of the number of elements in the array\
    \ which have been\n    // shifted so far.\n    shiftedElements := 0\n    \n  \
    \  // We will keep track of the number of elements in the array which have been\n\
    \    // moved so far.\n    movedElements := 0\n    \n    // We will keep track\
    \ of the number of elements in the array which have been\n    // moved so far.\n\
    \    movedElements := 0\n    \n    // We will keep track of the number of elements\
    \ in the array which have been\n    // moved so far.\n    movedElements := 0\n\
    \    \n    // We will keep track of the number of elements in the array which\
    \ have been\n    // moved so far.\n    movedElements := 0\n    \n    // We will\
    \ keep track of the number of elements in the array which have been\n    // moved\
    \ so far.\n    movedElements := 0\n    \n    // We will keep track of the number\
    \ of elements in the array which have been\n    // moved so far.\n    movedElements\
    \ := 0\n    \n    // We will keep track of the number of elements in the array\
    \ which have been\n    // moved so far.\n    movedElements := 0\n    \n    //\
    \ We will keep track of the number of elements in the array which have been\n\
    \    // moved so far.\n    movedElements := 0\n    \n    // We will keep track\
    \ of the number of elements in the array which have been\n    // moved so far.\n\
    \    movedElements := 0\n    \n    // We will keep track of the number of elements\
    \ in the array which have been\n    // moved so far.\n    movedElements := 0\n\
    \    \n    // We will keep track of the number of elements in the array which\
    \ have been\n    // moved so far.\n    movedElements := 0\n    \n    // We will\
    \ keep track of the number of elements in the array which have been\n    // moved\
    \ so far.\n    movedElements := 0\n    \n    // We will keep track of the number\
    \ of elements in the array which have been\n    // moved so far.\n    movedElements\
    \ := 0\n    \n    // We will keep track of the number of elements in the array\
    \ which have been\n    // moved so far.\n    movedElements := 0\n    \n    //\
    \ We will keep track of the number of \nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpkf8_42v7_test.go:96:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074471
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for i < j {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        }\n    }\n    \n    return arr[0] == arr[len(arr)-1]\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmppibeqx10_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmppibeqx10_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074469
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  arr := arr[:len(arr)-1]\n    \n    for i := len(arr) - 1; i > 0; i-- {\n  \
    \      arr[i] = arr[i-1]\n    }\n    arr[0] = arr[len(arr)-1]\n    \n    return\
    \ move_one_ball(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9sbgop3g_test.go:30:9: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074472
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            i++\n            j--\n        }\n      \
    \  if i == j {\n            break\n        }\n    }\n    return true\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpv81crjqd_test.go:34\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpv81crjqd_test.go:58\
    \ +0x525\ntesting.tRunner(0xc0001a0340, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074469
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for i < j {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            i++\n            j--\n        }\n    }\n\
    \    \n    return arr[0] == arr[len(arr)-1]\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp1vdp1mjt_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp1vdp1mjt_test.go:64:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074468
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for i < j {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        }\n    }\n    \n    return arr[0] == arr[len(arr)-1]\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmppibeqx10_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmppibeqx10_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074469
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            i++\n            j--\n        }\n      \
    \  if i >= j {\n            break\n        }\n    }\n    return false\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp8wbvilqa_test.go:66: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp8wbvilqa_test.go:66:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074472
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            i++\n            j--\n        }\n      \
    \  if i == j {\n            break\n        }\n    }\n    \n    return true\n}\n\
    \nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpxz663act_test.go:34\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpxz663act_test.go:59\
    \ +0x525\ntesting.tRunner(0xc0001964e0, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074468
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for i < j {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        }\n    }\n    \n    return arr[0] == arr[len(arr)-1]\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmppibeqx10_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmppibeqx10_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074469
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        arr[i]\
    \ = arr[i] >> 1\n    }\n    \n    for i := 0; i < shift; i++ {\n        arr[i]\
    \ = arr[i] >> 1\n    }\n    \n    arr[0] = arr[0] >> 1\n    \n    return false\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpe0hlp5ui_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpe0hlp5ui_test.go:62:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074472
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmphzv9h4a__test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmphzv9h4a__test.go:56:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074472
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        } else {\n          \
    \  arr[i], arr[shift] = arr[shift], arr[i]\n            shift -= 1\n        }\n\
    \    }\n    \n    return len(arr) == shift\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpha_hw9in_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpha_hw9in_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074471
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    return\
    \ arr[0] != arr[shift]\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmpjik721b2_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmpjik721b2_test.go:58:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074468
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // We will keep track of the number of right shift operations performed on\n\
    \    // the given array\n    shift := 0\n    \n    // We will keep track of the\
    \ number of elements in the given array\n    size := len(arr)\n    \n    // We\
    \ will keep track of the last element in the given array\n    last := arr[len(arr)-1]\n\
    \    \n    // We will keep track of the last element in the given array\n    start\
    \ := 0\n    \n    // We will keep track of the last element in the given array\n\
    \    end := 0\n    \n    // We will keep track of the last element in the given\
    \ array\n    i := 0\n    \n    // We will keep track of the last element in the\
    \ given array\n    j := size - 1\n    \n    // We will keep track of the last\
    \ element in the given array\n    k := size - 1\n    \n    // We will keep track\
    \ of the last element in the given array\n    l := size - 1\n    \n    // We will\
    \ keep track of the last element in the given array\n    m := size - 1\n    \n\
    \    // We will keep track of the last element in the given array\n    n := size\
    \ - 1\n    \n    // We will keep track of the last element in the given array\n\
    \    o := size - 1\n    \n    // We will keep track of the last element in the\
    \ given array\n    p := size - 1\n    \n    // We will keep track of the last\
    \ element in the given array\n    q := size - 1\n    \n    // We will keep track\
    \ of the last element in the given array\n    r := size - 1\n    \n    // We will\
    \ keep track of the last element in the given array\n    s := size - 1\n    \n\
    \    // We will keep track of the last element in the given array\n    t := size\
    \ - 1\n    \n    // We will keep track of the last element in the given array\n\
    \    u := size - 1\n    \n    // We will keep track of the last element in the\
    \ given array\n    v := size - 1\n    \n    // We will keep track of the last\
    \ element in the given array\n    w := size - 1\n    \n    // We will keep track\
    \ of the last element in the given array\n    x := size - 1\n    \n    // We will\
    \ keep track of the last element in the given array\n    y := size - 1\n    \n\
    \    // We will keep track of the last element in the given array\n    z := size\
    \ - 1\n    \n    // We will keep track of the last element in the given array\n\
    \    \n    // We will keep track of the last element in the given array\n    \n\
    \    // We will keep track of the last element \nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpgyh4zc61_test.go:105:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074471
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else if i == j {\n            break\n        }\n    }\n    \n\
    \    return arr[0] == 0\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpp1zw2rec_test.go:34\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpp1zw2rec_test.go:55\
    \ +0x53f\ntesting.tRunner(0xc0001a0340, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074472
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        arr[i]\
    \ = arr[i] >> 1\n        \n        if arr[i] > 0 {\n            arr[i] = arr[i]\
    \ << 1\n            arr[i] = arr[i] >> 1\n            arr[i] = arr[i] << 1\n \
    \           arr[i] = arr[i] >> 1\n            arr[i] = arr[i] << 1\n         \
    \   arr[i] = arr[i] >> 1\n            arr[i] = arr[i] << 1\n            arr[i]\
    \ = arr[i] >> 1\n            arr[i] = arr[i] << 1\n            arr[i] = arr[i]\
    \ >> 1\n            arr[i] = arr[i] << 1\n            arr[i] = arr[i] >> 1\n \
    \           arr[i] = arr[i] << 1\n            arr[i] = arr[i] >> 1\n         \
    \   arr[i] = arr[i] << 1\n            arr[i] = arr[i] >> 1\n            arr[i]\
    \ = arr[i] << 1\n            arr[i] = arr[i] >> 1\n            arr[i] = arr[i]\
    \ << 1\n            arr[i] = arr[i] >> 1\n            arr[i] = arr[i] << 1\n \
    \           arr[i] = arr[i] >> 1\n            arr[i] = arr[i] << 1\n         \
    \   arr[i] = arr[i] >> 1\n            arr[i] = arr[i] << 1\n            arr[i]\
    \ = arr[i] >> 1\n            arr[i] = arr[i] << 1\n            arr[i] = arr[i]\
    \ >> 1\n            arr[i] = arr[i] << 1\n            arr[i] = arr[i] >> 1\n \
    \           arr[i] = arr[i] << 1\n            arr[i] = arr[i] >> 1\n         \
    \   arr[i] = arr[i] << 1\n            arr[i] = arr[i] >> 1\n            arr[i]\
    \ = arr[i] << 1\n            arr[i] = arr[i] >> 1\n            arr[i] = arr[i]\
    \ << 1\n            arr[i] = arr[i] >> 1\n            arr[i] = arr[i] << 1\n \
    \           arr[i] = arr[i] >> 1\n            arr[i] = arr[i] << 1\n         \
    \   arr[i] = arr[i] >> 1\n            arr[i] = arr[i] << 1\n            arr[i]\
    \ = arr[i] >> 1\n            arr[i] = arr[i] << 1\n            arr[i] = arr[i]\
    \ >> 1\n            arr[i] = arr[i] << 1\n            arr[i] = arr[i] >> 1\n \
    \           arr[i] = arr[i] << 1\n            arr[i] = arr[i] >> 1\n         \
    \   arr[i] = arr[i] << 1\n            arr[i] = arr[i] >> 1\n            arr[i]\
    \ = arr[i] << 1\n            arr[i] = arr[i] >> 1\n            arr[i] = arr[i]\
    \ << 1\n            arr[i] = arr[i] >> 1\n            arr[i] = arr[i] << 1\n \
    \           arr[i] = arr[i] >> 1\n\nfunc TestMove_One_Ball(t *testing.T) {\n \
    \ candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0ev2hbtw_test.go:95:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074471
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // We need to find the last element of the array and move it to the 0th index\n\
    \    // and perform right shift operation on it.\n    lastElement := arr[len(arr)-1]\n\
    \    arr[len(arr)-1] = 0\n    \n    // We need to perform right shift operation\
    \ on all the elements of the array\n    // except the last element and check if\
    \ it is possible to obtain the sorted\n    // array by performing right shift\
    \ operation on the last element.\n    for i := 0; i < len(arr)-1; i++ {\n    \
    \    arr[i] = arr[i] + 1\n    }\n    \n    // We need to perform right shift operation\
    \ on the last element and check if it\n    // is possible to obtain the sorted\
    \ array by performing right shift operation \n    // on the last element.\n  \
    \  arr[len(arr)-1] = lastElement\n    \n    // We need to perform right shift\
    \ operation on the 0th index and check if it\n    // is possible to obtain the\
    \ sorted array by performing right shift operation \n    // on the 0th index.\n\
    \    arr[0] = 0\n    \n    // We need to perform right shift operation on the\
    \ 0th index and check if it\n    // is possible to obtain the sorted array by\
    \ performing right shift operation \n    // on the 0th index.\n    arr[0] = 0\n\
    \    \n    // We need to perform right shift operation on the 0th index and check\
    \ if it\n    // is possible to obtain the sorted array by performing right shift\
    \ operation \n    // on the 0th index.\n    arr[0] = 0\n    \n    // We need to\
    \ perform right shift operation on the 0th index and check if it\n    // is possible\
    \ to obtain the sorted array by performing right shift operation \n    // on the\
    \ 0th index.\n    arr[0] = 0\n    \n    // We need to perform right shift operation\
    \ on the 0th index and check if it\n    // is possible to obtain the sorted array\
    \ by performing right shift operation \n    // on the 0th index.\n    arr[0] =\
    \ 0\n    \n    // We need to perform right shift operation on the 0th index and\
    \ check if it\n    // is possible to obtain the sorted array by performing right\
    \ shift operation \n    // on the 0th index.\n    arr[0] = 0\n    \n    // We\
    \ need to perform right shift operation on the 0th index and check if it\n   \
    \ // is possible to obtain the sorted array by performing right shift operation\
    \ \n    // on the 0th index.\n    arr[0] = 0\n    \n    // We need to perform\
    \ right shift operation on the 0th index and check if it\n    // is possible to\
    \ obtain the sorted array by performing right shift operation \n    // on the\
    \ 0th index.\n    arr[0] = 0\n    \n    // We need to perform right shift operation\
    \ on the 0th index and check if it\n    // is possible to obtain the sorted array\
    \ by performing right shift operation \n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6fcaj45w_test.go:90:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074472
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for i < j {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            i++\n            j--\n        }\n    }\n\
    \    \n    return arr[0] == arr[len(arr)-1]\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp1vdp1mjt_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp1vdp1mjt_test.go:64:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074468
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    arr[0],\
    \ arr[shift] = arr[shift], arr[0]\n    \n    return move_one_ball(arr)\n}\n\n\
    func TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpnkx_39bj_test.go:25 +0xaa fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef70a\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074469
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    // Write your code here\n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4zxsx5jo_test.go:281:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074469
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := len(arr) - 1\n    j := len(arr) - 1\n    \n    for {\n        if arr[i]\
    \ > arr[j] {\n            arr[i], arr[j] = arr[j], arr[i]\n            i = i -\
    \ 1\n            j = j - 1\n        } else {\n            break\n        }\n \
    \   }\n    \n    return arr[i] == 0\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpxyostjfs_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpxyostjfs_test.go:63:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074473
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // We are going to perform N right shift operations on the given array\n  \
    \  // and after each right shift operation we will check if we can get\n    //\
    \ non-decreasing order for the array by performing right shift operation\n   \
    \ // again.\n    for i := 0; i < len(arr); i++ {\n        arr[i], arr[len(arr)-i-1]\
    \ = arr[len(arr)-i-1], arr[i]\n    }\n    \n    // We are going to perform N right\
    \ shift operations on the given array\n    // and after each right shift operation\
    \ we will check if we can get\n    // non-decreasing order for the array by performing\
    \ right shift operation\n    // again.\n    for i := 0; i < len(arr); i++ {\n\
    \        arr[i], arr[len(arr)-i-1] = arr[len(arr)-i-1], arr[i]\n    }\n    \n\
    \    // We are going to perform N right shift operations on the given array\n\
    \    // and after each right shift operation we will check if we can get\n   \
    \ // non-decreasing order for the array by performing right shift operation\n\
    \    // again.\n    for i := 0; i < len(arr); i++ {\n        arr[i], arr[len(arr)-i-1]\
    \ = arr[len(arr)-i-1], arr[i]\n    }\n    \n    // We are going to perform N right\
    \ shift operations on the given array\n    // and after each right shift operation\
    \ we will check if we can get\n    // non-decreasing order for the array by performing\
    \ right shift operation\n    // again.\n    for i := 0; i < len(arr); i++ {\n\
    \        arr[i], arr[len(arr)-i-1] = arr[len(arr)-i-1], arr[i]\n    }\n    \n\
    \    // We are going to perform N right shift operations on the given array\n\
    \    // and after each right shift operation we will check if we can get\n   \
    \ // non-decreasing order for the array by performing right shift operation\n\
    \    // again.\n    for i := 0; i < len(arr); i++ {\n        arr[i], arr[len(arr)-i-1]\
    \ = arr[len(arr)-i-1], arr[i]\n    }\n    \n    // We are going to perform N right\
    \ shift operations on the given array\n    // and after each right shift operation\
    \ we will check if we can get\n    // non-decreasing order for the array by performing\
    \ right shift operation\n    // again.\n    for i := 0; i < len(arr); i++ {\n\
    \        arr[i], arr[len(arr)-i-1] = arr[len(arr)-i-1], arr[i]\n    }\n    \n\
    \    // We are going to perform N right shift operations on the given array\n\
    \    // and after each right shift operation we will check if we can get\n   \
    \ // non-decreasing order for the array by performing right shift operation\n\
    \    // again.\n    for i := 0; i < len(arr); i++ {\n        arr[i], arr\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpj91mth9y_test.go:83:9: expected 1 expression

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074472
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // We are going to perform right shift operation on the given array arr\n \
    \   // and we will keep track of the number of right shift operations performed.\n\
    \    // We will keep track of how many elements are moved from the right side\
    \ to\n    // the left side.\n    shift := 0\n    \n    // We will keep track of\
    \ the number of elements that are moved from the left\n    // side to the right\
    \ side.\n    moved := 0\n    \n    // We will keep track of the number of elements\
    \ that are moved from the right\n    // side to the left side.\n    movedFromRight\
    \ := 0\n    \n    // We will keep track of the number of elements that are moved\
    \ from the left\n    // side to the right side.\n    movedFromLeft := 0\n    \n\
    \    // We will keep track of the number of elements that are moved from the right\n\
    \    // side to the left side.\n    movedFromLeftFromRight := 0\n    \n    //\
    \ We will keep track of the number of elements that are moved from the left\n\
    \    // side to the right side.\n    movedFromRightFromLeft := 0\n    \n    //\
    \ We will keep track of the number of elements that are moved from the right\n\
    \    // side to the left side.\n    movedFromLeftFromLeftFromRight := 0\n    \n\
    \    // We will keep track of the number of elements that are moved from the left\n\
    \    // side to the right side.\n    movedFromRightFromLeftFromLeft := 0\n   \
    \ \n    // We will keep track of the number of elements that are moved from the\
    \ right\n    // side to the left side.\n    movedFromLeftFromRightFromRight :=\
    \ 0\n    \n    // We will keep track of the number of elements that are moved\
    \ from the left\n    // side to the right side.\n    movedFromRightFromLeftFromLeftFromRight\
    \ := 0\n    \n    // We will keep track of the number of elements that are moved\
    \ from the left\n    // side to the right side.\n    movedFromLeftFromRightFromRightFromLeft\
    \ := 0\n    \n    // We will keep track of the number of elements that are moved\
    \ from the right\n    // side to the left side.\n    movedFromRightFromLeftFromLeftFromLeftFromRight\
    \ := 0\n    \n    // We will keep track of the number of elements that are moved\
    \ from the left\n    // side to the right side.\n    movedFromLeftFromRightFromRightFromRightFromLeft\
    \ := 0\n    \n    // We will keep track of the number of elements that are moved\
    \ from the right\n    // side to the left side.\n    movedFromRightFromLeftFromLeftFromRight\n\
    func TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdsiyv52j_test.go:87:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074472
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            i++\n            j--\n        }\n      \
    \  if i == j {\n            break\n        }\n    }\n    return true\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpv81crjqd_test.go:34\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpv81crjqd_test.go:58\
    \ +0x525\ntesting.tRunner(0xc0001a0340, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074469
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            i++\n            j--\n        }\n      \
    \  if i == j {\n            break\n        }\n    }\n    return true\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpv81crjqd_test.go:34\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpv81crjqd_test.go:58\
    \ +0x525\ntesting.tRunner(0xc0001a0340, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074469
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        arr[i]\
    \ = arr[i]<<1\n        arr[i] = arr[i]>>(shift-1)\n        shift -= 1\n    }\n\
    \    \n    return arr[0] == 0\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n \
    \ candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: negative shift\
    \ amount [recovered]\n\tpanic: runtime error: negative shift amount\n\ngoroutine\
    \ 6 [running]:\ntesting.tRunner.func1.2({0x5028a0, 0x5f1990})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x5028a0, 0x5f1990})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmp491hmoc1_test.go:34\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmp491hmoc1_test.go:48\
    \ +0x53b\ntesting.tRunner(0xc0001a0340, 0x527f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074473
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            i++\n            j--\n        }\n      \
    \  if i == j {\n            break\n        }\n    }\n    return true\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpv81crjqd_test.go:34\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpv81crjqd_test.go:58\
    \ +0x525\ntesting.tRunner(0xc0001a0340, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074469
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // We will keep track of the number of right shifts performed.\n    var shiftCount\
    \ int = 0\n    \n    // We will keep track of the number of elements in the array\
    \ that we\n    // have already visited.\n    var visited map[int]bool = make(map[int]bool)\n\
    \    \n    // We will keep track of the number of elements in the array that we\n\
    \    // have already visited.\n    var visited2 map[int]bool = make(map[int]bool)\n\
    \    \n    // We will keep track of the number of elements in the array that we\n\
    \    // have already visited.\n    var visited3 map[int]bool = make(map[int]bool)\n\
    \    \n    // We will keep track of the number of elements in the array that we\n\
    \    // have already visited.\n    var visited4 map[int]bool = make(map[int]bool)\n\
    \    \n    // We will keep track of the number of elements in the array that we\n\
    \    // have already visited.\n    var visited5 map[int]bool = make(map[int]bool)\n\
    \    \n    // We will keep track of the number of elements in the array that we\n\
    \    // have already visited.\n    var visited6 map[int]bool = make(map[int]bool)\n\
    \    \n    // We will keep track of the number of elements in the array that we\n\
    \    // have already visited.\n    var visited7 map[int]bool = make(map[int]bool)\n\
    \    \n    // We will keep track of the number of elements in the array that we\n\
    \    // have already visited.\n    var visited8 map[int]bool = make(map[int]bool)\n\
    \    \n    // We will keep track of the number of elements in the array that we\n\
    \    // have already visited.\n    var visited9 map[int]bool = make(map[int]bool)\n\
    \    \n    // We will keep track of the number of elements in the array that we\n\
    \    // have already visited.\n    var visited10 map[int]bool = make(map[int]bool)\n\
    \    \n    // We will keep track of the number of elements in the array that we\n\
    \    // have already visited.\n    var visited11 map[int]bool = make(map[int]bool)\n\
    \    \n    // We will keep track of the number of elements in the array that we\n\
    \    // have already visited.\n    var visited12 map[int]bool = make(map[int]bool)\n\
    \    \n    // We will keep track of the number of elements in the array that we\n\
    \    // have already visited.\n    var visited13 map[int]bool = make(map[int]bool)\n\
    \    \n    // We will keep track of the number of elements in the array that we\n\
    \    // have already visited.\n    var visited14 map[int]\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8fitkm6e_test.go:87:27: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074472
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    return move_one_ball(arr[:shift])\
    \ && move_one_ball(arr[shift:])\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x520348?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x0, 0x5})\n\t/tmp/tmp30bq7nx7_test.go:25 +0xd5 fp=0xc0201e03a8 sp=0xc0201e03a0\
    \ pc=0x4ef735\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmp30bq7nx7_test.go:36 +0x72 fp=0xc0201e03d8 sp=0xc0201e03a8 pc=0x4ef6d2\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmp30bq7nx7_test.go:36\
    \ +0xb7 fp=0xc0201e0408 sp=0xc0201e03d8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmp30bq7nx7_test.go:36 +0xb7 fp=0xc0201e0438 sp=0xc0201e0408\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmp30bq7nx7_test.go:36 +0xb7 fp=0xc0201e0468 sp=0xc0201e0438 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmp30bq7nx7_test.go:36\
    \ +0xb7 fp=0xc0201e0498 sp=0xc0201e0468 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmp30bq7nx7_test.go:36 +0xb7 fp=0xc0201e04c8 sp=0xc0201e0498\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmp30bq7nx7_test.go:36 +0xb7 fp=0xc0201e04f8 sp=0xc0201e04c8 pc=0x4ef717\n\
    command-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\t/tmp/tmp30bq7nx7_test.go:36\
    \ +0xb7 fp=0xc0201e0528 sp=0xc0201e04f8 pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40,\
    \ 0x1, 0x5})\n\t/tmp/tmp30bq7nx7_test.go:36 +0xb7 fp=0xc0201e0558 sp=0xc0201e0528\
    \ pc=0x4ef717\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40, 0x1, 0x5})\n\
    \t/tmp/tmp30bq7nx7_test.go:36 +0xb7 fp="
  timestamp: 1660074474
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        arr[i]\
    \ = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n    }\n\
    \    \n    for i := 0; i < shift; i++ {\n        arr[i] = arr[i]>>1\n    }\n \
    \   \n    return arr[0] == 0\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp8g5lwdk0_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp8g5lwdk0_test.go:62:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074473
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        arr[i]\
    \ = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n      \
    \  arr[i] = arr[i]>>1\n    }\n    \n    for i := 0; i < shift; i++ {\n       \
    \ arr[i] = arr[i]>>1\n    }\n    \n    return arr[0] == 0\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmplqn4mpi2_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmplqn4mpi2_test.go:63:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074473
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        } else {\n          \
    \  arr[i], arr[shift] = arr[shift], arr[i]\n            shift -= 1\n        }\n\
    \    }\n    \n    return len(arr) == shift\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpha_hw9in_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpha_hw9in_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074471
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    // Your code here\n    \n    if len(arr) == 0 {\n       \
    \ return true\n    }\n    \n    i := 0\n    j := len(arr) - 1\n    \n    for i\
    \ < j {\n        if arr[i] > arr[j] {\n            arr[i], arr[j] = arr[j], arr[i]\n\
    \            i++\n            j--\n        }\n    }\n    \n    return false\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpgjs3s6qd_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpgjs3s6qd_test.go:63:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074474
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        arr[i]\
    \ = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n    }\n\
    \    \n    for i := 0; i < shift; i++ {\n        arr[i] = arr[i]>>1\n    }\n \
    \   \n    return arr[0] == 0\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp8g5lwdk0_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp8g5lwdk0_test.go:62:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074473
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for i < j {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        }\n    }\n    \n    return arr[i] == arr[j]\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__3\
    \ (0.00s)\n        tmpf0qbld_7_test.go:61: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074469
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := len(arr) - 1\n    j := len(arr) - 1\n    \n    for {\n        if arr[i]\
    \ > arr[j] {\n            arr[i], arr[j] = arr[j], arr[i]\n            \n    \
    \        if i == 0 {\n                return true\n            }\n           \
    \ \n            i -= 1\n            j -= 1\n        } else {\n            arr[i],\
    \ arr[j] = arr[j], arr[i]\n            \n            if i == 0 {\n           \
    \     return false\n            }\n            \n            i -= 1\n        \
    \    j -= 1\n        }\n    }\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n \
    \ candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpelpjxde4_test.go:73: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpelpjxde4_test.go:73:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074474
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            i++\n            j--\n        }\n      \
    \  if i == j {\n            break\n        }\n    }\n    return true\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpv81crjqd_test.go:34\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpv81crjqd_test.go:58\
    \ +0x525\ntesting.tRunner(0xc0001a0340, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074469
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    // Write your code here\n    if len(arr) == 0 {\n       \
    \ return true\n    }\n    \n    i := 0\n    j := len(arr) - 1\n    \n    for i\
    \ < j {\n        if arr[i] > arr[j] {\n            arr[i], arr[j] = arr[j], arr[i]\n\
    \            i++\n            j--\n        }\n    }\n    \n    return arr[0] ==\
    \ arr[len(arr)-1]\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate :=\
    \ move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpribvpyi6_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpribvpyi6_test.go:62:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074474
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        arr[i]\
    \ = arr[i] >> 1\n    }\n    \n    for i := 0; i < shift; i++ {\n        arr[i]\
    \ = arr[i] >> 1\n    }\n    \n    arr[0] = arr[0] >> 1\n    \n    return move_one_ball(arr)\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmphsbru51x_test.go:25 +0x91 fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef6f1\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmphsbru51x_test.go:42 +0x73 fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6d3\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmphsbru51x_test.go:42 +0x73 fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6d3\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmphsbru51x_test.go:42 +0x73 fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6d3\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmphsbru51x_test.go:42 +0x73 fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6d3\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmphsbru51x_test.go:42 +0x73 fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6d3\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmphsbru51x_test.go:42 +0x73 fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6d3\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmphsbru51x_test.go:42 +0x73 fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6d3\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmphsbru51x_test.go:42 +0x73 fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6d3\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmphsbru51x_test.go:42 +0x73 fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6d3\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074475
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  arr := arr[:len(arr)-1]\n    \n    for i := 0; i < len(arr); i++ {\n      \
    \  arr[i] = arr[i] + 1\n    }\n    \n    arr[len(arr)-1] = 0\n    \n    return\
    \ move_one_ball(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp65ojwreh_test.go:30:9: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074473
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            arr[i], arr[shift] = arr[shift], arr[i]\n\
    \            shift -= 1\n        }\n    }\n    \n    return len(arr) == shift\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmptabr5pnu_test.go:59: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmptabr5pnu_test.go:59:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660074468
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for i < j {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            i++\n        }\n    }\n    \n    return\
    \ arr[0] == arr[len(arr)-1]\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpwnsdd24t_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpwnsdd24t_test.go:63:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074474
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        arr[i]\
    \ = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n    }\n\
    \    \n    for i := 0; i < shift; i++ {\n        arr[i] = arr[i]<<1\n        arr[i]\
    \ = arr[i]>>1\n    }\n    \n    for i := 0; i < len(arr); i++ {\n        arr[i]\
    \ = arr[i]<<1\n        arr[i] = arr[i]>>1\n    }\n    \n    return arr[0] == 0\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpu3id9e1z_test.go:68: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpu3id9e1z_test.go:68:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074474
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    arr[0]\
    \ = arr[shift]\n    \n    return move_one_ball(arr[1:])\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmph6703f_f_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmph6703f_f_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074469
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    if\
    \ shift > 0 {\n        return false\n    }\n    \n    shift -= len(arr)\n    \n\
    \    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[shift] {\n     \
    \       shift -= 1\n        }\n    }\n    \n    if shift > 0 {\n        return\
    \ false\n    }\n    \n    shift -= len(arr)\n    \n    for i := 0; i < len(arr);\
    \ i++ {\n        if arr[i] > arr[shift] {\n            shift -= 1\n        }\n\
    \    }\n    \n    if shift > 0 {\n        return false\n    }\n    \n    shift\
    \ -= len(arr)\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] >\
    \ arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    if shift >\
    \ 0 {\n        return false\n    }\n    \n    shift -= len(arr)\n    \n    for\
    \ i := 0; i < len(arr); i++ {\n        if arr[i] > arr[shift] {\n            shift\
    \ -= 1\n        }\n    }\n    \n    if shift > 0 {\n        return false\n   \
    \ }\n    \n    shift -= len(arr)\n    \n    for i := 0; i < len(arr); i++ {\n\
    \        if arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n\
    \    \n    if shift > 0 {\n        return false\n    }\n    \n    shift -= len(arr)\n\
    \    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[shift] {\n\
    \            shift -= 1\n        }\n    }\n    \n    if shift > 0 {\n        return\
    \ false\n    }\n    \n    shift -= len(arr)\n    \n    for i := 0; i < len(arr);\
    \ i++ {\n        if arr[i] > arr[shift] {\n            shift -= 1\n        }\n\
    \    }\n    \n    if shift > 0 {\n        return false\n    }\n    \n    shift\
    \ -= len(arr)\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] >\
    \ arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    if shift >\
    \ 0 {\n        return false\n    }\n    \n    shift -= len(arr)\n    \n    for\
    \ i := 0; i < len(arr); i++ {\n        if arr[i] > arr[shift] {\n            shift\
    \ -= 1\n        }\n    }\n    \n    if shift > 0 {\n        return false\n   \
    \ }\n    \n    shift -= len(arr)\n    \n    for \nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpif_nozbc_test.go:153:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074473
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // We will keep track of the number of right shift operations performed\n \
    \   // and we will keep track of the number of elements in the array after \n\
    \    // performing right shift operations.\n    right_shift_count := 0\n    array_size\
    \ := len(arr)\n    \n    // We will keep track of the number of elements in the\
    \ array after \n    // performing right shift operations.\n    array_size_after_right_shift\
    \ := 0\n    \n    // We will keep track of the number of elements in the array\
    \ after \n    // performing right shift operations.\n    array_size_after_right_shift_after_right_shift\
    \ := 0\n    \n    // We will keep track of the number of elements in the array\
    \ after \n    // performing right shift operations.\n    array_size_after_right_shift_after_right_shift_after_right_shift\
    \ := 0\n    \n    // We will keep track of the number of elements in the array\
    \ after \n    // performing right shift operations.\n    array_size_after_right_shift_after_right_shift_after_right_shift_after_right_shift\
    \ := 0\n    \n    // We will keep track of the number of elements in the array\
    \ after \n    // performing right shift operations.\n    array_size_after_right_shift_after_right_shift_after_right_shift_after_right_shift_after_right_shift\
    \ := 0\n    \n    // We will keep track of the number of elements in the array\
    \ after \n    // performing right shift operations.\n    array_size_after_right_shift_after_right_shift_after_right_shift_after_right_shift_after_right_shift_after_right_shift\
    \ := 0\n    \n    // We will keep track of the number of elements in the array\
    \ after \n    // performing right shift operations.\n    array_size_after_right_shift_after_right_shift_after_right_shift_after_right_shift_after_right_shift_after_right_shift_after_right_shift\
    \ := 0\n    \n    // We will keep track of the number of elements in the array\
    \ after \n    // performing right shift operations.\n    array_size_after_right_shift_after_right_shift_after_right_shift_after_right_shift_after_right_shift_after_right_shift_after_right_shift_after_right_shift\
    \ := 0\n    \n    // We will keep track of the number of elements in the array\
    \ after \n    // performing right shift operations.\n    array_size_after_right_shift_after_right_shift_after_right_shift_after_right_shift_after_right_shift_after_right_shift_after_right_shift_after_right_shift_after_right_shift\
    \ := 0\n    \n    // We will keep track of the number of elements in the array\
    \ after \n    // performing right shift operations.\n    array_size_after_right_shift_after_right_shift_after_right_shift_after_right_shift_after_right_shift_after_right_shift_after_right_shift_after_right_shift_after_right_shift\
    \ := 0\n    \n    // We will keep track of the number of elements in the array\
    \ after \n    // performing right shift operations.\n    \nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp1t9guai__test.go:79:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074473
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    arr[0],\
    \ arr[shift] = arr[shift], arr[0]\n    \n    return move_one_ball(arr)\n}\n\n\
    func TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpnkx_39bj_test.go:25 +0xaa fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef70a\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074469
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            i++\n            j--\n        }\n      \
    \  if i == j {\n            break\n        }\n    }\n    return false\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpts1gu5uq_test.go:34\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpts1gu5uq_test.go:58\
    \ +0x532\ntesting.tRunner(0xc0001a0340, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074474
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  arr := append(arr, 0)\n    \n    for i := len(arr) - 1; i > 0; i-- {\n    \
    \    arr[i] = arr[i-1]\n    }\n    \n    return arr[0] == 0\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwe7xp69i_test.go:30:9: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074474
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // We have already sorted the array so no need to do any more checks\n    if\
    \ len(arr) == 1 {\n        return true\n    }\n    \n    // We have already sorted\
    \ the array so no need to do any more checks\n    if len(arr) == 2 {\n       \
    \ return true\n    }\n    \n    // We have already sorted the array so no need\
    \ to do any more checks\n    if len(arr) == 3 {\n        return true\n    }\n\
    \    \n    // We have already sorted the array so no need to do any more checks\n\
    \    if len(arr) == 4 {\n        return true\n    }\n    \n    // We have already\
    \ sorted the array so no need to do any more checks\n    if len(arr) == 5 {\n\
    \        return true\n    }\n    \n    // We have already sorted the array so\
    \ no need to do any more checks\n    if len(arr) == 6 {\n        return true\n\
    \    }\n    \n    // We have already sorted the array so no need to do any more\
    \ checks\n    if len(arr) == 7 {\n        return true\n    }\n    \n    // We\
    \ have already sorted the array so no need to do any more checks\n    if len(arr)\
    \ == 8 {\n        return true\n    }\n    \n    // We have already sorted the\
    \ array so no need to do any more checks\n    if len(arr) == 9 {\n        return\
    \ true\n    }\n    \n    // We have already sorted the array so no need to do\
    \ any more checks\n    if len(arr) == 10 {\n        return true\n    }\n    \n\
    \    // We have already sorted the array so no need to do any more checks\n  \
    \  if len(arr) == 11 {\n        return true\n    }\n    \n    // We have already\
    \ sorted the array so no need to do any more checks\n    if len(arr) == 12 {\n\
    \        return true\n    }\n    \n    // We have already sorted the array so\
    \ no need to do any more checks\n    if len(arr) == 13 {\n        return true\n\
    \    }\n    \n    // We have already sorted the array so no need to do any more\
    \ checks\n    if len(arr) == 14 {\n        return true\n    }\n    \n    // We\
    \ have already sorted the array so no need to do any more checks\n    if len(arr)\
    \ == 15 {\n        return true\n    }\n    \n    // We have already sorted the\
    \ array so no need to do any more checks\n    if len(arr) == 16 {\n        return\
    \ true\n    }\n    \n    // We have already sorted the array so no need to do\
    \ any more checks\n    if len(arr) == 17 {\n        return true\n    }\n    \n\
    \    // We have already sorted the array so no need to do any more checks\n  \
    \  if len(arr) == 18 {\n        return true\n    }\n    \n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphfagjax__test.go:121:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074473
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    return\
    \ arr[0] == arr[shift]\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp3hmzlqtq_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp3hmzlqtq_test.go:58:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074475
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[i+1] {\n            arr[i], arr[i+1] = arr[i+1], arr[i]\n     \
    \   }\n    }\n    \n    return move_one_ball(arr)\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpt3sixmjb_test.go:30:5: shift declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074474
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    arr[0]\
    \ = arr[shift]\n    arr[shift] = 0\n    \n    return move_one_ball(arr)\n}\n\n\
    func TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpjhxyr4em_test.go:25 +0xae fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef70e\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpjhxyr4em_test.go:41 +0x79 fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6d9\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpjhxyr4em_test.go:41 +0x79 fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6d9\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpjhxyr4em_test.go:41 +0x79 fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6d9\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpjhxyr4em_test.go:41 +0x79 fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6d9\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpjhxyr4em_test.go:41 +0x79 fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6d9\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpjhxyr4em_test.go:41 +0x79 fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6d9\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpjhxyr4em_test.go:41 +0x79 fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6d9\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpjhxyr4em_test.go:41 +0x79 fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6d9\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpjhxyr4em_test.go:41 +0x79 fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6d9\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074472
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // We will keep track of the number of right shift operations performed\n \
    \   // and will keep track of the last element of the array i.e. arr[N-1]\n  \
    \  // and will keep track of the number of right shift operations performed \n\
    \    // for the last element of the array i.e. arr[0]\n    rightShiftCount :=\
    \ 0\n    lastElement := arr[len(arr)-1]\n    firstElement := arr[0]\n    \n  \
    \  // We will keep track of the number of right shift operations performed \n\
    \    // for the first element of the array i.e. arr[1]\n    rightShiftCountForFirstElement\
    \ := 0\n    \n    // We will keep track of the number of right shift operations\
    \ performed \n    // for the last element of the array i.e. arr[0]\n    rightShiftCountForLastElement\
    \ := 0\n    \n    // We will keep track of the number of right shift operations\
    \ performed \n    // for the first element of the array i.e. arr[1]\n    rightShiftCountForFirstElementForLastElement\
    \ := 0\n    \n    // We will keep track of the number of right shift operations\
    \ performed \n    // for the last element of the array i.e. arr[0]\n    rightShiftCountForLastElementForFirstElement\
    \ := 0\n    \n    // We will keep track of the number of right shift operations\
    \ performed \n    // for the first element of the array i.e. arr[1]\n    rightShiftCountForFirstElementForLastElementForLastElement\
    \ := 0\n    \n    // We will keep track of the number of right shift operations\
    \ performed \n    // for the last element of the array i.e. arr[0]\n    rightShiftCountForLastElementForFirstElementForLastElement\
    \ := 0\n    \n    // We will keep track of the number of right shift operations\
    \ performed \n    // for the first element of the array i.e. arr[1]\n    rightShiftCountForFirstElementForLastElementForLastElementForFirstElement\
    \ := 0\n    \n    // We will keep track of the number of right shift operations\
    \ performed \n    // for the last element of the array i.e. arr[0]\n    rightShiftCountForLastElementForFirstElementForLastElementForFirstElementForLastElement\
    \ := 0\n    \n    // We will keep track of the number of right shift operations\
    \ performed \n    // for the first element of the array i.e. arr[1]\n    rightShiftCountForFirstElementForLastElementForLastElementForFirstElementForLastElementForFirstElement\
    \ := 0\n    \n    // We will keep track of the number of right shift operations\
    \ performed \n    // for the last element of the array i.e. arr[0]\n    rightShiftCountForLastElementForFirstElementForLastElementForFirstElementForLastElementForFirstElementForLastElement\
    \ := 0\n    \n    // We will keep track of the number of right shift operations\
    \ performed \n    // \nfunc TestMove_One_Ball(t *testing.T) {\n  candidate :=\
    \ move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp2bv3hv8f_test.go:80:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074474
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for i < j {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        }\n    }\n    \n    return arr[0] == arr[len(arr)-1]\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmppibeqx10_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmppibeqx10_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074469
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for i < j {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        }\n    }\n    \n    return arr[0] == arr[len(arr)-1]\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmppibeqx10_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmppibeqx10_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074469
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // We have two pointers left and right which point to different positions in\n\
    \    // the given array.\n    left := 0\n    right := len(arr) - 1\n    \n   \
    \ // We will keep track of the number of right shift operations performed on\n\
    \    // the given array till now.\n    shift := 0\n    \n    // We will keep track\
    \ of the number of right shift operations performed on\n    // the given array\
    \ till now.\n    shift := 0\n    \n    // We will keep track of the number of\
    \ right shift operations performed on\n    // the given array till now.\n    shift\
    \ := 0\n    \n    // We will keep track of the number of right shift operations\
    \ performed on\n    // the given array till now.\n    shift := 0\n    \n    //\
    \ We will keep track of the number of right shift operations performed on\n  \
    \  // the given array till now.\n    shift := 0\n    \n    // We will keep track\
    \ of the number of right shift operations performed on\n    // the given array\
    \ till now.\n    shift := 0\n    \n    // We will keep track of the number of\
    \ right shift operations performed on\n    // the given array till now.\n    shift\
    \ := 0\n    \n    // We will keep track of the number of right shift operations\
    \ performed on\n    // the given array till now.\n    shift := 0\n    \n    //\
    \ We will keep track of the number of right shift operations performed on\n  \
    \  // the given array till now.\n    shift := 0\n    \n    // We will keep track\
    \ of the number of right shift operations performed on\n    // the given array\
    \ till now.\n    shift := 0\n    \n    // We will keep track of the number of\
    \ right shift operations performed on\n    // the given array till now.\n    shift\
    \ := 0\n    \n    // We will keep track of the number of right shift operations\
    \ performed on\n    // the given array till now.\n    shift := 0\n    \n    //\
    \ We will keep track of the number of right shift operations performed on\n  \
    \  // the given array till now.\n    shift := 0\n    \n    // We will keep track\
    \ of the number of right shift operations performed on\n    // the given array\
    \ till now.\n    shift := 0\n    \n    // We will keep track of the number of\
    \ right shift operations performed on\n    // the given array till now.\n    shift\
    \ := 0\n    \n    // We will keep track of the number of right shift operations\
    \ performed on\n    // the given array till now.\n    shift := 0\n    \n    //\
    \ We will keep track of the number of right shift operations performed on\n  \
    \  // the given array till now.\n    shift := 0\n    \n    // We will keep track\
    \ of the \nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7_ft4whx_test.go:104:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074474
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            i++\n            j--\n        }\n      \
    \  if i == j {\n            break\n        }\n    }\n    \n    return true\n}\n\
    \nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpxz663act_test.go:34\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpxz663act_test.go:59\
    \ +0x525\ntesting.tRunner(0xc0001964e0, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074468
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    shift\
    \ += 1\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[shift]\
    \ {\n            shift -= 1\n        }\n    }\n    \n    return arr[0] == arr[shift]\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpnj46ro94_test.go:66: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpnj46ro94_test.go:66:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074475
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    shift\
    \ += 1\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[shift]\
    \ {\n            shift -= 1\n        }\n    }\n    \n    shift += 1\n    \n  \
    \  for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[shift] {\n       \
    \     shift -= 1\n        }\n    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp8l_f51vo_test.go:74: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp8l_f51vo_test.go:74:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074475
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        arr[i]\
    \ = arr[i]>>1\n        arr[i] = arr[i]<<1\n    }\n    \n    arr[0] = arr[0]<<1\n\
    \    \n    for i := 0; i < shift; i++ {\n        arr[i] = arr[i]>>1\n    }\n \
    \   \n    return arr[0] == 0\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpcqlud5ti_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpcqlud5ti_test.go:63:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074475
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  sorted, _ := sort(arr)\n    \n    return sorted == arr\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkhhrvflb_test.go:30:18: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074475
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  arr := arr[:len(arr)]\n    \n    i := len(arr) - 1\n    \n    for i >= 0 {\n\
    \        arr[i] = arr[i] + 1\n        \n        if arr[i] > 1 {\n            arr[i]\
    \ = arr[i] - 1\n            \n            if arr[i] > 1 {\n                arr[i]\
    \ = arr[i] - 1\n                \n                if arr[i] > 1 {\n          \
    \          arr[i] = arr[i] - 1\n                    \n                    if arr[i]\
    \ > 1 {\n                        arr[i] = arr[i] - 1\n                       \
    \ \n                        if arr[i] > 1 {\n                            arr[i]\
    \ = arr[i] - 1\n                            \n                            if arr[i]\
    \ > 1 {\n                                arr[i] = arr[i] - 1\n               \
    \                 \n                                if arr[i] > 1 {\n        \
    \                            arr[i] = arr[i] - 1\n                           \
    \         \n                                    if arr[i] > 1 {\n            \
    \                            arr[i] = arr[i] - 1\n                           \
    \             \n                                        if arr[i] > 1 {\n    \
    \                                        arr[i] = arr[i] - 1\n               \
    \                             \n                                            if\
    \ arr[i] > 1 {\n                                                arr[i] = arr[i]\
    \ - 1\n                                                \n                    \
    \                            if arr[i] > 1 {\n                               \
    \                     arr[i] = arr[i] - 1\n                                  \
    \                  \n                                                    if arr[i]\
    \ > 1 {\n                                                        arr[i] = arr[i]\
    \ - 1\n                                                        \n            \
    \                                            if arr[i] > 1 {\n               \
    \                                             arr[i] = arr[i] - 1\n          \
    \                                                  \n                        \
    \                                    if arr[i] > 1 {\n                       \
    \                                         arr[i] = arr[i] - 1\n              \
    \                                                  \n                        \
    \                                        if arr[i] > 1 {\n                   \
    \                                                 arr[i] = arr[i] - 1\n      \
    \                                                              \n            \
    \                                                        if arr[i] > 1 {\n   \
    \                                                                     arr[i] =\
    \ arr[i] - 1\n                                                               \
    \         \n                                                                 \
    \       if arr[i] > 1 {\n                                                    \
    \                        arr[i] = arr[i] - 1\n                               \
    \                                             \n                             \
    \                                               if arr[i] > 1 {\n            \
    \                                                                    arr[i] =\
    \ arr[i] - 1\n                                                               \
    \                 \n                                                         \
    \                       if arr[i] > 1 {\n                                    \
    \                                                arr[i] = arr[i] - 1\n       \
    \                                                                            \
    \ \n                                                                         \
    \           if arr[i] > 1 {\n                                                \
    \                                        arr[i] = arr[i] - 1\n               \
    \                                                                         \n \
    \                                                                            \
    \           if arr[i] > 1 {\n                                                \
    \                                            arr[i] = arr[i] - 1\n           \
    \                                                                            \
    \     \n                                                                     \
    \                       if arr[i] > 1 {\n                                    \
    \                                                            arr[i] = arr[i] -\
    \ 1\n                                                                        \
    \                        \n                                                  \
    \                                              if arr[i] > 1 {\n             \
    \                                                                            \
    \           arr[i] = arr[i] - 1\n                                            \
    \                                                        \n                  \
    \                                                                            \
    \      if arr[i] > 1 {\n                                                     \
    \                                                   arr[i] = arr[i] - 1\n    \
    \                                                                            \
    \                        \n                                                  \
    \                                                      if arr[i] > 1 {\n     \
    \                                                                            \
    \                           arr[i] = arr[i] - 1\n                            \
    \                                                                            \
    \    \n                                                                      \
    \                                      if arr[i] > 1 {\n                     \
    \                                                                            \
    \               arr[i] = arr[i] - 1\n                                        \
    \                                                                        \n  \
    \                                                                            \
    \                  \nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvm2idrq2_test.go:116:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074474
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            i++\n            j--\n        }\n      \
    \  if i == j {\n            break\n        }\n    }\n    return false\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpts1gu5uq_test.go:34\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpts1gu5uq_test.go:58\
    \ +0x532\ntesting.tRunner(0xc0001a0340, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074474
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            break\n        }\n    }\n    \n    return\
    \ arr[i] == 0\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmp4h7b85f3_test.go:34\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmp4h7b85f3_test.go:55\
    \ +0x505\ntesting.tRunner(0xc0001a01a0, 0x527f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074476
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        } else {\n          \
    \  arr[i], arr[shift] = arr[shift], arr[i]\n        }\n    }\n    \n    return\
    \ len(arr) == shift\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp03b0pdw3_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp03b0pdw3_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074468
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        arr[i]\
    \ = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n      \
    \  arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpkvt243rl_test.go:94:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074469
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        arr[i]\
    \ >>= 1\n        arr[i] |= (arr[i] << 1) >> 1\n        arr[i] |= (arr[i] << 1)\
    \ >> 1\n        arr[i] >>= 1\n        arr[i] |= (arr[i] << 1) >> 1\n        arr[i]\
    \ |= (arr[i] << 1) >> 1\n        arr[i] >>= 1\n        arr[i] |= (arr[i] << 1)\
    \ >> 1\n        arr[i] |= (arr[i] << 1) >> 1\n        arr[i] >>= 1\n        arr[i]\
    \ |= (arr[i] << 1) >> 1\n        arr[i] |= (arr[i] << 1) >> 1\n        arr[i]\
    \ >>= 1\n        arr[i] |= (arr[i] << 1) >> 1\n        arr[i] |= (arr[i] << 1)\
    \ >> 1\n        arr[i] >>= 1\n        arr[i] |= (arr[i] << 1) >> 1\n        arr[i]\
    \ |= (arr[i] << 1) >> 1\n        arr[i] >>= 1\n        arr[i] |= (arr[i] << 1)\
    \ >> 1\n        arr[i] |= (arr[i] << 1) >> 1\n        arr[i] >>= 1\n        arr[i]\
    \ |= (arr[i] << 1) >> 1\n        arr[i] |= (arr[i] << 1) >> 1\n        arr[i]\
    \ >>= 1\n        arr[i] |= (arr[i] << 1) >> 1\n        arr[i] |= (arr[i] << 1)\
    \ >> 1\n        arr[i] >>= 1\n        arr[i] |= (arr[i] << 1) >> 1\n        arr[i]\
    \ |= (arr[i] << 1) >> 1\n        arr[i] >>= 1\n        arr[i] |= (arr[i] << 1)\
    \ >> 1\n        arr[i] |= (arr[i] << 1) >> 1\n        arr[i] >>= 1\n        arr[i]\
    \ |= (arr[i] << 1) >> 1\n        arr[i] |= (arr[i] << 1) >> 1\n        arr[i]\
    \ >>= 1\n        arr[i] |= (arr[i] << 1) >> 1\n        arr[i] |= (arr[i] << 1)\
    \ >> 1\n        arr[i] >>= 1\n        arr[i] |= (arr[i] << 1) >> 1\n        arr[i]\
    \ |= (arr[i] << 1) >> 1\n        arr[i] >>= 1\n        arr[i] |= (arr[i] << 1)\
    \ >> 1\n        arr[i] |= (arr[i] << 1) >> 1\n        arr[i] >>= 1\n        arr[i]\
    \ |= (arr[i] << \nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfn4brera_test.go:80:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074475
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    if\
    \ shift > 0 {\n        return false\n    }\n    \n    shift -= 1\n    \n    for\
    \ i := 0; i < len(arr); i++ {\n        if arr[i] > arr[shift] {\n            shift\
    \ -= 1\n        }\n    }\n    \n    if shift > 0 {\n        return false\n   \
    \ }\n    \n    shift -= 1\n    \n    for i := 0; i < len(arr); i++ {\n       \
    \ if arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n \
    \   if shift > 0 {\n        return false\n    }\n    \n    shift -= 1\n    \n\
    \    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[shift] {\n     \
    \       shift -= 1\n        }\n    }\n    \n    if shift > 0 {\n        return\
    \ false\n    }\n    \n    shift -= 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        if arr[i] > arr[shift] {\n            shift -= 1\n        }\n   \
    \ }\n    \n    if shift > 0 {\n        return false\n    }\n    \n    shift -=\
    \ 1\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[shift]\
    \ {\n            shift -= 1\n        }\n    }\n    \n    if shift > 0 {\n    \
    \    return false\n    }\n    \n    shift -= 1\n    \n    for i := 0; i < len(arr);\
    \ i++ {\n        if arr[i] > arr[shift] {\n            shift -= 1\n        }\n\
    \    }\n    \n    if shift > 0 {\n        return false\n    }\n    \n    shift\
    \ -= 1\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[shift]\
    \ {\n            shift -= 1\n        }\n    }\n    \n    if shift > 0 {\n    \
    \    return false\n    }\n    \n    shift -= 1\n    \n    for i := 0; i < len(arr);\
    \ i++ {\n        if arr[i] > arr[shift] {\n            shift -= 1\n        }\n\
    \    }\n    \n    if shift > 0 {\n        return false\n    }\n    \n    shift\
    \ -= 1\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[shift]\
    \ {\n            shift -= 1\n        }\n    }\n    \n    if shift > 0 {\n    \
    \    return false\n    }\n    \n    shift -= 1\n    \n    for i := 0; i < len(arr);\
    \ i++ {\n        if arr[i] > arr[shift] {\n            shift \nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8zvegvs4_test.go:155:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074475
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i]\
    \ = arr[i+1]\n    }\n    \n    arr[0] = arr[len(arr)-1]\n    \n    return move_one_ball(arr)\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmp80nxse6f_test.go:25 +0x88 fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef6e8\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp80nxse6f_test.go:38 +0x5e fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp80nxse6f_test.go:38 +0x5e fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp80nxse6f_test.go:38 +0x5e fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp80nxse6f_test.go:38 +0x5e fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp80nxse6f_test.go:38 +0x5e fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp80nxse6f_test.go:38 +0x5e fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp80nxse6f_test.go:38 +0x5e fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp80nxse6f_test.go:38 +0x5e fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmp80nxse6f_test.go:38 +0x5e fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6be\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074477
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            i++\n            j--\n        }\n      \
    \  if i == j {\n            break\n        }\n    }\n    return false\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpts1gu5uq_test.go:34\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpts1gu5uq_test.go:58\
    \ +0x532\ntesting.tRunner(0xc0001a0340, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074474
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            if i == j {\n                return false\n\
    \            }\n            i++\n            j--\n        }\n    }\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmp685y4k9g_test.go:34\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmp685y4k9g_test.go:57\
    \ +0x532\ntesting.tRunner(0xc0001a01a0, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074471
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            arr[i], arr[shift] = arr[shift], arr[i]\n\
    \            shift -= 1\n        }\n    }\n    \n    return len(arr) == shift\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmptabr5pnu_test.go:59: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmptabr5pnu_test.go:59:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660074468
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  sorted, _ := sort.IntSlice(arr)\n    \n    if sorted == arr {\n        return\
    \ true\n    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i < len(arr);\
    \ i++ {\n        if arr[i] > arr[i+1] {\n            arr[i], arr[i+1] = arr[i+1],\
    \ arr[i]\n            shift -= 1\n        }\n    }\n    \n    arr[0], arr[shift]\
    \ = arr[shift], arr[0]\n    \n    return move_one_ball(arr)\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6kyczf5h_test.go:30:18: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074476
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // We will keep track of the number of right shift operations performed.\n\
    \    // We will start by performing the first right shift operation\n    // and\
    \ we will keep track of the number of right shift operations performed.\n    var\
    \ shiftCount int = 0\n    \n    // We will keep track of the number of elements\
    \ in the array that have been\n    // moved so far.\n    var movedCount int =\
    \ 0\n    \n    // We will keep track of the number of elements in the array that\
    \ have been\n    // moved so far.\n    var movedCount int = 0\n    \n    // We\
    \ will keep track of the number of elements in the array that have been\n    //\
    \ moved so far.\n    var movedCount int = 0\n    \n    // We will keep track of\
    \ the number of elements in the array that have been\n    // moved so far.\n \
    \   var movedCount int = 0\n    \n    // We will keep track of the number of elements\
    \ in the array that have been\n    // moved so far.\n    var movedCount int =\
    \ 0\n    \n    // We will keep track of the number of elements in the array that\
    \ have been\n    // moved so far.\n    var movedCount int = 0\n    \n    // We\
    \ will keep track of the number of elements in the array that have been\n    //\
    \ moved so far.\n    var movedCount int = 0\n    \n    // We will keep track of\
    \ the number of elements in the array that have been\n    // moved so far.\n \
    \   var movedCount int = 0\n    \n    // We will keep track of the number of elements\
    \ in the array that have been\n    // moved so far.\n    var movedCount int =\
    \ 0\n    \n    // We will keep track of the number of elements in the array that\
    \ have been\n    // moved so far.\n    var movedCount int = 0\n    \n    // We\
    \ will keep track of the number of elements in the array that have been\n    //\
    \ moved so far.\n    var movedCount int = 0\n    \n    // We will keep track of\
    \ the number of elements in the array that have been\n    // moved so far.\n \
    \   var movedCount int = 0\n    \n    // We will keep track of the number of elements\
    \ in the array that have been\n    // moved so far.\n    var movedCount int =\
    \ 0\n    \n    // We will keep track of the number of elements in the array that\
    \ have been\n    // moved so far.\n    var movedCount int = 0\n    \n    // We\
    \ will keep track of the number of elements in the array that have been\n    //\
    \ moved so far.\n    var movedCount int = 0\n    \n    // We will keep track of\
    \ the number of elements in the array that have been\n    // moved so far.\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmph61_t2p3_test.go:97:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074475
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    arr[0]\
    \ = arr[shift]\n    \n    return move_one_ball(arr[1:])\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmph6703f_f_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmph6703f_f_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074469
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for i < j {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        }\n    }\n    \n    return arr[0] == arr[len(arr)-1]\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmppibeqx10_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmppibeqx10_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074469
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            i++\n            j--\n        }\n      \
    \  if i == j {\n            break\n        }\n    }\n    return false\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpts1gu5uq_test.go:34\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpts1gu5uq_test.go:58\
    \ +0x532\ntesting.tRunner(0xc0001a0340, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074474
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            if i == j {\n                return true\n\
    \            }\n            i++\n            j--\n        }\n    }\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpv4jt8c16_test.go:34\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpv4jt8c16_test.go:57\
    \ +0x525\ntesting.tRunner(0xc0001924e0, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074476
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for i < j {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        }\n    }\n    \n    return arr[0] == arr[len(arr)-1]\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmppibeqx10_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmppibeqx10_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074469
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            arr[i], arr[shift] = arr[shift], arr[i]\n\
    \            shift -= 1\n        }\n    }\n    \n    return len(arr) == shift\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmptabr5pnu_test.go:59: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmptabr5pnu_test.go:59:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660074468
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    // Write your code here\n    if len(arr) == 0 {\n       \
    \ return true\n    }\n    \n    arr := append(arr, 0)\n    \n    for i := 0; i\
    \ < len(arr); i++ {\n        arr[i] = arr[i] >> 1\n    }\n    \n    return arr[0]\
    \ == 0\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpm5z5qdn0_test.go:31:9: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074476
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    // Write your code here\n    if len(arr) == 0 {\n       \
    \ return true\n    }\n    \n    arr := append(arr, 0)\n    \n    i := 0\n    for\
    \ i < len(arr) {\n        if arr[i] > arr[i+1] {\n            arr[i], arr[i+1]\
    \ = arr[i+1], arr[i]\n        }\n        i++\n    }\n    \n    return false\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3j8_adcu_test.go:31:9: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074476
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    // Write your code here\n    if len(arr) == 0 {\n       \
    \ return true\n    }\n    \n    shift := len(arr) - 1\n    \n    for i := 0; i\
    \ < len(arr); i++ {\n        arr[i] = arr[i]<<1\n        arr[i] |= arr[i]>>(shift-1)\n\
    \        arr[i] = arr[i]>>1\n        shift -= 1\n    }\n    \n    return false\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: negative shift\
    \ amount [recovered]\n\tpanic: runtime error: negative shift amount\n\ngoroutine\
    \ 6 [running]:\ntesting.tRunner.func1.2({0x5028a0, 0x5f1990})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x5028a0, 0x5f1990})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmp9hbrubqb_test.go:35\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmp9hbrubqb_test.go:50\
    \ +0x50f\ntesting.tRunner(0xc0001a0340, 0x527f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074476
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            i++\n            j--\n        }\n      \
    \  if i == j {\n            break\n        }\n    }\n    return false\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpts1gu5uq_test.go:34\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpts1gu5uq_test.go:58\
    \ +0x532\ntesting.tRunner(0xc0001a0340, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074474
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  arr := arr[:len(arr)-1]\n    arr[len(arr)-1] = arr[0]\n    arr[0] = arr[len(arr)-1]\n\
    \    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[i+1] {\n \
    \           return false\n        }\n    }\n    return true\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp30cdo1h1_test.go:30:9: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074467
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        arr[i]\
    \ = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n    }\n\
    \    \n    arr[0] = arr[0]<<1\n    arr[0] = arr[0]>>1\n    arr[0] = arr[0]<<1\n\
    \    \n    if arr[0] == 0 {\n        return true\n    }\n    \n    for i := 0;\
    \ i < shift; i++ {\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n \
    \       arr[i] = arr[i]<<1\n    }\n    \n    arr[0] = arr[0]<<1\n    arr[0] =\
    \ arr[0]>>1\n    arr[0] = arr[0]<<1\n    \n    if arr[0] == 0 {\n        return\
    \ true\n    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpzjnar01f_test.go:80: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpzjnar01f_test.go:80:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074476
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            i++\n            j--\n        }\n      \
    \  if i == j {\n            break\n        }\n    }\n    return false\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpts1gu5uq_test.go:34\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpts1gu5uq_test.go:58\
    \ +0x532\ntesting.tRunner(0xc0001a0340, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074474
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  sorted, err := sort_arr(arr)\n    if err != nil {\n        return false\n \
    \   }\n    \n    if sorted == arr {\n        return true\n    }\n    \n    arr\
    \ := arr[:len(sorted)]\n    \n    shift := len(arr) - 1\n    \n    for i := 0;\
    \ i < len(arr); i++ {\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        \nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7s0ul33p_test.go:99:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074475
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for i < j {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        }\n    }\n    \n    return arr[0] == arr[len(arr)-1]\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmppibeqx10_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmppibeqx10_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074469
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    // Write your code here\n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4zxsx5jo_test.go:281:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074469
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for i < j {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        }\n    }\n    \n    return arr[0] == arr[len(arr)-1]\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmppibeqx10_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmppibeqx10_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074469
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        arr[i]\
    \ = arr[i]<<1\n        arr[i] = arr[i]>>(shift-1)\n        shift -= 1\n    }\n\
    \    \n    return arr[0] == 0\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n \
    \ candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: negative shift\
    \ amount [recovered]\n\tpanic: runtime error: negative shift amount\n\ngoroutine\
    \ 6 [running]:\ntesting.tRunner.func1.2({0x5028a0, 0x5f1990})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x5028a0, 0x5f1990})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmp491hmoc1_test.go:34\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmp491hmoc1_test.go:48\
    \ +0x53b\ntesting.tRunner(0xc0001a0340, 0x527f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074473
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for i < j {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        }\n    }\n    \n    return arr[0] == arr[len(arr)-1]\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmppibeqx10_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmppibeqx10_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074469
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for i < j {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        }\n    }\n    \n    return arr[0] == arr[j]\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpwjnvhxw4_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpwjnvhxw4_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074470
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for i < j {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        }\n    }\n    \n    return arr[i] == arr[0]\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpk27qrxex_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpk27qrxex_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074470
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // We will keep track of the number of right shift operations performed \n\
    \    // to achieve non-decreasing order.\n    var shiftCount int = 0\n    \n \
    \   // We will keep track of the last element of the array \n    // to move it\
    \ to the starting position.\n    var lastElement int = 0\n    \n    // We will\
    \ keep track of the number of elements in the array \n    // to perform right\
    \ shift operations.\n    var elementCount int = len(arr)\n    \n    // We will\
    \ keep track of the number of elements in the array \n    // to move to the starting\
    \ position.\n    var startElementCount int = 0\n    \n    // We will keep track\
    \ of the number of elements in the array \n    // to move to the starting position.\n\
    \    var endElementCount int = 0\n    \n    // We will keep track of the number\
    \ of elements in the array \n    // to move to the starting position.\n    var\
    \ startElementCount int = 0\n    \n    // We will keep track of the number of\
    \ elements in the array \n    // to move to the starting position.\n    var endElementCount\
    \ int = 0\n    \n    // We will keep track of the number of elements in the array\
    \ \n    // to move to the starting position.\n    var startElementCount int =\
    \ 0\n    \n    // We will keep track of the number of elements in the array \n\
    \    // to move to the starting position.\n    var endElementCount int = 0\n \
    \   \n    // We will keep track of the number of elements in the array \n    //\
    \ to move to the starting position.\n    var startElementCount int = 0\n    \n\
    \    // We will keep track of the number of elements in the array \n    // to\
    \ move to the starting position.\n    var endElementCount int = 0\n    \n    //\
    \ We will keep track of the number of elements in the array \n    // to move to\
    \ the starting position.\n    var startElementCount int = 0\n    \n    // We will\
    \ keep track of the number of elements in the array \n    // to move to the starting\
    \ position.\n    var endElementCount int = 0\n    \n    // We will keep track\
    \ of the number of elements in the array \n    // to move to the starting position.\n\
    \    var startElementCount int = 0\n    \n    // We will keep track of the number\
    \ of elements in the array \n    // to move to the starting position.\n    var\
    \ endElementCount int = 0\n    \n    // We will keep track of the number of elements\
    \ in the array \n    // to move to the starting position.\n    var startElementCount\
    \ int = 0\n    \n    // We will keep track of the number of elements in the array\
    \ \n    // to move to the starting position.\n    var endElementCount int = 0\n\
    \    \n    // We will keep track of the number of elements in the array \n   \
    \ // to move to the starting position.\n    var startElementCount int = 0\n  \
    \  \n    // We will keep track of the number of elements in the array \n    //\
    \ to \nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzb8lm8y7_test.go:104:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074475
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    if\
    \ shift > 0 {\n        return false\n    }\n    \n    shift -= 1\n    \n    for\
    \ i := 0; i < len(arr); i++ {\n        if arr[i] > arr[shift] {\n            shift\
    \ -= 1\n        }\n    }\n    \n    if shift > 0 {\n        return false\n   \
    \ }\n    \n    shift -= 1\n    \n    for i := 0; i < len(arr); i++ {\n       \
    \ if arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n \
    \   if shift > 0 {\n        return false\n    }\n    \n    shift -= 1\n    \n\
    \    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[shift] {\n     \
    \       shift -= 1\n        }\n    }\n    \n    if shift > 0 {\n        return\
    \ false\n    }\n    \n    shift -= 1\n    \n    for i := 0; i < len(arr); i++\
    \ {\n        if arr[i] > arr[shift] {\n            shift -= 1\n        }\n   \
    \ }\n    \n    if shift > 0 {\n        return false\n    }\n    \n    shift -=\
    \ 1\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[shift]\
    \ {\n            shift -= 1\n        }\n    }\n    \n    if shift > 0 {\n    \
    \    return false\n    }\n    \n    shift -= 1\n    \n    for i := 0; i < len(arr);\
    \ i++ {\n        if arr[i] > arr[shift] {\n            shift -= 1\n        }\n\
    \    }\n    \n    if shift > 0 {\n        return false\n    }\n    \n    shift\
    \ -= 1\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[shift]\
    \ {\n            shift -= 1\n        }\n    }\n    \n    if shift > 0 {\n    \
    \    return false\n    }\n    \n    shift -= 1\n    \n    for i := 0; i < len(arr);\
    \ i++ {\n        if arr[i] > arr[shift] {\n            shift -= 1\n        }\n\
    \    }\n    \n    if shift > 0 {\n        return false\n    }\n    \n    shift\
    \ -= 1\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[shift]\
    \ {\n            shift -= 1\n        }\n    }\n    \n    if shift > 0 {\n    \
    \    return false\n    }\n    \n    shift -= 1\n    \n    for i := 0; i < len(arr);\
    \ i++ {\n        if arr[i] > arr[shift] {\n            shift \nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8zvegvs4_test.go:155:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074475
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[i+1] {\n            arr[i], arr[i+1] = arr[i+1], arr[i]\n     \
    \   }\n    }\n    \n    for i := 0; i < shift; i++ {\n        arr[i], arr[0] =\
    \ arr[0], arr[i]\n    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [5] with length 5 [recovered]\n\tpanic: runtime error: index out of range\
    \ [5] with length 5\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball({0xc0000c4640?, 0xc0000f8d18?,\
    \ 0x4b3193?})\n\t/tmp/tmpbpzj60ig_test.go:33 +0x8f\ncommand-line-arguments_test.TestMove_One_Ball(0x0?)\n\
    \t/tmp/tmpbpzj60ig_test.go:52 +0xa8\ntesting.tRunner(0xc0001924e0, 0x527f40)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074476
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            arr[i], arr[shift] = arr[shift], arr[i]\n\
    \            shift -= 1\n        }\n    }\n    \n    return len(arr) == shift\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmptabr5pnu_test.go:59: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmptabr5pnu_test.go:59:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660074468
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    arr[0]\
    \ = arr[shift]\n    \n    return move_one_ball(arr[1:])\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmph6703f_f_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmph6703f_f_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074469
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  sorted, _ := sort_arr(arr)\n    return !is_sorted(sorted)\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8rdnsxj9_test.go:30:18: undefined: sort_arr

    /tmp/tmp8rdnsxj9_test.go:31:13: undefined: is_sorted

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074476
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        arr[i]\
    \ = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n      \
    \  arr[i] = arr[i]>>1\n    }\n    \n    if arr[0] != 0 {\n        return false\n\
    \    }\n    \n    arr[0] = arr[0]<<1\n    arr[0] = arr[0]>>1\n    arr[0] = arr[0]<<1\n\
    \    arr[0] = arr[0]>>1\n    \n    for i := 0; i < shift; i++ {\n        arr[i]\
    \ = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n      \
    \  arr[i] = arr[i]>>1\n    }\n    \n    if arr[len(arr)-1] != 0 {\n        return\
    \ false\n    }\n    \n    arr[len(arr)-1] = arr[len(arr)-1]<<1\n    arr[len(arr)-1]\
    \ = arr[len(arr)-1]>>1\n    arr[len(arr)-1] = arr[len(arr)-1]<<1\n    arr[len(arr)-1]\
    \ = arr[len(arr)-1]>>1\n    \n    return true\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpvwue25z8_test.go:84: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpvwue25z8_test.go:84:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074476
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  arr := arr[:len(arr)-1]\n    \n    for i := 0; i < len(arr); i++ {\n      \
    \  arr[i] = arr[i] + 1\n    }\n    \n    return move_one_ball(arr)\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp48frg3h9_test.go:30:9: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074471
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for i < j {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        }\n    }\n    \n    return arr[0] == arr[j]\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpwjnvhxw4_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpwjnvhxw4_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074470
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    arr[0],\
    \ arr[shift] = arr[shift], arr[0]\n    \n    return move_one_ball(arr[1:])\n}\n\
    \nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmpl9s1edvb_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmpl9s1edvb_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074476
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        arr[i]\
    \ = arr[i] >> 1\n    }\n    \n    for i := 0; i < shift; i++ {\n        arr[0]\
    \ = arr[0] >> 1\n    }\n    \n    return arr[0] == 0\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmpja1qe4j1_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmpja1qe4j1_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074476
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  arr := arr[:len(arr)-1]\n    arr[len(arr)-1] = 0\n    \n    i := 0\n    for\
    \ i < len(arr) {\n        arr[i] = arr[i] + 1\n        i++\n    }\n    \n    i\
    \ := 0\n    for i < len(arr) {\n        arr[i] = arr[i] - 1\n        i++\n   \
    \ }\n    \n    i := 0\n    for i < len(arr) {\n        arr[i] = arr[i] + 1\n \
    \       i++\n    }\n    \n    i := 0\n    for i < len(arr) {\n        arr[i] =\
    \ arr[i] - 1\n        i++\n    }\n    \n    i := 0\n    for i < len(arr) {\n \
    \       arr[i] = arr[i] + 1\n        i++\n    }\n    \n    i := 0\n    for i <\
    \ len(arr) {\n        arr[i] = arr[i] - 1\n        i++\n    }\n    \n    i :=\
    \ 0\n    for i < len(arr) {\n        arr[i] = arr[i] + 1\n        i++\n    }\n\
    \    \n    i := 0\n    for i < len(arr) {\n        arr[i] = arr[i] - 1\n     \
    \   i++\n    }\n    \n    i := 0\n    for i < len(arr) {\n        arr[i] = arr[i]\
    \ + 1\n        i++\n    }\n    \n    i := 0\n    for i < len(arr) {\n        arr[i]\
    \ = arr[i] - 1\n        i++\n    }\n    \n    i := 0\n    for i < len(arr) {\n\
    \        arr[i] = arr[i] + 1\n        i++\n    }\n    \n    i := 0\n    for i\
    \ < len(arr) {\n        arr[i] = arr[i] - 1\n        i++\n    }\n    \n    i :=\
    \ 0\n    for i < len(arr) {\n        arr[i] = arr[i] + 1\n        i++\n    }\n\
    \    \n    i := 0\n    for i < len(arr) {\n        arr[i] = arr[i] - 1\n     \
    \   i++\n    }\n    \n    i := 0\n    for i < len(arr) {\n        arr[i] = arr[i]\
    \ + 1\n        i++\n    }\n    \n    i := 0\n    for i < len(arr) {\n        arr[i]\
    \ = arr[i] - 1\n        i++\n    }\n    \n    i := 0\n    for i < len(arr) {\n\
    \        arr[i] = arr[i] + 1\n        i++\n    }\n    \n    i := 0\n    for i\
    \ < len(arr) {\n        arr[i] = arr[i] - 1\n        i++\n    }\n    \n    i :=\
    \ 0\n    for i < len(arr) {\n        arr[i] = arr[i] + 1\n        i++\n    }\n\
    func TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpq_cseiz6_test.go:146:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074476
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := len(arr) - 1\n    j := len(arr) - 1\n    \n    for {\n        if arr[i]\
    \ > arr[j] {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n \
    \           j--\n        } else {\n            arr[i], arr[j] = arr[j], arr[i]\n\
    \            j--\n        }\n        if i == 0 && j == 0 {\n            return\
    \ true\n        }\n    }\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [5] with length 5 [recovered]\n\tpanic: runtime error: index out of range\
    \ [5] with length 5\n\ngoroutine 34 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpg5q2ztr1_test.go:34\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpg5q2ztr1_test.go:55\
    \ +0x579\ntesting.tRunner(0xc000198ea0, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660074476
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        arr[i]\
    \ = arr[i]<<1\n        arr[i] |= arr[i]>>(shift-1)\n        arr[i] = arr[i]>>1\n\
    \        shift -= 1\n    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: negative shift\
    \ amount [recovered]\n\tpanic: runtime error: negative shift amount\n\ngoroutine\
    \ 34 [running]:\ntesting.tRunner.func1.2({0x5028a0, 0x5f1990})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x5028a0, 0x5f1990})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmp98chd5t2_test.go:34\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmp98chd5t2_test.go:49\
    \ +0x50f\ntesting.tRunner(0xc000198ea0, 0x527f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n"
  timestamp: 1660074476
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > arr[shift] {\n            shift -= 1\n        }\n    }\n    \n    arr[0],\
    \ arr[shift] = arr[shift], arr[0]\n    \n    return move_one_ball(arr)\n}\n\n\
    func TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0390\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?,\
    \ 0x5?, 0x5?})\n\t/tmp/tmpnkx_39bj_test.go:25 +0xaa fp=0xc0201e03a0 sp=0xc0201e0398\
    \ pc=0x4ef70a\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e03c8 sp=0xc0201e03a0\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e03f0 sp=0xc0201e03c8\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e0418 sp=0xc0201e03f0\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e0440 sp=0xc0201e0418\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e0468 sp=0xc0201e0440\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e0490 sp=0xc0201e0468\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e04b8 sp=0xc0201e0490\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e04e0 sp=0xc0201e04b8\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmpnkx_39bj_test.go:40 +0x75 fp=0xc0201e0508 sp=0xc0201e04e0\
    \ pc=0x4ef6d5\ncommand-line-arguments_test.move_one_ball({0xc0401dfe40?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074469
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        arr[i]\
    \ = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n      \
    \  arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n\
    \        arr[i] = arr[i]<<1\n        arr[i] = arr[i]>>1\n        arr[i] = arr[i]<<1\n\
    \nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8ztob929_test.go:94:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074469
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < len(arr); i++ {\n        arr[i]\
    \ = arr[i]<<1\n        arr[i] = arr[i]>>(shift-1)\n        shift -= 1\n    }\n\
    \    \n    return false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: negative shift\
    \ amount [recovered]\n\tpanic: runtime error: negative shift amount\n\ngoroutine\
    \ 6 [running]:\ntesting.tRunner.func1.2({0x5028a0, 0x5f1990})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x5028a0, 0x5f1990})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmp4u3jbo1u_test.go:34\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmp4u3jbo1u_test.go:48\
    \ +0x4db\ntesting.tRunner(0xc0001a01a0, 0x527f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074476
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  shift := len(arr) - 1\n    \n    for i := 0; i < shift; i++ {\n        arr[i],\
    \ arr[shift] = arr[shift], arr[i]\n    }\n    \n    shift -= 1\n    \n    for\
    \ i := 0; i < shift; i++ {\n        arr[i], arr[shift] = arr[shift], arr[i]\n\
    \    }\n    \n    return false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpcm23u2a2_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpcm23u2a2_test.go:62:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074476
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // We need to perform right shift operation N times to get non-decreasing order.\n\
    \    // We need to perform N right shift operations to get non-decreasing order.\n\
    \    // We need to perform N right shift operations to get non-decreasing order.\n\
    \    // We need to perform N right shift operations to get non-decreasing order.\n\
    \    // We need to perform N right shift operations to get non-decreasing order.\n\
    \    // We need to perform N right shift operations to get non-decreasing order.\n\
    \    // We need to perform N right shift operations to get non-decreasing order.\n\
    \    // We need to perform N right shift operations to get non-decreasing order.\n\
    \    // We need to perform N right shift operations to get non-decreasing order.\n\
    \    // We need to perform N right shift operations to get non-decreasing order.\n\
    \    // We need to perform N right shift operations to get non-decreasing order.\n\
    \    // We need to perform N right shift operations to get non-decreasing order.\n\
    \    // We need to perform N right shift operations to get non-decreasing order.\n\
    \    // We need to perform N right shift operations to get non-decreasing order.\n\
    \    // We need to perform N right shift operations to get non-decreasing order.\n\
    \    // We need to perform N right shift operations to get non-decreasing order.\n\
    \    // We need to perform N right shift operations to get non-decreasing order.\n\
    \    // We need to perform N right shift operations to get non-decreasing order.\n\
    \    // We need to perform N right shift operations to get non-decreasing order.\n\
    \    // We need to perform N right shift operations to get non-decreasing order.\n\
    \    // We need to perform N right shift operations to get non-decreasing order.\n\
    \    // We need to perform N right shift operations to get non-decreasing order.\n\
    \    // We need to perform N right shift operations to get non-decreasing order.\n\
    \    // We need to perform N right shift operations to get non-decreasing order.\n\
    \    // We need to perform N right shift operations to get non-decreasing order.\n\
    \    // We need to perform N right shift operations to get non-decreasing order.\n\
    \    // We need to perform N right shift operations to get non-decreasing order.\n\
    \    // We need to perform N right shift operations to get non-decreasing order.\n\
    \    // We need to perform N right shift operations to get non-decreasing order.\n\
    \    // We need to perform N right shift operations to get non-decreasing order.\n\
    \    // We need to perform N right shift operations to get non-decreasing order.\n\
    \    // We need to perform N right shift operations to get non-decreasing order.\n\
    \    // We need to perform N right shift operations to get non-decreasing order.\n\
    \    // We need to perform \nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpabe0dw8h_test.go:64:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074476
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := 0\n    j := len(arr) - 1\n    \n    for {\n        if arr[i] > arr[j]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            i++\n          \
    \  j--\n        } else {\n            if i == j {\n                return true\n\
    \            }\n            i++\n            j--\n        }\n    }\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range\
    \ [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpv4jt8c16_test.go:34\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpv4jt8c16_test.go:57\
    \ +0x525\ntesting.tRunner(0xc0001924e0, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074476
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  i := len(arr) - 1\n    j := len(arr) - 1\n    k := len(arr) - 1\n    \n   \
    \ for {\n        if arr[i] > arr[j] {\n            arr[i], arr[j] = arr[j], arr[i]\n\
    \            i, j = j, i\n            k, i = i, k\n        }\n        \n     \
    \   if i == k {\n            break\n        }\n    }\n    \n    return arr ==\
    \ arr[:len(arr)-1]\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate :=\
    \ move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpopry0az4_test.go:46:12: invalid operation: arr == arr[:len(arr) - 1] (slice
    can only be compared to nil)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074476
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  // We are going to perform right shift operation on the given array \n    //\
    \ arr[1], arr[2], ..., arr[N]\n    // We will keep track of how many times we\
    \ perform right shift operation\n    // and we will keep track of how many elements\
    \ are shifted so far.\n    // We will keep track of how many elements are shifted\
    \ so far.\n    // We will keep track of how many elements are shifted so far.\n\
    \    // We will keep track of how many elements are shifted so far.\n    // We\
    \ will keep track of how many elements are shifted so far.\n    // We will keep\
    \ track of how many elements are shifted so far.\n    // We will keep track of\
    \ how many elements are shifted so far.\n    // We will keep track of how many\
    \ elements are shifted so far.\n    // We will keep track of how many elements\
    \ are shifted so far.\n    // We will keep track of how many elements are shifted\
    \ so far.\n    // We will keep track of how many elements are shifted so far.\n\
    \    // We will keep track of how many elements are shifted so far.\n    // We\
    \ will keep track of how many elements are shifted so far.\n    // We will keep\
    \ track of how many elements are shifted so far.\n    // We will keep track of\
    \ how many elements are shifted so far.\n    // We will keep track of how many\
    \ elements are shifted so far.\n    // We will keep track of how many elements\
    \ are shifted so far.\n    // We will keep track of how many elements are shifted\
    \ so far.\n    // We will keep track of how many elements are shifted so far.\n\
    \    // We will keep track of how many elements are shifted so far.\n    // We\
    \ will keep track of how many elements are shifted so far.\n    // We will keep\
    \ track of how many elements are shifted so far.\n    // We will keep track of\
    \ how many elements are shifted so far.\n    // We will keep track of how many\
    \ elements are shifted so far.\n    // We will keep track of how many elements\
    \ are shifted so far.\n    // We will keep track of how many elements are shifted\
    \ so far.\n    // We will keep track of how many elements are shifted so far.\n\
    \    // We will keep track of how many elements are shifted so far.\n    // We\
    \ will keep track of how many elements are shifted so far.\n    // We will keep\
    \ track of how many elements are shifted so far.\n    // We will keep track of\
    \ how many elements are shifted so far.\n    // We will keep track of how many\
    \ elements are shifted so far.\n    // We will keep track of how many elements\
    \ are shifted so far.\n    // We will keep track of how many elements are shifted\
    \ so far.\n    // We will keep track of how many elements are shifted so far.\n\
    \    // We will keep track of how many elements are shifted \nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7_sp4hze_test.go:69:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074476
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    // numbers in the array will be randomly ordered. Your task is to determine if\n\
    // it is possible to get an array sorted in non-decreasing order by performing\
    \ \n// the following operation on the given array:\n// You are allowed to perform\
    \ right shift operation any number of times.\n// One right shift operation means\
    \ shifting all elements of the array by one\n// position in the right direction.\
    \ The last element of the array will be moved to\n// the starting position in\
    \ the array i.e. 0th index. \n// If it is possible to obtain the sorted array\
    \ by performing the above operation\n// then return True else return False.\n\
    // If the given array is empty then return True.\n// Note: The given list is guaranteed\
    \ to have unique elements.\n// For Example:\n// Explanation: By performin 2 right\
    \ shift operations, non-decreasing order can\n// be achieved for the given array.\n\
    // Explanation:It is not possible to get non-decreasing order for the given\n\
    // array by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    \n  \
    \  sorted, _ := is_sorted(arr)\n    if sorted {\n        return true\n    }\n\
    \    \n    i := len(arr) - 1\n    j := 0\n    \n    for {\n        if arr[i] >\
    \ arr[j] {\n            arr[i], arr[j] = arr[j], arr[i]\n            i, j = i+1,\
    \ j-1\n        } else {\n            break\n        }\n    }\n    \n    return\
    \ is_sorted(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate :=\
    \ move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdjnbtzdy_test.go:30:18: undefined: is_sorted

    /tmp/tmpdjnbtzdy_test.go:47:12: undefined: is_sorted

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074476
