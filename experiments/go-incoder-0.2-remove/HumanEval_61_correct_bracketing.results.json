{
  "language": "go_test.go",
  "name": "HumanEval_61_correct_bracketing",
  "results": [
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"{\", -1)\n    brackets = strings.Replace(brackets, \">\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"<\", -1)\n    brackets = strings.Replace(brackets, \"}\", \">\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"<\", -1)\n    brackets = strings.Replace(brackets, \"]\", \">\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"[\", -1)\n    brackets = strings.Replace(brackets, \">\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"{\", -1)\n    brackets = strings.Replace(brackets, \">\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"<\", -1)\n    brackets = strings.Replace(brackets, \"}\", \">\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"<\", -1)\n    brackets = strings.Replace(brackets, \"]\", \">\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"[\", -1)\n    brackets = strings.Replace(brackets, \">\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"{\", -1)\n    brackets = strings.Replace(brackets, \">\", \"\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpqonlm7f1_test.go:45:47: string literal not terminated\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074165
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = strings.TrimSpace(brackets)\n    brackets = strings.Replace(brackets, \"(\", \"((\", -1)\n    brackets = strings.Replace(brackets, \")\", \")(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"](\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}(\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"<(\", -1)\n    brackets = strings.Replace(brackets, \">\", \">(\", -1)\n    brackets = strings.Replace(brackets, \"|\", \"|(\", -1)\n    brackets = strings.Replace(brackets, \"~\", \"~(\", -1)\n    brackets = strings.Replace(brackets, \"!\", \"!(\", -1)\n    brackets = strings.Replace(brackets, \"$\", \"$(\", -1)\n    brackets = strings.Replace(brackets, \"%\", \"%(\", -1)\n    brackets = strings.Replace(brackets, \"^\", \"^(\", -1)\n    brackets = strings.Replace(brackets, \"&\", \"&(\", -1)\n    brackets = strings.Replace(brackets, \"*\", \"*(\", -1)\n    brackets = strings.Replace(brackets, \"+\", \"+(\", -1)\n    brackets = strings.Replace(brackets, \",\", \",(\", -1)\n    brackets = strings.Replace(brackets, \"-\", \"-(\", -1)\n    brackets = strings.Replace(brackets, \"=\", \"=(\", -1)\n    brackets = strings.Replace(brackets, \"?\", \"?(\", -1)\n    brackets = strings.Replace(brackets, \"/\", \"/(\", -1)\n    brackets = strings.Replace(brackets, \"\\\\\", \"\\\\(\", -1)\n    brackets = strings.Replace(brackets, \"|\", \"|(\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"(\", -1)\n    brackets = strings.Replace(brackets, \")\", \")(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"](\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}(\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"<(\", -1)\n    brackets = strings.Replace(bracket\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpz2fya6ud_test.go:43:39: missing ',' before newline in argument list\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074165
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"{\", -1)\n    brackets = strings.Replace(brackets, \")\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", \nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpqhlj7vky_test.go:46:6: expected '(', found TestCorrect_Bracketing\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074165
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    for _, c := range brackets {\n        if c != \")\" && c != \"(\" {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpu_ny8211_test.go:13:17: invalid operation: c != \")\" (mismatched types rune and untyped string)\n/tmp/tmpu_ny8211_test.go:13:29: invalid operation: c != \"(\" (mismatched types rune and untyped string)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074166
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    for _, char := range brackets {\n        if char != \")\" && char != \"(\" {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphp1j9pa4_test.go:13:20: invalid operation: char != \")\" (mismatched types rune and untyped string)\n/tmp/tmphp1j9pa4_test.go:13:35: invalid operation: char != \"(\" (mismatched types rune and untyped string)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074166
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    openingBrackets := 0\n    closingBrackets := 0\n    for _, c := range brackets {\n        if c == '(' {\n            openingBrackets++\n        } else if c == ')' {\n            closingBrackets++\n        }\n    }\n    return openingBrackets == closingBrackets\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__5 (0.00s)\n        tmpbs47m96x_test.go:47: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__10 (0.00s)\n        tmpbs47m96x_test.go:47: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "timestamp": 1660074166
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    openingBrackets := make([]string, 0)\n    closingBrackets := make([]string, 0)\n    for _, c := range brackets {\n        if c == '(' {\n            openingBrackets = append(openingBrackets, c)\n        } else {\n            closingBrackets = append(closingBrackets, c)\n        }\n    }\n    if len(openingBrackets) != len(closingBrackets) {\n        return false\n    }\n    for i := 0; i < len(openingBrackets); i++ {\n        if openingBrackets[i] != closingBrackets[i] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5r4jiuvy_test.go:16:55: cannot use c (variable of type rune) as type string in argument to append\n/tmp/tmp5r4jiuvy_test.go:18:55: cannot use c (variable of type rune) as type string in argument to append\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074166
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    for _, opening := range brackets {\n        if opening != \")\" {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2y0yyutv_test.go:13:23: invalid operation: opening != \")\" (mismatched types rune and untyped string)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074166
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    for _, char := range brackets {\n        if char != \")\" && char != \"(\" {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphp1j9pa4_test.go:13:20: invalid operation: char != \")\" (mismatched types rune and untyped string)\n/tmp/tmphp1j9pa4_test.go:13:35: invalid operation: char != \"(\" (mismatched types rune and untyped string)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074166
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    for _, opening := range brackets {\n        if opening != \")\" {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2y0yyutv_test.go:13:23: invalid operation: opening != \")\" (mismatched types rune and untyped string)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074166
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"{\", -1)\n    brackets = strings.Replace(brackets, \">\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"<\", -1)\n    brackets = strings.Replace(brackets, \">\", \">\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"<\", -1)\n    brackets = strings.Replace(brackets, \">\", \">\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpdwoflz06_test.go:45:47: string literal not terminated\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074165
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"{\", -1)\n    brackets = strings.Replace(brackets, \")\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpx0art4nq_test.go:46:6: expected '(', found TestCorrect_Bracketing\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074165
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    for _, openBracket := range brackets {\n        if openBracket != \")\" {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpw7need2g_test.go:13:27: invalid operation: openBracket != \")\" (mismatched types rune and untyped string)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074166
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"{\", -1)\n    brackets = strings.Replace(brackets, \")\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", \nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpqyjlqmow_test.go:46:6: expected '(', found TestCorrect_Bracketing\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074165
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = strings.TrimSpace(brackets)\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"[\", -1)\n    brackets = strings.Replace(brackets, \">\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"<\", -1)\n    brackets = strings.Replace(brackets, \"]\", \">\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"{\", -1)\n    brackets = strings.Replace(brackets, \">\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"(\", -1)\n    brackets = strings.Replace(brackets, \")\", \")\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"[\", -1)\n    brackets = strings.Replace(brackets, \">\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"<\", -1)\n    brackets = strings.Replace(brackets, \"]\", \">\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"{\", -1)\n    brackets = strings.Replace(brackets, \">\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp1ylravlo_test.go:45:47: string literal not terminated\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074165
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    for _, char := range brackets {\n        if char != \")\" && char != \"(\" {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphp1j9pa4_test.go:13:20: invalid operation: char != \")\" (mismatched types rune and untyped string)\n/tmp/tmphp1j9pa4_test.go:13:35: invalid operation: char != \"(\" (mismatched types rune and untyped string)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074166
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    for _, char := range brackets {\n        if char != \")\" && char != \"(\" {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphp1j9pa4_test.go:13:20: invalid operation: char != \")\" (mismatched types rune and untyped string)\n/tmp/tmphp1j9pa4_test.go:13:35: invalid operation: char != \"(\" (mismatched types rune and untyped string)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074166
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"()\", -1)\n    brackets = strings.Replace(brackets, \")\", \"()\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"[]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{}\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"{}\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"<>\", -1)\n    brackets = strings.Replace(brackets, \">\", \"<>\", -1)\n    brackets = strings.Replace(brackets, \"=\", \"==\", -1)\n    brackets = strings.Replace(brackets, \"!=\", \"!=\", -1)\n    brackets = strings.Replace(brackets, \"<=\", \"<=\", -1)\n    brackets = strings.Replace(brackets, \">=\", \">=\", -1)\n    brackets = strings.Replace(brackets, \"!=\", \"!=\", -1)\n    brackets = strings.Replace(brackets, \"==\", \"==\", -1)\n    brackets = strings.Replace(brackets, \"=\", \"==\", -1)\n    brackets = strings.Replace(brackets, \"<=\", \"<=\", -1)\n    brackets = strings.Replace(brackets, \">=\", \">=\", -1)\n    brackets = strings.Replace(brackets, \"!=\", \"!=\", -1)\n    brackets = strings.Replace(brackets, \"==\", \"==\", -1)\n    brackets = strings.Replace(brackets, \"=\", \"==\", -1)\n    brackets = strings.Replace(brackets, \"<=\", \"<=\", -1)\n    brackets = strings.Replace(brackets, \">=\", \">=\", -1)\n    brackets = strings.Replace(brackets, \"!=\", \"!=\", -1)\n    brackets = strings.Replace(brackets, \"==\", \"==\", -1)\n    brackets = strings.Replace(brackets, \"=\", \"==\", -1)\n    brackets = strings.Replace(brackets, \"<=\", \"<=\", -1)\n    brackets = strings.Replace(brackets, \">=\", \">=\", -1)\n    brackets = strings.Replace(brackets, \"!=\", \"!=\", -1)\n    brackets = strings.Replace(brackets, \"==\", \"==\", -1)\n    brackets = strings.Replace(brackets, \"=\", \"==\", -1)\n    brackets = strings.Replace(brackets, \"<=\", \"<=\", -1)\n    brackets = strings.Replace(bracket\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpxgv4xc50_test.go:43:39: missing ',' before newline in argument list\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074165
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"{\", -1)\n    brackets = strings.Replace(brackets, \")\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"[\", -1)\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpr5zpa5qc_test.go:46:6: expected '(', found TestCorrect_Bracketing\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074165
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    for _, c := range brackets {\n        if c != \"(\" {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpny56bf5l_test.go:13:17: invalid operation: c != \"(\" (mismatched types rune and untyped string)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074166
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    for _, char := range brackets {\n        if char != \")\" && char != \"(\" {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphp1j9pa4_test.go:13:20: invalid operation: char != \")\" (mismatched types rune and untyped string)\n/tmp/tmphp1j9pa4_test.go:13:35: invalid operation: char != \"(\" (mismatched types rune and untyped string)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074166
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"((\", -1)\n    brackets = strings.Replace(brackets, \")\", \")(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"](\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}(\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"<(\", -1)\n    brackets = strings.Replace(brackets, \">\", \">(\", -1)\n    brackets = strings.Replace(brackets, \"/\", \"/((\", -1)\n    brackets = strings.Replace(brackets, \"\\\\\", \"/((\", -1)\n    brackets = strings.Replace(brackets, \"|\", \"|(\", -1)\n    brackets = strings.Replace(brackets, \"-\", \"-(\", -1)\n    brackets = strings.Replace(brackets, \"+\", \"+((\", -1)\n    brackets = strings.Replace(brackets, \"*\", \"*((\", -1)\n    brackets = strings.Replace(brackets, \"=\", \"=((\", -1)\n    brackets = strings.Replace(brackets, \"!\", \"!(\", -1)\n    brackets = strings.Replace(brackets, \"?\", \"?(\", -1)\n    brackets = strings.Replace(brackets, \"`\", \"`(\", -1)\n    brackets = strings.Replace(brackets, \"~\", \"~(\", -1)\n    brackets = strings.Replace(brackets, \"!~\", \"!~(\", -1)\n    brackets = strings.Replace(brackets, \"?~\", \"?~(\", -1)\n    brackets = strings.Replace(brackets, \"@\", \"@(\", -1)\n    brackets = strings.Replace(brackets, \"#\", \"#(\", -1)\n    brackets = strings.Replace(brackets, \"$\", \"$(\", -1)\n    brackets = strings.Replace(brackets, \"%\", \"%(\", -1)\n    brackets = strings.Replace(brackets, \"^\", \"^(\", -1)\n    brackets = strings.Replace(brackets, \"&\", \"&(\", -1)\n    brackets = strings.Replace(brackets, \"*\", \"*(\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"(\", -1)\n    brackets = strings.Replace(brackets, \")\", \")(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[(\", -1)\n    brackets = strings.\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpo8krkv7l_test.go:44:1: expected selector or type assertion, found 'func'\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074165
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    for _, c := range brackets {\n        if c != ')' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\npanic: runtime error: slice bounds out of range [1:0] [recovered]\n\tpanic: runtime error: slice bounds out of range [1:0]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838 +0x207\ncommand-line-arguments_test.correct_bracketing(...)\n\t/tmp/tmp_5inqdgl_test.go:11\ncommand-line-arguments_test.TestCorrect_Bracketing(0x0?)\n\t/tmp/tmp_5inqdgl_test.go:33 +0x1dc\ntesting.tRunner(0xc0000da340, 0x527d80)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486 +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "timestamp": 1660074166
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    for _, c := range brackets {\n        if c != \")\" && c != \"(\" {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpu_ny8211_test.go:13:17: invalid operation: c != \")\" (mismatched types rune and untyped string)\n/tmp/tmpu_ny8211_test.go:13:29: invalid operation: c != \"(\" (mismatched types rune and untyped string)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074166
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"((\", -1)\n    brackets = strings.Replace(brackets, \")\", \")(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"](\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}(\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"<(\", -1)\n    brackets = strings.Replace(brackets, \">\", \">(\", -1)\n    brackets = strings.Replace(brackets, \"|\", \"|(\", -1)\n    brackets = strings.Replace(brackets, \"~\", \"~(\", -1)\n    brackets = strings.Replace(brackets, \"!\", \"!(\", -1)\n    brackets = strings.Replace(brackets, \"=\", \"=(\", -1)\n    brackets = strings.Replace(brackets, \"+\", \"+(\", -1)\n    brackets = strings.Replace(brackets, \"-\", \"-(\", -1)\n    brackets = strings.Replace(brackets, \"*\", \"*(\", -1)\n    brackets = strings.Replace(brackets, \"/\", \"/(\", -1)\n    brackets = strings.Replace(brackets, \"%\", \"%(\", -1)\n    brackets = strings.Replace(brackets, \"&\", \"&(\", -1)\n    brackets = strings.Replace(brackets, \"^\", \"^(\", -1)\n    brackets = strings.Replace(brackets, \"|\", \"|(\", -1)\n    brackets = strings.Replace(brackets, \"~\", \"~(\", -1)\n    brackets = strings.Replace(brackets, \"!\", \"!(\", -1)\n    brackets = strings.Replace(brackets, \"=\", \"=(\", -1)\n    brackets = strings.Replace(brackets, \"+\", \"+(\", -1)\n    brackets = strings.Replace(brackets, \"-\", \"-(\", -1)\n    brackets = strings.Replace(brackets, \"*\", \"*(\", -1)\n    brackets = strings.Replace(brackets, \"/\", \"/(\", -1)\n    brackets = strings.Replace(brackets, \"%\", \"%(\", -1)\n    brackets = strings.Replace(brackets, \"&\", \"&(\", -1)\n    brackets = strings.Replace(brackets, \"^\", \"^(\", -1)\n    brackets = strings.Replace(brackets, \"|\", \"|(\", -1)\n    brackets = strings.Replace(brackets, \"\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp2jtiq7_b_test.go:43:42: string literal not terminated\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074165
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    var opening_brackets []string\n    var closing_brackets []string\n    for _, c := range brackets {\n        if c == '(' {\n            opening_brackets = append(opening_brackets, c)\n        } else if c == ')' {\n            closing_brackets = append(closing_brackets, c)\n        }\n    }\n    if len(opening_brackets) != len(closing_brackets) {\n        return false\n    }\n    for i := 0; i < len(opening_brackets); i++ {\n        if opening_brackets[i] != closing_brackets[i] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpa4x2e4il_test.go:15:57: cannot use c (variable of type rune) as type string in argument to append\n/tmp/tmpa4x2e4il_test.go:17:57: cannot use c (variable of type rune) as type string in argument to append\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074166
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    openingBrackets := make([]string, 0)\n    closingBrackets := make([]string, 0)\n    for _, c := range brackets {\n        if c == '(' {\n            openingBrackets = append(openingBrackets, c)\n        } else {\n            closingBrackets = append(closingBrackets, c)\n        }\n    }\n    if len(openingBrackets) != len(closingBrackets) {\n        return false\n    }\n    for i := 0; i < len(openingBrackets); i++ {\n        if openingBrackets[i] != closingBrackets[i] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5r4jiuvy_test.go:16:55: cannot use c (variable of type rune) as type string in argument to append\n/tmp/tmp5r4jiuvy_test.go:18:55: cannot use c (variable of type rune) as type string in argument to append\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074166
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    openingBrackets := []string{\"(\", \"[\", \"{\"}\n    closingBrackets := []string{\")\", \"]\", \"}\"}\n    for _, openingBracket := range openingBrackets {\n        for _, closingBracket := range closingBrackets {\n            if openingBracket == closingBracket {\n                continue\n            }\n            if brackets[len(brackets)-len(closingBracket):len(brackets)] == openingBracket {\n                return false\n            }\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__4 (0.00s)\n        tmpohebhznw_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__5 (0.00s)\n        tmpohebhznw_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__8 (0.00s)\n        tmpohebhznw_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__9 (0.00s)\n        tmpohebhznw_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__10 (0.00s)\n        tmpohebhznw_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__11 (0.00s)\n        tmpohebhznw_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "timestamp": 1660074166
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"{\", -1)\n    brackets = strings.Replace(brackets, \")\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(bracket\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpv9a_vmpe_test.go:45:39: missing ',' before newline in argument list\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074165
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    var openingBrackets []string\n    var closingBrackets []string\n    for _, char := range brackets {\n        if char == '(' {\n            openingBrackets = append(openingBrackets, char)\n        } else if char == ')' {\n            closingBrackets = append(closingBrackets, char)\n        } else {\n            return false\n        }\n    }\n    if len(openingBrackets) != len(closingBrackets) {\n        return false\n    }\n    for i := 0; i < len(openingBrackets); i++ {\n        if openingBrackets[i] != closingBrackets[i] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpr2dckwr2_test.go:15:55: cannot use char (variable of type rune) as type string in argument to append\n/tmp/tmpr2dckwr2_test.go:17:55: cannot use char (variable of type rune) as type string in argument to append\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074166
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    for _, char := range brackets {\n        if char != \")\" && char != \"(\" {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphp1j9pa4_test.go:13:20: invalid operation: char != \")\" (mismatched types rune and untyped string)\n/tmp/tmphp1j9pa4_test.go:13:35: invalid operation: char != \"(\" (mismatched types rune and untyped string)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074166
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    for _, c := range brackets {\n        if c != ')' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\npanic: runtime error: slice bounds out of range [1:0] [recovered]\n\tpanic: runtime error: slice bounds out of range [1:0]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838 +0x207\ncommand-line-arguments_test.correct_bracketing(...)\n\t/tmp/tmp_5inqdgl_test.go:11\ncommand-line-arguments_test.TestCorrect_Bracketing(0x0?)\n\t/tmp/tmp_5inqdgl_test.go:33 +0x1dc\ntesting.tRunner(0xc0000da340, 0x527d80)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486 +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "timestamp": 1660074166
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = strings.TrimSpace(brackets)\n    brackets = strings.Replace(brackets, \"(\", \"((\", -1)\n    brackets = strings.Replace(brackets, \")\", \")(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"](\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}(\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"<(\", -1)\n    brackets = strings.Replace(brackets, \">\", \">(\", -1)\n    brackets = strings.Replace(brackets, \"/\", \"/((\", -1)\n    brackets = strings.Replace(brackets, \"\\\\\", \"/((\", -1)\n    brackets = strings.Replace(brackets, \"|\", \"|(\", -1)\n    brackets = strings.Replace(brackets, \"-\", \"-(\", -1)\n    brackets = strings.Replace(brackets, \"_\", \"_((\", -1)\n    brackets = strings.Replace(brackets, \"+\", \"+((\", -1)\n    brackets = strings.Replace(brackets, \".\", \".(\", -1)\n    brackets = strings.Replace(brackets, \"?\", \".(\", -1)\n    brackets = strings.Replace(brackets, \"!\", \".(\", -1)\n    brackets = strings.Replace(brackets, \"$\", \".(\", -1)\n    brackets = strings.Replace(brackets, \"%\", \".(\", -1)\n    brackets = strings.Replace(brackets, \"^\", \".(\", -1)\n    brackets = strings.Replace(brackets, \"&\", \".(\", -1)\n    brackets = strings.Replace(brackets, \"*\", \".(\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"(\", -1)\n    brackets = strings.Replace(brackets, \")\", \")\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"<\", -1)\n    brackets = strings.Replace(brackets, \">\", \">\", -1)\n    brackets = strings.Replace(brackets, \"/\", \"/(\", -1)\n    brackets = strings.Replace(brackets, \"\\\\\", \"/(\", -1)\n    brackets = strings.Replace(brackets, \"\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpctls4b4v_test.go:44:42: string literal not terminated\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074166
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    openingBrackets := 0\n    closingBrackets := 0\n    for _, char := range brackets {\n        if char == '(' {\n            openingBrackets++\n        } else if char == ')' {\n            closingBrackets++\n        }\n    }\n    return openingBrackets == closingBrackets\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__5 (0.00s)\n        tmp6w9wqft__test.go:47: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__10 (0.00s)\n        tmp6w9wqft__test.go:47: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "timestamp": 1660074168
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    var opening = brackets[0 : len(brackets)-1]\n    var closing = brackets[len(brackets)-1:]\n    for _, c := range opening {\n        if c != closing[0] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkxhjeozj_test.go:14:17: invalid operation: c != closing[0] (mismatched types rune and byte)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074167
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"{\", -1)\n    brackets = strings.Replace(brackets, \")\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(bracket\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmptb37874q_test.go:45:39: missing ',' before newline in argument list\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074166
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[0 : \nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpd_q5alnk_test.go:58:6: expected '(', found TestCorrect_Bracketing\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074166
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    openingBrackets := make(map[string]bool)\n    closingBrackets := make(map[string]bool)\n    for _, c := range brackets {\n        if c == '(' {\n            openingBrackets[c] = true\n        } else if c == ')' {\n            closingBrackets[c] = true\n        }\n    }\n    for c := range openingBrackets {\n        if !closingBrackets[c] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpb7jgzzxl_test.go:15:29: cannot use c (variable of type rune) as type string in map index\n/tmp/tmpb7jgzzxl_test.go:17:29: cannot use c (variable of type rune) as type string in map index\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074167
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"{\", -1)\n    brackets = strings.Replace(brackets, \")\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"]\", -1)\n    brackets = strings.Replace(brackets, \nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp_ulm9fmc_test.go:46:6: expected '(', found TestCorrect_Bracketing\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074166
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = strings.TrimSpace(brackets)\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"{\", -1)\n    brackets = strings.Replace(brackets, \")\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = \nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpoe75qo71_test.go:47:6: expected '(', found TestCorrect_Bracketing\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074166
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    openingBrackets := 0\n    closingBrackets := 0\n    for _, char := range brackets {\n        if char == '(' {\n            openingBrackets++\n        } else if char == ')' {\n            closingBrackets++\n        }\n    }\n    return openingBrackets == closingBrackets\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\npanic: runtime error: slice bounds out of range [1:0] [recovered]\n\tpanic: runtime error: slice bounds out of range [1:0]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838 +0x207\ncommand-line-arguments_test.correct_bracketing(...)\n\t/tmp/tmprw9z5f3j_test.go:11\ncommand-line-arguments_test.TestCorrect_Bracketing(0x0?)\n\t/tmp/tmprw9z5f3j_test.go:37 +0x1be\ntesting.tRunner(0xc0000da1a0, 0x527d80)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486 +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "timestamp": 1660074168
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"((\", -1)\n    brackets = strings.Replace(brackets, \")\", \")(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"](\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}(\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"<(\", -1)\n    brackets = strings.Replace(brackets, \">\", \">(\", -1)\n    brackets = strings.Replace(brackets, \"|\", \"|(\", -1)\n    brackets = strings.Replace(brackets, \"~\", \"~(\", -1)\n    brackets = strings.Replace(brackets, \"!\", \"!(\", -1)\n    brackets = strings.Replace(brackets, \"$\", \"$(\", -1)\n    brackets = strings.Replace(brackets, \"%\", \"%(\", -1)\n    brackets = strings.Replace(brackets, \"^\", \"^(\", -1)\n    brackets = strings.Replace(brackets, \"&\", \"&(\", -1)\n    brackets = strings.Replace(brackets, \"*\", \"*(\", -1)\n    brackets = strings.Replace(brackets, \"+\", \"+(\", -1)\n    brackets = strings.Replace(brackets, \",\", \",(\", -1)\n    brackets = strings.Replace(brackets, \"-\", \"-(\", -1)\n    brackets = strings.Replace(brackets, \"/\", \"/(\", -1)\n    brackets = strings.Replace(brackets, \"=\", \"=\", -1)\n    brackets = strings.Replace(brackets, \"?\", \"?(\", -1)\n    brackets = strings.Replace(brackets, \"!\", \"!(\", -1)\n    brackets = strings.Replace(brackets, \"@\", \"@(\", -1)\n    brackets = strings.Replace(brackets, \"#\", \"#(\", -1)\n    brackets = strings.Replace(brackets, \"$\", \"$(\", -1)\n    brackets = strings.Replace(brackets, \"%\", \"%(\", -1)\n    brackets = strings.Replace(brackets, \"^\", \"^(\", -1)\n    brackets = strings.Replace(brackets, \"&\", \"&(\", -1)\n    brackets = strings.Replace(brackets, \"*\", \"*(\", -1)\n    brackets = strings.Replace(brackets, \"+\", \"+(\", -1)\n    brackets = strings.Replace(brackets, \nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpwvod6iok_test.go:44:6: expected '(', found TestCorrect_Bracketing\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074166
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    openingBrackets := make(map[string]bool)\n    closingBrackets := make(map[string]bool)\n    for _, c := range brackets {\n        if c == '(' {\n            openingBrackets[c] = true\n        } else if c == ')' {\n            closingBrackets[c] = true\n        }\n    }\n    for _, c := range brackets {\n        if !openingBrackets[c] {\n            return false\n        }\n        if !closingBrackets[c] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpauyuf8hr_test.go:15:29: cannot use c (variable of type rune) as type string in map index\n/tmp/tmpauyuf8hr_test.go:17:29: cannot use c (variable of type rune) as type string in map index\n/tmp/tmpauyuf8hr_test.go:21:29: cannot use c (variable of type rune) as type string in map index\n/tmp/tmpauyuf8hr_test.go:24:29: cannot use c (variable of type rune) as type string in map index\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074167
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"()\", -1)\n    brackets = strings.Replace(brackets, \")\", \"()\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"[]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{}\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"{}\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"<\", -1)\n    brackets = strings.Replace(brackets, \">\", \">\", -1)\n    brackets = strings.Replace(brackets, \"&\", \"&\", -1)\n    brackets = strings.Replace(brackets, \"|\", \"|\", -1)\n    brackets = strings.Replace(brackets, \"!\", \"!\", -1)\n    brackets = strings.Replace(brackets, \"=\", \"=\", -1)\n    brackets = strings.Replace(brackets, \"?\", \"?\", -1)\n    brackets = strings.Replace(brackets, \"$\", \"$\", -1)\n    brackets = strings.Replace(brackets, \"%\", \"%\", -1)\n    brackets = strings.Replace(brackets, \"*\", \"*\", -1)\n    brackets = strings.Replace(brackets, \"+\", \"+\", -1)\n    brackets = strings.Replace(brackets, \"-\", \"-\", -1)\n    brackets = strings.Replace(brackets, \"/\", \"/\", -1)\n    brackets = strings.Replace(brackets, \"\\\\\", \"\\\\\", -1)\n    brackets = strings.Replace(brackets, \"^\", \"^\", -1)\n    brackets = strings.Replace(brackets, \"~\", \"~\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"(\", -1)\n    brackets = strings.Replace(brackets, \")\", \")\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"<\", -1)\n    brackets = strings.Replace(brackets, \">\", \">\", -1)\n    brackets = strings.Replace(brackets, \"&\", \"&\", -1)\n    brackets = strings.Replace(brackets, \"|\", \"|\", -1)\n    brackets = strings.Replace(brackets, \"!\", \"!\", -1)\n    brackets = strings.Replace(brackets, \"=\"\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpcs6ywxu9_test.go:45:45: missing ',' before newline in argument list\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074166
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    for _, c := range brackets {\n        if c != \")\" && c != \"(\" {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpu_ny8211_test.go:13:17: invalid operation: c != \")\" (mismatched types rune and untyped string)\n/tmp/tmpu_ny8211_test.go:13:29: invalid operation: c != \"(\" (mismatched types rune and untyped string)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074166
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    for _, char := range brackets {\n        if char != \")\" && char != \"(\" {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphp1j9pa4_test.go:13:20: invalid operation: char != \")\" (mismatched types rune and untyped string)\n/tmp/tmphp1j9pa4_test.go:13:35: invalid operation: char != \"(\" (mismatched types rune and untyped string)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074166
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"{\", -1)\n    brackets = strings.Replace(brackets, \")\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"{\", -1)\n    brackets = strings.Replace(brackets, \")\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp70zsjn0b_test.go:46:6: expected '(', found TestCorrect_Bracketing\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074168
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"((\", -1)\n    brackets = strings.Replace(brackets, \")\", \")(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"](\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}(\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"<(\", -1)\n    brackets = strings.Replace(brackets, \">\", \">(\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"((\", -1)\n    brackets = strings.Replace(brackets, \")\", \"))\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"](\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}(\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"<(\", -1)\n    brackets = strings.Replace(brackets, \">\", \">(\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"((\", -1)\n    brackets = strings.Replace(brackets, \")\", \"))\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"](\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}(\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"<(\", -1)\n    brackets = strings.Replace(brackets, \">\", \">(\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"((\", -1)\n    brackets = strings.Replace(brackets, \")\", \"))\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"](\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}(\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"<(\", -1)\n    brackets = strings.Replace(bracket\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpc6veawww_test.go:43:39: missing ',' before newline in argument list\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074168
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    openingBrackets := []string{\"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpn_j3z_j6_test.go:11:1288: string literal not terminated\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074168
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    openingBrackets := make([]int, len(brackets))\n    closingBrackets := make([]int, len(brackets))\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '(' {\n            openingBrackets[i] = 1\n        } else {\n            closingBrackets[i] = 1\n        }\n    }\n    for i := 0; i < len(brackets); i++ {\n        if openingBrackets[i] != closingBrackets[i] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\npanic: runtime error: slice bounds out of range [1:0] [recovered]\n\tpanic: runtime error: slice bounds out of range [1:0]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838 +0x207\ncommand-line-arguments_test.correct_bracketing(...)\n\t/tmp/tmpbr6p2q0u_test.go:11\ncommand-line-arguments_test.TestCorrect_Bracketing(0x0?)\n\t/tmp/tmpbr6p2q0u_test.go:42 +0x2c5\ntesting.tRunner(0xc0000da1a0, 0x527d80)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486 +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "timestamp": 1660074169
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"{\", -1)\n    brackets = strings.Replace(brackets, \")\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(bracket\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpcq7ps5tw_test.go:45:39: missing ',' before newline in argument list\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074168
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    openingBrackets := 0\n    closingBrackets := 0\n    for _, char := range brackets {\n        if char == '(' {\n            openingBrackets++\n        } else if char == ')' {\n            closingBrackets++\n        }\n    }\n    return openingBrackets == closingBrackets\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__5 (0.00s)\n        tmp6w9wqft__test.go:47: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__10 (0.00s)\n        tmp6w9wqft__test.go:47: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "timestamp": 1660074168
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    openingBrackets := make([]int, len(brackets))\n    closingBrackets := make([]int, len(brackets))\n    for i, c := range brackets {\n        if c == '(' {\n            openingBrackets[i] = 1\n        } else if c == ')' {\n            closingBrackets[i] = 1\n        }\n    }\n    for i := 0; i < len(openingBrackets); i++ {\n        if openingBrackets[i] != closingBrackets[i] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\npanic: runtime error: slice bounds out of range [1:0] [recovered]\n\tpanic: runtime error: slice bounds out of range [1:0]\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x512440, 0xc000166000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x512440, 0xc000166000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838 +0x207\ncommand-line-arguments_test.correct_bracketing(...)\n\t/tmp/tmpq0ospjvr_test.go:11\ncommand-line-arguments_test.TestCorrect_Bracketing(0x0?)\n\t/tmp/tmpq0ospjvr_test.go:42 +0x505\ntesting.tRunner(0xc000103380, 0x527d80)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486 +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "timestamp": 1660074169
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"{\", -1)\n    brackets = strings.Replace(brackets, \")\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpzez11zp8_test.go:46:6: expected '(', found TestCorrect_Bracketing\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074168
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    openingBrackets := make(map[string]bool)\n    closingBrackets := make(map[string]bool)\n    for _, c := range brackets {\n        if c == '(' {\n            openingBrackets[c] = true\n        } else if c == ')' {\n            closingBrackets[c] = true\n        }\n    }\n    for c := range openingBrackets {\n        if !closingBrackets[c] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpb7jgzzxl_test.go:15:29: cannot use c (variable of type rune) as type string in map index\n/tmp/tmpb7jgzzxl_test.go:17:29: cannot use c (variable of type rune) as type string in map index\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074167
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"{\", -1)\n    brackets = strings.Replace(brackets, \")\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(bracket\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmptb37874q_test.go:45:39: missing ',' before newline in argument list\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074166
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    for _, char := range brackets {\n        if char != \")\" && char != \"(\" {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphp1j9pa4_test.go:13:20: invalid operation: char != \")\" (mismatched types rune and untyped string)\n/tmp/tmphp1j9pa4_test.go:13:35: invalid operation: char != \"(\" (mismatched types rune and untyped string)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074166
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    openingBrackets := make([]string, 0)\n    closingBrackets := make([]string, 0)\n    for _, char := range brackets {\n        if char == \"(\" {\n            openingBrackets = append(openingBrackets, char)\n        } else {\n            closingBrackets = append(closingBrackets, char)\n        }\n    }\n    if len(openingBrackets) != len(closingBrackets) {\n        return false\n    }\n    for i := 0; i < len(openingBrackets); i++ {\n        if openingBrackets[i] != closingBrackets[i] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp3skk6put_test.go:15:20: invalid operation: char == \"(\" (mismatched types rune and untyped string)\n/tmp/tmp3skk6put_test.go:16:55: cannot use char (variable of type rune) as type string in argument to append\n/tmp/tmp3skk6put_test.go:18:55: cannot use char (variable of type rune) as type string in argument to append\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074169
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"{\", -1)\n    brackets = strings.Replace(brackets, \")\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpx0art4nq_test.go:46:6: expected '(', found TestCorrect_Bracketing\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074165
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = strings.TrimSpace(brackets)\n    brackets = strings.Replace(brackets, \"(\", \"((\", -1)\n    brackets = strings.Replace(brackets, \")\", \")(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"](\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}(\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"<(\", -1)\n    brackets = strings.Replace(brackets, \">\", \">(\", -1)\n    brackets = strings.Replace(brackets, \"|\", \"|(\", -1)\n    brackets = strings.Replace(brackets, \"!\", \"!(\", -1)\n    brackets = strings.Replace(brackets, \"?\", \"?(\", -1)\n    brackets = strings.Replace(brackets, \"%\", \"%(\", -1)\n    brackets = strings.Replace(brackets, \"$\", \"$(\", -1)\n    brackets = strings.Replace(brackets, \"@\", \"@(\", -1)\n    brackets = strings.Replace(brackets, \"~\", \"~(\", -1)\n    brackets = strings.Replace(brackets, \"^\", \"^(\", -1)\n    brackets = strings.Replace(brackets, \"*\", \"*(\", -1)\n    brackets = strings.Replace(brackets, \"+\", \"+(\", -1)\n    brackets = strings.Replace(brackets, \",\", \",(\", -1)\n    brackets = strings.Replace(brackets, \"-\", \"-(\", -1)\n    brackets = strings.Replace(brackets, \"/\", \"/(\", -1)\n    brackets = strings.Replace(brackets, \"=\", \"=\", -1)\n    brackets = strings.Replace(brackets, \"|\", \"|(\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"(\", -1)\n    brackets = strings.Replace(brackets, \")\", \")(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"](\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}(\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"<(\", -1)\n    brackets = strings.Replace(brackets, \">\", \">(\", -1)\n    brackets = strings.Replace(brackets, \"\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpnbr_0ejx_test.go:43:42: string literal not terminated\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074168
    },
    {
      "exit_code": 0,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    var brackets_count int\n    for _, c := range brackets {\n        if c == '(' {\n            brackets_count++\n        }\n        if c == ')' {\n            brackets_count--\n        }\n        if brackets_count < 0 {\n            return false\n        }\n    }\n    return brackets_count == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "timestamp": 1660074170
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"((\", -1)\n    brackets = strings.Replace(brackets, \")\", \")(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"](\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}(\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"<(\", -1)\n    brackets = strings.Replace(brackets, \">\", \">(\", -1)\n    brackets = strings.Replace(brackets, \"|\", \"|(\", -1)\n    brackets = strings.Replace(brackets, \"/\", \"/((\", -1)\n    brackets = strings.Replace(brackets, \"\\\\\", \"/((\", -1)\n    brackets = strings.Replace(brackets, \"-\", \"/((\", -1)\n    brackets = strings.Replace(brackets, \",\", \"/((\", -1)\n    brackets = strings.Replace(brackets, \"=\", \"/((\", -1)\n    brackets = strings.Replace(brackets, \"?\", \"/((\", -1)\n    brackets = strings.Replace(brackets, \"!\", \"/((\", -1)\n    brackets = strings.Replace(brackets, \"$\", \"/((\", -1)\n    brackets = strings.Replace(brackets, \"%\", \"/((\", -1)\n    brackets = strings.Replace(brackets, \"^\", \"/((\", -1)\n    brackets = strings.Replace(brackets, \"&\", \"/((\", -1)\n    brackets = strings.Replace(brackets, \"*\", \"/((\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"((\", -1)\n    brackets = strings.Replace(brackets, \")\", \"))\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"](\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}(\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"<(\", -1)\n    brackets = strings.Replace(brackets, \">\", \">(\", -1)\n    brackets = strings.Replace(brackets, \"|\", \"|(\", -1)\n    brackets = strings.Replace(brackets, \"/\", \"/((\", -1)\n    brackets = strings.Replace(b\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmps23ql5a8_test.go:43:33: missing ',' before newline in argument list\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074168
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    openingBrackets := 0\n    closingBrackets := 0\n    for _, c := range brackets {\n        if c == '(' {\n            openingBrackets++\n        } else if c == ')' {\n            closingBrackets++\n        }\n    }\n    return openingBrackets == closingBrackets\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__5 (0.00s)\n        tmpbs47m96x_test.go:47: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__10 (0.00s)\n        tmpbs47m96x_test.go:47: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "timestamp": 1660074166
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"[\", -1)\n    brackets = strings.Replace(brackets, \">\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"<\", -1)\n    brackets = strings.Replace(brackets, \"]\", \">\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"{\", -1)\n    brackets = strings.Replace(brackets, \">\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"[\", -1)\n    brackets = strings.Replace(brackets, \">\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"<\", -1)\n    brackets = strings.Replace(brackets, \"]\", \">\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"[\", -1)\n    brackets = strings.Replace(brackets, \">\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"<\", -1)\n    brackets = strings.Replace(brackets, \"]\", \">\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"[\", -1)\n    brackets = strings.Replace(brackets, \">\", \"]\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpfivoqyx9_test.go:45:47: string literal not terminated\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074168
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    openingBrackets := []string{\"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"{\", \"(\", \"[\", \"\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpn_j3z_j6_test.go:11:1288: string literal not terminated\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074168
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    openingBrackets := brackets[0 : len(brackets)-1]\n    closingBrackets := brackets[len(brackets)-1:]\n    for _, openingBracket := range openingBrackets {\n        if closingBrackets[len(closingBrackets)-1] != openingBracket {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpesdjxuci_test.go:14:55: invalid operation: closingBrackets[len(closingBrackets) - 1] != openingBracket (mismatched types byte and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074169
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"{\", -1)\n    brackets = strings.Replace(brackets, \")\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(bracket\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpv9a_vmpe_test.go:45:39: missing ',' before newline in argument list\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074165
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"{\", -1)\n    brackets = strings.Replace(brackets, \")\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = \nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp0vlmm1h5_test.go:47:6: expected '(', found TestCorrect_Bracketing\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074168
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    openingBrackets := make(map[string]bool)\n    closingBrackets := make(map[string]bool)\n    for _, c := range brackets {\n        if c == '(' {\n            openingBrackets[c] = true\n        } else if c == ')' {\n            closingBrackets[c] = true\n        }\n    }\n    for c := range openingBrackets {\n        if !closingBrackets[c] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpb7jgzzxl_test.go:15:29: cannot use c (variable of type rune) as type string in map index\n/tmp/tmpb7jgzzxl_test.go:17:29: cannot use c (variable of type rune) as type string in map index\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074167
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"{\", -1)\n    brackets = strings.Replace(brackets, \">\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"<\", -1)\n    brackets = strings.Replace(brackets, \"}\", \">\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"<\", -1)\n    brackets = strings.Replace(brackets, \"]\", \">\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"[\", -1)\n    brackets = strings.Replace(brackets, \">\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"{\", -1)\n    brackets = strings.Replace(brackets, \">\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"[\", -1)\n    brackets = strings.Replace(brackets, \">\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"{\", -1)\n    brackets = strings.Replace(brackets, \">\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"[\", -1)\n    brackets = strings.Replace(brackets, \">\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"{\", -1)\n    brackets = strings.Replace(brackets, \">\", \"}\", \nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpfw7d7ucw_test.go:46:6: expected '(', found TestCorrect_Bracketing\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074168
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    var opening = false\n    var closing = false\n    var openingCount int\n    var closingCount int\n    for _, c := range brackets {\n        if c == '(' {\n            opening = true\n            openingCount++\n        } else if c == ')' {\n            closing = true\n            closingCount++\n        }\n        if opening && closing {\n            return false\n        }\n    }\n    return openingCount == closingCount\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0 (0.00s)\n        tmp3u3fr30e_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmp3u3fr30e_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmp3u3fr30e_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmp3u3fr30e_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "timestamp": 1660074170
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    openingBrackets := 0\n    closingBrackets := 0\n    for _, c := range brackets {\n        if c == '(' {\n            openingBrackets++\n        } else if c == ')' {\n            closingBrackets++\n        }\n    }\n    return openingBrackets == closingBrackets\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__5 (0.00s)\n        tmpbs47m96x_test.go:47: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__10 (0.00s)\n        tmpbs47m96x_test.go:47: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "timestamp": 1660074166
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    for _, c := range brackets {\n        if c != \")\" && c != \"(\" {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpu_ny8211_test.go:13:17: invalid operation: c != \")\" (mismatched types rune and untyped string)\n/tmp/tmpu_ny8211_test.go:13:29: invalid operation: c != \"(\" (mismatched types rune and untyped string)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074166
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    for _, char := range brackets {\n        if char != \"(\" && char != \")\" {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7y72gket_test.go:13:20: invalid operation: char != \"(\" (mismatched types rune and untyped string)\n/tmp/tmp7y72gket_test.go:13:35: invalid operation: char != \")\" (mismatched types rune and untyped string)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074169
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    for _, c := range brackets {\n        if c != \")\" {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp24xitz2g_test.go:13:17: invalid operation: c != \")\" (mismatched types rune and untyped string)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074169
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    var opening = false\n    var closing = false\n    for _, c := range brackets {\n        if c == '(' {\n            opening = true\n        } else if c == ')' {\n            closing = true\n        }\n    }\n    return opening && closing\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__4 (0.00s)\n        tmp8pmmespd_test.go:47: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__5 (0.00s)\n        tmp8pmmespd_test.go:47: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__9 (0.00s)\n        tmp8pmmespd_test.go:47: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__10 (0.00s)\n        tmp8pmmespd_test.go:47: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__11 (0.00s)\n        tmp8pmmespd_test.go:47: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "timestamp": 1660074170
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    for _, c := range brackets {\n        if c != \")\" && c != \"(\" {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpu_ny8211_test.go:13:17: invalid operation: c != \")\" (mismatched types rune and untyped string)\n/tmp/tmpu_ny8211_test.go:13:29: invalid operation: c != \"(\" (mismatched types rune and untyped string)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074166
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    openingBrackets := 0\n    closingBrackets := 0\n    for _, c := range brackets {\n        if c == '(' {\n            openingBrackets++\n        } else if c == ')' {\n            closingBrackets++\n        }\n    }\n    return openingBrackets == closingBrackets\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__5 (0.00s)\n        tmpbs47m96x_test.go:47: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__10 (0.00s)\n        tmpbs47m96x_test.go:47: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "timestamp": 1660074166
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"()\", -1)\n    brackets = strings.Replace(brackets, \")\", \"()\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"[]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{}\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"{}\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"<>\", -1)\n    brackets = strings.Replace(brackets, \">\", \"<>\", -1)\n    brackets = strings.Replace(brackets, \"=\", \"==\", -1)\n    brackets = strings.Replace(brackets, \"!=\", \"!=\", -1)\n    brackets = strings.Replace(brackets, \"<=\", \"<=\", -1)\n    brackets = strings.Replace(brackets, \">=\", \">=\", -1)\n    brackets = strings.Replace(brackets, \"!=\", \"!=\", -1)\n    brackets = strings.Replace(brackets, \"==\", \"==\", -1)\n    brackets = strings.Replace(brackets, \"!=\", \"!=\", -1)\n    brackets = strings.Replace(brackets, \"<=\", \"<=\", -1)\n    brackets = strings.Replace(brackets, \">=\", \">=\", -1)\n    brackets = strings.Replace(brackets, \"!=\", \"!=\", -1)\n    brackets = strings.Replace(brackets, \"==\", \"==\", -1)\n    brackets = strings.Replace(brackets, \"!=\", \"!=\", -1)\n    brackets = strings.Replace(brackets, \"<=\", \"<=\", -1)\n    brackets = strings.Replace(brackets, \">=\", \">=\", -1)\n    brackets = strings.Replace(brackets, \"!=\", \"!=\", -1)\n    brackets = strings.Replace(brackets, \"==\", \"==\", -1)\n    brackets = strings.Replace(brackets, \"!=\", \"!=\", -1)\n    brackets = strings.Replace(brackets, \"<=\", \"<=\", -1)\n    brackets = strings.Replace(brackets, \">=\", \">=\", -1)\n    brackets = strings.Replace(brackets, \"!=\", \"!=\", -1)\n    brackets = strings.Replace(brackets, \"==\", \"==\", -1)\n    brackets = strings.Replace(brackets, \"!=\", \"!=\", -1)\n    brackets = strings.Replace(brackets, \"<=\", \"<=\", -1)\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3en520um_test.go:44:6: expected '(', found TestCorrect_Bracketing\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074169
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    for _, openingBracket := range brackets {\n        if openingBracket != \")\" && openingBracket != \"(\" {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpq5qudy3d_test.go:13:30: invalid operation: openingBracket != \")\" (mismatched types rune and untyped string)\n/tmp/tmpq5qudy3d_test.go:13:55: invalid operation: openingBracket != \"(\" (mismatched types rune and untyped string)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074170
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"((\", -1)\n    brackets = strings.Replace(brackets, \")\", \")(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"](\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}(\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"<(\", -1)\n    brackets = strings.Replace(brackets, \">\", \">(\", -1)\n    brackets = strings.Replace(brackets, \"|\", \"|(\", -1)\n    brackets = strings.Replace(brackets, \"~\", \"~(\", -1)\n    brackets = strings.Replace(brackets, \"!\", \"!(\", -1)\n    brackets = strings.Replace(brackets, \"$\", \"$(\", -1)\n    brackets = strings.Replace(brackets, \"%\", \"%(\", -1)\n    brackets = strings.Replace(brackets, \"^\", \"^(\", -1)\n    brackets = strings.Replace(brackets, \"&\", \"&(\", -1)\n    brackets = strings.Replace(brackets, \"*\", \"*(\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"(\", -1)\n    brackets = strings.Replace(brackets, \")\", \")(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"](\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}(\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"<(\", -1)\n    brackets = strings.Replace(brackets, \">\", \">(\", -1)\n    brackets = strings.Replace(brackets, \"|\", \"|(\", -1)\n    brackets = strings.Replace(brackets, \"~\", \"~(\", -1)\n    brackets = strings.Replace(brackets, \"!\", \"!(\", -1)\n    brackets = strings.Replace(brackets, \"$\", \"$(\", -1)\n    brackets = strings.Replace(brackets, \"%\", \"%(\", -1)\n    brackets = strings.Replace(brackets, \"^\", \"^(\", -1)\n    brackets = strings.Replace(brackets, \"&\", \"&(\", -1)\n    brackets = strings.Replace(b\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpv2nb50h7_test.go:43:33: missing ',' before newline in argument list\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074169
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    for _, char := range brackets {\n        if char != \")\" && char != \"(\" {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphp1j9pa4_test.go:13:20: invalid operation: char != \")\" (mismatched types rune and untyped string)\n/tmp/tmphp1j9pa4_test.go:13:35: invalid operation: char != \"(\" (mismatched types rune and untyped string)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074166
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"{\", -1)\n    brackets = strings.Replace(brackets, \")\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp_9i3abx6_test.go:47:1: expected selector or type assertion, found 'func'\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074169
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    openingBrackets := make(map[string]bool)\n    closingBrackets := make(map[string]bool)\n    for _, c := range brackets {\n        if c == '(' {\n            openingBrackets[c] = true\n        } else if c == ')' {\n            closingBrackets[c] = true\n        }\n    }\n    for c := range openingBrackets {\n        if !closingBrackets[c] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpb7jgzzxl_test.go:15:29: cannot use c (variable of type rune) as type string in map index\n/tmp/tmpb7jgzzxl_test.go:17:29: cannot use c (variable of type rune) as type string in map index\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074167
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    for _, char := range brackets {\n        if char != \")\" && char != \"(\" {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphp1j9pa4_test.go:13:20: invalid operation: char != \")\" (mismatched types rune and untyped string)\n/tmp/tmphp1j9pa4_test.go:13:35: invalid operation: char != \"(\" (mismatched types rune and untyped string)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074166
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = strings.TrimSpace(brackets)\n    brackets = strings.Replace(brackets, \"(\", \"((\", -1)\n    brackets = strings.Replace(brackets, \")\", \")(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"](\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}(\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"<(\", -1)\n    brackets = strings.Replace(brackets, \">\", \">(\", -1)\n    brackets = strings.Replace(brackets, \"!\", \"!(\", -1)\n    brackets = strings.Replace(brackets, \"?\", \"?(\", -1)\n    brackets = strings.Replace(brackets, \"=\", \"=(\", -1)\n    brackets = strings.Replace(brackets, \"|\", \"|(\", -1)\n    brackets = strings.Replace(brackets, \"+\", \"+(\", -1)\n    brackets = strings.Replace(brackets, \"-\", \"-(\", -1)\n    brackets = strings.Replace(brackets, \"*\", \"*(\", -1)\n    brackets = strings.Replace(brackets, \"/\", \"/(\", -1)\n    brackets = strings.Replace(brackets, \"%\", \"%(\", -1)\n    brackets = strings.Replace(brackets, \"^\", \"^(\", -1)\n    brackets = strings.Replace(brackets, \"&\", \"&(\", -1)\n    brackets = strings.Replace(brackets, \"==\", \"==(\", -1)\n    brackets = strings.Replace(brackets, \"!=\", \"!=(\", -1)\n    brackets = strings.Replace(brackets, \"<=\", \"<==(\", -1)\n    brackets = strings.Replace(brackets, \">=\", \">==(\", -1)\n    brackets = strings.Replace(brackets, \"<\", \">\", -1)\n    brackets = strings.Replace(brackets, \"=\", \"==\", -1)\n    brackets = strings.Replace(brackets, \"!=\", \"!=\", -1)\n    brackets = strings.Replace(brackets, \"<=\", \"<\", -1)\n    brackets = strings.Replace(brackets, \">=\", \">\", -1)\n    brackets = strings.Replace(brackets, \"<\", \">=\", -1)\n    brackets = strings.Replace(brackets, \"=\", \"==\", -1)\n    brackets = strings.Replace(brackets, \"!=\", \"!=\", -1)\n    brackets = \nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp0jc_7pi5_test.go:44:6: expected '(', found TestCorrect_Bracketing\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074169
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"{\", -1)\n    brackets = strings.Replace(brackets, \")\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(b\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpe20_095g_test.go:46:33: missing ',' before newline in argument list\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074169
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"{\", -1)\n    brackets = strings.Replace(brackets, \">\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"{\", -1)\n    brackets = strings.Replace(brackets, \">\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(bracket\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpqbb804qd_test.go:45:39: missing ',' before newline in argument list\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074169
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"{\", -1)\n    brackets = strings.Replace(brackets, \")\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"{\", -1)\n    brackets = strings.Replace(brackets, \")\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp11z_cr86_test.go:45:47: string literal not terminated\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074170
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    openingBrackets := make(map[string]bool)\n    closingBrackets := make(map[string]bool)\n    for _, c := range brackets {\n        if c == '(' {\n            openingBrackets[c] = true\n        } else if c == ')' {\n            closingBrackets[c] = true\n        }\n    }\n    for c := range openingBrackets {\n        if !closingBrackets[c] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpb7jgzzxl_test.go:15:29: cannot use c (variable of type rune) as type string in map index\n/tmp/tmpb7jgzzxl_test.go:17:29: cannot use c (variable of type rune) as type string in map index\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074167
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"{\", -1)\n    brackets = strings.Replace(brackets, \")\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp81o7mhpv_test.go:46:6: expected '(', found TestCorrect_Bracketing\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074170
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"{\", -1)\n    brackets = strings.Replace(brackets, \")\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpx0art4nq_test.go:46:6: expected '(', found TestCorrect_Bracketing\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074165
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"{\", -1)\n    brackets = strings.Replace(brackets, \")\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(bracket\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmptb37874q_test.go:45:39: missing ',' before newline in argument list\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074166
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    openingBrackets := make([]string, 0)\n    closingBrackets := make([]string, 0)\n    for _, c := range brackets {\n        if c == '(' {\n            openingBrackets = append(openingBrackets, c)\n        } else {\n            closingBrackets = append(closingBrackets, c)\n        }\n    }\n    if len(openingBrackets) != len(closingBrackets) {\n        return false\n    }\n    for i := 0; i < len(openingBrackets); i++ {\n        if openingBrackets[i] != closingBrackets[i] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3unoidp_test.go:15:55: cannot use c (variable of type rune) as type string in argument to append\n/tmp/tmpe3unoidp_test.go:17:55: cannot use c (variable of type rune) as type string in argument to append\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074171
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    openingBrackets := 0\n    closingBrackets := 0\n    for _, c := range brackets {\n        if c == '(' {\n            openingBrackets++\n        } else if c == ')' {\n            closingBrackets++\n        }\n    }\n    return openingBrackets == closingBrackets\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__5 (0.00s)\n        tmpbs47m96x_test.go:47: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__10 (0.00s)\n        tmpbs47m96x_test.go:47: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "timestamp": 1660074166
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"((\", -1)\n    brackets = strings.Replace(brackets, \")\", \")(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"](\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}(\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"<(\", -1)\n    brackets = strings.Replace(brackets, \">\", \">(\", -1)\n    brackets = strings.Replace(brackets, \"|\", \"|(\", -1)\n    brackets = strings.Replace(brackets, \"~\", \"~(\", -1)\n    brackets = strings.Replace(brackets, \"!\", \"!(\", -1)\n    brackets = strings.Replace(brackets, \"@\", \"@(\", -1)\n    brackets = strings.Replace(brackets, \"$\", \"$(\", -1)\n    brackets = strings.Replace(brackets, \"%\", \"%(\", -1)\n    brackets = strings.Replace(brackets, \"^\", \"^(\", -1)\n    brackets = strings.Replace(brackets, \"&\", \"&(\", -1)\n    brackets = strings.Replace(brackets, \"*\", \"*(\", -1)\n    brackets = strings.Replace(brackets, \"+\", \"+(\", -1)\n    brackets = strings.Replace(brackets, \",\", \",(\", -1)\n    brackets = strings.Replace(brackets, \"-\", \"-(\", -1)\n    brackets = strings.Replace(brackets, \"/\", \"/(\", -1)\n    brackets = strings.Replace(brackets, \"=\", \"=\", -1)\n    brackets = strings.Replace(brackets, \"?\", \"?(\", -1)\n    brackets = strings.Replace(brackets, \"!\", \"!(\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"(\", -1)\n    brackets = strings.Replace(brackets, \")\", \")(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"](\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}(\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"<(\", -1)\n    brackets = strings.Replace(brackets, \nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpufbiz2d__test.go:44:6: expected '(', found TestCorrect_Bracketing\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074170
    },
    {
      "exit_code": 0,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    var count int\n    for _, c := range brackets {\n        if c == '(' {\n            count++\n        }\n        if c == ')' {\n            count--\n        }\n        if count < 0 {\n            return false\n        }\n    }\n    return count == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "timestamp": 1660074171
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"{\", -1)\n    brackets = strings.Replace(brackets, \">\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"<\", -1)\n    brackets = strings.Replace(brackets, \"}\", \">\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"<\", -1)\n    brackets = strings.Replace(brackets, \"]\", \">\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"[\", -1)\n    brackets = strings.Replace(brackets, \">\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"{\", -1)\n    brackets = strings.Replace(brackets, \">\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"{\", -1)\n    brackets = strings.Replace(brackets, \">\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"{\", -1)\n    brackets = strings.Replace(brackets, \">\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpaw7ra16h_test.go:46:6: expected '(', found TestCorrect_Bracketing\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074170
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    openingBrackets := []string{\"(\", \"[\", \"{\"}\n    closingBrackets := []string{\")\", \"]\", \"}\"}\n    for _, openingBracket := range openingBrackets {\n        for _, closingBracket := range closingBrackets {\n            if openingBracket == closingBracket {\n                continue\n            }\n            if brackets[len(brackets)-len(closingBracket):len(brackets)] == openingBracket {\n                return false\n            }\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__4 (0.00s)\n        tmpohebhznw_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__5 (0.00s)\n        tmpohebhznw_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__8 (0.00s)\n        tmpohebhznw_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__9 (0.00s)\n        tmpohebhznw_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__10 (0.00s)\n        tmpohebhznw_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__11 (0.00s)\n        tmpohebhznw_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "timestamp": 1660074166
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    openingBrackets := 0\n    closingBrackets := 0\n    for _, char := range brackets {\n        if char == '(' {\n            openingBrackets++\n        } else if char == ')' {\n            closingBrackets++\n        }\n    }\n    return openingBrackets == closingBrackets\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__5 (0.00s)\n        tmp6w9wqft__test.go:47: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__10 (0.00s)\n        tmp6w9wqft__test.go:47: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "timestamp": 1660074168
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"{\", -1)\n    brackets = strings.Replace(brackets, \">\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"{\", -1)\n    brackets = strings.Replace(brackets, \">\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"{\", -1)\n    brackets = strings.Replace(brackets, \">\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"{\", -1)\n    brackets = strings.Replace(brackets, \">\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"{\", -1)\n    brackets = strings.Replace(brackets, \">\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpk4iyjs_a_test.go:45:42: string literal not terminated\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074170
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    for _, char := range brackets {\n        if char != \")\" && char != \"(\" {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphp1j9pa4_test.go:13:20: invalid operation: char != \")\" (mismatched types rune and untyped string)\n/tmp/tmphp1j9pa4_test.go:13:35: invalid operation: char != \"(\" (mismatched types rune and untyped string)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074166
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    for _, char := range brackets {\n        if char != \")\" && char != \"(\" {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphp1j9pa4_test.go:13:20: invalid operation: char != \")\" (mismatched types rune and untyped string)\n/tmp/tmphp1j9pa4_test.go:13:35: invalid operation: char != \"(\" (mismatched types rune and untyped string)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074166
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"{\", -1)\n    brackets = strings.Replace(brackets, \")\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = \nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp0vlmm1h5_test.go:47:6: expected '(', found TestCorrect_Bracketing\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074168
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    for _, c := range brackets {\n        if c != \"(\" && c != \")\" {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5vkx83_2_test.go:13:17: invalid operation: c != \"(\" (mismatched types rune and untyped string)\n/tmp/tmp5vkx83_2_test.go:13:29: invalid operation: c != \")\" (mismatched types rune and untyped string)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074171
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    openingBrackets := make(map[string]bool)\n    closingBrackets := make(map[string]bool)\n    for _, c := range brackets {\n        if c == '(' {\n            openingBrackets[c] = true\n        } else if c == ')' {\n            closingBrackets[c] = true\n        }\n    }\n    for c := range openingBrackets {\n        if !closingBrackets[c] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpb7jgzzxl_test.go:15:29: cannot use c (variable of type rune) as type string in map index\n/tmp/tmpb7jgzzxl_test.go:17:29: cannot use c (variable of type rune) as type string in map index\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074167
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"{\", -1)\n    brackets = strings.Replace(brackets, \")\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(bracket\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpyg0to0nw_test.go:45:39: missing ',' before newline in argument list\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074171
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"[\", -1)\n    brackets = strings.Replace(brackets, \">\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"<\", -1)\n    brackets = strings.Replace(brackets, \"]\", \">\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"{\", -1)\n    brackets = strings.Replace(brackets, \">\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"<\", -1)\n    brackets = strings.Replace(brackets, \"]\", \">\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"[\", -1)\n    brackets = strings.Replace(brackets, \">\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"<\", -1)\n    brackets = strings.Replace(brackets, \"]\", \">\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"{\", -1)\n    brackets = strings.Replace(brackets, \">\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"<\", -1)\n    brackets = strings.Replace(brackets, \"]\", \">\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"[\", -1)\n    brackets = strings.Replace(brackets, \">\", \"\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpv34uwhw2_test.go:45:47: string literal not terminated\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074171
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = strings.TrimSpace(brackets)\n    if len(brackets) == 0 {\n        return true\n    }\n    brackets = brackets[1 : len(brackets)-1]\n    for _, char := range brackets {\n        if char != \")\" && char != \"(\" {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkaj1ts8r_test.go:11:16: undefined: strings\n/tmp/tmpkaj1ts8r_test.go:17:20: invalid operation: char != \")\" (mismatched types rune and untyped string)\n/tmp/tmpkaj1ts8r_test.go:17:35: invalid operation: char != \"(\" (mismatched types rune and untyped string)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074172
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"{\", -1)\n    brackets = strings.Replace(brackets, \")\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpwxizoumh_test.go:46:6: expected '(', found TestCorrect_Bracketing\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074171
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"{\", -1)\n    brackets = strings.Replace(brackets, \")\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpoi32zl4k_test.go:47:1: expected selector or type assertion, found 'func'\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074171
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"{\", -1)\n    brackets = strings.Replace(brackets, \")\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp1wgvttto_test.go:45:47: string literal not terminated\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074171
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"((\", -1)\n    brackets = strings.Replace(brackets, \")\", \")(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"](\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}(\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"<(\", -1)\n    brackets = strings.Replace(brackets, \">\", \">(\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"((\", -1)\n    brackets = strings.Replace(brackets, \")\", \"))\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"](\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}(\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"<(\", -1)\n    brackets = strings.Replace(brackets, \">\", \">(\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"((\", -1)\n    brackets = strings.Replace(brackets, \")\", \"))\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"](\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}(\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"<(\", -1)\n    brackets = strings.Replace(brackets, \">\", \">(\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"((\", -1)\n    brackets = strings.Replace(brackets, \")\", \"))\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"](\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}(\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"<(\", -1)\n    brackets = strings.Replace(bracket\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpc6veawww_test.go:43:39: missing ',' before newline in argument list\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074168
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"{\", -1)\n    brackets = strings.Replace(brackets, \")\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"{\", -1)\n    brackets = strings.Replace(brackets, \")\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", \nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp67mruykx_test.go:46:6: expected '(', found TestCorrect_Bracketing\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074171
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"{\", -1)\n    brackets = strings.Replace(brackets, \")\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpcfa4may3_test.go:46:6: expected '(', found TestCorrect_Bracketing\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074171
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    for _, c := range brackets {\n        if c != \"(\" && c != \")\" {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5vkx83_2_test.go:13:17: invalid operation: c != \"(\" (mismatched types rune and untyped string)\n/tmp/tmp5vkx83_2_test.go:13:29: invalid operation: c != \")\" (mismatched types rune and untyped string)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074171
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    var openingBrackets []string\n    var closingBrackets []string\n\n    for _, char := range brackets {\n        if char == '(' {\n            openingBrackets = append(openingBrackets, char)\n        } else {\n            closingBrackets = append(closingBrackets, char)\n        }\n    }\n\n    if len(openingBrackets) != len(closingBrackets) {\n        return false\n    }\n\n    for i := 0; i < len(openingBrackets); i++ {\n        if openingBrackets[i] != closingBrackets[i] {\n            return false\n        }\n    }\n\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptl5ak73i_test.go:16:55: cannot use char (variable of type rune) as type string in argument to append\n/tmp/tmptl5ak73i_test.go:18:55: cannot use char (variable of type rune) as type string in argument to append\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074172
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"()\", -1)\n    brackets = strings.Replace(brackets, \")\", \"()\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"[]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{}\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"{}\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"<\", -1)\n    brackets = strings.Replace(brackets, \">\", \">\", -1)\n    brackets = strings.Replace(brackets, \"&\", \"&\", -1)\n    brackets = strings.Replace(brackets, \"|\", \"|\", -1)\n    brackets = strings.Replace(brackets, \"!\", \"!\", -1)\n    brackets = strings.Replace(brackets, \"=\", \"=\", -1)\n    brackets = strings.Replace(brackets, \"?\", \"?\", -1)\n    brackets = strings.Replace(brackets, \"+\", \"+\", -1)\n    brackets = strings.Replace(brackets, \"-\", \"-\", -1)\n    brackets = strings.Replace(brackets, \"*\", \"*\", -1)\n    brackets = strings.Replace(brackets, \"/\", \"/\", -1)\n    brackets = strings.Replace(brackets, \"%\", \"%\", -1)\n    brackets = strings.Replace(brackets, \"^\", \"^\", -1)\n    brackets = strings.Replace(brackets, \"~\", \"~\", -1)\n    brackets = strings.Replace(brackets, \"`\", \"`\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"|\", \"|\", -1)\n    brackets = strings.Replace(brackets, \"!\", \"!\", -1)\n    brackets = strings.Replace(brackets, \"=\", \"=\", -1)\n    brackets = strings.Replace(brackets, \"?\", \"?\", -1)\n    brackets = strings.Replace(brackets, \"+\", \"+\", -1)\n    brackets = strings.Replace(brackets, \"-\", \"-\", -1)\n    brackets = strings.Replace(brackets, \"*\", \"*\", -1)\n    brackets = strings.Replace(brackets, \"/\", \"/\", -1)\n    brackets = strings.Replace(brackets, \"%\", \"\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmperflmo6l_test.go:45:47: string literal not terminated\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074171
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    openingBrackets := 0\n    closingBrackets := 0\n    for _, char := range brackets {\n        if char == '(' {\n            openingBrackets++\n        } else if char == ')' {\n            closingBrackets++\n        }\n    }\n    return openingBrackets == closingBrackets\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\npanic: runtime error: slice bounds out of range [1:0] [recovered]\n\tpanic: runtime error: slice bounds out of range [1:0]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838 +0x207\ncommand-line-arguments_test.correct_bracketing(...)\n\t/tmp/tmprw9z5f3j_test.go:11\ncommand-line-arguments_test.TestCorrect_Bracketing(0x0?)\n\t/tmp/tmprw9z5f3j_test.go:37 +0x1be\ntesting.tRunner(0xc0000da1a0, 0x527d80)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486 +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "timestamp": 1660074168
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    for _, char := range brackets {\n        if char != \")\" && char != \"(\" {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphp1j9pa4_test.go:13:20: invalid operation: char != \")\" (mismatched types rune and untyped string)\n/tmp/tmphp1j9pa4_test.go:13:35: invalid operation: char != \"(\" (mismatched types rune and untyped string)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074166
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"{\", -1)\n    brackets = strings.Replace(brackets, \">\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"{\", -1)\n    brackets = strings.Replace(brackets, \">\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(bracket\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpmy0fh_ua_test.go:45:39: missing ',' before newline in argument list\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074171
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    for _, char := range brackets {\n        if char != \")\" && char != \"(\" {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphp1j9pa4_test.go:13:20: invalid operation: char != \")\" (mismatched types rune and untyped string)\n/tmp/tmphp1j9pa4_test.go:13:35: invalid operation: char != \"(\" (mismatched types rune and untyped string)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074166
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp1y0wfne8_test.go:45:42: string literal not terminated\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074171
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    for _, opening := range brackets {\n        if opening != \"(\" {\n            return false\n        }\n    }\n    for _, closing := range brackets {\n        if closing != \")\" {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5ziih_nz_test.go:13:23: invalid operation: opening != \"(\" (mismatched types rune and untyped string)\n/tmp/tmp5ziih_nz_test.go:18:23: invalid operation: closing != \")\" (mismatched types rune and untyped string)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074172
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    openingBrackets := 0\n    closingBrackets := 0\n    for _, c := range brackets {\n        if c == '(' {\n            openingBrackets++\n        } else if c == ')' {\n            closingBrackets++\n        }\n    }\n    return openingBrackets == closingBrackets\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__5 (0.00s)\n        tmpbs47m96x_test.go:47: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__10 (0.00s)\n        tmpbs47m96x_test.go:47: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "timestamp": 1660074166
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"{\", -1)\n    brackets = strings.Replace(brackets, \">\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(bra\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp4uj715xw_test.go:45:35: missing ',' before newline in argument list\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074171
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"{\", -1)\n    brackets = strings.Replace(brackets, \")\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    \nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpn6djwx4h_test.go:47:6: expected '(', found TestCorrect_Bracketing\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074171
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    openingBrackets := make(map[string]bool)\n    closingBrackets := make(map[string]bool)\n    for _, c := range brackets {\n        if c == '(' {\n            openingBrackets[c] = true\n        } else {\n            closingBrackets[c] = true\n        }\n    }\n    for c := range openingBrackets {\n        if !closingBrackets[c] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpasq7ses6_test.go:15:29: cannot use c (variable of type rune) as type string in map index\n/tmp/tmpasq7ses6_test.go:17:29: cannot use c (variable of type rune) as type string in map index\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074173
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"{\", -1)\n    brackets = strings.Replace(brackets, \")\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"{\", -1)\n    brackets = strings.Replace(brackets, \")\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp70zsjn0b_test.go:46:6: expected '(', found TestCorrect_Bracketing\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074168
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"{\", -1)\n    brackets = strings.Replace(brackets, \")\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(bracket\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpr9wguyxn_test.go:45:39: missing ',' before newline in argument list\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074172
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"((\", -1)\n    brackets = strings.Replace(brackets, \")\", \")(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"](\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}(\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"<(\", -1)\n    brackets = strings.Replace(brackets, \">\", \">(\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}(\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"<(\", -1)\n    brackets = strings.Replace(brackets, \">\", \">(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"](\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"((\", -1)\n    brackets = strings.Replace(brackets, \")\", \")(\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"<(\", -1)\n    brackets = strings.Replace(brackets, \">\", \">(\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}(\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"<(\", -1)\n    brackets = strings.Replace(brackets, \">\", \">(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"](\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"((\", -1)\n    brackets = strings.Replace(brackets, \")\", \")(\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"<(\", -1)\n    brackets = strings.Replace(brackets, \">\", \">(\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}(\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"<(\", -1)\n    brackets = strings.Replace\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpiehsv59t_test.go:44:6: expected '(', found TestCorrect_Bracketing\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074172
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    openingBrackets := brackets[0 : len(brackets)-1]\n    closingBrackets := brackets[len(brackets)-1:]\n    for _, openingBracket := range openingBrackets {\n        if closingBrackets[len(closingBrackets)-1] != openingBracket {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpesdjxuci_test.go:14:55: invalid operation: closingBrackets[len(closingBrackets) - 1] != openingBracket (mismatched types byte and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074169
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"{\", -1)\n    brackets = strings.Replace(brackets, \")\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp62kqt_a6_test.go:45:47: string literal not terminated\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074172
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    openingBrackets := make(map[string]bool)\n    closingBrackets := make(map[string]bool)\n    for _, c := range brackets {\n        if c == '(' {\n            openingBrackets[c] = true\n        } else if c == ')' {\n            closingBrackets[c] = true\n        }\n    }\n    for c := range openingBrackets {\n        if !closingBrackets[c] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpb7jgzzxl_test.go:15:29: cannot use c (variable of type rune) as type string in map index\n/tmp/tmpb7jgzzxl_test.go:17:29: cannot use c (variable of type rune) as type string in map index\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074167
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    openingBrackets := 0\n    closingBrackets := 0\n    for _, c := range brackets {\n        if c == '(' {\n            openingBrackets++\n        } else if c == ')' {\n            closingBrackets++\n        }\n    }\n    return openingBrackets == closingBrackets\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__5 (0.00s)\n        tmpbs47m96x_test.go:47: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__10 (0.00s)\n        tmpbs47m96x_test.go:47: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "timestamp": 1660074166
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    openingBrackets := make([]string, 0)\n    closingBrackets := make([]string, 0)\n    for _, char := range brackets {\n        if char == '(' {\n            openingBrackets = append(openingBrackets, char)\n        } else {\n            closingBrackets = append(closingBrackets, char)\n        }\n    }\n    if len(openingBrackets) != len(closingBrackets) {\n        return false\n    }\n    for i := 0; i < len(openingBrackets); i++ {\n        if openingBrackets[i] != closingBrackets[i] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmps244y73c_test.go:16:55: cannot use char (variable of type rune) as type string in argument to append\n/tmp/tmps244y73c_test.go:18:55: cannot use char (variable of type rune) as type string in argument to append\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074173
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"{\", -1)\n    brackets = strings.Replace(brackets, \")\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = \nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp0vlmm1h5_test.go:47:6: expected '(', found TestCorrect_Bracketing\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074168
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpgd9260yu_test.go:45:47: string literal not terminated\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074173
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"{\", -1)\n    brackets = strings.Replace(brackets, \">\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"<\", -1)\n    brackets = strings.Replace(brackets, \"}\", \">\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"<\", -1)\n    brackets = strings.Replace(brackets, \"]\", \">\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"[\", -1)\n    brackets = strings.Replace(brackets, \">\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"{\", -1)\n    brackets = strings.Replace(brackets, \">\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"<\", -1)\n    brackets = strings.Replace(brackets, \"}\", \">\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"<\", -1)\n    brackets = strings.Replace(brackets, \"]\", \">\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"[\", -1)\n    brackets = strings.Replace(brackets, \">\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"{\", -1)\n    brackets = strings.Replace(brackets, \">\", \"\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpqonlm7f1_test.go:45:47: string literal not terminated\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074165
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    for _, char := range brackets {\n        if char != \"(\" && char != \")\" {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7y72gket_test.go:13:20: invalid operation: char != \"(\" (mismatched types rune and untyped string)\n/tmp/tmp7y72gket_test.go:13:35: invalid operation: char != \")\" (mismatched types rune and untyped string)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074169
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : \nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpsfh5e8xv_test.go:58:6: expected '(', found TestCorrect_Bracketing\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074173
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"{\", -1)\n    brackets = strings.Replace(brackets, \">\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"<\", -1)\n    brackets = strings.Replace(brackets, \"}\", \">\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"<\", -1)\n    brackets = strings.Replace(brackets, \"]\", \">\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"[\", -1)\n    brackets = strings.Replace(brackets, \">\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"{\", -1)\n    brackets = strings.Replace(brackets, \">\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"<\", -1)\n    brackets = strings.Replace(brackets, \"}\", \">\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"<\", -1)\n    brackets = strings.Replace(brackets, \"]\", \">\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"[\", -1)\n    brackets = strings.Replace(brackets, \">\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"{\", -1)\n    brackets = strings.Replace(brackets, \">\", \"\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpqonlm7f1_test.go:45:47: string literal not terminated\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074165
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    for _, c := range brackets {\n        if c != ')' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\npanic: runtime error: slice bounds out of range [1:0] [recovered]\n\tpanic: runtime error: slice bounds out of range [1:0]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838 +0x207\ncommand-line-arguments_test.correct_bracketing(...)\n\t/tmp/tmp_5inqdgl_test.go:11\ncommand-line-arguments_test.TestCorrect_Bracketing(0x0?)\n\t/tmp/tmp_5inqdgl_test.go:33 +0x1dc\ntesting.tRunner(0xc0000da340, 0x527d80)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486 +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "timestamp": 1660074166
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    openingBrackets := 0\n    closingBrackets := 0\n    for _, char := range brackets {\n        if char == '(' {\n            openingBrackets++\n        } else if char == ')' {\n            closingBrackets++\n        }\n    }\n    return openingBrackets == closingBrackets\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__5 (0.00s)\n        tmp6w9wqft__test.go:47: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__10 (0.00s)\n        tmp6w9wqft__test.go:47: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "timestamp": 1660074168
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    openingBrackets := brackets[0 : len(brackets)-1]\n    closingBrackets := brackets[len(brackets)-1:]\n    for _, openingBracket := range openingBrackets {\n        if closingBrackets[len(closingBrackets)-1] != openingBracket {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpesdjxuci_test.go:14:55: invalid operation: closingBrackets[len(closingBrackets) - 1] != openingBracket (mismatched types byte and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074169
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    for _, c := range brackets {\n        if c != ')' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\npanic: runtime error: slice bounds out of range [1:0] [recovered]\n\tpanic: runtime error: slice bounds out of range [1:0]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838 +0x207\ncommand-line-arguments_test.correct_bracketing(...)\n\t/tmp/tmp_5inqdgl_test.go:11\ncommand-line-arguments_test.TestCorrect_Bracketing(0x0?)\n\t/tmp/tmp_5inqdgl_test.go:33 +0x1dc\ntesting.tRunner(0xc0000da340, 0x527d80)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486 +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "timestamp": 1660074166
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"((\", -1)\n    brackets = strings.Replace(brackets, \")\", \")(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"](\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}(\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"<(\", -1)\n    brackets = strings.Replace(brackets, \">\", \">(\", -1)\n    brackets = strings.Replace(brackets, \"|\", \"|(\", -1)\n    brackets = strings.Replace(brackets, \"/\", \"/((\", -1)\n    brackets = strings.Replace(brackets, \"\\\\\", \"/((\", -1)\n    brackets = strings.Replace(brackets, \"!\", \"/((\", -1)\n    brackets = strings.Replace(brackets, \"$\", \"/((\", -1)\n    brackets = strings.Replace(brackets, \"%\", \"/((\", -1)\n    brackets = strings.Replace(brackets, \"^\", \"/((\", -1)\n    brackets = strings.Replace(brackets, \"&\", \"/((\", -1)\n    brackets = strings.Replace(brackets, \"*\", \"/((\", -1)\n    brackets = strings.Replace(brackets, \"-\", \"/((\", -1)\n    brackets = strings.Replace(brackets, \"+\", \"/((\", -1)\n    brackets = strings.Replace(brackets, \"=\", \"/((\", -1)\n    brackets = strings.Replace(brackets, \"?\", \"/((\", -1)\n    brackets = strings.Replace(brackets, \"!\", \"/((\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"((\", -1)\n    brackets = strings.Replace(brackets, \")\", \")(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"](\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}(\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"<(\", -1)\n    brackets = strings.Replace(brackets, \">\", \">(\", -1)\n    brackets = strings.Replace(brackets, \"|\", \"|(\", -1)\n    brackets = strings.Replace\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpmrdand6s_test.go:44:6: expected '(', found TestCorrect_Bracketing\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074173
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"((\", -1)\n    brackets = strings.Replace(brackets, \")\", \")(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"](\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}(\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"<(\", -1)\n    brackets = strings.Replace(brackets, \">\", \">(\", -1)\n    brackets = strings.Replace(brackets, \"/\", \"/((\", -1)\n    brackets = strings.Replace(brackets, \"\\\\\", \"/((\", -1)\n    brackets = strings.Replace(brackets, \"|\", \"|(\", -1)\n    brackets = strings.Replace(brackets, \"-\", \"-(\", -1)\n    brackets = strings.Replace(brackets, \"_\", \"_(\", -1)\n    brackets = strings.Replace(brackets, \"+\", \"+(\", -1)\n    brackets = strings.Replace(brackets, \"=\", \"=((\", -1)\n    brackets = strings.Replace(brackets, \"!\", \"!(\", -1)\n    brackets = strings.Replace(brackets, \"?\", \"?(\", -1)\n    brackets = strings.Replace(brackets, \"%\", \"%(\", -1)\n    brackets = strings.Replace(brackets, \"$\", \"$(\", -1)\n    brackets = strings.Replace(brackets, \"@\", \"@(\", -1)\n    brackets = strings.Replace(brackets, \"~\", \"~(\", -1)\n    brackets = strings.Replace(brackets, \"^\", \"^(\", -1)\n    brackets = strings.Replace(brackets, \"&\", \"&(\", -1)\n    brackets = strings.Replace(brackets, \"*\", \"*(\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"((\", -1)\n    brackets = strings.Replace(brackets, \")\", \")(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"](\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}(\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"<(\", -1)\n    brackets = strings.Replace(b\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp_7acyi4n_test.go:43:33: missing ',' before newline in argument list\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074173
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    openingBrackets := make(map[string]bool)\n    closingBrackets := make(map[string]bool)\n    for _, c := range brackets {\n        if c == '(' {\n            openingBrackets[c] = true\n        } else if c == ')' {\n            closingBrackets[c] = true\n        }\n    }\n    for c := range openingBrackets {\n        if !closingBrackets[c] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpb7jgzzxl_test.go:15:29: cannot use c (variable of type rune) as type string in map index\n/tmp/tmpb7jgzzxl_test.go:17:29: cannot use c (variable of type rune) as type string in map index\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074167
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"{\", -1)\n    brackets = strings.Replace(brackets, \")\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"{\", -1)\n    brackets = strings.Replace(brackets, \")\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp70zsjn0b_test.go:46:6: expected '(', found TestCorrect_Bracketing\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074168
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"()\", -1)\n    brackets = strings.Replace(brackets, \")\", \"()\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"[]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{}\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"{}\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"<\", -1)\n    brackets = strings.Replace(brackets, \">\", \">\", -1)\n    brackets = strings.Replace(brackets, \"&\", \"&\", -1)\n    brackets = strings.Replace(brackets, \"|\", \"|\", -1)\n    brackets = strings.Replace(brackets, \"!\", \"!\", -1)\n    brackets = strings.Replace(brackets, \"=\", \"=\", -1)\n    brackets = strings.Replace(brackets, \"?\", \"?\", -1)\n    brackets = strings.Replace(brackets, \"-\", \"-\", -1)\n    brackets = strings.Replace(brackets, \"_\", \"_\", -1)\n    brackets = strings.Replace(brackets, \"/\", \"//\", -1)\n    brackets = strings.Replace(brackets, \"\\\\\", \"\\\\\", -1)\n    brackets = strings.Replace(brackets, \"\\\"\", \"\\\"\", -1)\n    brackets = strings.Replace(brackets, \"\\n\", \"\", -1)\n    brackets = strings.Replace(brackets, \"\\r\", \"\", -1)\n    brackets = strings.Replace(brackets, \"\\t\", \"\", -1)\n    brackets = strings.Replace(brackets, \"\\0\", \"\", -1)\n    brackets = strings.Replace(brackets, \"\\\"\", \"\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"\", -1)\n    brackets = strings.Replace(brackets, \">\", \"\", -1)\n    brackets = strings.Replace(brackets, \"&\", \"\", -1)\n    brackets = strings.Replace(brackets, \"|\", \"\", -1)\n    brackets = strings.Replace(brackets, \"!\", \"\", -1)\n    brackets = strings.Replace(brackets, \"=\", \"\", -1)\n    brackets = strings.Replace(brackets, \"?\", \"\", -1)\n    brackets = strings.Replace(brackets, \"-\", \"\", -1)\n    brackets = strings.Replace(brackets, \"_\", \"\", -1)\n    brackets = strings.Replace(brackets, \"/\", \"\", -1)\n    brackets = strings.Replace(brackets, \"\\\\\", \"\", -1)\n    brackets = strings.Replace(bracket\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp0k7j9f8u_test.go:33:45: illegal character U+0022 '\"' in escape sequence\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074173
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    for _, c := range brackets {\n        if c != \"(\" && c != \")\" {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5vkx83_2_test.go:13:17: invalid operation: c != \"(\" (mismatched types rune and untyped string)\n/tmp/tmp5vkx83_2_test.go:13:29: invalid operation: c != \")\" (mismatched types rune and untyped string)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074171
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"[\", -1)\n    brackets = strings.Replace(brackets, \">\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"<\", -1)\n    brackets = strings.Replace(brackets, \"]\", \">\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"{\", -1)\n    brackets = strings.Replace(brackets, \">\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"[\", -1)\n    brackets = strings.Replace(brackets, \">\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"<\", -1)\n    brackets = strings.Replace(brackets, \"]\", \">\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"[\", -1)\n    brackets = strings.Replace(brackets, \">\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"<\", -1)\n    brackets = strings.Replace(brackets, \"]\", \">\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"[\", -1)\n    brackets = strings.Replace(brackets, \">\", \"]\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpfivoqyx9_test.go:45:47: string literal not terminated\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074168
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    openingBrackets := []string{\"(\", \"[\", \"{\"}\n    closingBrackets := []string{\")\", \"]\", \"}\"}\n    for _, openingBracket := range openingBrackets {\n        if brackets == openingBracket {\n            return false\n        }\n    }\n    for _, closingBracket := range closingBrackets {\n        if brackets == closingBracket {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__4 (0.00s)\n        tmpuoi4f1kh_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__5 (0.00s)\n        tmpuoi4f1kh_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__7 (0.00s)\n        tmpuoi4f1kh_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__9 (0.00s)\n        tmpuoi4f1kh_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__10 (0.00s)\n        tmpuoi4f1kh_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__11 (0.00s)\n        tmpuoi4f1kh_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "timestamp": 1660074174
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"[\", -1)\n    brackets = strings.Replace(brackets, \">\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"<\", -1)\n    brackets = strings.Replace(brackets, \"]\", \">\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"{\", -1)\n    brackets = strings.Replace(brackets, \")\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \")\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"{\", -1)\n    brackets = strings.Replace(brackets, \">\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"<\", -1)\n    brackets = strings.Replace(brackets, \"]\", \">\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"[\", -1)\n    brackets = strings.Replace(brackets, \">\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"<\", -1)\n    brackets = strings.Replace(brackets, \"]\", \">\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"{\", -1)\n    brackets = strings.Replace(brackets, \")\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \")\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"{\", -1)\n    brackets = strings.Replace(brackets, \">\", \"\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpvde2jp8u_test.go:45:47: string literal not terminated\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074173
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"((\", -1)\n    brackets = strings.Replace(brackets, \")\", \")(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"](\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}(\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"<(\", -1)\n    brackets = strings.Replace(brackets, \">\", \">(\", -1)\n    brackets = strings.Replace(brackets, \"|\", \"|(\", -1)\n    brackets = strings.Replace(brackets, \"!\", \"!(\", -1)\n    brackets = strings.Replace(brackets, \"?\", \"?(\", -1)\n    brackets = strings.Replace(brackets, \"=\", \"=(\", -1)\n    brackets = strings.Replace(brackets, \"-\", \"(-(\", -1)\n    brackets = strings.Replace(brackets, \",\", \",(\", -1)\n    brackets = strings.Replace(brackets, \"/\", \"/(\", -1)\n    brackets = strings.Replace(brackets, \"\\\\\", \"\\\\(\", -1)\n    brackets = strings.Replace(brackets, \"*\", \"*(\", -1)\n    brackets = strings.Replace(brackets, \"%\", \"%(\", -1)\n    brackets = strings.Replace(brackets, \"$\", \"$(\", -1)\n    brackets = strings.Replace(brackets, \"@\", \"@(\", -1)\n    brackets = strings.Replace(brackets, \"^\", \"^(\", -1)\n    brackets = strings.Replace(brackets, \"~\", \"~(\", -1)\n    brackets = strings.Replace(brackets, \"&\", \"&(\", -1)\n    brackets = strings.Replace(brackets, \"=\", \"=(\", -1)\n    brackets = strings.Replace(brackets, \"|\", \"|(\", -1)\n    brackets = strings.Replace(brackets, \"!\", \"!(\", -1)\n    brackets = strings.Replace(brackets, \"?\", \"?(\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"<(\", -1)\n    brackets = strings.Replace(brackets, \">\", \">(\", -1)\n    brackets = strings.Replace(brackets, \"-\", \"(-(\", -1)\n    brackets = strings.Replace(brackets, \",\", \",(\", -1)\n    brackets = strings.Replace(b\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmppey__vjz_test.go:43:33: missing ',' before newline in argument list\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074173
    },
    {
      "exit_code": 0,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    var count int\n    for _, c := range brackets {\n        if c == '(' {\n            count++\n        } else if c == ')' {\n            count--\n        }\n        if count < 0 {\n            return false\n        }\n    }\n    return count == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "timestamp": 1660074174
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    for _, char := range brackets {\n        if char != \")\" && char != \"(\" {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphp1j9pa4_test.go:13:20: invalid operation: char != \")\" (mismatched types rune and untyped string)\n/tmp/tmphp1j9pa4_test.go:13:35: invalid operation: char != \"(\" (mismatched types rune and untyped string)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074166
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    openingBrackets := 0\n    closingBrackets := 0\n    for _, c := range brackets {\n        if c == '(' {\n            openingBrackets++\n        } else if c == ')' {\n            closingBrackets++\n        }\n    }\n    return openingBrackets == closingBrackets\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__5 (0.00s)\n        tmpbs47m96x_test.go:47: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__10 (0.00s)\n        tmpbs47m96x_test.go:47: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "timestamp": 1660074166
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    var opening_brackets []string\n    var closing_brackets []string\n    for _, char := range brackets {\n        if char == \"(\" {\n            opening_brackets = append(opening_brackets, char)\n        } else {\n            closing_brackets = append(closing_brackets, char)\n        }\n    }\n    if len(opening_brackets) != len(closing_brackets) {\n        return false\n    }\n    for i := 0; i < len(opening_brackets); i++ {\n        if opening_brackets[i] != closing_brackets[i] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpy8yl42na_test.go:14:20: invalid operation: char == \"(\" (mismatched types rune and untyped string)\n/tmp/tmpy8yl42na_test.go:15:57: cannot use char (variable of type rune) as type string in argument to append\n/tmp/tmpy8yl42na_test.go:17:57: cannot use char (variable of type rune) as type string in argument to append\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074174
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"{\", -1)\n    brackets = strings.Replace(brackets, \")\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp3340phxn_test.go:45:42: string literal not terminated\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074173
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"{\", -1)\n    brackets = strings.Replace(brackets, \">\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"<\", -1)\n    brackets = strings.Replace(brackets, \"}\", \">\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"<\", -1)\n    brackets = strings.Replace(brackets, \"]\", \">\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"[\", -1)\n    brackets = strings.Replace(brackets, \">\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"{\", -1)\n    brackets = strings.Replace(brackets, \">\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"<\", -1)\n    brackets = strings.Replace(brackets, \"}\", \">\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"[\", -1)\n    brackets = strings.Replace(brackets, \">\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"[\", -1)\n    brackets = strings.Replace(brackets, \">\", \nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpyg6g9pzt_test.go:46:6: expected '(', found TestCorrect_Bracketing\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074173
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"{\", -1)\n    brackets = strings.Replace(brackets, \">\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"<\", -1)\n    brackets = strings.Replace(brackets, \"}\", \">\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"<\", -1)\n    brackets = strings.Replace(brackets, \"]\", \">\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"[\", -1)\n    brackets = strings.Replace(brackets, \">\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"{\", -1)\n    brackets = strings.Replace(brackets, \">\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"[\", -1)\n    brackets = strings.Replace(brackets, \">\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"[\", -1)\n    brackets = strings.Replace(brackets, \">\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"[\", -1)\n    brackets = strings.Replace(brackets, \">\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", \nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpoy1iyags_test.go:46:6: expected '(', found TestCorrect_Bracketing\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074173
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    for _, c := range brackets {\n        if c != \")\" && c != \"(\" {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpu_ny8211_test.go:13:17: invalid operation: c != \")\" (mismatched types rune and untyped string)\n/tmp/tmpu_ny8211_test.go:13:29: invalid operation: c != \"(\" (mismatched types rune and untyped string)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074166
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : \nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpsfh5e8xv_test.go:58:6: expected '(', found TestCorrect_Bracketing\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074173
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"{\", -1)\n    brackets = strings.Replace(brackets, \")\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpoqacm_uo_test.go:46:6: expected '(', found TestCorrect_Bracketing\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074173
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"{\", -1)\n    brackets = strings.Replace(brackets, \")\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(bracket\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpv9a_vmpe_test.go:45:39: missing ',' before newline in argument list\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074165
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    for _, char := range brackets {\n        if char != \")\" && char != \"(\" {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphp1j9pa4_test.go:13:20: invalid operation: char != \")\" (mismatched types rune and untyped string)\n/tmp/tmphp1j9pa4_test.go:13:35: invalid operation: char != \"(\" (mismatched types rune and untyped string)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074166
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    for _, char := range brackets {\n        if char != \")\" && char != \"(\" {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnwuj_ovp_test.go:14:20: invalid operation: char != \")\" (mismatched types rune and untyped string)\n/tmp/tmpnwuj_ovp_test.go:14:35: invalid operation: char != \"(\" (mismatched types rune and untyped string)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074174
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    openingBrackets := make(map[string]bool)\n    closingBrackets := make(map[string]bool)\n    for _, c := range brackets {\n        if c == '(' {\n            openingBrackets[c] = true\n        } else {\n            closingBrackets[c] = true\n        }\n    }\n    for c := range openingBrackets {\n        if !closingBrackets[c] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpasq7ses6_test.go:15:29: cannot use c (variable of type rune) as type string in map index\n/tmp/tmpasq7ses6_test.go:17:29: cannot use c (variable of type rune) as type string in map index\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074173
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"((\", -1)\n    brackets = strings.Replace(brackets, \")\", \")(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"](\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}(\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"<(\", -1)\n    brackets = strings.Replace(brackets, \">\", \">(\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"((\", -1)\n    brackets = strings.Replace(brackets, \")\", \")(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"](\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}(\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"<(\", -1)\n    brackets = strings.Replace(brackets, \">\", \">(\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"((\", -1)\n    brackets = strings.Replace(brackets, \")\", \")(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"](\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}(\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"<(\", -1)\n    brackets = strings.Replace(brackets, \">\", \">(\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"((\", -1)\n    brackets = strings.Replace(brackets, \")\", \")(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"](\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}(\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"<(\", -1)\n    brackets = strings.Replace\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp1medocbc_test.go:44:6: expected '(', found TestCorrect_Bracketing\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074173
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = brackets[0 : len(brackets)-1]\n    brackets = brackets[1 : \nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpsfh5e8xv_test.go:58:6: expected '(', found TestCorrect_Bracketing\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074173
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"{\", -1)\n    brackets = strings.Replace(brackets, \")\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(bracket\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp9q7qlxel_test.go:45:39: missing ',' before newline in argument list\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074173
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    openingBrackets := []string{\"(\", \"[\", \"{\"}\n    closingBrackets := []string{\")\", \"]\", \"}\"}\n    for _, openingBracket := range openingBrackets {\n        for _, closingBracket := range closingBrackets {\n            if openingBracket == closingBracket {\n                continue\n            }\n            if brackets[len(brackets)-len(closingBracket):len(brackets)] == openingBracket {\n                return false\n            }\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__4 (0.00s)\n        tmpohebhznw_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__5 (0.00s)\n        tmpohebhznw_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__8 (0.00s)\n        tmpohebhznw_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__9 (0.00s)\n        tmpohebhznw_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__10 (0.00s)\n        tmpohebhznw_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__11 (0.00s)\n        tmpohebhznw_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "timestamp": 1660074166
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"{\", -1)\n    brackets = strings.Replace(brackets, \")\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"]\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpi7033sy5_test.go:45:42: string literal not terminated\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074173
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = strings.TrimSpace(brackets)\n    if len(brackets) == 0 {\n        return false\n    }\n    brackets = brackets[1 : len(brackets)-1]\n    for _, char := range brackets {\n        if char != \")\" && char != \"(\" {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2suxy3pl_test.go:11:16: undefined: strings\n/tmp/tmp2suxy3pl_test.go:17:20: invalid operation: char != \")\" (mismatched types rune and untyped string)\n/tmp/tmp2suxy3pl_test.go:17:35: invalid operation: char != \"(\" (mismatched types rune and untyped string)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074174
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    openingBrackets := make(map[string]bool)\n    closingBrackets := make(map[string]bool)\n    for _, c := range brackets {\n        if c == '(' {\n            openingBrackets[c] = true\n        } else if c == ')' {\n            closingBrackets[c] = true\n        }\n    }\n    for c := range openingBrackets {\n        if !closingBrackets[c] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpb7jgzzxl_test.go:15:29: cannot use c (variable of type rune) as type string in map index\n/tmp/tmpb7jgzzxl_test.go:17:29: cannot use c (variable of type rune) as type string in map index\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074167
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"{\", -1)\n    brackets = strings.Replace(brackets, \")\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(bracket\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpv9a_vmpe_test.go:45:39: missing ',' before newline in argument list\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074165
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    openingBrackets := make([]string, 0)\n    closingBrackets := make([]string, 0)\n    for _, c := range brackets {\n        if c == '(' {\n            openingBrackets = append(openingBrackets, c)\n        } else {\n            closingBrackets = append(closingBrackets, c)\n        }\n    }\n    return len(openingBrackets) == len(closingBrackets)\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6qeh05nm_test.go:16:55: cannot use c (variable of type rune) as type string in argument to append\n/tmp/tmp6qeh05nm_test.go:18:55: cannot use c (variable of type rune) as type string in argument to append\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074174
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    openingBrackets := brackets[:len(brackets)-1]\n    closingBrackets := brackets[len(brackets)-1:]\n    for _, openingBracket := range openingBrackets {\n        if closingBrackets[openingBracket] == \"\" {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpk4j3_m92_test.go:14:47: invalid operation: closingBrackets[openingBracket] == \"\" (mismatched types byte and untyped string)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074174
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"{\", -1)\n    brackets = strings.Replace(brackets, \")\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(bracket\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpv9a_vmpe_test.go:45:39: missing ',' before newline in argument list\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074165
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    openingBrackets := []string{\"(\", \"[\", \"{\"}\n    closingBrackets := []string{\")\", \"]\", \"}\"}\n    for _, openingBracket := range openingBrackets {\n        for _, closingBracket := range closingBrackets {\n            if openingBracket == closingBracket {\n                continue\n            }\n            if brackets[len(brackets)-1-len(closingBracket):len(brackets)-1] == openingBracket {\n                return false\n            }\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\npanic: runtime error: slice bounds out of range [:-1] [recovered]\n\tpanic: runtime error: slice bounds out of range [:-1]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x513440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838 +0x207\ncommand-line-arguments_test.correct_bracketing(...)\n\t/tmp/tmp2esq37zn_test.go:19\ncommand-line-arguments_test.TestCorrect_Bracketing(0x0?)\n\t/tmp/tmp2esq37zn_test.go:34 +0xf74\ntesting.tRunner(0xc0000cc4e0, 0x528d80)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486 +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "timestamp": 1660074174
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = strings.TrimSpace(brackets)\n    brackets = strings.Replace(brackets, \"(\", \"((\", -1)\n    brackets = strings.Replace(brackets, \")\", \")(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"](\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}(\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"<(\", -1)\n    brackets = strings.Replace(brackets, \">\", \">(\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}(\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"<(\", -1)\n    brackets = strings.Replace(brackets, \">\", \">(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"](\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"((\", -1)\n    brackets = strings.Replace(brackets, \")\", \"))\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"((\", -1)\n    brackets = strings.Replace(brackets, \")\", \"))\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"((\", -1)\n    brackets = strings.Replace(brackets, \")\", \"))\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"((\", -1)\n    brackets = strings.Replace(brackets, \")\", \"))\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"((\", -1)\n    brackets = strings.Replace(brackets, \")\", \"))\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"((\", -1)\n    brackets = strings.Replace(brackets, \")\", \"))\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"((\", -1)\n    brackets = strings.Replace(brackets, \")\", \"))\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"((\", -1)\n    brackets = strings.Replace(brackets, \")\", \"))\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"((\", -1)\n    brackets = strings.Replace(brackets, \")\", \"))\", \nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpd7d524an_test.go:44:6: expected '(', found TestCorrect_Bracketing\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074174
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"{\", -1)\n    brackets = strings.Replace(brackets, \">\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"<\", -1)\n    brackets = strings.Replace(brackets, \"}\", \">\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"<\", -1)\n    brackets = strings.Replace(brackets, \"]\", \">\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"[\", -1)\n    brackets = strings.Replace(brackets, \">\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"{\", -1)\n    brackets = strings.Replace(brackets, \">\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"<\", -1)\n    brackets = strings.Replace(brackets, \"}\", \">\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"<\", -1)\n    brackets = strings.Replace(brackets, \"]\", \">\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"[\", -1)\n    brackets = strings.Replace(brackets, \">\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"{\", -1)\n    brackets = strings.Replace(brackets, \">\", \"\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpqonlm7f1_test.go:45:47: string literal not terminated\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074165
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    for _, c := range brackets {\n        if c != \")\" && c != \"(\" {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpu_ny8211_test.go:13:17: invalid operation: c != \")\" (mismatched types rune and untyped string)\n/tmp/tmpu_ny8211_test.go:13:29: invalid operation: c != \"(\" (mismatched types rune and untyped string)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074166
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    for _, c := range brackets {\n        if c != \"(\" && c != \")\" {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5vkx83_2_test.go:13:17: invalid operation: c != \"(\" (mismatched types rune and untyped string)\n/tmp/tmp5vkx83_2_test.go:13:29: invalid operation: c != \")\" (mismatched types rune and untyped string)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074171
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    for _, c := range brackets {\n        if c != \"(\" && c != \")\" {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5vkx83_2_test.go:13:17: invalid operation: c != \"(\" (mismatched types rune and untyped string)\n/tmp/tmp5vkx83_2_test.go:13:29: invalid operation: c != \")\" (mismatched types rune and untyped string)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074171
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    openingBrackets := make([]string, 0)\n    closingBrackets := make([]string, 0)\n    for _, c := range brackets {\n        if c == '(' {\n            openingBrackets = append(openingBrackets, c)\n        } else {\n            closingBrackets = append(closingBrackets, c)\n        }\n    }\n    if len(openingBrackets) != len(closingBrackets) {\n        return false\n    }\n    for i := 0; i < len(openingBrackets); i++ {\n        if openingBrackets[i] != closingBrackets[i] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5r4jiuvy_test.go:16:55: cannot use c (variable of type rune) as type string in argument to append\n/tmp/tmp5r4jiuvy_test.go:18:55: cannot use c (variable of type rune) as type string in argument to append\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074166
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    openingBrackets := []string{\"(\", \"[\", \"{\"}\n    closingBrackets := []string{\")\", \"]\", \"}\"}\n    for _, openingBracket := range openingBrackets {\n        for _, closingBracket := range closingBrackets {\n            if openingBracket == closingBracket {\n                continue\n            }\n            if brackets[len(brackets)-1-len(closingBracket):len(brackets)] == closingBracket {\n                return true\n            }\n        }\n    }\n    return false\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\npanic: runtime error: slice bounds out of range [-1:] [recovered]\n\tpanic: runtime error: slice bounds out of range [-1:]\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x515640, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x515640, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838 +0x207\ncommand-line-arguments_test.correct_bracketing(...)\n\t/tmp/tmp1rbfkbh3_test.go:18\ncommand-line-arguments_test.TestCorrect_Bracketing(0xc000103380?)\n\t/tmp/tmp1rbfkbh3_test.go:39 +0x2b0c\ntesting.tRunner(0xc000103380, 0x52afc8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486 +0x35f\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "timestamp": 1660074174
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    openingBrackets := make(map[string]bool)\n    closingBrackets := make(map[string]bool)\n    for _, char := range brackets {\n        if char == '(' {\n            openingBrackets[char] = true\n        } else if char == ')' {\n            closingBrackets[char] = true\n        }\n    }\n    for _, char := range brackets {\n        if !openingBrackets[char] {\n            return false\n        }\n        if !closingBrackets[char] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp41do0u7__test.go:15:29: cannot use char (variable of type rune) as type string in map index\n/tmp/tmp41do0u7__test.go:17:29: cannot use char (variable of type rune) as type string in map index\n/tmp/tmp41do0u7__test.go:21:29: cannot use char (variable of type rune) as type string in map index\n/tmp/tmp41do0u7__test.go:24:29: cannot use char (variable of type rune) as type string in map index\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074174
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    openingBrackets := make([]string, 0)\n    closingBrackets := make([]string, 0)\n    for _, char := range brackets {\n        if char == '(' {\n            openingBrackets = append(openingBrackets, char)\n        } else {\n            closingBrackets = append(closingBrackets, char)\n        }\n    }\n    if len(openingBrackets) != len(closingBrackets) {\n        return false\n    }\n    for i := 0; i < len(openingBrackets); i++ {\n        if openingBrackets[i] != closingBrackets[i] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmps244y73c_test.go:16:55: cannot use char (variable of type rune) as type string in argument to append\n/tmp/tmps244y73c_test.go:18:55: cannot use char (variable of type rune) as type string in argument to append\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074173
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    for _, char := range brackets {\n        if char != \")\" && char != \"(\" {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphp1j9pa4_test.go:13:20: invalid operation: char != \")\" (mismatched types rune and untyped string)\n/tmp/tmphp1j9pa4_test.go:13:35: invalid operation: char != \"(\" (mismatched types rune and untyped string)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074166
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    openingBrackets := make([]string, 0)\n    closingBrackets := make([]string, 0)\n    for _, char := range brackets {\n        if char == '(' {\n            openingBrackets = append(openingBrackets, char)\n        } else {\n            closingBrackets = append(closingBrackets, char)\n        }\n    }\n    if len(openingBrackets) != len(closingBrackets) {\n        return false\n    }\n    for _, openingBracket := range openingBrackets {\n        closingBracket := closingBrackets[len(openingBrackets)]\n        if openingBracket != closingBracket {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjyhooo0q_test.go:16:55: cannot use char (variable of type rune) as type string in argument to append\n/tmp/tmpjyhooo0q_test.go:18:55: cannot use char (variable of type rune) as type string in argument to append\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074174
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"{\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"{\", -1)\n    brackets = strings.Replace(brackets, \")\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"]\", -1)\n    brackets = strings.Replace(bracket\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpv9a_vmpe_test.go:45:39: missing ',' before newline in argument list\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074165
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    openingBrackets := 0\n    closingBrackets := 0\n    for _, c := range brackets {\n        if c == '(' {\n            openingBrackets++\n        } else if c == ')' {\n            closingBrackets++\n        }\n    }\n    return openingBrackets == closingBrackets\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__5 (0.00s)\n        tmpbs47m96x_test.go:47: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__10 (0.00s)\n        tmpbs47m96x_test.go:47: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "timestamp": 1660074166
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"{\", -1)\n    brackets = strings.Replace(brackets, \">\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"{\", -1)\n    brackets = strings.Replace(brackets, \">\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(bracket\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpqbb804qd_test.go:45:39: missing ',' before newline in argument list\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074169
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    openingBrackets := make(map[string]bool)\n    closingBrackets := make(map[string]bool)\n    for _, c := range brackets {\n        if c == '(' {\n            openingBrackets[c] = true\n        } else if c == ')' {\n            closingBrackets[c] = true\n        }\n    }\n    for c := range openingBrackets {\n        if !closingBrackets[c] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpb7jgzzxl_test.go:15:29: cannot use c (variable of type rune) as type string in map index\n/tmp/tmpb7jgzzxl_test.go:17:29: cannot use c (variable of type rune) as type string in map index\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074167
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"((\", -1)\n    brackets = strings.Replace(brackets, \")\", \")(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"](\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}(\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"<(\", -1)\n    brackets = strings.Replace(brackets, \">\", \">(\", -1)\n    brackets = strings.Replace(brackets, \"|\", \"|(\", -1)\n    brackets = strings.Replace(brackets, \"!\", \"!(\", -1)\n    brackets = strings.Replace(brackets, \"?\", \"?(\", -1)\n    brackets = strings.Replace(brackets, \"%\", \"%(\", -1)\n    brackets = strings.Replace(brackets, \"$\", \"$(\", -1)\n    brackets = strings.Replace(brackets, \"^\", \"^(\", -1)\n    brackets = strings.Replace(brackets, \"&\", \"&(\", -1)\n    brackets = strings.Replace(brackets, \"*\", \"*(\", -1)\n    brackets = strings.Replace(brackets, \"+\", \"+(\", -1)\n    brackets = strings.Replace(brackets, \",\", \",(\", -1)\n    brackets = strings.Replace(brackets, \"-\", \"-(\", -1)\n    brackets = strings.Replace(brackets, \"/\", \"/(\", -1)\n    brackets = strings.Replace(brackets, \"=\", \"=\", -1)\n    brackets = strings.Replace(brackets, \"?\", \"?(\", -1)\n    brackets = strings.Replace(brackets, \"!\", \"!(\", -1)\n    brackets = strings.Replace(brackets, \"|\", \"|(\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"<(\", -1)\n    brackets = strings.Replace(brackets, \">\", \">(\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"{(\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"}(\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"[(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \"](\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"((\", -1)\n    brackets = strings.Replace(bracket\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpid_euyaf_test.go:43:39: missing ',' before newline in argument list\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074174
    },
    {
      "exit_code": 1,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"{\", -1)\n    brackets = strings.Replace(brackets, \">\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"{\", -1)\n    brackets = strings.Replace(brackets, \">\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"(\", \"[\", -1)\n    brackets = strings.Replace(brackets, \")\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \"]\", \")\", -1)\n    brackets = strings.Replace(brackets, \"<\", \"{\", -1)\n    brackets = strings.Replace(brackets, \">\", \"}\", -1)\n    brackets = strings.Replace(brackets, \"{\", \"[\", -1)\n    brackets = strings.Replace(brackets, \"}\", \"]\", -1)\n    brackets = strings.Replace(brackets, \"[\", \"(\", -1)\n    brackets = strings.Replace(brackets, \nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmpsp77zutv_test.go:46:6: expected '(', found TestCorrect_Bracketing\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660074174
    },
    {
      "exit_code": 2,
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfunc correct_bracketing(brackets string) bool {\n    brackets = brackets[1 : len(brackets)-1]\n    for _, c := range brackets {\n        if c != \")\" && c != \"(\" {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpu_ny8211_test.go:13:17: invalid operation: c != \")\" (mismatched types rune and untyped string)\n/tmp/tmpu_ny8211_test.go:13:29: invalid operation: c != \"(\" (mismatched types rune and untyped string)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660074166
    }
  ]
}